<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>WinVisor – A hypervisor-based emulator for Windows x64 user-mode executables — Elastic Security Labs</title><meta name="description" content="WinVisor is a hypervisor-based emulator for Windows x64 user-mode executables that leverages the Windows Hypervisor Platform API to provide a virtualized environment for logging syscalls and enabling memory introspection."/><meta property="og:title" content="WinVisor – A hypervisor-based emulator for Windows x64 user-mode executables — Elastic Security Labs"/><meta property="og:description" content="WinVisor is a hypervisor-based emulator for Windows x64 user-mode executables that leverages the Windows Hypervisor Platform API to provide a virtualized environment for logging syscalls and enabling memory introspection."/><meta property="og:image" content="https://www.elastic.co/security-labs/assets/images/winvisor-hypervisor-based-emulator/winvisor.jpg?02c296206e0fe3682f262ce81df5da8b"/><meta property="og:image:alt" content="WinVisor is a hypervisor-based emulator for Windows x64 user-mode executables that leverages the Windows Hypervisor Platform API to provide a virtualized environment for logging syscalls and enabling memory introspection."/><meta property="og:site_name"/><meta property="og:url" content="https://www.elastic.co/security-labs/winvisor-hypervisor-based-emulator"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="WinVisor – A hypervisor-based emulator for Windows x64 user-mode executables — Elastic Security Labs"/><meta name="twitter:description" content="WinVisor is a hypervisor-based emulator for Windows x64 user-mode executables that leverages the Windows Hypervisor Platform API to provide a virtualized environment for logging syscalls and enabling memory introspection."/><meta name="twitter:image" content="https://www.elastic.co/security-labs/assets/images/winvisor-hypervisor-based-emulator/winvisor.jpg?02c296206e0fe3682f262ce81df5da8b"/><meta name="twitter:image:alt" content="WinVisor is a hypervisor-based emulator for Windows x64 user-mode executables that leverages the Windows Hypervisor Platform API to provide a virtualized environment for logging syscalls and enabling memory introspection."/><link rel="canonical" href="https://www.elastic.co/security-labs/winvisor-hypervisor-based-emulator"/><link rel="preload" href="/security-labs/logo.svg" as="image" fetchpriority="high"/><link rel="preload" as="image" imageSrcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fwinvisor-hypervisor-based-emulator%2Fwinvisor.jpg&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fwinvisor-hypervisor-based-emulator%2Fwinvisor.jpg&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fwinvisor-hypervisor-based-emulator%2Fwinvisor.jpg&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fwinvisor-hypervisor-based-emulator%2Fwinvisor.jpg&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fwinvisor-hypervisor-based-emulator%2Fwinvisor.jpg&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fwinvisor-hypervisor-based-emulator%2Fwinvisor.jpg&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fwinvisor-hypervisor-based-emulator%2Fwinvisor.jpg&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fwinvisor-hypervisor-based-emulator%2Fwinvisor.jpg&amp;w=3840&amp;q=75 3840w" imageSizes="100vw" fetchpriority="high"/><meta name="next-head-count" content="19"/><script src="https://play.vidyard.com/embed/v4.js" type="text/javascript" async=""></script><link rel="icon" href="/security-labs/favicon.svg"/><link rel="mask-icon" href="/security-labs/favicon.svg" color="#1C1E23"/><link rel="apple-touch-icon" href="/security-labs/favicon.svg"/><meta name="theme-color" content="#1C1E23"/><link rel="preload" href="/security-labs/_next/static/media/6d93bde91c0c2823-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/a34f9d1faa5f3315-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/369c6e283c5acc6e-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/92f44bb82993d879-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/ee71530a747ff30b-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/9fac010bc1f02be0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/cbf5fbad4d73afac-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><script id="google-tag-manager" data-nscript="beforeInteractive">
          (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
          new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
          j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
          'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
          })(window,document,'script','dataLayer','GTM-KNJMG2M');
          </script><link rel="preload" href="/security-labs/_next/static/css/265ed7605fd03477.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/265ed7605fd03477.css" data-n-g=""/><link rel="preload" href="/security-labs/_next/static/css/1007ff9e696f6f88.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/1007ff9e696f6f88.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/security-labs/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/security-labs/_next/static/chunks/webpack-7987c6fda769d510.js" defer=""></script><script src="/security-labs/_next/static/chunks/framework-7a7e500878b44665.js" defer=""></script><script src="/security-labs/_next/static/chunks/main-ebd33a9f1cae5951.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/_app-cb8664d1d3df2511.js" defer=""></script><script src="/security-labs/_next/static/chunks/fec483df-43ee602fabdfe3a4.js" defer=""></script><script src="/security-labs/_next/static/chunks/877-34f408271ef44c22.js" defer=""></script><script src="/security-labs/_next/static/chunks/511-d08fe0fdd6f8a984.js" defer=""></script><script src="/security-labs/_next/static/chunks/683-a5053c37fe5bd0c9.js" defer=""></script><script src="/security-labs/_next/static/chunks/402-eea0bd294d7631d1.js" defer=""></script><script src="/security-labs/_next/static/chunks/616-0b017b9cfa597392.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/%5Bslug%5D-b0c191de1a3710e4.js" defer=""></script><script src="/security-labs/_next/static/rlzZ6pCDkscxnj1LTzZLu/_buildManifest.js" defer=""></script><script src="/security-labs/_next/static/rlzZ6pCDkscxnj1LTzZLu/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KNJMG2M" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><main class="__variable_0351a5 __variable_1f211e __variable_a5b5f5 flex flex-col min-h-screen"><div class="scroll-percentage-container"><div class="scroll-percentage-bar" style="width:0%"></div></div><nav class="fixed w-full z-40" data-headlessui-state=""><div class="bg-gradient-to-b from-zinc-900 from-20% h-[200%] to-transparent absolute inset-0 z-0 pointer-events-none"></div><div class="container relative z-10"><div class="flex h-16 items-center justify-between"><div class="flex items-center justify-start w-full"><div><a class="hover:opacity-50 transition" href="/security-labs"><img alt="elastic security labs logo" fetchpriority="high" width="200" height="30" decoding="async" data-nimg="1" style="color:transparent" src="/security-labs/logo.svg"/></a></div><div class="hidden lg:ml-6 lg:block"><div class="flex space-x-4"><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/about"><span>About</span></a><div class="relative" data-headlessui-state=""><div><button class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" id="headlessui-menu-button-:R2kpm:" type="button" aria-haspopup="menu" aria-expanded="false" data-headlessui-state="">Topics<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="ml-1 -mr-1 h-4 w-4 text-zinc-400 relative top-[1px]"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z" clip-rule="evenodd"></path></svg></button></div></div><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/vulnerability-updates"><span>Vulnerability updates</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/reports"><span>Reports</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/tools"><span>Tools</span></a></div></div><div class="hidden lg:ml-auto lg:block"><div class="flex items-center space-x-4"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/winvisor-hypervisor-based-emulator"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="https://www.elastic.co/security-labs/rss/feed.xml"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="h-4 w-4 mr-1"><path d="M3.75 3a.75.75 0 00-.75.75v.5c0 .414.336.75.75.75H4c6.075 0 11 4.925 11 11v.25c0 .414.336.75.75.75h.5a.75.75 0 00.75-.75V16C17 8.82 11.18 3 4 3h-.25z"></path><path d="M3 8.75A.75.75 0 013.75 8H4a8 8 0 018 8v.25a.75.75 0 01-.75.75h-.5a.75.75 0 01-.75-.75V16a6 6 0 00-6-6h-.25A.75.75 0 013 9.25v-.5zM7 15a2 2 0 11-4 0 2 2 0 014 0z"></path></svg><span class="hidden xl:block">Subscribe</span></a><a class="font-display inline-flex items-center justify-center rounded font-semibold disabled:!select-none disabled:!bg-gray-400 bg-blue-600 text-white hover:bg-blue-500 enabled:hover:text-white/80 transition-colors px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://cloud.elastic.co/registration?cta=cloud-registration&amp;tech=trial&amp;plcmt=navigation&amp;pg=security-labs">Start free trial</a><a class="font-display inline-flex items-center justify-center rounded font-semibold text-white disabled:!select-none disabled:!bg-gray-400 button px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://www.elastic.co/contact">Contact sales</a></div></div></div><div class="-mr-2 flex lg:hidden"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/winvisor-hypervisor-based-emulator"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><button class="inline-flex items-center justify-center rounded-md p-2 text-gray-400 hover:bg-gray-700 hover:text-white focus:outline-none focus:ring-2 focus:ring-inset focus:ring-white" id="headlessui-disclosure-button-:R59m:" type="button" aria-expanded="false" data-headlessui-state=""><span class="sr-only">Open navigation menu</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="block h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div></div></div></nav><main class="mb-20 flex-1 flex flex-col"><div class="h-48 md:h-64"><div class="after:absolute after:block after:bg-blue-400 after:blur-3xl after:content-[&#x27; &#x27;] after:h-96 after:opacity-5 after:right-0 after:rounded-full after:top-20 after:w-1/2 after:z-0 before:absolute before:block before:blur-3xl before:bg-orange-400 before:content-[&#x27; &#x27;] before:h-96 before:left-0 before:opacity-5 before:rounded-full before:w-1/2 before:z-0 w-full h-full relative"><div class="relative z-10 w-full h-[125%] -top-[25%] bg-no-repeat bg-cover bg-bottom flex items-center justify-center" style="background-image:url(/security-labs/grid.svg)"></div></div></div><article class="px-4"><div class="max-w-7xl mx-auto relative z-10 flex flex-col space-y-4"><div class="eyebrow break-words"><time class="block mb-2 md:mb-0 md:inline-block article-published-date" dateTime="2025-01-24T00:00:00.000Z">24 January 2025</time><span class="hidden md:inline-block md:mx-2">•</span><a class="hover:text-blue-400 text-xs md:text-sm whitespace-nowrap author-name" href="/security-labs/author/elastic-security-labs">Elastic Security Labs</a></div><h1 class="font-bold leading-tighter text-3xl md:text-5xl"><span>WinVisor – A hypervisor-&nbsp;based emulator for Windows x64 user-&nbsp;mode&nbsp;executables</span></h1><p class="text-zinc-200 text-base md:text-xl">A proof-of-concept hypervisor-based emulator for Windows x64 binaries</p><div class="flex items-center mt-4 text-zinc-200 text-sm space-x-4 border-t border-white/25 pt-4"><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span>25 min read</span></span><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M9.568 3H5.25A2.25 2.25 0 003 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 005.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 009.568 3z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M6 6h.008v.008H6V6z"></path></svg><span><a class="hover:text-blue-400 whitespace-nowrap" href="/security-labs/category/perspectives">Perspectives</a></span></span></div></div><div class="max-w-7xl mx-auto"><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 sm:p-8 md:p-10 rounded-3xl mt-5 md:mt-10"><div class="relative w-full rounded-lg overflow-hidden aspect-video"><img alt="WinVisor – A hypervisor-based emulator for Windows x64 user-mode executables" fetchpriority="high" decoding="async" data-nimg="fill" class="object-cover absolute h-full w-full" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" sizes="100vw" srcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fwinvisor-hypervisor-based-emulator%2Fwinvisor.jpg&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fwinvisor-hypervisor-based-emulator%2Fwinvisor.jpg&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fwinvisor-hypervisor-based-emulator%2Fwinvisor.jpg&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fwinvisor-hypervisor-based-emulator%2Fwinvisor.jpg&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fwinvisor-hypervisor-based-emulator%2Fwinvisor.jpg&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fwinvisor-hypervisor-based-emulator%2Fwinvisor.jpg&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fwinvisor-hypervisor-based-emulator%2Fwinvisor.jpg&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fwinvisor-hypervisor-based-emulator%2Fwinvisor.jpg&amp;w=3840&amp;q=75 3840w" src="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fwinvisor-hypervisor-based-emulator%2Fwinvisor.jpg&amp;w=3840&amp;q=75"/><div class="absolute border border-white/50 inset-0 mix-blend-overlay rounded-lg z-10"></div></div></div></div><div class="lg:max-w-7xl mx-auto relative mt-12 lg:grid lg:grid-cols-4 lg:gap-8 items-start"><div class="flex justify-center lg:col-span-3"><div class="prose lg:prose-lg prose-invert w-full article-content"><div><h2 class="font-bold text-2xl md:text-4xl relative"><span id="background" class="absolute -top-32"></span>Background</h2>
<p>In Windows 10 (version RS4), Microsoft introduced the <a href="https://learn.microsoft.com/en-us/virtualization/api/hypervisor-platform/hypervisor-platform">Windows Hypervisor Platform</a> (WHP) API. This API exposes Microsoft&#x27;s built-in hypervisor functionality to user-mode Windows applications. In 2024, the author used this API to create a personal project: a 16-bit MS-DOS emulator called <a href="https://github.com/x86matthew/DOSVisor">DOSVisor</a>. As mentioned in the release notes, there have always been plans to take this concept further and use it to emulate Windows applications. Elastic provides a research week (ON Week) twice per year for staff to work on personal projects, providing a great opportunity to begin working on this project. This project will be (unimaginatively) named WinVisor, inspired by its DOSVisor predecessor.</p>
<p>Hypervisors provide hardware-level virtualization, eliminating the need to emulate the CPU via software. This ensures that instructions are executed exactly as they would be on a physical CPU, whereas software-based emulators often behave inconsistently in edge cases.</p>
<p>This project aims to build a virtual environment for executing Windows x64 binaries, allowing syscalls to be logged (or hooked) and enabling memory introspection. The goal of this project is not to build a comprehensive and secure sandbox - by default, all syscalls will simply be logged and forwarded directly to the host. In its initial form, it will be trivial for code running within the virtualized guest to &quot;escape&quot; to the host. Safely securing a sandbox is a difficult task, and is beyond the scope of this project. The limitations will be described in further detail at the end of the article.</p>
<p>Despite having been available for 6 years (at the time of writing), it seems that the WHP API hasn’t been used in many public projects other than complex codebases such as <a href="https://github.com/qemu/qemu">QEMU</a> and <a href="https://www.virtualbox.org/">VirtualBox</a>. One other notable project is Alex Ionescu&#x27;s <a href="https://github.com/ionescu007/Simpleator">Simpleator</a> - a lightweight Windows user-mode emulator that also utilizes the WHP API. This project has many of the same goals as WinVisor, although the approach for implementation is quite different. The WinVisor project aims to automate as much as possible and support simple executables (e.g. <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ping.exe</code>) universally out of the box.</p>
<p>This article will cover the general design of the project, some of the issues that were encountered, and how they were worked through. Some features will be limited due to development time constraints, but the final product will at least be a usable proof-of-concept. Links to the source code and binaries hosted on GitHub will be provided at the end of the article.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="hypervisor-basics" class="absolute -top-32"></span>Hypervisor basics</h3>
<p>Hypervisors are powered by VT-x (Intel) and AMD-V (AMD) extensions. These hardware-assisted frameworks enable virtualization by allowing one or more virtual machines to run on a single physical CPU. These extensions use different instruction sets and, therefore, are not inherently compatible with each other; separate code must be written for each.</p>
<p>Internally, Hyper-V uses <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">hvix64.exe</code> for Intel support and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">hvax64.exe</code> for AMD support. Microsoft&#x27;s WHP API abstracts these hardware differences, allowing applications to create and manage virtual partitions regardless of the underlying CPU type. For simplicity, the following explanation will focus solely on VT-x.</p>
<p>VT-x adds an additional set of instructions known as VMX (Virtual Machine Extensions), containing instructions such as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">VMLAUNCH</code>, which begins the execution of a VM for the first time, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">VMRESUME</code>, which re-enters the VM after a VM exit. A VM exit occurs when certain conditions are triggered by the guest, such as specific instructions, I/O port access, page faults, and other exceptions.</p>
<p>Central to VMX is the Virtual Machine Control Structure (VMCS), a per-VM data structure that stores the state of the guest and host contexts as well as information about the execution environment. The VMCS contains fields that define processor state, control configurations, and optional conditions that trigger transitions from the guest back to the host. VMCS fields can be read or written to using the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">VMREAD</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">VMWRITE</code> instructions.</p>
<p>During a VM exit, the processor saves the guest state in the VMCS and transitions back to the host state for hypervisor intervention.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="winvisor-overview" class="absolute -top-32"></span>WinVisor overview</h2>
<p>This project takes advantage of the high-level nature of the WHP API. The API exposes hypervisor functionality to user-mode and allows applications to map virtual memory from the host process directly into the guest&#x27;s physical memory.</p>
<p>The virtual CPU operates almost exclusively in CPL3 (user-mode), except for a small bootloader that runs at CPL0 (kernel-mode) to initialize the CPU state before execution. This will be described in further detail in the Virtual CPU section.</p>
<p>Building up the memory space for an emulated guest environment involves mapping the target executable and all DLL dependencies, followed by populating other internal data structures such as the Process Environment Block (PEB), Thread Environment Block (TEB), <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">KUSER_SHARED_DATA</code>, etc.</p>
<p>Mapping the EXE and DLL dependencies is straightforward, but accurately maintaining internal structures, such as the PEB, is a more complex task. These structures are large, mostly undocumented, and their contents can vary between Windows versions. It would be relatively simple to populate a minimalist set of fields to execute a simple &quot;Hello World&quot; application, but an improved approach should be taken to provide good compatibility.</p>
<p>Instead of manually building up a virtual environment, WinVisor launches a suspended instance of the target process and clones the entire address space into the guest. The Import Address Table (IAT) and Thread Local Storage (TLS) data directories are temporarily removed from the PE headers in memory to stop DLL dependencies from loading and to prevent TLS callbacks from executing before reaching the entry point. The process is then resumed, allowing the usual process initialization to continue (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">LdrpInitializeProcess</code>) until it reaches the entry point of the target executable, at which point the hypervisor launches and takes control. This essentially means that Windows has done all of the hard work for us, and we now have a pre-populated user-mode address space for the target executable that is ready for execution.</p>
<p>A new thread is then created in a suspended state, with the start address pointing to the address of a custom loader function. This function populates the IAT, executes TLS callbacks, and finally executes the original entry point of the target application. This essentially simulates what the main thread would do if the process were being executed natively. The context of this thread is then &quot;cloned&quot; into the virtual CPU, and execution begins under the control of the hypervisor.</p>
<p>Memory is paged into the guest as necessary, and syscalls are intercepted, logged, and forwarded to the host OS until the virtualized target process exits.</p>
<p>As the WHP API only allows memory from the current process to be mapped into the guest, the main hypervisor logic is encapsulated within a DLL that gets injected into the target process.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="virtual-cpu" class="absolute -top-32"></span>Virtual CPU</h2>
<p>The WHP API provides a &quot;friendly&quot; wrapper around the VMX functionality described earlier, meaning that the usual steps, such as manually populating the VMCS before executing <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">VMLAUNCH</code>,  are no longer necessary. It also exposes the functionality to user-mode, meaning a custom driver is not required. However, the virtual CPU must still be initialized appropriately via WHP prior to executing the target code. The important aspects will be described below.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="control-registers" class="absolute -top-32"></span>Control registers</h3>
<p>Only the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CR0</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CR3</code>, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CR4</code> control registers are relevant for this project. <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CR0</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CR4</code> are used to enable CPU configuration options such as protected mode, paging, and PAE. <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CR3</code> contains the physical address of the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">PML4</code> paging table, which will be described in further detail in the Memory Paging section.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="model-specific-registers" class="absolute -top-32"></span>Model-specific registers</h3>
<p>Model-Specific Registers (MSRs) must also be initialized to ensure the correct operation of the virtual CPU. <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">MSR_EFER</code> contains flags for extended features, such as enabling long mode (64-bit) and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SYSCALL</code> instructions. <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">MSR_LSTAR</code> contains the address of the syscall handler, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">MSR_STAR</code> contains the segment selectors for transitioning to CPL0 (and back to CPL3) during syscalls. <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">MSR_KERNEL_GS_BASE</code> contains the shadow base address of the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">GS</code> selector.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="global-descriptor-table" class="absolute -top-32"></span>Global descriptor table</h3>
<p>The Global Descriptor Table (GDT) defines the segment descriptors, which essentially describe memory regions and their properties for use in protected mode.</p>
<p>In long mode, the GDT has limited use and is mostly a relic of the past - x64 always operates in a flat memory mode, meaning all selectors are based at <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">0</code>. The only exceptions to this are the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">FS</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">GS</code> registers, which are used for thread-specific purposes. Even in those cases, their base addresses are not defined by the GDT. Instead, MSRs (such as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">MSR_KERNEL_GS_BASE</code> described above) are used to store the base address.</p>
<p>Despite this obsolescence, the GDT is still an important part of the x64 model. For example, the current privilege level is defined by the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CS</code> (Code Segment) selector.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="task-state-segment" class="absolute -top-32"></span>Task state segment</h3>
<p>In long mode, the Task State Segment (TSS) is simply used to load the stack pointer when transitioning from a lower privilege level to a higher one. As this emulator operates almost exclusively in CPL3, except for the initial bootloader and interrupt handlers, only a single page is allocated for the CPL0 stack. The TSS is stored as a special system entry within the GDT and occupies two slots.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="interrupt-descriptor-table" class="absolute -top-32"></span>Interrupt descriptor table</h3>
<p>The Interrupt Descriptor Table (IDT) contains information about each type of interrupt, such as the handler addresses. This will be described in further detail in the Interrupt Handling section.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="bootloader" class="absolute -top-32"></span>Bootloader</h3>
<p>Most of the CPU fields mentioned above can be initialized using WHP wrapper functions, but support for certain fields (e.g. <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">XCR0</code>) only arrived in later versions of the WHP API (Windows 10 RS5). For completeness, the project includes a small “bootloader”, which runs at CPL0 upon startup and manually initializes the final parts of the CPU prior to executing the target code. Unlike a physical CPU, which would start in 16-bit real mode, the virtual CPU has already been initialized to run in long-mode (64-bit), making the boot process slightly more straightforward.</p>
<p>The following steps are performed by the bootloader:</p>
<ol>
<li>
<p>Load the GDT using the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">LGDT</code> instruction. The source operand for this instruction specifies a 10-byte memory block which contains the base address and limit (size) of the table that was populated earlier.</p>
</li>
<li>
<p>Load the IDT using the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">LIDT</code> instruction. The source operand for this instruction uses the same format as LGDT described above.</p>
</li>
<li>
<p>Set the TSS selector index into the task register using the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">LTR</code> instruction. As mentioned above, the TSS descriptor exists as a special entry within the GDT (at <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">0x40</code> in this case).</p>
</li>
<li>
<p>The XCR0 register can be set using the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">XSETBV</code> instruction. This is an additional control register which is used for optional features such as AVX. The native process executes XGETBV to get the host value, which is then copied into the guest via <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">XSETBV</code> in the bootloader.</p>
</li>
</ol>
<p>This is an important step because DLL dependencies that have already been loaded may have set global flags during their initialization process. For example, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ucrtbase.dll</code> checks if the CPU supports AVX via the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CPUID</code> instruction on startup and, if so, sets a global flag to allow the CRT to use AVX instructions for optimization reasons. If the virtual CPU attempts to execute these AVX instructions without explicitly enabling them in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">XCR0</code> first, an undefined instruction exception will be raised.</p>
<ol start="5">
<li>
<p>Manually update <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">DS</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ES</code>, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">GS</code> data segment selectors to their CPL3 equivalents (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">0x2B</code>). Execute the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SWAPGS</code> instruction to load the TEB base address from <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">MSR_KERNEL_GS_BASE</code>.</p>
</li>
<li>
<p>Finally, use the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SYSRET</code> instruction to transition into CPL3. Prior to the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SYSRET</code> instruction, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RCX</code> is set to a placeholder address (CPL3 entry point), and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">R11</code> is set to the initial CPL3 RFLAGS value (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">0x202</code>). The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SYSRET</code> instruction automatically switches the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CS</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SS</code> segment selectors to their CPL3 equivalents from <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">MSR_STAR</code>.</p>
</li>
</ol>
<p>When the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SYSRET</code> instruction executes, a page fault will be raised due to the invalid placeholder address in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RIP</code>. The emulator will catch this page fault and recognize it as a “special” address. The initial CPL3 register values will then be copied into the virtual CPU, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RIP</code> is updated to point to a custom user-mode loader function, and execution resumes. This function loads all DLL dependencies for the target executable, populates the IAT table, executes TLS callbacks, and then executes the original entry point. The import table and TLS callbacks are handled at this stage, rather than earlier on, to ensure their code is executed within the virtualized environment.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="memory-paging" class="absolute -top-32"></span>Memory paging</h2>
<p>All memory management for the guest must be handled manually. This means a paging table must be populated and maintained, allowing the virtual CPU to translate a virtual address to a physical address.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="virtual-address-translation" class="absolute -top-32"></span>Virtual address translation</h3>
<p>For those who are not familiar with paging in x64, the paging table has four levels: <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">PML4</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">PDPT</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">PD</code>, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">PT</code>. For any given virtual address, the CPU walks through each layer of the table, eventually reaching the target physical address. Modern CPUs also support 5-level paging (in case the 256TB of addressable memory offered by 4-level paging isn&#x27;t enough!), but this is irrelevant for the purposes of this project.</p>
<p>The following image illustrates the format of a sample virtual address:</p>
<p></p>
<p>Using the example above, the CPU would calculate the physical page corresponding to the virtual address <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">0x7FFB7D030D10</code> via the following table entries: <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">PML4[0xFF]</code> -&gt; <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">PDPT[0x1ED]</code> -&gt; <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">PD[0x1E8]</code> -&gt; <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">PT[0x30]</code>. Finally, the offset (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">0xD10</code>) will be added to this physical page to calculate the exact address.</p>
<p>Bits <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">48</code> - <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">63</code> within a virtual address are unused in 4-level paging and are essentially sign-extended to match bit <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">47</code>.</p>
<p>The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CR3</code> control register contains the physical address of the base <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">PML4</code> table. When paging is enabled (mandatory in long-mode), all other addresses within the context of the CPU refer to virtual addresses.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="page-faults" class="absolute -top-32"></span>Page faults</h3>
<p>When the guest attempts to access memory, the virtual CPU will raise a page fault exception if the requested page isn&#x27;t already present in the paging table. This will trigger a VM Exit event and pass control back to the host. When this occurs, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CR2</code> control register contains the requested virtual address, although the WHP API already provides this value within the VM Exit context data. The host can then map the requested page into memory (if possible) and resume execution or throw an error if the target address is invalid.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="hostguest-memory-mirroring" class="absolute -top-32"></span>Host/guest memory mirroring</h3>
<p>As mentioned earlier, the emulator creates a child process, and all virtual memory within that process will be mapped directly into the guest using the same address layout. The Hypervisor Platform API allows us to map virtual memory from the host user-mode process directly into the physical memory of the guest. The paging table will then map virtual addresses to the corresponding physical pages.</p>
<p>Instead of mapping the entire address space of the process upfront, a fixed number of physical pages are allocated for the guest. The emulator contains a very basic memory manager, and pages are mapped &quot;on demand.&quot; When a page fault occurs, the requested page will be paged in, and execution resumes. If all page &quot;slots&quot; are full, the oldest entry is swapped out to make room for the new one.</p>
<p>In addition to using a fixed number of currently mapped pages, the emulator also uses a fixed-size page table. The size of the page table is determined by calculating the maximum possible number of tables for the amount of mapped page entries. This model results in a simple and consistent physical memory layout but comes at the cost of efficiency. In fact, the paging tables take up more space than the actual page entries.</p>
<p>There is a single PML4 table, and in the worst-case scenario, each mapped page entry will reference unique PDPT/PD/PT tables. As each table is <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">4096</code> bytes, the total page table size can be calculated using the following formula:</p>
<pre><code>PAGE_TABLE_SIZE = 4096 + (MAXIMUM_MAPPED_PAGES * 4096 * 3)</code></pre>
<p>By default, the emulator allows for <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">256</code> pages to be mapped at any one time (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">1024KB</code> in total). Using the formula above, we can calculate that this will require <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">3076KB</code> for the paging table, as illustrated below:</p>
<p></p>
<p>In practice, many of the page table entries will be shared, and a lot of the space allocated for the paging tables will remain unused. However, as this emulator functions well even with a small number of pages, this level of overhead is not a major concern.</p>
<p>The CPU maintains a hardware-level cache for the paging table known as the Translation Lookaside Buffer (TLB). When translating a virtual address to a physical address, the CPU will first check the TLB. If a matching entry is not found in the cache (known as a “TLB miss”), the paging tables will be read instead. For this reason, it is important to flush the TLB cache whenever the paging tables have been rebuilt to prevent it from falling out of sync. The simplest way to flush the entire TLB is to reset the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CR3</code> register value.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="syscall-handling" class="absolute -top-32"></span>Syscall handling</h2>
<p>As the target program executes, any system calls that occur within the guest must be handled by the host. This emulator handles both <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SYSCALL</code> instructions and legacy (interrupt-based) syscalls. <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SYSENTER</code> is not used in long-mode and, therefore, is not supported by WinVisor.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="fast-syscall-syscall" class="absolute -top-32"></span>Fast syscall (SYSCALL)</h3>
<p>When a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SYSCALL</code> instruction executes, the CPU transitions to CPL0 and loads <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RIP</code> from <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">MSR_LSTAR</code>. In the Windows kernel, this would point to <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">KiSystemCall64</code>. <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SYSCALL</code> instructions won&#x27;t inherently trigger a VM Exit event, but the emulator sets <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">MSR_LSTAR</code> to a reserved placeholder address — <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">0xFFFF800000000000</code> in this case. When a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SYSCALL</code> instruction is executed, a page fault will be raised when RIP is set to this address, and the call can be intercepted. This placeholder is a kernel address in Windows and won&#x27;t cause any conflicts with the user-mode address space.</p>
<p>Unlike legacy syscalls, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SYSCALL</code> instruction doesn&#x27;t swap the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RSP</code> value during the transition to CPL0, so the user-mode stack pointer can be retrieved directly from <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RSP</code>.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="legacy-syscalls-int-2e" class="absolute -top-32"></span>Legacy syscalls (INT 2E)</h3>
<p>Legacy interrupt-based syscalls are slower and have more overhead than the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SYSCALL</code> instruction, but despite this, they are still supported by Windows. As the emulator already contains a framework for handling interrupts, adding support for legacy syscalls is very simple. When a legacy syscall interrupt is caught, it can be forwarded to the “common” syscall handler after some minor translations — specifically, retrieving the stored user-mode <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RSP</code> value from the CPL0 stack.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="syscall-forwarding" class="absolute -top-32"></span>Syscall forwarding</h3>
<p>After the emulator creates the &quot;main thread&quot; whose context gets cloned into the virtual CPU, this native thread is reused as a proxy to forward syscalls to the host. Reusing the same thread maintains consistency for the TEB and any kernel state between the guest and the host. Win32k, in particular, relies on many thread-specific states, which should be reflected in the emulator.</p>
<p>When a syscall occurs, either by a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SYSCALL</code> instruction or a legacy interrupt, the emulator intercepts it and transfers it to a universal handler function. The syscall number is stored in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RAX</code> register, and the first four parameter values are stored in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">R10</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RDX</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">R8</code>, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">R9</code>, respectively. <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">R10</code> is used for the first parameter instead of the usual <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RCX</code> register because the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SYSCALL</code> instruction overwrites <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RCX</code> with the return address. The legacy syscall handler in Windows (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">KiSystemService</code>) also uses <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">R10</code> for compatibility, so it doesn’t need to be handled differently in the emulator. The remaining parameters are retrieved from the stack.</p>
<p>We don’t know the exact number of parameters expected for any given syscall number, but luckily, this doesn’t matter. We can simply use a fixed amount, and as long as the number of supplied parameters is greater than or equal to the actual number, the syscall will function correctly. A simple assembly stub will be dynamically created, populating all of the parameters, executing the target syscall, and returning cleanly.</p>
<p>Testing showed that the maximum number of parameters currently used by Windows syscalls is <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">17</code> (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">NtAccessCheckByTypeResultListAndAuditAlarmByHandle</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">NtCreateTokenEx</code>, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">NtUserCreateWindowEx</code>). WinVisor uses <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">32</code> as the maximum number of parameters to allow for potential future expansion.</p>
<p>After executing the syscall on the host, the return value is copied to <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RAX</code> in the guest. <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RIP</code> is then transferred to a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SYSRET</code> instruction (or <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">IRETQ</code> for legacy syscalls) before resuming the virtual CPU for a seamless transition back to user-mode.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="syscall-logging" class="absolute -top-32"></span>Syscall logging</h3>
<p>By default, the emulator simply forwards guest syscalls to the host and logs them to the console. However, some additional steps are necessary to convert the raw syscalls into a readable format.</p>
<p>The first step is to convert the syscall number to a name. Syscall numbers are made up of multiple parts: bits <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">12</code> - <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">13</code> contain the system service table index (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">0</code> for <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ntoskrnl</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">1</code> for <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">win32k</code>), and bits <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">0</code> - <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">11</code> contain the syscall index within the table. This information allows us to perform a reverse-lookup within the corresponding user-mode module (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ntdll</code> / <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">win32u</code>) to resolve the original syscall name.</p>
<p>The next step is to determine the number of parameter values to display for each syscall. As mentioned above, the emulator passes <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">32</code> parameter values to each syscall, even if most of them are not used. However, logging all <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">32</code> values for each syscall wouldn&#x27;t be ideal for readability reasons. For example, a simple <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">NtClose(0x100)</code> call would be printed as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">NtClose(0x100, xxx, xxx, xxx, xxx, xxx, xxx, xxx, xxx, ...)</code>. As mentioned earlier, there is no simple way to automatically determine the exact number of parameters for each syscall, but there is a trick that we can use to estimate it with high accuracy.</p>
<p>This trick relies on the 32-bit system libraries used by WoW64. These libraries use the stdcall calling convention, which means the caller pushes all parameters onto the stack, and they are cleaned internally by the callee before returning. In contrast, native x64 code places the first 4 parameters into registers, and the caller is responsible for managing the stack.</p>
<p>For example, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">NtClose</code> function in the WoW64 version of <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ntdll.dll</code> ends with the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RET 4</code> instruction. This pops an additional 4-bytes off the stack after the return address, which implies that the function takes one parameter. If the function used <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RET 8</code>, this would suggest that it takes 2 parameters, and so on.</p>
<p>Even though the emulator runs as a 64-bit process, we can still load the 32-bit copies of <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ntdll.dll</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">win32u.dll</code> into memory - either manually or mapped using <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SEC_IMAGE</code>. A custom version of <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">GetProcAddress</code> must be written to resolve the WoW64 export addresses, but this is a trivial task. From here, we can automatically find the corresponding WoW64 export for each syscall, scan for the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RET</code> instruction to calculate the number of parameters, and store the value in a lookup table.</p>
<p>This method is not perfect, and there are a number of ways that this could fail:</p>
<ul>
<li>A small number of native syscalls don&#x27;t exist in WoW64, such as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">NtUserSetWindowLongPtr</code>.</li>
<li>If a 32-bit function contains a 64-bit parameter, it will be split into 2x 32-bit parameters internally, whereas the corresponding 64-bit function would only require a single parameter for the same value.</li>
<li>The WoW64 syscall stub functions within Windows could change in such a way that causes the existing <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RET</code> instruction search to fail.</li>
</ul>
<p>Despite these pitfalls, the results will be accurate for the vast majority of syscalls without having to rely on hardcoded values. In addition, these values are only used for logging purposes and won&#x27;t affect anything else, so minor inaccuracies are acceptable in this context. If a failure is detected, it will revert back to displaying the maximum number of parameter values.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="syscall-hooking" class="absolute -top-32"></span>Syscall hooking</h3>
<p>If this project were being used for sandboxing purposes, blindly forwarding all syscalls to the host would be undesirable for obvious reasons. The emulator contains a framework that allows specific syscalls to be easily hooked if necessary.</p>
<p>By default, only <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">NtTerminateThread</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">NtTerminateProcess</code> are hooked to catch the guest process exiting.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="interrupt-handling" class="absolute -top-32"></span>Interrupt handling</h2>
<p>Interrupts are defined by the IDT, which is populated before the virtual CPU execution begins. When an interrupt occurs, the current CPU state is pushed onto the CPL0 stack (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SS</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RSP</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RFLAGS</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CS</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RIP</code>), and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RIP</code> is set to the target handler function.</p>
<p>As with <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">MSR_LSTAR</code> for the SYSCALL handler, the emulator populates all interrupt handler addresses with placeholder values (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">0xFFFFA00000000000</code> - <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">0xFFFFA000000000FF</code>). When an interrupt occurs, a page fault will occur within this range, which we can catch. The interrupt index can be extracted from the lowest 8-bits of the target address (e.g., <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">0xFFFFA00000000003</code> is <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">INT 3</code>), and the host can handle it as necessary.</p>
<p>At present, the emulator only handles <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">INT 1</code> (single-step), <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">INT 3</code> (breakpoint), and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">INT 2E</code> (legacy syscall). If any other interrupt is caught, the emulator will exit with an error.</p>
<p>When an interrupt has been handled, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RIP</code> is transferred to an <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">IRETQ</code> instruction, which returns to user-mode cleanly. Some types of interrupts push an additional &quot;error code&quot; value onto the stack - if this is the case, it must be popped prior to the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">IRETQ</code> instruction to avoid stack corruption. The interrupt handler framework within this emulator contains an optional flag to handle this transparently.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="hypervisor-shared-page-bug" class="absolute -top-32"></span>Hypervisor shared page bug</h2>
<p>Windows 10 introduced a new type of shared page which is located close to <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">KUSER_SHARED_DATA</code>. This page is used by timing-related functions such as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RtlQueryPerformanceCounter</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RtlGetMultiTimePrecise</code>.</p>
<p>The exact address of this page can be retrieved with <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">NtQuerySystemInformation</code>, using the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SystemHypervisorSharedPageInformation</code> information class. The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">LdrpInitializeProcess</code> function stores the address of this page in a global variable (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RtlpHypervisorSharedUserVa</code>) during process startup.</p>
<p>The WHP API seems to contain a bug that causes the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">WHvRunVirtualProcessor</code> function to get stuck in an infinite loop if this shared page is mapped into the guest and the virtual CPU attempts to read from it.</p>
<p>Time constraints limited the ability to fully investigate this; however, a simple workaround was implemented. The emulator patches the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">NtQuerySystemInformation</code> function within the target process and forces it to return <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">STATUS_INVALID_INFO_CLASS</code> for <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SystemHypervisorSharedPageInformation</code> requests. This causes the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ntdll</code> code to fall back to traditional methods.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="demos" class="absolute -top-32"></span>Demos</h2>
<p>Some examples of common Windows executables being emulated under this virtualized environment below:</p>
<p></p>
<p></p>
<p></p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="limitations" class="absolute -top-32"></span>Limitations</h2>
<p>The emulator has several limitations that make it unsafe to use as a secure sandbox in its current form.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="safety-issues" class="absolute -top-32"></span>Safety issues</h3>
<p>There are several ways to &quot;escape&quot; the VM, such as simply creating a new process/thread, scheduling asynchronous procedure calls (APCs), etc.</p>
<p>Windows GUI-related syscalls can also make nested calls directly back into user-mode from the kernel, which would currently bypass the hypervisor layer. For this reason, GUI executables such as notepad.exe are only partially virtualized when run under WinVisor.</p>
<p>To demonstrate this, WinVisor includes an <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">-nx</code> command-line switch to the emulator. This forces the entire target EXE image to be marked as non-executable in memory prior to starting the virtual CPU, causing the process to crash if the host process attempts to execute any of the code natively. However, this is still unsafe to rely on — the target application could make the region executable again or simply allocate executable memory elsewhere.</p>
<p>As the WinVisor DLL is injected into the target process, it exists within the same virtual address space as the target executable. This means the code running under the virtual CPU is able to directly access the memory within the host hypervisor module, which could potentially corrupt it.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="non-executable-guest-memory" class="absolute -top-32"></span>Non-executable guest memory</h3>
<p>While the virtual CPU is set up to support NX, all memory regions are currently mirrored into the guest with full RWX access.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="single-thread-only" class="absolute -top-32"></span>Single-thread only</h3>
<p>The emulator currently only supports virtualizing a single thread. If the target executable creates additional threads, they will be executed natively. To support multiple threads, a pseudo-scheduler could be developed to handle this in the future.</p>
<p>The Windows parallel loader is disabled to ensure all module dependencies are loaded by a single thread.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="software-exceptions" class="absolute -top-32"></span>Software exceptions</h3>
<p>Virtualized software exceptions are not currently supported. If an exception occurs, the system will call the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">KiUserExceptionDispatcher</code> function natively as usual.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="conclusion" class="absolute -top-32"></span>Conclusion</h2>
<p>As seen above, the emulator performs well with a wide range of executables in its current form. While it is currently effective for logging syscalls and interrupts, a lot of further work would be required to make it safe to use for malware analysis purposes. Despite this, the project provides an effective framework for future development.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="project-links" class="absolute -top-32"></span>Project links</h2>
<p><a href="https://github.com/x86matthew/WinVisor">https://github.com/x86matthew/WinVisor</a></p>
<p>The author can be found on X at <a href="https://x.com/x86matthew">@x86matthew</a>.</p></div></div></div><div class="hidden lg:flex lg:col-span-1 text-sm lg:flex-col lg:space-y-6"><div class="toc"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Jump to section</h4><ul class="flex flex-col space-y-2"><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/winvisor-hypervisor-based-emulator#background"><span>Background</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/winvisor-hypervisor-based-emulator#hypervisor-basics"><span>Hypervisor&nbsp;basics</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/winvisor-hypervisor-based-emulator#winvisor-overview"><span>WinVisor&nbsp;overview</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/winvisor-hypervisor-based-emulator#virtual-cpu"><span>Virtual&nbsp;CPU</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/winvisor-hypervisor-based-emulator#control-registers"><span>Control&nbsp;registers</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/winvisor-hypervisor-based-emulator#model-specific-registers"><span>Model-&nbsp;specific&nbsp;registers</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/winvisor-hypervisor-based-emulator#global-descriptor-table"><span>Global descriptor&nbsp;table</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/winvisor-hypervisor-based-emulator#task-state-segment"><span>Task state&nbsp;segment</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/winvisor-hypervisor-based-emulator#interrupt-descriptor-table"><span>Interrupt descriptor&nbsp;table</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/winvisor-hypervisor-based-emulator#bootloader"><span>Bootloader</span></a></li></ul><button class="border-t border-white/20 w-full mt-3 py-2 flex items-center space-x-1 text-xs font-medium uppercase tracking-wide hover:text-white"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="w-3 h-3"><path d="M10.75 4.75a.75.75 0 00-1.5 0v4.5h-4.5a.75.75 0 000 1.5h4.5v4.5a.75.75 0 001.5 0v-4.5h4.5a.75.75 0 000-1.5h-4.5v-4.5z"></path></svg><span>Show more</span></button></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Elastic Security Labs Newsletter</h4><div><a target="_blank" class="button inline-flex" href="https://www.elastic.co/elastic-security-labs/newsletter?utm_source=security-labs">Sign Up</a></div></div></div></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl my-5 md:my-10 max-w-3xl mx-auto flex flex-col items-center shadow-2xl"><h4 class="font-bold leading-tight text-lg md:text-2xl">Share this article</h4><div class="flex flex-wrap items-center justify-center mt-4 space-x-4"><a class="flex items-center space-x-2 button" href="https://twitter.com/intent/tweet?text=WinVisor – A hypervisor-based emulator for Windows x64 user-mode executables&amp;url=https://www.elastic.co/security-labs/winvisor-hypervisor-based-emulator" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Twitter" title="Share this article on Twitter"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>Twitter</span></a><a class="flex items-center space-x-2 button" href="https://www.facebook.com/sharer/sharer.php?u=https://www.elastic.co/security-labs/winvisor-hypervisor-based-emulator" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Facebook" title="Share this article on Facebook"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M22.5 12c0-5.799-4.701-10.5-10.5-10.5S1.5 6.201 1.5 12c0 5.301 3.901 9.699 9 10.401V14.4h-2.7v-2.7h2.7v-2.1c0-2.7 1.8-4.2 4.2-4.2 1.2 0 2.1.1 2.4.2v2.4h-1.5c-1.2 0-1.5.6-1.5 1.5v1.8h3l-.3 2.7h-2.7V22C18.599 21.3 22.5 17.301 22.5 12z"></path></svg><span>Facebook</span></a><a class="flex items-center space-x-2 button" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://www.elastic.co/security-labs/winvisor-hypervisor-based-emulator&amp;title=WinVisor – A hypervisor-based emulator for Windows x64 user-mode executables" target="_blank" rel="noopener noreferrer" aria-label="Share this article on LinkedIn" title="Share this article on LinkedIn"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"></path></svg><span>LinkedIn</span></a><a class="flex items-center space-x-2 button" href="https://reddit.com/submit?url=https://www.elastic.co/security-labs/winvisor-hypervisor-based-emulator&amp;title=WinVisor – A hypervisor-based emulator for Windows x64 user-mode executables" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Reddit" title="Share this article on Reddit"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M24 12C24 18.6274 18.6274 24 12 24C5.37258 24 0 18.6274 0 12C0 5.37258 5.37258 0 12 0C18.6274 0 24 5.37258 24 12ZM19.6879 11.0584C19.8819 11.3352 19.9916 11.6622 20.004 12C20.0091 12.3306 19.9205 12.656 19.7485 12.9384C19.5765 13.2208 19.3281 13.4488 19.032 13.596C19.0455 13.7717 19.0455 13.9483 19.032 14.124C19.032 16.812 15.9 18.996 12.036 18.996C8.172 18.996 5.04 16.812 5.04 14.124C5.02649 13.9483 5.02649 13.7717 5.04 13.596C4.80919 13.49 4.6042 13.335 4.43923 13.1419C4.27427 12.9487 4.15327 12.722 4.08462 12.4775C4.01598 12.2329 4.00133 11.9764 4.04169 11.7256C4.08205 11.4748 4.17646 11.2358 4.31837 11.0251C4.46028 10.8145 4.6463 10.6372 4.86354 10.5056C5.08078 10.3739 5.32404 10.2911 5.57646 10.2629C5.82889 10.2346 6.08444 10.2616 6.32541 10.3419C6.56638 10.4222 6.78701 10.5539 6.972 10.728C8.35473 9.79023 9.98146 9.27718 11.652 9.252L12.54 5.088C12.55 5.03979 12.5694 4.99405 12.5972 4.95341C12.625 4.91277 12.6605 4.87805 12.7018 4.85127C12.7431 4.82448 12.7894 4.80615 12.8378 4.79735C12.8862 4.78855 12.9359 4.78945 12.984 4.8L15.924 5.388C16.0676 5.14132 16.2944 4.9539 16.5637 4.85937C16.833 4.76484 17.1272 4.7694 17.3934 4.87222C17.6597 4.97505 17.8806 5.1694 18.0164 5.42041C18.1523 5.67141 18.1942 5.96262 18.1348 6.24177C18.0753 6.52092 17.9182 6.76972 17.6918 6.94352C17.4654 7.11732 17.1845 7.20473 16.8995 7.19006C16.6144 7.1754 16.3439 7.05962 16.1366 6.8635C15.9292 6.66738 15.7985 6.40378 15.768 6.12L13.2 5.58L12.42 9.324C14.0702 9.3594 15.6749 9.87206 17.04 10.8C17.2839 10.566 17.5902 10.4074 17.9221 10.3436C18.254 10.2797 18.5973 10.3132 18.9106 10.4401C19.2239 10.5669 19.4939 10.7817 19.6879 11.0584ZM8.20624 12.5333C8.07438 12.7307 8.004 12.9627 8.004 13.2C8.004 13.5183 8.13043 13.8235 8.35547 14.0485C8.58051 14.2736 8.88574 14.4 9.204 14.4C9.44134 14.4 9.67335 14.3296 9.87068 14.1978C10.068 14.0659 10.2218 13.8785 10.3127 13.6592C10.4035 13.4399 10.4272 13.1987 10.3809 12.9659C10.3346 12.7331 10.2204 12.5193 10.0525 12.3515C9.8847 12.1836 9.67089 12.0694 9.43811 12.0231C9.20533 11.9768 8.96405 12.0005 8.74478 12.0913C8.52551 12.1822 8.33809 12.336 8.20624 12.5333ZM12.012 17.424C13.0771 17.4681 14.1246 17.1416 14.976 16.5V16.548C15.0075 16.5173 15.0327 16.4806 15.05 16.4402C15.0674 16.3997 15.0766 16.3563 15.0772 16.3122C15.0777 16.2682 15.0696 16.2245 15.0533 16.1837C15.0369 16.1428 15.0127 16.1055 14.982 16.074C14.9513 16.0425 14.9146 16.0173 14.8742 16C14.8337 15.9826 14.7903 15.9734 14.7462 15.9728C14.7022 15.9723 14.6585 15.9804 14.6177 15.9967C14.5768 16.0131 14.5395 16.0373 14.508 16.068C13.7797 16.5904 12.895 16.8487 12 16.8C11.1061 16.8399 10.2255 16.5732 9.504 16.044C9.44182 15.993 9.36289 15.9669 9.28256 15.9708C9.20222 15.9748 9.12622 16.0085 9.06935 16.0653C9.01247 16.1222 8.97879 16.1982 8.97484 16.2786C8.97089 16.3589 8.99697 16.4378 9.048 16.5C9.89937 17.1416 10.9469 17.4681 12.012 17.424ZM14.0933 14.2458C14.2907 14.3776 14.5227 14.448 14.76 14.448L14.748 14.496C14.9107 14.4978 15.0721 14.4664 15.2223 14.4038C15.3725 14.3413 15.5084 14.2488 15.6218 14.1321C15.7352 14.0154 15.8236 13.8768 15.8818 13.7248C15.9399 13.5728 15.9665 13.4106 15.96 13.248C15.96 13.0107 15.8896 12.7787 15.7578 12.5813C15.6259 12.384 15.4385 12.2302 15.2192 12.1393C14.9999 12.0485 14.7587 12.0248 14.5259 12.0711C14.2931 12.1174 14.0793 12.2316 13.9115 12.3995C13.7436 12.5673 13.6294 12.7811 13.5831 13.0139C13.5368 13.2467 13.5605 13.4879 13.6513 13.7072C13.7422 13.9265 13.896 14.1139 14.0933 14.2458Z" fill="currentColor"></path></svg><span>Reddit</span></a></div></div></article></main><footer class="mt-auto text-xs md:text-sm"><div class="container py-6 flex flex-col md:flex-row gap-2 md:gap-0 justify-between items-center"><div class="text-zinc-300"><nav><ul class="flex space-x-4"><li><a class="hover:text-white font-medium" href="/security-labs/sitemap.xml">Sitemap</a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://elastic.co?utm_source=elastic-search-labs&amp;utm_medium=referral&amp;utm_campaign=search-labs&amp;utm_content=footer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="inline-block w-3 h-3"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 003 8.25v10.5A2.25 2.25 0 005.25 21h10.5A2.25 2.25 0 0018 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg><span>Elastic.co</span></a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://twitter.com/elasticseclabs"><svg class="w-4 h-4 inline-block w-3 h-3" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>@elasticseclabs</span></a></li></ul></nav></div><div class="flex flex-col space-y-1 text-zinc-300"><p>© <!-- -->2025<!-- -->. Elasticsearch B.V. All Rights Reserved.</p></div></div></footer></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"title":"WinVisor – A hypervisor-based emulator for Windows x64 user-mode executables","slug":"winvisor-hypervisor-based-emulator","date":"2025-01-24","description":"WinVisor is a hypervisor-based emulator for Windows x64 user-mode executables that leverages the Windows Hypervisor Platform API to provide a virtualized environment for logging syscalls and enabling memory introspection.","image":"winvisor.jpg","subtitle":"A proof-of-concept hypervisor-based emulator for Windows x64 binaries","tags":["onweek","winvisor"],"body":{"raw":"\n## Background\n\nIn Windows 10 (version RS4), Microsoft introduced the [Windows Hypervisor Platform](https://learn.microsoft.com/en-us/virtualization/api/hypervisor-platform/hypervisor-platform) (WHP) API. This API exposes Microsoft's built-in hypervisor functionality to user-mode Windows applications. In 2024, the author used this API to create a personal project: a 16-bit MS-DOS emulator called [DOSVisor](https://github.com/x86matthew/DOSVisor). As mentioned in the release notes, there have always been plans to take this concept further and use it to emulate Windows applications. Elastic provides a research week (ON Week) twice per year for staff to work on personal projects, providing a great opportunity to begin working on this project. This project will be (unimaginatively) named WinVisor, inspired by its DOSVisor predecessor.\n\nHypervisors provide hardware-level virtualization, eliminating the need to emulate the CPU via software. This ensures that instructions are executed exactly as they would be on a physical CPU, whereas software-based emulators often behave inconsistently in edge cases.\n\nThis project aims to build a virtual environment for executing Windows x64 binaries, allowing syscalls to be logged (or hooked) and enabling memory introspection. The goal of this project is not to build a comprehensive and secure sandbox - by default, all syscalls will simply be logged and forwarded directly to the host. In its initial form, it will be trivial for code running within the virtualized guest to \"escape\" to the host. Safely securing a sandbox is a difficult task, and is beyond the scope of this project. The limitations will be described in further detail at the end of the article.\n\nDespite having been available for 6 years (at the time of writing), it seems that the WHP API hasn’t been used in many public projects other than complex codebases such as [QEMU](https://github.com/qemu/qemu) and [VirtualBox](https://www.virtualbox.org/). One other notable project is Alex Ionescu's [Simpleator](https://github.com/ionescu007/Simpleator) - a lightweight Windows user-mode emulator that also utilizes the WHP API. This project has many of the same goals as WinVisor, although the approach for implementation is quite different. The WinVisor project aims to automate as much as possible and support simple executables (e.g. `ping.exe`) universally out of the box.\n\nThis article will cover the general design of the project, some of the issues that were encountered, and how they were worked through. Some features will be limited due to development time constraints, but the final product will at least be a usable proof-of-concept. Links to the source code and binaries hosted on GitHub will be provided at the end of the article.\n\n### Hypervisor basics\n\nHypervisors are powered by VT-x (Intel) and AMD-V (AMD) extensions. These hardware-assisted frameworks enable virtualization by allowing one or more virtual machines to run on a single physical CPU. These extensions use different instruction sets and, therefore, are not inherently compatible with each other; separate code must be written for each.\n\nInternally, Hyper-V uses `hvix64.exe` for Intel support and `hvax64.exe` for AMD support. Microsoft's WHP API abstracts these hardware differences, allowing applications to create and manage virtual partitions regardless of the underlying CPU type. For simplicity, the following explanation will focus solely on VT-x.\n\nVT-x adds an additional set of instructions known as VMX (Virtual Machine Extensions), containing instructions such as `VMLAUNCH`, which begins the execution of a VM for the first time, and `VMRESUME`, which re-enters the VM after a VM exit. A VM exit occurs when certain conditions are triggered by the guest, such as specific instructions, I/O port access, page faults, and other exceptions. \n\nCentral to VMX is the Virtual Machine Control Structure (VMCS), a per-VM data structure that stores the state of the guest and host contexts as well as information about the execution environment. The VMCS contains fields that define processor state, control configurations, and optional conditions that trigger transitions from the guest back to the host. VMCS fields can be read or written to using the `VMREAD` and `VMWRITE` instructions.\n\nDuring a VM exit, the processor saves the guest state in the VMCS and transitions back to the host state for hypervisor intervention.\n\n## WinVisor overview\n\nThis project takes advantage of the high-level nature of the WHP API. The API exposes hypervisor functionality to user-mode and allows applications to map virtual memory from the host process directly into the guest's physical memory.\n\nThe virtual CPU operates almost exclusively in CPL3 (user-mode), except for a small bootloader that runs at CPL0 (kernel-mode) to initialize the CPU state before execution. This will be described in further detail in the Virtual CPU section.\n\nBuilding up the memory space for an emulated guest environment involves mapping the target executable and all DLL dependencies, followed by populating other internal data structures such as the Process Environment Block (PEB), Thread Environment Block (TEB), `KUSER_SHARED_DATA`, etc.\n\nMapping the EXE and DLL dependencies is straightforward, but accurately maintaining internal structures, such as the PEB, is a more complex task. These structures are large, mostly undocumented, and their contents can vary between Windows versions. It would be relatively simple to populate a minimalist set of fields to execute a simple \"Hello World\" application, but an improved approach should be taken to provide good compatibility.\n\nInstead of manually building up a virtual environment, WinVisor launches a suspended instance of the target process and clones the entire address space into the guest. The Import Address Table (IAT) and Thread Local Storage (TLS) data directories are temporarily removed from the PE headers in memory to stop DLL dependencies from loading and to prevent TLS callbacks from executing before reaching the entry point. The process is then resumed, allowing the usual process initialization to continue (`LdrpInitializeProcess`) until it reaches the entry point of the target executable, at which point the hypervisor launches and takes control. This essentially means that Windows has done all of the hard work for us, and we now have a pre-populated user-mode address space for the target executable that is ready for execution.\n\nA new thread is then created in a suspended state, with the start address pointing to the address of a custom loader function. This function populates the IAT, executes TLS callbacks, and finally executes the original entry point of the target application. This essentially simulates what the main thread would do if the process were being executed natively. The context of this thread is then \"cloned\" into the virtual CPU, and execution begins under the control of the hypervisor.\n\nMemory is paged into the guest as necessary, and syscalls are intercepted, logged, and forwarded to the host OS until the virtualized target process exits.\n\nAs the WHP API only allows memory from the current process to be mapped into the guest, the main hypervisor logic is encapsulated within a DLL that gets injected into the target process.\n\n## Virtual CPU\n\nThe WHP API provides a \"friendly\" wrapper around the VMX functionality described earlier, meaning that the usual steps, such as manually populating the VMCS before executing `VMLAUNCH`,  are no longer necessary. It also exposes the functionality to user-mode, meaning a custom driver is not required. However, the virtual CPU must still be initialized appropriately via WHP prior to executing the target code. The important aspects will be described below.\n\n### Control registers\n\nOnly the `CR0`, `CR3`, and `CR4` control registers are relevant for this project. `CR0` and `CR4` are used to enable CPU configuration options such as protected mode, paging, and PAE. `CR3` contains the physical address of the `PML4` paging table, which will be described in further detail in the Memory Paging section.\n\n### Model-specific registers\n\nModel-Specific Registers (MSRs) must also be initialized to ensure the correct operation of the virtual CPU. `MSR_EFER` contains flags for extended features, such as enabling long mode (64-bit) and `SYSCALL` instructions. `MSR_LSTAR` contains the address of the syscall handler, and `MSR_STAR` contains the segment selectors for transitioning to CPL0 (and back to CPL3) during syscalls. `MSR_KERNEL_GS_BASE` contains the shadow base address of the `GS` selector.\n\n### Global descriptor table\n\nThe Global Descriptor Table (GDT) defines the segment descriptors, which essentially describe memory regions and their properties for use in protected mode.\n\nIn long mode, the GDT has limited use and is mostly a relic of the past - x64 always operates in a flat memory mode, meaning all selectors are based at `0`. The only exceptions to this are the `FS` and `GS` registers, which are used for thread-specific purposes. Even in those cases, their base addresses are not defined by the GDT. Instead, MSRs (such as `MSR_KERNEL_GS_BASE` described above) are used to store the base address.\n\nDespite this obsolescence, the GDT is still an important part of the x64 model. For example, the current privilege level is defined by the `CS` (Code Segment) selector.\n\n### Task state segment\n\nIn long mode, the Task State Segment (TSS) is simply used to load the stack pointer when transitioning from a lower privilege level to a higher one. As this emulator operates almost exclusively in CPL3, except for the initial bootloader and interrupt handlers, only a single page is allocated for the CPL0 stack. The TSS is stored as a special system entry within the GDT and occupies two slots.\n\n### Interrupt descriptor table\n\nThe Interrupt Descriptor Table (IDT) contains information about each type of interrupt, such as the handler addresses. This will be described in further detail in the Interrupt Handling section.\n\n### Bootloader\n\nMost of the CPU fields mentioned above can be initialized using WHP wrapper functions, but support for certain fields (e.g. `XCR0`) only arrived in later versions of the WHP API (Windows 10 RS5). For completeness, the project includes a small “bootloader”, which runs at CPL0 upon startup and manually initializes the final parts of the CPU prior to executing the target code. Unlike a physical CPU, which would start in 16-bit real mode, the virtual CPU has already been initialized to run in long-mode (64-bit), making the boot process slightly more straightforward. \n\nThe following steps are performed by the bootloader:\n\n1. Load the GDT using the `LGDT` instruction. The source operand for this instruction specifies a 10-byte memory block which contains the base address and limit (size) of the table that was populated earlier.\n\n2. Load the IDT using the `LIDT` instruction. The source operand for this instruction uses the same format as LGDT described above.\n\n3. Set the TSS selector index into the task register using the `LTR` instruction. As mentioned above, the TSS descriptor exists as a special entry within the GDT (at `0x40` in this case).\n\n4. The XCR0 register can be set using the `XSETBV` instruction. This is an additional control register which is used for optional features such as AVX. The native process executes XGETBV to get the host value, which is then copied into the guest via `XSETBV` in the bootloader. \n \nThis is an important step because DLL dependencies that have already been loaded may have set global flags during their initialization process. For example, `ucrtbase.dll` checks if the CPU supports AVX via the `CPUID` instruction on startup and, if so, sets a global flag to allow the CRT to use AVX instructions for optimization reasons. If the virtual CPU attempts to execute these AVX instructions without explicitly enabling them in `XCR0` first, an undefined instruction exception will be raised.\n\n5. Manually update `DS`, `ES`, and `GS` data segment selectors to their CPL3 equivalents (`0x2B`). Execute the `SWAPGS` instruction to load the TEB base address from `MSR_KERNEL_GS_BASE`.\n\n6. Finally, use the `SYSRET` instruction to transition into CPL3. Prior to the `SYSRET` instruction, `RCX` is set to a placeholder address (CPL3 entry point), and `R11` is set to the initial CPL3 RFLAGS value (`0x202`). The `SYSRET` instruction automatically switches the `CS` and `SS` segment selectors to their CPL3 equivalents from `MSR_STAR`.  \n \nWhen the `SYSRET` instruction executes, a page fault will be raised due to the invalid placeholder address in `RIP`. The emulator will catch this page fault and recognize it as a “special” address. The initial CPL3 register values will then be copied into the virtual CPU, `RIP` is updated to point to a custom user-mode loader function, and execution resumes. This function loads all DLL dependencies for the target executable, populates the IAT table, executes TLS callbacks, and then executes the original entry point. The import table and TLS callbacks are handled at this stage, rather than earlier on, to ensure their code is executed within the virtualized environment.\n\n## Memory paging\n\nAll memory management for the guest must be handled manually. This means a paging table must be populated and maintained, allowing the virtual CPU to translate a virtual address to a physical address.\n\n### Virtual address translation\n\nFor those who are not familiar with paging in x64, the paging table has four levels: `PML4`, `PDPT`, `PD`, and `PT`. For any given virtual address, the CPU walks through each layer of the table, eventually reaching the target physical address. Modern CPUs also support 5-level paging (in case the 256TB of addressable memory offered by 4-level paging isn't enough!), but this is irrelevant for the purposes of this project.\n\nThe following image illustrates the format of a sample virtual address:\n\n![Breakdown of an example virtual address](/assets/images/winvisor-hypervisor-based-emulator/5WT-image.png \"Breakdown of an example virtual address\")\n\nUsing the example above, the CPU would calculate the physical page corresponding to the virtual address `0x7FFB7D030D10` via the following table entries: `PML4[0xFF]` -\u003e `PDPT[0x1ED]` -\u003e `PD[0x1E8]` -\u003e `PT[0x30]`. Finally, the offset (`0xD10`) will be added to this physical page to calculate the exact address.\n\nBits `48` - `63` within a virtual address are unused in 4-level paging and are essentially sign-extended to match bit `47`.\n\nThe `CR3` control register contains the physical address of the base `PML4` table. When paging is enabled (mandatory in long-mode), all other addresses within the context of the CPU refer to virtual addresses.\n\n### Page faults\n\nWhen the guest attempts to access memory, the virtual CPU will raise a page fault exception if the requested page isn't already present in the paging table. This will trigger a VM Exit event and pass control back to the host. When this occurs, the `CR2` control register contains the requested virtual address, although the WHP API already provides this value within the VM Exit context data. The host can then map the requested page into memory (if possible) and resume execution or throw an error if the target address is invalid.\n\n### Host/guest memory mirroring\n\nAs mentioned earlier, the emulator creates a child process, and all virtual memory within that process will be mapped directly into the guest using the same address layout. The Hypervisor Platform API allows us to map virtual memory from the host user-mode process directly into the physical memory of the guest. The paging table will then map virtual addresses to the corresponding physical pages.\n\nInstead of mapping the entire address space of the process upfront, a fixed number of physical pages are allocated for the guest. The emulator contains a very basic memory manager, and pages are mapped \"on demand.\" When a page fault occurs, the requested page will be paged in, and execution resumes. If all page \"slots\" are full, the oldest entry is swapped out to make room for the new one.\n\nIn addition to using a fixed number of currently mapped pages, the emulator also uses a fixed-size page table. The size of the page table is determined by calculating the maximum possible number of tables for the amount of mapped page entries. This model results in a simple and consistent physical memory layout but comes at the cost of efficiency. In fact, the paging tables take up more space than the actual page entries.\n\nThere is a single PML4 table, and in the worst-case scenario, each mapped page entry will reference unique PDPT/PD/PT tables. As each table is `4096` bytes, the total page table size can be calculated using the following formula:\n\n```\nPAGE_TABLE_SIZE = 4096 + (MAXIMUM_MAPPED_PAGES * 4096 * 3)\n```\n\nBy default, the emulator allows for `256` pages to be mapped at any one time (`1024KB` in total). Using the formula above, we can calculate that this will require `3076KB` for the paging table, as illustrated below:\n\n![Diagram illustrating the physical memory map within the virtualized guest](/assets/images/winvisor-hypervisor-based-emulator/8gv-image.png \"Diagram illustrating the physical memory map within the virtualized guest\")\n\nIn practice, many of the page table entries will be shared, and a lot of the space allocated for the paging tables will remain unused. However, as this emulator functions well even with a small number of pages, this level of overhead is not a major concern.\n\nThe CPU maintains a hardware-level cache for the paging table known as the Translation Lookaside Buffer (TLB). When translating a virtual address to a physical address, the CPU will first check the TLB. If a matching entry is not found in the cache (known as a “TLB miss”), the paging tables will be read instead. For this reason, it is important to flush the TLB cache whenever the paging tables have been rebuilt to prevent it from falling out of sync. The simplest way to flush the entire TLB is to reset the `CR3` register value.\n\n## Syscall handling\n\nAs the target program executes, any system calls that occur within the guest must be handled by the host. This emulator handles both `SYSCALL` instructions and legacy (interrupt-based) syscalls. `SYSENTER` is not used in long-mode and, therefore, is not supported by WinVisor.\n\n### Fast syscall (SYSCALL)\n\nWhen a `SYSCALL` instruction executes, the CPU transitions to CPL0 and loads `RIP` from `MSR_LSTAR`. In the Windows kernel, this would point to `KiSystemCall64`. `SYSCALL` instructions won't inherently trigger a VM Exit event, but the emulator sets `MSR_LSTAR` to a reserved placeholder address — `0xFFFF800000000000` in this case. When a `SYSCALL` instruction is executed, a page fault will be raised when RIP is set to this address, and the call can be intercepted. This placeholder is a kernel address in Windows and won't cause any conflicts with the user-mode address space.\n\nUnlike legacy syscalls, the `SYSCALL` instruction doesn't swap the `RSP` value during the transition to CPL0, so the user-mode stack pointer can be retrieved directly from `RSP`.\n\n### Legacy syscalls (INT 2E)\n\nLegacy interrupt-based syscalls are slower and have more overhead than the `SYSCALL` instruction, but despite this, they are still supported by Windows. As the emulator already contains a framework for handling interrupts, adding support for legacy syscalls is very simple. When a legacy syscall interrupt is caught, it can be forwarded to the “common” syscall handler after some minor translations — specifically, retrieving the stored user-mode `RSP` value from the CPL0 stack.\n\n### Syscall forwarding\n\nAfter the emulator creates the \"main thread\" whose context gets cloned into the virtual CPU, this native thread is reused as a proxy to forward syscalls to the host. Reusing the same thread maintains consistency for the TEB and any kernel state between the guest and the host. Win32k, in particular, relies on many thread-specific states, which should be reflected in the emulator.\n\nWhen a syscall occurs, either by a `SYSCALL` instruction or a legacy interrupt, the emulator intercepts it and transfers it to a universal handler function. The syscall number is stored in the `RAX` register, and the first four parameter values are stored in `R10`, `RDX`, `R8`, and `R9`, respectively. `R10` is used for the first parameter instead of the usual `RCX` register because the `SYSCALL` instruction overwrites `RCX` with the return address. The legacy syscall handler in Windows (`KiSystemService`) also uses `R10` for compatibility, so it doesn’t need to be handled differently in the emulator. The remaining parameters are retrieved from the stack.\n\nWe don’t know the exact number of parameters expected for any given syscall number, but luckily, this doesn’t matter. We can simply use a fixed amount, and as long as the number of supplied parameters is greater than or equal to the actual number, the syscall will function correctly. A simple assembly stub will be dynamically created, populating all of the parameters, executing the target syscall, and returning cleanly.\n\nTesting showed that the maximum number of parameters currently used by Windows syscalls is `17` (`NtAccessCheckByTypeResultListAndAuditAlarmByHandle`, `NtCreateTokenEx`, and `NtUserCreateWindowEx`). WinVisor uses `32` as the maximum number of parameters to allow for potential future expansion.\n\nAfter executing the syscall on the host, the return value is copied to `RAX` in the guest. `RIP` is then transferred to a `SYSRET` instruction (or `IRETQ` for legacy syscalls) before resuming the virtual CPU for a seamless transition back to user-mode.\n\n### Syscall logging\n\nBy default, the emulator simply forwards guest syscalls to the host and logs them to the console. However, some additional steps are necessary to convert the raw syscalls into a readable format.\n\nThe first step is to convert the syscall number to a name. Syscall numbers are made up of multiple parts: bits `12` - `13` contain the system service table index (`0` for `ntoskrnl`, `1` for `win32k`), and bits `0` - `11` contain the syscall index within the table. This information allows us to perform a reverse-lookup within the corresponding user-mode module (`ntdll` / `win32u`) to resolve the original syscall name.\n\nThe next step is to determine the number of parameter values to display for each syscall. As mentioned above, the emulator passes `32` parameter values to each syscall, even if most of them are not used. However, logging all `32` values for each syscall wouldn't be ideal for readability reasons. For example, a simple `NtClose(0x100)` call would be printed as `NtClose(0x100, xxx, xxx, xxx, xxx, xxx, xxx, xxx, xxx, ...)`. As mentioned earlier, there is no simple way to automatically determine the exact number of parameters for each syscall, but there is a trick that we can use to estimate it with high accuracy.\n\nThis trick relies on the 32-bit system libraries used by WoW64. These libraries use the stdcall calling convention, which means the caller pushes all parameters onto the stack, and they are cleaned internally by the callee before returning. In contrast, native x64 code places the first 4 parameters into registers, and the caller is responsible for managing the stack.\n\nFor example, the `NtClose` function in the WoW64 version of `ntdll.dll` ends with the `RET 4` instruction. This pops an additional 4-bytes off the stack after the return address, which implies that the function takes one parameter. If the function used `RET 8`, this would suggest that it takes 2 parameters, and so on.\n\nEven though the emulator runs as a 64-bit process, we can still load the 32-bit copies of `ntdll.dll` and `win32u.dll` into memory - either manually or mapped using `SEC_IMAGE`. A custom version of `GetProcAddress` must be written to resolve the WoW64 export addresses, but this is a trivial task. From here, we can automatically find the corresponding WoW64 export for each syscall, scan for the `RET` instruction to calculate the number of parameters, and store the value in a lookup table.\n\nThis method is not perfect, and there are a number of ways that this could fail:\n\n* A small number of native syscalls don't exist in WoW64, such as `NtUserSetWindowLongPtr`.\n* If a 32-bit function contains a 64-bit parameter, it will be split into 2x 32-bit parameters internally, whereas the corresponding 64-bit function would only require a single parameter for the same value.\n* The WoW64 syscall stub functions within Windows could change in such a way that causes the existing `RET` instruction search to fail.\n\nDespite these pitfalls, the results will be accurate for the vast majority of syscalls without having to rely on hardcoded values. In addition, these values are only used for logging purposes and won't affect anything else, so minor inaccuracies are acceptable in this context. If a failure is detected, it will revert back to displaying the maximum number of parameter values.\n\n### Syscall hooking\n\nIf this project were being used for sandboxing purposes, blindly forwarding all syscalls to the host would be undesirable for obvious reasons. The emulator contains a framework that allows specific syscalls to be easily hooked if necessary.\n\nBy default, only `NtTerminateThread` and `NtTerminateProcess` are hooked to catch the guest process exiting.\n\n## Interrupt handling\n\nInterrupts are defined by the IDT, which is populated before the virtual CPU execution begins. When an interrupt occurs, the current CPU state is pushed onto the CPL0 stack (`SS`, `RSP`, `RFLAGS`, `CS`, `RIP`), and `RIP` is set to the target handler function.\n\nAs with `MSR_LSTAR` for the SYSCALL handler, the emulator populates all interrupt handler addresses with placeholder values (`0xFFFFA00000000000` - `0xFFFFA000000000FF`). When an interrupt occurs, a page fault will occur within this range, which we can catch. The interrupt index can be extracted from the lowest 8-bits of the target address (e.g., `0xFFFFA00000000003` is `INT 3`), and the host can handle it as necessary.\n\nAt present, the emulator only handles `INT 1` (single-step), `INT 3` (breakpoint), and `INT 2E` (legacy syscall). If any other interrupt is caught, the emulator will exit with an error.\n\nWhen an interrupt has been handled, `RIP` is transferred to an `IRETQ` instruction, which returns to user-mode cleanly. Some types of interrupts push an additional \"error code\" value onto the stack - if this is the case, it must be popped prior to the `IRETQ` instruction to avoid stack corruption. The interrupt handler framework within this emulator contains an optional flag to handle this transparently.\n\n## Hypervisor shared page bug\n\nWindows 10 introduced a new type of shared page which is located close to `KUSER_SHARED_DATA`. This page is used by timing-related functions such as `RtlQueryPerformanceCounter` and `RtlGetMultiTimePrecise`.\n\nThe exact address of this page can be retrieved with `NtQuerySystemInformation`, using the `SystemHypervisorSharedPageInformation` information class. The `LdrpInitializeProcess` function stores the address of this page in a global variable (`RtlpHypervisorSharedUserVa`) during process startup.\n\nThe WHP API seems to contain a bug that causes the `WHvRunVirtualProcessor` function to get stuck in an infinite loop if this shared page is mapped into the guest and the virtual CPU attempts to read from it.\n\nTime constraints limited the ability to fully investigate this; however, a simple workaround was implemented. The emulator patches the `NtQuerySystemInformation` function within the target process and forces it to return `STATUS_INVALID_INFO_CLASS` for `SystemHypervisorSharedPageInformation` requests. This causes the `ntdll` code to fall back to traditional methods.\n\n## Demos\n\nSome examples of common Windows executables being emulated under this virtualized environment below:\n\n![ping.exe being emulated by WinVisor](/assets/images/winvisor-hypervisor-based-emulator/Slj_Image_3.png \"ping.exe being emulated by WinVisor\")\n\n![cmd.exe being emulated by WinVisor](/assets/images/winvisor-hypervisor-based-emulator/gs2_Image_4.png \"cmd.exe being emulated by WinVisor\")\n\n![notepad.exe being emulated by WinVisor, including a hooked syscall (NtUserCreateWindowEx) for demonstration purposes](/assets/images/winvisor-hypervisor-based-emulator/zkL_Image_5.png \"notepad.exe being emulated by WinVisor, including a hooked syscall (NtUserCreateWindowEx) for demonstration purposes\")\n\n## Limitations\n\nThe emulator has several limitations that make it unsafe to use as a secure sandbox in its current form. \n\n### Safety issues\n\nThere are several ways to \"escape\" the VM, such as simply creating a new process/thread, scheduling asynchronous procedure calls (APCs), etc.\n\nWindows GUI-related syscalls can also make nested calls directly back into user-mode from the kernel, which would currently bypass the hypervisor layer. For this reason, GUI executables such as notepad.exe are only partially virtualized when run under WinVisor.\n\nTo demonstrate this, WinVisor includes an `-nx` command-line switch to the emulator. This forces the entire target EXE image to be marked as non-executable in memory prior to starting the virtual CPU, causing the process to crash if the host process attempts to execute any of the code natively. However, this is still unsafe to rely on — the target application could make the region executable again or simply allocate executable memory elsewhere.\n\nAs the WinVisor DLL is injected into the target process, it exists within the same virtual address space as the target executable. This means the code running under the virtual CPU is able to directly access the memory within the host hypervisor module, which could potentially corrupt it. \n\n### Non-executable guest memory\n\nWhile the virtual CPU is set up to support NX, all memory regions are currently mirrored into the guest with full RWX access.\n\n### Single-thread only\n\nThe emulator currently only supports virtualizing a single thread. If the target executable creates additional threads, they will be executed natively. To support multiple threads, a pseudo-scheduler could be developed to handle this in the future.\n\nThe Windows parallel loader is disabled to ensure all module dependencies are loaded by a single thread.\n\n### Software exceptions\n\nVirtualized software exceptions are not currently supported. If an exception occurs, the system will call the `KiUserExceptionDispatcher` function natively as usual.\n\n## Conclusion\n\nAs seen above, the emulator performs well with a wide range of executables in its current form. While it is currently effective for logging syscalls and interrupts, a lot of further work would be required to make it safe to use for malware analysis purposes. Despite this, the project provides an effective framework for future development.\n\n## Project links\n\n[https://github.com/x86matthew/WinVisor](https://github.com/x86matthew/WinVisor)\n\nThe author can be found on X at [@x86matthew](https://x.com/x86matthew).\n","code":"var Component=(()=\u003e{var h=Object.create;var a=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var f=(i,e)=\u003e()=\u003e(e||i((e={exports:{}}).exports,e),e.exports),y=(i,e)=\u003e{for(var n in e)a(i,n,{get:e[n],enumerable:!0})},o=(i,e,n,s)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!g.call(i,r)\u0026\u0026r!==n\u0026\u0026a(i,r,{get:()=\u003ee[r],enumerable:!(s=u(e,r))||s.enumerable});return i};var b=(i,e,n)=\u003e(n=i!=null?h(m(i)):{},o(e||!i||!i.__esModule?a(n,\"default\",{value:i,enumerable:!0}):n,i)),w=i=\u003eo(a({},\"__esModule\",{value:!0}),i);var d=f((C,l)=\u003e{l.exports=_jsx_runtime});var S={};y(S,{default:()=\u003eT,frontmatter:()=\u003ev});var t=b(d()),v={title:\"WinVisor \\u2013 A hypervisor-based emulator for Windows x64 user-mode executables\",slug:\"winvisor-hypervisor-based-emulator\",date:\"2025-01-24\",subtitle:\"A proof-of-concept hypervisor-based emulator for Windows x64 binaries\",description:\"WinVisor is a hypervisor-based emulator for Windows x64 user-mode executables that leverages the Windows Hypervisor Platform API to provide a virtualized environment for logging syscalls and enabling memory introspection.\",author:[{slug:\"elastic-security-labs\"}],image:\"winvisor.jpg\",category:[{slug:\"perspectives\"}],tags:[\"onweek\",\"winvisor\"]};function c(i){let e=Object.assign({h2:\"h2\",p:\"p\",a:\"a\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",img:\"img\",pre:\"pre\",ul:\"ul\"},i.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{id:\"background\",children:\"Background\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"In Windows 10 (version RS4), Microsoft introduced the \",(0,t.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/virtualization/api/hypervisor-platform/hypervisor-platform\",rel:\"nofollow\",children:\"Windows Hypervisor Platform\"}),\" (WHP) API. This API exposes Microsoft's built-in hypervisor functionality to user-mode Windows applications. In 2024, the author used this API to create a personal project: a 16-bit MS-DOS emulator called \",(0,t.jsx)(e.a,{href:\"https://github.com/x86matthew/DOSVisor\",rel:\"nofollow\",children:\"DOSVisor\"}),\". As mentioned in the release notes, there have always been plans to take this concept further and use it to emulate Windows applications. Elastic provides a research week (ON Week) twice per year for staff to work on personal projects, providing a great opportunity to begin working on this project. This project will be (unimaginatively) named WinVisor, inspired by its DOSVisor predecessor.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Hypervisors provide hardware-level virtualization, eliminating the need to emulate the CPU via software. This ensures that instructions are executed exactly as they would be on a physical CPU, whereas software-based emulators often behave inconsistently in edge cases.\"}),`\n`,(0,t.jsx)(e.p,{children:'This project aims to build a virtual environment for executing Windows x64 binaries, allowing syscalls to be logged (or hooked) and enabling memory introspection. The goal of this project is not to build a comprehensive and secure sandbox - by default, all syscalls will simply be logged and forwarded directly to the host. In its initial form, it will be trivial for code running within the virtualized guest to \"escape\" to the host. Safely securing a sandbox is a difficult task, and is beyond the scope of this project. The limitations will be described in further detail at the end of the article.'}),`\n`,(0,t.jsxs)(e.p,{children:[\"Despite having been available for 6 years (at the time of writing), it seems that the WHP API hasn\\u2019t been used in many public projects other than complex codebases such as \",(0,t.jsx)(e.a,{href:\"https://github.com/qemu/qemu\",rel:\"nofollow\",children:\"QEMU\"}),\" and \",(0,t.jsx)(e.a,{href:\"https://www.virtualbox.org/\",rel:\"nofollow\",children:\"VirtualBox\"}),\". One other notable project is Alex Ionescu's \",(0,t.jsx)(e.a,{href:\"https://github.com/ionescu007/Simpleator\",rel:\"nofollow\",children:\"Simpleator\"}),\" - a lightweight Windows user-mode emulator that also utilizes the WHP API. This project has many of the same goals as WinVisor, although the approach for implementation is quite different. The WinVisor project aims to automate as much as possible and support simple executables (e.g. \",(0,t.jsx)(e.code,{children:\"ping.exe\"}),\") universally out of the box.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"This article will cover the general design of the project, some of the issues that were encountered, and how they were worked through. Some features will be limited due to development time constraints, but the final product will at least be a usable proof-of-concept. Links to the source code and binaries hosted on GitHub will be provided at the end of the article.\"}),`\n`,(0,t.jsx)(e.h3,{id:\"hypervisor-basics\",children:\"Hypervisor basics\"}),`\n`,(0,t.jsx)(e.p,{children:\"Hypervisors are powered by VT-x (Intel) and AMD-V (AMD) extensions. These hardware-assisted frameworks enable virtualization by allowing one or more virtual machines to run on a single physical CPU. These extensions use different instruction sets and, therefore, are not inherently compatible with each other; separate code must be written for each.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Internally, Hyper-V uses \",(0,t.jsx)(e.code,{children:\"hvix64.exe\"}),\" for Intel support and \",(0,t.jsx)(e.code,{children:\"hvax64.exe\"}),\" for AMD support. Microsoft's WHP API abstracts these hardware differences, allowing applications to create and manage virtual partitions regardless of the underlying CPU type. For simplicity, the following explanation will focus solely on VT-x.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"VT-x adds an additional set of instructions known as VMX (Virtual Machine Extensions), containing instructions such as \",(0,t.jsx)(e.code,{children:\"VMLAUNCH\"}),\", which begins the execution of a VM for the first time, and \",(0,t.jsx)(e.code,{children:\"VMRESUME\"}),\", which re-enters the VM after a VM exit. A VM exit occurs when certain conditions are triggered by the guest, such as specific instructions, I/O port access, page faults, and other exceptions.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Central to VMX is the Virtual Machine Control Structure (VMCS), a per-VM data structure that stores the state of the guest and host contexts as well as information about the execution environment. The VMCS contains fields that define processor state, control configurations, and optional conditions that trigger transitions from the guest back to the host. VMCS fields can be read or written to using the \",(0,t.jsx)(e.code,{children:\"VMREAD\"}),\" and \",(0,t.jsx)(e.code,{children:\"VMWRITE\"}),\" instructions.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"During a VM exit, the processor saves the guest state in the VMCS and transitions back to the host state for hypervisor intervention.\"}),`\n`,(0,t.jsx)(e.h2,{id:\"winvisor-overview\",children:\"WinVisor overview\"}),`\n`,(0,t.jsx)(e.p,{children:\"This project takes advantage of the high-level nature of the WHP API. The API exposes hypervisor functionality to user-mode and allows applications to map virtual memory from the host process directly into the guest's physical memory.\"}),`\n`,(0,t.jsx)(e.p,{children:\"The virtual CPU operates almost exclusively in CPL3 (user-mode), except for a small bootloader that runs at CPL0 (kernel-mode) to initialize the CPU state before execution. This will be described in further detail in the Virtual CPU section.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Building up the memory space for an emulated guest environment involves mapping the target executable and all DLL dependencies, followed by populating other internal data structures such as the Process Environment Block (PEB), Thread Environment Block (TEB), \",(0,t.jsx)(e.code,{children:\"KUSER_SHARED_DATA\"}),\", etc.\"]}),`\n`,(0,t.jsx)(e.p,{children:'Mapping the EXE and DLL dependencies is straightforward, but accurately maintaining internal structures, such as the PEB, is a more complex task. These structures are large, mostly undocumented, and their contents can vary between Windows versions. It would be relatively simple to populate a minimalist set of fields to execute a simple \"Hello World\" application, but an improved approach should be taken to provide good compatibility.'}),`\n`,(0,t.jsxs)(e.p,{children:[\"Instead of manually building up a virtual environment, WinVisor launches a suspended instance of the target process and clones the entire address space into the guest. The Import Address Table (IAT) and Thread Local Storage (TLS) data directories are temporarily removed from the PE headers in memory to stop DLL dependencies from loading and to prevent TLS callbacks from executing before reaching the entry point. The process is then resumed, allowing the usual process initialization to continue (\",(0,t.jsx)(e.code,{children:\"LdrpInitializeProcess\"}),\") until it reaches the entry point of the target executable, at which point the hypervisor launches and takes control. This essentially means that Windows has done all of the hard work for us, and we now have a pre-populated user-mode address space for the target executable that is ready for execution.\"]}),`\n`,(0,t.jsx)(e.p,{children:'A new thread is then created in a suspended state, with the start address pointing to the address of a custom loader function. This function populates the IAT, executes TLS callbacks, and finally executes the original entry point of the target application. This essentially simulates what the main thread would do if the process were being executed natively. The context of this thread is then \"cloned\" into the virtual CPU, and execution begins under the control of the hypervisor.'}),`\n`,(0,t.jsx)(e.p,{children:\"Memory is paged into the guest as necessary, and syscalls are intercepted, logged, and forwarded to the host OS until the virtualized target process exits.\"}),`\n`,(0,t.jsx)(e.p,{children:\"As the WHP API only allows memory from the current process to be mapped into the guest, the main hypervisor logic is encapsulated within a DLL that gets injected into the target process.\"}),`\n`,(0,t.jsx)(e.h2,{id:\"virtual-cpu\",children:\"Virtual CPU\"}),`\n`,(0,t.jsxs)(e.p,{children:['The WHP API provides a \"friendly\" wrapper around the VMX functionality described earlier, meaning that the usual steps, such as manually populating the VMCS before executing ',(0,t.jsx)(e.code,{children:\"VMLAUNCH\"}),\",  are no longer necessary. It also exposes the functionality to user-mode, meaning a custom driver is not required. However, the virtual CPU must still be initialized appropriately via WHP prior to executing the target code. The important aspects will be described below.\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"control-registers\",children:\"Control registers\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Only the \",(0,t.jsx)(e.code,{children:\"CR0\"}),\", \",(0,t.jsx)(e.code,{children:\"CR3\"}),\", and \",(0,t.jsx)(e.code,{children:\"CR4\"}),\" control registers are relevant for this project. \",(0,t.jsx)(e.code,{children:\"CR0\"}),\" and \",(0,t.jsx)(e.code,{children:\"CR4\"}),\" are used to enable CPU configuration options such as protected mode, paging, and PAE. \",(0,t.jsx)(e.code,{children:\"CR3\"}),\" contains the physical address of the \",(0,t.jsx)(e.code,{children:\"PML4\"}),\" paging table, which will be described in further detail in the Memory Paging section.\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"model-specific-registers\",children:\"Model-specific registers\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Model-Specific Registers (MSRs) must also be initialized to ensure the correct operation of the virtual CPU. \",(0,t.jsx)(e.code,{children:\"MSR_EFER\"}),\" contains flags for extended features, such as enabling long mode (64-bit) and \",(0,t.jsx)(e.code,{children:\"SYSCALL\"}),\" instructions. \",(0,t.jsx)(e.code,{children:\"MSR_LSTAR\"}),\" contains the address of the syscall handler, and \",(0,t.jsx)(e.code,{children:\"MSR_STAR\"}),\" contains the segment selectors for transitioning to CPL0 (and back to CPL3) during syscalls. \",(0,t.jsx)(e.code,{children:\"MSR_KERNEL_GS_BASE\"}),\" contains the shadow base address of the \",(0,t.jsx)(e.code,{children:\"GS\"}),\" selector.\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"global-descriptor-table\",children:\"Global descriptor table\"}),`\n`,(0,t.jsx)(e.p,{children:\"The Global Descriptor Table (GDT) defines the segment descriptors, which essentially describe memory regions and their properties for use in protected mode.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"In long mode, the GDT has limited use and is mostly a relic of the past - x64 always operates in a flat memory mode, meaning all selectors are based at \",(0,t.jsx)(e.code,{children:\"0\"}),\". The only exceptions to this are the \",(0,t.jsx)(e.code,{children:\"FS\"}),\" and \",(0,t.jsx)(e.code,{children:\"GS\"}),\" registers, which are used for thread-specific purposes. Even in those cases, their base addresses are not defined by the GDT. Instead, MSRs (such as \",(0,t.jsx)(e.code,{children:\"MSR_KERNEL_GS_BASE\"}),\" described above) are used to store the base address.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Despite this obsolescence, the GDT is still an important part of the x64 model. For example, the current privilege level is defined by the \",(0,t.jsx)(e.code,{children:\"CS\"}),\" (Code Segment) selector.\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"task-state-segment\",children:\"Task state segment\"}),`\n`,(0,t.jsx)(e.p,{children:\"In long mode, the Task State Segment (TSS) is simply used to load the stack pointer when transitioning from a lower privilege level to a higher one. As this emulator operates almost exclusively in CPL3, except for the initial bootloader and interrupt handlers, only a single page is allocated for the CPL0 stack. The TSS is stored as a special system entry within the GDT and occupies two slots.\"}),`\n`,(0,t.jsx)(e.h3,{id:\"interrupt-descriptor-table\",children:\"Interrupt descriptor table\"}),`\n`,(0,t.jsx)(e.p,{children:\"The Interrupt Descriptor Table (IDT) contains information about each type of interrupt, such as the handler addresses. This will be described in further detail in the Interrupt Handling section.\"}),`\n`,(0,t.jsx)(e.h3,{id:\"bootloader\",children:\"Bootloader\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Most of the CPU fields mentioned above can be initialized using WHP wrapper functions, but support for certain fields (e.g. \",(0,t.jsx)(e.code,{children:\"XCR0\"}),\") only arrived in later versions of the WHP API (Windows 10 RS5). For completeness, the project includes a small \\u201Cbootloader\\u201D, which runs at CPL0 upon startup and manually initializes the final parts of the CPU prior to executing the target code. Unlike a physical CPU, which would start in 16-bit real mode, the virtual CPU has already been initialized to run in long-mode (64-bit), making the boot process slightly more straightforward.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"The following steps are performed by the bootloader:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsxs)(e.p,{children:[\"Load the GDT using the \",(0,t.jsx)(e.code,{children:\"LGDT\"}),\" instruction. The source operand for this instruction specifies a 10-byte memory block which contains the base address and limit (size) of the table that was populated earlier.\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsxs)(e.p,{children:[\"Load the IDT using the \",(0,t.jsx)(e.code,{children:\"LIDT\"}),\" instruction. The source operand for this instruction uses the same format as LGDT described above.\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsxs)(e.p,{children:[\"Set the TSS selector index into the task register using the \",(0,t.jsx)(e.code,{children:\"LTR\"}),\" instruction. As mentioned above, the TSS descriptor exists as a special entry within the GDT (at \",(0,t.jsx)(e.code,{children:\"0x40\"}),\" in this case).\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsxs)(e.p,{children:[\"The XCR0 register can be set using the \",(0,t.jsx)(e.code,{children:\"XSETBV\"}),\" instruction. This is an additional control register which is used for optional features such as AVX. The native process executes XGETBV to get the host value, which is then copied into the guest via \",(0,t.jsx)(e.code,{children:\"XSETBV\"}),\" in the bootloader.\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"This is an important step because DLL dependencies that have already been loaded may have set global flags during their initialization process. For example, \",(0,t.jsx)(e.code,{children:\"ucrtbase.dll\"}),\" checks if the CPU supports AVX via the \",(0,t.jsx)(e.code,{children:\"CPUID\"}),\" instruction on startup and, if so, sets a global flag to allow the CRT to use AVX instructions for optimization reasons. If the virtual CPU attempts to execute these AVX instructions without explicitly enabling them in \",(0,t.jsx)(e.code,{children:\"XCR0\"}),\" first, an undefined instruction exception will be raised.\"]}),`\n`,(0,t.jsxs)(e.ol,{start:\"5\",children:[`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsxs)(e.p,{children:[\"Manually update \",(0,t.jsx)(e.code,{children:\"DS\"}),\", \",(0,t.jsx)(e.code,{children:\"ES\"}),\", and \",(0,t.jsx)(e.code,{children:\"GS\"}),\" data segment selectors to their CPL3 equivalents (\",(0,t.jsx)(e.code,{children:\"0x2B\"}),\"). Execute the \",(0,t.jsx)(e.code,{children:\"SWAPGS\"}),\" instruction to load the TEB base address from \",(0,t.jsx)(e.code,{children:\"MSR_KERNEL_GS_BASE\"}),\".\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsxs)(e.p,{children:[\"Finally, use the \",(0,t.jsx)(e.code,{children:\"SYSRET\"}),\" instruction to transition into CPL3. Prior to the \",(0,t.jsx)(e.code,{children:\"SYSRET\"}),\" instruction, \",(0,t.jsx)(e.code,{children:\"RCX\"}),\" is set to a placeholder address (CPL3 entry point), and \",(0,t.jsx)(e.code,{children:\"R11\"}),\" is set to the initial CPL3 RFLAGS value (\",(0,t.jsx)(e.code,{children:\"0x202\"}),\"). The \",(0,t.jsx)(e.code,{children:\"SYSRET\"}),\" instruction automatically switches the \",(0,t.jsx)(e.code,{children:\"CS\"}),\" and \",(0,t.jsx)(e.code,{children:\"SS\"}),\" segment selectors to their CPL3 equivalents from \",(0,t.jsx)(e.code,{children:\"MSR_STAR\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"When the \",(0,t.jsx)(e.code,{children:\"SYSRET\"}),\" instruction executes, a page fault will be raised due to the invalid placeholder address in \",(0,t.jsx)(e.code,{children:\"RIP\"}),\". The emulator will catch this page fault and recognize it as a \\u201Cspecial\\u201D address. The initial CPL3 register values will then be copied into the virtual CPU, \",(0,t.jsx)(e.code,{children:\"RIP\"}),\" is updated to point to a custom user-mode loader function, and execution resumes. This function loads all DLL dependencies for the target executable, populates the IAT table, executes TLS callbacks, and then executes the original entry point. The import table and TLS callbacks are handled at this stage, rather than earlier on, to ensure their code is executed within the virtualized environment.\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"memory-paging\",children:\"Memory paging\"}),`\n`,(0,t.jsx)(e.p,{children:\"All memory management for the guest must be handled manually. This means a paging table must be populated and maintained, allowing the virtual CPU to translate a virtual address to a physical address.\"}),`\n`,(0,t.jsx)(e.h3,{id:\"virtual-address-translation\",children:\"Virtual address translation\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"For those who are not familiar with paging in x64, the paging table has four levels: \",(0,t.jsx)(e.code,{children:\"PML4\"}),\", \",(0,t.jsx)(e.code,{children:\"PDPT\"}),\", \",(0,t.jsx)(e.code,{children:\"PD\"}),\", and \",(0,t.jsx)(e.code,{children:\"PT\"}),\". For any given virtual address, the CPU walks through each layer of the table, eventually reaching the target physical address. Modern CPUs also support 5-level paging (in case the 256TB of addressable memory offered by 4-level paging isn't enough!), but this is irrelevant for the purposes of this project.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"The following image illustrates the format of a sample virtual address:\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/winvisor-hypervisor-based-emulator/5WT-image.png\",alt:\"Breakdown of an example virtual address\",title:\"Breakdown of an example virtual address\",width:\"736\",height:\"142\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Using the example above, the CPU would calculate the physical page corresponding to the virtual address \",(0,t.jsx)(e.code,{children:\"0x7FFB7D030D10\"}),\" via the following table entries: \",(0,t.jsx)(e.code,{children:\"PML4[0xFF]\"}),\" -\u003e \",(0,t.jsx)(e.code,{children:\"PDPT[0x1ED]\"}),\" -\u003e \",(0,t.jsx)(e.code,{children:\"PD[0x1E8]\"}),\" -\u003e \",(0,t.jsx)(e.code,{children:\"PT[0x30]\"}),\". Finally, the offset (\",(0,t.jsx)(e.code,{children:\"0xD10\"}),\") will be added to this physical page to calculate the exact address.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Bits \",(0,t.jsx)(e.code,{children:\"48\"}),\" - \",(0,t.jsx)(e.code,{children:\"63\"}),\" within a virtual address are unused in 4-level paging and are essentially sign-extended to match bit \",(0,t.jsx)(e.code,{children:\"47\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"CR3\"}),\" control register contains the physical address of the base \",(0,t.jsx)(e.code,{children:\"PML4\"}),\" table. When paging is enabled (mandatory in long-mode), all other addresses within the context of the CPU refer to virtual addresses.\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"page-faults\",children:\"Page faults\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"When the guest attempts to access memory, the virtual CPU will raise a page fault exception if the requested page isn't already present in the paging table. This will trigger a VM Exit event and pass control back to the host. When this occurs, the \",(0,t.jsx)(e.code,{children:\"CR2\"}),\" control register contains the requested virtual address, although the WHP API already provides this value within the VM Exit context data. The host can then map the requested page into memory (if possible) and resume execution or throw an error if the target address is invalid.\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"hostguest-memory-mirroring\",children:\"Host/guest memory mirroring\"}),`\n`,(0,t.jsx)(e.p,{children:\"As mentioned earlier, the emulator creates a child process, and all virtual memory within that process will be mapped directly into the guest using the same address layout. The Hypervisor Platform API allows us to map virtual memory from the host user-mode process directly into the physical memory of the guest. The paging table will then map virtual addresses to the corresponding physical pages.\"}),`\n`,(0,t.jsx)(e.p,{children:'Instead of mapping the entire address space of the process upfront, a fixed number of physical pages are allocated for the guest. The emulator contains a very basic memory manager, and pages are mapped \"on demand.\" When a page fault occurs, the requested page will be paged in, and execution resumes. If all page \"slots\" are full, the oldest entry is swapped out to make room for the new one.'}),`\n`,(0,t.jsx)(e.p,{children:\"In addition to using a fixed number of currently mapped pages, the emulator also uses a fixed-size page table. The size of the page table is determined by calculating the maximum possible number of tables for the amount of mapped page entries. This model results in a simple and consistent physical memory layout but comes at the cost of efficiency. In fact, the paging tables take up more space than the actual page entries.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"There is a single PML4 table, and in the worst-case scenario, each mapped page entry will reference unique PDPT/PD/PT tables. As each table is \",(0,t.jsx)(e.code,{children:\"4096\"}),\" bytes, the total page table size can be calculated using the following formula:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`PAGE_TABLE_SIZE = 4096 + (MAXIMUM_MAPPED_PAGES * 4096 * 3)\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"By default, the emulator allows for \",(0,t.jsx)(e.code,{children:\"256\"}),\" pages to be mapped at any one time (\",(0,t.jsx)(e.code,{children:\"1024KB\"}),\" in total). Using the formula above, we can calculate that this will require \",(0,t.jsx)(e.code,{children:\"3076KB\"}),\" for the paging table, as illustrated below:\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/winvisor-hypervisor-based-emulator/8gv-image.png\",alt:\"Diagram illustrating the physical memory map within the virtualized guest\",title:\"Diagram illustrating the physical memory map within the virtualized guest\",width:\"637\",height:\"145\"})}),`\n`,(0,t.jsx)(e.p,{children:\"In practice, many of the page table entries will be shared, and a lot of the space allocated for the paging tables will remain unused. However, as this emulator functions well even with a small number of pages, this level of overhead is not a major concern.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The CPU maintains a hardware-level cache for the paging table known as the Translation Lookaside Buffer (TLB). When translating a virtual address to a physical address, the CPU will first check the TLB. If a matching entry is not found in the cache (known as a \\u201CTLB miss\\u201D), the paging tables will be read instead. For this reason, it is important to flush the TLB cache whenever the paging tables have been rebuilt to prevent it from falling out of sync. The simplest way to flush the entire TLB is to reset the \",(0,t.jsx)(e.code,{children:\"CR3\"}),\" register value.\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"syscall-handling\",children:\"Syscall handling\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"As the target program executes, any system calls that occur within the guest must be handled by the host. This emulator handles both \",(0,t.jsx)(e.code,{children:\"SYSCALL\"}),\" instructions and legacy (interrupt-based) syscalls. \",(0,t.jsx)(e.code,{children:\"SYSENTER\"}),\" is not used in long-mode and, therefore, is not supported by WinVisor.\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"fast-syscall-syscall\",children:\"Fast syscall (SYSCALL)\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"When a \",(0,t.jsx)(e.code,{children:\"SYSCALL\"}),\" instruction executes, the CPU transitions to CPL0 and loads \",(0,t.jsx)(e.code,{children:\"RIP\"}),\" from \",(0,t.jsx)(e.code,{children:\"MSR_LSTAR\"}),\". In the Windows kernel, this would point to \",(0,t.jsx)(e.code,{children:\"KiSystemCall64\"}),\". \",(0,t.jsx)(e.code,{children:\"SYSCALL\"}),\" instructions won't inherently trigger a VM Exit event, but the emulator sets \",(0,t.jsx)(e.code,{children:\"MSR_LSTAR\"}),\" to a reserved placeholder address \\u2014 \",(0,t.jsx)(e.code,{children:\"0xFFFF800000000000\"}),\" in this case. When a \",(0,t.jsx)(e.code,{children:\"SYSCALL\"}),\" instruction is executed, a page fault will be raised when RIP is set to this address, and the call can be intercepted. This placeholder is a kernel address in Windows and won't cause any conflicts with the user-mode address space.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Unlike legacy syscalls, the \",(0,t.jsx)(e.code,{children:\"SYSCALL\"}),\" instruction doesn't swap the \",(0,t.jsx)(e.code,{children:\"RSP\"}),\" value during the transition to CPL0, so the user-mode stack pointer can be retrieved directly from \",(0,t.jsx)(e.code,{children:\"RSP\"}),\".\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"legacy-syscalls-int-2e\",children:\"Legacy syscalls (INT 2E)\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Legacy interrupt-based syscalls are slower and have more overhead than the \",(0,t.jsx)(e.code,{children:\"SYSCALL\"}),\" instruction, but despite this, they are still supported by Windows. As the emulator already contains a framework for handling interrupts, adding support for legacy syscalls is very simple. When a legacy syscall interrupt is caught, it can be forwarded to the \\u201Ccommon\\u201D syscall handler after some minor translations \\u2014 specifically, retrieving the stored user-mode \",(0,t.jsx)(e.code,{children:\"RSP\"}),\" value from the CPL0 stack.\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"syscall-forwarding\",children:\"Syscall forwarding\"}),`\n`,(0,t.jsx)(e.p,{children:'After the emulator creates the \"main thread\" whose context gets cloned into the virtual CPU, this native thread is reused as a proxy to forward syscalls to the host. Reusing the same thread maintains consistency for the TEB and any kernel state between the guest and the host. Win32k, in particular, relies on many thread-specific states, which should be reflected in the emulator.'}),`\n`,(0,t.jsxs)(e.p,{children:[\"When a syscall occurs, either by a \",(0,t.jsx)(e.code,{children:\"SYSCALL\"}),\" instruction or a legacy interrupt, the emulator intercepts it and transfers it to a universal handler function. The syscall number is stored in the \",(0,t.jsx)(e.code,{children:\"RAX\"}),\" register, and the first four parameter values are stored in \",(0,t.jsx)(e.code,{children:\"R10\"}),\", \",(0,t.jsx)(e.code,{children:\"RDX\"}),\", \",(0,t.jsx)(e.code,{children:\"R8\"}),\", and \",(0,t.jsx)(e.code,{children:\"R9\"}),\", respectively. \",(0,t.jsx)(e.code,{children:\"R10\"}),\" is used for the first parameter instead of the usual \",(0,t.jsx)(e.code,{children:\"RCX\"}),\" register because the \",(0,t.jsx)(e.code,{children:\"SYSCALL\"}),\" instruction overwrites \",(0,t.jsx)(e.code,{children:\"RCX\"}),\" with the return address. The legacy syscall handler in Windows (\",(0,t.jsx)(e.code,{children:\"KiSystemService\"}),\") also uses \",(0,t.jsx)(e.code,{children:\"R10\"}),\" for compatibility, so it doesn\\u2019t need to be handled differently in the emulator. The remaining parameters are retrieved from the stack.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"We don\\u2019t know the exact number of parameters expected for any given syscall number, but luckily, this doesn\\u2019t matter. We can simply use a fixed amount, and as long as the number of supplied parameters is greater than or equal to the actual number, the syscall will function correctly. A simple assembly stub will be dynamically created, populating all of the parameters, executing the target syscall, and returning cleanly.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Testing showed that the maximum number of parameters currently used by Windows syscalls is \",(0,t.jsx)(e.code,{children:\"17\"}),\" (\",(0,t.jsx)(e.code,{children:\"NtAccessCheckByTypeResultListAndAuditAlarmByHandle\"}),\", \",(0,t.jsx)(e.code,{children:\"NtCreateTokenEx\"}),\", and \",(0,t.jsx)(e.code,{children:\"NtUserCreateWindowEx\"}),\"). WinVisor uses \",(0,t.jsx)(e.code,{children:\"32\"}),\" as the maximum number of parameters to allow for potential future expansion.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"After executing the syscall on the host, the return value is copied to \",(0,t.jsx)(e.code,{children:\"RAX\"}),\" in the guest. \",(0,t.jsx)(e.code,{children:\"RIP\"}),\" is then transferred to a \",(0,t.jsx)(e.code,{children:\"SYSRET\"}),\" instruction (or \",(0,t.jsx)(e.code,{children:\"IRETQ\"}),\" for legacy syscalls) before resuming the virtual CPU for a seamless transition back to user-mode.\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"syscall-logging\",children:\"Syscall logging\"}),`\n`,(0,t.jsx)(e.p,{children:\"By default, the emulator simply forwards guest syscalls to the host and logs them to the console. However, some additional steps are necessary to convert the raw syscalls into a readable format.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The first step is to convert the syscall number to a name. Syscall numbers are made up of multiple parts: bits \",(0,t.jsx)(e.code,{children:\"12\"}),\" - \",(0,t.jsx)(e.code,{children:\"13\"}),\" contain the system service table index (\",(0,t.jsx)(e.code,{children:\"0\"}),\" for \",(0,t.jsx)(e.code,{children:\"ntoskrnl\"}),\", \",(0,t.jsx)(e.code,{children:\"1\"}),\" for \",(0,t.jsx)(e.code,{children:\"win32k\"}),\"), and bits \",(0,t.jsx)(e.code,{children:\"0\"}),\" - \",(0,t.jsx)(e.code,{children:\"11\"}),\" contain the syscall index within the table. This information allows us to perform a reverse-lookup within the corresponding user-mode module (\",(0,t.jsx)(e.code,{children:\"ntdll\"}),\" / \",(0,t.jsx)(e.code,{children:\"win32u\"}),\") to resolve the original syscall name.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The next step is to determine the number of parameter values to display for each syscall. As mentioned above, the emulator passes \",(0,t.jsx)(e.code,{children:\"32\"}),\" parameter values to each syscall, even if most of them are not used. However, logging all \",(0,t.jsx)(e.code,{children:\"32\"}),\" values for each syscall wouldn't be ideal for readability reasons. For example, a simple \",(0,t.jsx)(e.code,{children:\"NtClose(0x100)\"}),\" call would be printed as \",(0,t.jsx)(e.code,{children:\"NtClose(0x100, xxx, xxx, xxx, xxx, xxx, xxx, xxx, xxx, ...)\"}),\". As mentioned earlier, there is no simple way to automatically determine the exact number of parameters for each syscall, but there is a trick that we can use to estimate it with high accuracy.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"This trick relies on the 32-bit system libraries used by WoW64. These libraries use the stdcall calling convention, which means the caller pushes all parameters onto the stack, and they are cleaned internally by the callee before returning. In contrast, native x64 code places the first 4 parameters into registers, and the caller is responsible for managing the stack.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"For example, the \",(0,t.jsx)(e.code,{children:\"NtClose\"}),\" function in the WoW64 version of \",(0,t.jsx)(e.code,{children:\"ntdll.dll\"}),\" ends with the \",(0,t.jsx)(e.code,{children:\"RET 4\"}),\" instruction. This pops an additional 4-bytes off the stack after the return address, which implies that the function takes one parameter. If the function used \",(0,t.jsx)(e.code,{children:\"RET 8\"}),\", this would suggest that it takes 2 parameters, and so on.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Even though the emulator runs as a 64-bit process, we can still load the 32-bit copies of \",(0,t.jsx)(e.code,{children:\"ntdll.dll\"}),\" and \",(0,t.jsx)(e.code,{children:\"win32u.dll\"}),\" into memory - either manually or mapped using \",(0,t.jsx)(e.code,{children:\"SEC_IMAGE\"}),\". A custom version of \",(0,t.jsx)(e.code,{children:\"GetProcAddress\"}),\" must be written to resolve the WoW64 export addresses, but this is a trivial task. From here, we can automatically find the corresponding WoW64 export for each syscall, scan for the \",(0,t.jsx)(e.code,{children:\"RET\"}),\" instruction to calculate the number of parameters, and store the value in a lookup table.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"This method is not perfect, and there are a number of ways that this could fail:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"A small number of native syscalls don't exist in WoW64, such as \",(0,t.jsx)(e.code,{children:\"NtUserSetWindowLongPtr\"}),\".\"]}),`\n`,(0,t.jsx)(e.li,{children:\"If a 32-bit function contains a 64-bit parameter, it will be split into 2x 32-bit parameters internally, whereas the corresponding 64-bit function would only require a single parameter for the same value.\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"The WoW64 syscall stub functions within Windows could change in such a way that causes the existing \",(0,t.jsx)(e.code,{children:\"RET\"}),\" instruction search to fail.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"Despite these pitfalls, the results will be accurate for the vast majority of syscalls without having to rely on hardcoded values. In addition, these values are only used for logging purposes and won't affect anything else, so minor inaccuracies are acceptable in this context. If a failure is detected, it will revert back to displaying the maximum number of parameter values.\"}),`\n`,(0,t.jsx)(e.h3,{id:\"syscall-hooking\",children:\"Syscall hooking\"}),`\n`,(0,t.jsx)(e.p,{children:\"If this project were being used for sandboxing purposes, blindly forwarding all syscalls to the host would be undesirable for obvious reasons. The emulator contains a framework that allows specific syscalls to be easily hooked if necessary.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"By default, only \",(0,t.jsx)(e.code,{children:\"NtTerminateThread\"}),\" and \",(0,t.jsx)(e.code,{children:\"NtTerminateProcess\"}),\" are hooked to catch the guest process exiting.\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"interrupt-handling\",children:\"Interrupt handling\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Interrupts are defined by the IDT, which is populated before the virtual CPU execution begins. When an interrupt occurs, the current CPU state is pushed onto the CPL0 stack (\",(0,t.jsx)(e.code,{children:\"SS\"}),\", \",(0,t.jsx)(e.code,{children:\"RSP\"}),\", \",(0,t.jsx)(e.code,{children:\"RFLAGS\"}),\", \",(0,t.jsx)(e.code,{children:\"CS\"}),\", \",(0,t.jsx)(e.code,{children:\"RIP\"}),\"), and \",(0,t.jsx)(e.code,{children:\"RIP\"}),\" is set to the target handler function.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"As with \",(0,t.jsx)(e.code,{children:\"MSR_LSTAR\"}),\" for the SYSCALL handler, the emulator populates all interrupt handler addresses with placeholder values (\",(0,t.jsx)(e.code,{children:\"0xFFFFA00000000000\"}),\" - \",(0,t.jsx)(e.code,{children:\"0xFFFFA000000000FF\"}),\"). When an interrupt occurs, a page fault will occur within this range, which we can catch. The interrupt index can be extracted from the lowest 8-bits of the target address (e.g., \",(0,t.jsx)(e.code,{children:\"0xFFFFA00000000003\"}),\" is \",(0,t.jsx)(e.code,{children:\"INT 3\"}),\"), and the host can handle it as necessary.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"At present, the emulator only handles \",(0,t.jsx)(e.code,{children:\"INT 1\"}),\" (single-step), \",(0,t.jsx)(e.code,{children:\"INT 3\"}),\" (breakpoint), and \",(0,t.jsx)(e.code,{children:\"INT 2E\"}),\" (legacy syscall). If any other interrupt is caught, the emulator will exit with an error.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"When an interrupt has been handled, \",(0,t.jsx)(e.code,{children:\"RIP\"}),\" is transferred to an \",(0,t.jsx)(e.code,{children:\"IRETQ\"}),' instruction, which returns to user-mode cleanly. Some types of interrupts push an additional \"error code\" value onto the stack - if this is the case, it must be popped prior to the ',(0,t.jsx)(e.code,{children:\"IRETQ\"}),\" instruction to avoid stack corruption. The interrupt handler framework within this emulator contains an optional flag to handle this transparently.\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"hypervisor-shared-page-bug\",children:\"Hypervisor shared page bug\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Windows 10 introduced a new type of shared page which is located close to \",(0,t.jsx)(e.code,{children:\"KUSER_SHARED_DATA\"}),\". This page is used by timing-related functions such as \",(0,t.jsx)(e.code,{children:\"RtlQueryPerformanceCounter\"}),\" and \",(0,t.jsx)(e.code,{children:\"RtlGetMultiTimePrecise\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The exact address of this page can be retrieved with \",(0,t.jsx)(e.code,{children:\"NtQuerySystemInformation\"}),\", using the \",(0,t.jsx)(e.code,{children:\"SystemHypervisorSharedPageInformation\"}),\" information class. The \",(0,t.jsx)(e.code,{children:\"LdrpInitializeProcess\"}),\" function stores the address of this page in a global variable (\",(0,t.jsx)(e.code,{children:\"RtlpHypervisorSharedUserVa\"}),\") during process startup.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The WHP API seems to contain a bug that causes the \",(0,t.jsx)(e.code,{children:\"WHvRunVirtualProcessor\"}),\" function to get stuck in an infinite loop if this shared page is mapped into the guest and the virtual CPU attempts to read from it.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Time constraints limited the ability to fully investigate this; however, a simple workaround was implemented. The emulator patches the \",(0,t.jsx)(e.code,{children:\"NtQuerySystemInformation\"}),\" function within the target process and forces it to return \",(0,t.jsx)(e.code,{children:\"STATUS_INVALID_INFO_CLASS\"}),\" for \",(0,t.jsx)(e.code,{children:\"SystemHypervisorSharedPageInformation\"}),\" requests. This causes the \",(0,t.jsx)(e.code,{children:\"ntdll\"}),\" code to fall back to traditional methods.\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"demos\",children:\"Demos\"}),`\n`,(0,t.jsx)(e.p,{children:\"Some examples of common Windows executables being emulated under this virtualized environment below:\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/winvisor-hypervisor-based-emulator/Slj_Image_3.png\",alt:\"ping.exe being emulated by WinVisor\",title:\"ping.exe being emulated by WinVisor\",width:\"1125\",height:\"749\"})}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/winvisor-hypervisor-based-emulator/gs2_Image_4.png\",alt:\"cmd.exe being emulated by WinVisor\",title:\"cmd.exe being emulated by WinVisor\",width:\"1130\",height:\"754\"})}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/winvisor-hypervisor-based-emulator/zkL_Image_5.png\",alt:\"notepad.exe being emulated by WinVisor, including a hooked syscall (NtUserCreateWindowEx) for demonstration purposes\",title:\"notepad.exe being emulated by WinVisor, including a hooked syscall (NtUserCreateWindowEx) for demonstration purposes\",width:\"1138\",height:\"756\"})}),`\n`,(0,t.jsx)(e.h2,{id:\"limitations\",children:\"Limitations\"}),`\n`,(0,t.jsx)(e.p,{children:\"The emulator has several limitations that make it unsafe to use as a secure sandbox in its current form.\"}),`\n`,(0,t.jsx)(e.h3,{id:\"safety-issues\",children:\"Safety issues\"}),`\n`,(0,t.jsx)(e.p,{children:'There are several ways to \"escape\" the VM, such as simply creating a new process/thread, scheduling asynchronous procedure calls (APCs), etc.'}),`\n`,(0,t.jsx)(e.p,{children:\"Windows GUI-related syscalls can also make nested calls directly back into user-mode from the kernel, which would currently bypass the hypervisor layer. For this reason, GUI executables such as notepad.exe are only partially virtualized when run under WinVisor.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"To demonstrate this, WinVisor includes an \",(0,t.jsx)(e.code,{children:\"-nx\"}),\" command-line switch to the emulator. This forces the entire target EXE image to be marked as non-executable in memory prior to starting the virtual CPU, causing the process to crash if the host process attempts to execute any of the code natively. However, this is still unsafe to rely on \\u2014 the target application could make the region executable again or simply allocate executable memory elsewhere.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"As the WinVisor DLL is injected into the target process, it exists within the same virtual address space as the target executable. This means the code running under the virtual CPU is able to directly access the memory within the host hypervisor module, which could potentially corrupt it.\"}),`\n`,(0,t.jsx)(e.h3,{id:\"non-executable-guest-memory\",children:\"Non-executable guest memory\"}),`\n`,(0,t.jsx)(e.p,{children:\"While the virtual CPU is set up to support NX, all memory regions are currently mirrored into the guest with full RWX access.\"}),`\n`,(0,t.jsx)(e.h3,{id:\"single-thread-only\",children:\"Single-thread only\"}),`\n`,(0,t.jsx)(e.p,{children:\"The emulator currently only supports virtualizing a single thread. If the target executable creates additional threads, they will be executed natively. To support multiple threads, a pseudo-scheduler could be developed to handle this in the future.\"}),`\n`,(0,t.jsx)(e.p,{children:\"The Windows parallel loader is disabled to ensure all module dependencies are loaded by a single thread.\"}),`\n`,(0,t.jsx)(e.h3,{id:\"software-exceptions\",children:\"Software exceptions\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Virtualized software exceptions are not currently supported. If an exception occurs, the system will call the \",(0,t.jsx)(e.code,{children:\"KiUserExceptionDispatcher\"}),\" function natively as usual.\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"conclusion\",children:\"Conclusion\"}),`\n`,(0,t.jsx)(e.p,{children:\"As seen above, the emulator performs well with a wide range of executables in its current form. While it is currently effective for logging syscalls and interrupts, a lot of further work would be required to make it safe to use for malware analysis purposes. Despite this, the project provides an effective framework for future development.\"}),`\n`,(0,t.jsx)(e.h2,{id:\"project-links\",children:\"Project links\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:\"https://github.com/x86matthew/WinVisor\",rel:\"nofollow\",children:\"https://github.com/x86matthew/WinVisor\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"The author can be found on X at \",(0,t.jsx)(e.a,{href:\"https://x.com/x86matthew\",rel:\"nofollow\",children:\"@x86matthew\"}),\".\"]})]})}function x(i={}){let{wrapper:e}=i.components||{};return e?(0,t.jsx)(e,Object.assign({},i,{children:(0,t.jsx)(c,i)})):c(i)}var T=x;return w(S);})();\n;return Component;"},"_id":"articles/winvisor-hypervisor-based-emulator.mdx","_raw":{"sourceFilePath":"articles/winvisor-hypervisor-based-emulator.mdx","sourceFileName":"winvisor-hypervisor-based-emulator.mdx","sourceFileDir":"articles","contentType":"mdx","flattenedPath":"articles/winvisor-hypervisor-based-emulator"},"type":"Article","imageUrl":"/assets/images/winvisor-hypervisor-based-emulator/winvisor.jpg","readingTime":"25 min read","series":"","url":"/winvisor-hypervisor-based-emulator","headings":[{"level":2,"title":"Background","href":"#background"},{"level":3,"title":"Hypervisor basics","href":"#hypervisor-basics"},{"level":2,"title":"WinVisor overview","href":"#winvisor-overview"},{"level":2,"title":"Virtual CPU","href":"#virtual-cpu"},{"level":3,"title":"Control registers","href":"#control-registers"},{"level":3,"title":"Model-specific registers","href":"#model-specific-registers"},{"level":3,"title":"Global descriptor table","href":"#global-descriptor-table"},{"level":3,"title":"Task state segment","href":"#task-state-segment"},{"level":3,"title":"Interrupt descriptor table","href":"#interrupt-descriptor-table"},{"level":3,"title":"Bootloader","href":"#bootloader"},{"level":2,"title":"Memory paging","href":"#memory-paging"},{"level":3,"title":"Virtual address translation","href":"#virtual-address-translation"},{"level":3,"title":"Page faults","href":"#page-faults"},{"level":3,"title":"Host/guest memory mirroring","href":"#hostguest-memory-mirroring"},{"level":2,"title":"Syscall handling","href":"#syscall-handling"},{"level":3,"title":"Fast syscall (SYSCALL)","href":"#fast-syscall-syscall"},{"level":3,"title":"Legacy syscalls (INT 2E)","href":"#legacy-syscalls-int-2e"},{"level":3,"title":"Syscall forwarding","href":"#syscall-forwarding"},{"level":3,"title":"Syscall logging","href":"#syscall-logging"},{"level":3,"title":"Syscall hooking","href":"#syscall-hooking"},{"level":2,"title":"Interrupt handling","href":"#interrupt-handling"},{"level":2,"title":"Hypervisor shared page bug","href":"#hypervisor-shared-page-bug"},{"level":2,"title":"Demos","href":"#demos"},{"level":2,"title":"Limitations","href":"#limitations"},{"level":3,"title":"Safety issues","href":"#safety-issues"},{"level":3,"title":"Non-executable guest memory","href":"#non-executable-guest-memory"},{"level":3,"title":"Single-thread only","href":"#single-thread-only"},{"level":3,"title":"Software exceptions","href":"#software-exceptions"},{"level":2,"title":"Conclusion","href":"#conclusion"},{"level":2,"title":"Project links","href":"#project-links"}],"author":[{"title":"Elastic Security Labs","slug":"elastic-security-labs","body":{"raw":"","code":"var Component=(()=\u003e{var m=Object.create;var a=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var _=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var j=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=\u003e{for(var n in e)a(t,n,{get:e[n],enumerable:!0})},c=(t,e,n,o)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let s of f(e))!g.call(t,s)\u0026\u0026s!==n\u0026\u0026a(t,s,{get:()=\u003ee[s],enumerable:!(o=x(e,s))||o.enumerable});return t};var d=(t,e,n)=\u003e(n=t!=null?m(_(t)):{},c(e||!t||!t.__esModule?a(n,\"default\",{value:t,enumerable:!0}):n,t)),p=t=\u003ec(a({},\"__esModule\",{value:!0}),t);var u=j((L,i)=\u003e{i.exports=_jsx_runtime});var D={};b(D,{default:()=\u003eC,frontmatter:()=\u003ey});var r=d(u()),y={title:\"Elastic Security Labs\",slug:\"elastic-security-labs\"};function l(t){return(0,r.jsx)(r.Fragment,{})}function M(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(l,t)})):l(t)}var C=M;return p(D);})();\n;return Component;"},"_id":"authors/elastic-security-labs.mdx","_raw":{"sourceFilePath":"authors/elastic-security-labs.mdx","sourceFileName":"elastic-security-labs.mdx","sourceFileDir":"authors","contentType":"mdx","flattenedPath":"authors/elastic-security-labs"},"type":"Author","imageUrl":"","url":"/authors/elastic-security-labs"}],"category":[{"title":"Perspectives","slug":"perspectives","body":{"raw":"","code":"var Component=(()=\u003e{var x=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var _=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var j=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),l=(t,e)=\u003e{for(var n in e)o(t,n,{get:e[n],enumerable:!0})},c=(t,e,n,a)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let s of f(e))!g.call(t,s)\u0026\u0026s!==n\u0026\u0026o(t,s,{get:()=\u003ee[s],enumerable:!(a=p(e,s))||a.enumerable});return t};var d=(t,e,n)=\u003e(n=t!=null?x(_(t)):{},c(e||!t||!t.__esModule?o(n,\"default\",{value:t,enumerable:!0}):n,t)),M=t=\u003ec(o({},\"__esModule\",{value:!0}),t);var u=j((b,i)=\u003e{i.exports=_jsx_runtime});var F={};l(F,{default:()=\u003eD,frontmatter:()=\u003ev});var r=d(u()),v={title:\"Perspectives\",slug:\"perspectives\"};function m(t){return(0,r.jsx)(r.Fragment,{})}function C(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(m,t)})):m(t)}var D=C;return M(F);})();\n;return Component;"},"_id":"categories/perspectives.mdx","_raw":{"sourceFilePath":"categories/perspectives.mdx","sourceFileName":"perspectives.mdx","sourceFileDir":"categories","contentType":"mdx","flattenedPath":"categories/perspectives"},"type":"Category","url":"/categories/perspectives"}]},"seriesArticles":null},"__N_SSG":true},"page":"/[slug]","query":{"slug":"winvisor-hypervisor-based-emulator"},"buildId":"rlzZ6pCDkscxnj1LTzZLu","assetPrefix":"/security-labs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>