<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Introducing a New Vulnerability Class: False File Immutability — Elastic Security Labs</title><meta name="description" content="This article introduces a previously-unnamed class of Windows vulnerability that demonstrates the dangers of assumption and describes some unintended security consequences."/><meta property="og:title" content="Introducing a New Vulnerability Class: False File Immutability — Elastic Security Labs"/><meta property="og:description" content="This article introduces a previously-unnamed class of Windows vulnerability that demonstrates the dangers of assumption and describes some unintended security consequences."/><meta property="og:image" content="https://www.elastic.co/security-labs/assets/images/false-file-immutability/Security Labs Images 36.jpg?3ffdd571baa01f12b59739a4e5644a01"/><meta property="og:image:alt" content="This article introduces a previously-unnamed class of Windows vulnerability that demonstrates the dangers of assumption and describes some unintended security consequences."/><meta property="og:site_name"/><meta property="og:url" content="https://www.elastic.co/security-labs/false-file-immutability"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Introducing a New Vulnerability Class: False File Immutability — Elastic Security Labs"/><meta name="twitter:description" content="This article introduces a previously-unnamed class of Windows vulnerability that demonstrates the dangers of assumption and describes some unintended security consequences."/><meta name="twitter:image" content="https://www.elastic.co/security-labs/assets/images/false-file-immutability/Security Labs Images 36.jpg?3ffdd571baa01f12b59739a4e5644a01"/><meta name="twitter:image:alt" content="This article introduces a previously-unnamed class of Windows vulnerability that demonstrates the dangers of assumption and describes some unintended security consequences."/><link rel="canonical" href="https://www.elastic.co/security-labs/false-file-immutability"/><link rel="preload" href="/security-labs/logo.svg" as="image" fetchpriority="high"/><link rel="preload" as="image" imageSrcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2FSecurity%20Labs%20Images%2036.jpg&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2FSecurity%20Labs%20Images%2036.jpg&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2FSecurity%20Labs%20Images%2036.jpg&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2FSecurity%20Labs%20Images%2036.jpg&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2FSecurity%20Labs%20Images%2036.jpg&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2FSecurity%20Labs%20Images%2036.jpg&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2FSecurity%20Labs%20Images%2036.jpg&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2FSecurity%20Labs%20Images%2036.jpg&amp;w=3840&amp;q=75 3840w" imageSizes="100vw" fetchpriority="high"/><meta name="next-head-count" content="19"/><script src="https://play.vidyard.com/embed/v4.js" type="text/javascript" async=""></script><link rel="icon" href="/security-labs/favicon.svg"/><link rel="mask-icon" href="/security-labs/favicon.svg" color="#1C1E23"/><link rel="apple-touch-icon" href="/security-labs/favicon.svg"/><meta name="theme-color" content="#1C1E23"/><link rel="preload" href="/security-labs/_next/static/media/6d93bde91c0c2823-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/a34f9d1faa5f3315-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/369c6e283c5acc6e-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/92f44bb82993d879-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/ee71530a747ff30b-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/9fac010bc1f02be0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/cbf5fbad4d73afac-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><script id="google-tag-manager" data-nscript="beforeInteractive">
          (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
          new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
          j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
          'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
          })(window,document,'script','dataLayer','GTM-KNJMG2M');
          </script><link rel="preload" href="/security-labs/_next/static/css/265ed7605fd03477.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/265ed7605fd03477.css" data-n-g=""/><link rel="preload" href="/security-labs/_next/static/css/1007ff9e696f6f88.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/1007ff9e696f6f88.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/security-labs/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/security-labs/_next/static/chunks/webpack-7987c6fda769d510.js" defer=""></script><script src="/security-labs/_next/static/chunks/framework-7a7e500878b44665.js" defer=""></script><script src="/security-labs/_next/static/chunks/main-ebd33a9f1cae5951.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/_app-cb8664d1d3df2511.js" defer=""></script><script src="/security-labs/_next/static/chunks/fec483df-43ee602fabdfe3a4.js" defer=""></script><script src="/security-labs/_next/static/chunks/877-34f408271ef44c22.js" defer=""></script><script src="/security-labs/_next/static/chunks/511-d08fe0fdd6f8a984.js" defer=""></script><script src="/security-labs/_next/static/chunks/683-a5053c37fe5bd0c9.js" defer=""></script><script src="/security-labs/_next/static/chunks/402-791da5e634930df4.js" defer=""></script><script src="/security-labs/_next/static/chunks/616-0b017b9cfa597392.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/%5Bslug%5D-3d74e9a05863bcfd.js" defer=""></script><script src="/security-labs/_next/static/dGrrQfBbQkqaleQ_11aBK/_buildManifest.js" defer=""></script><script src="/security-labs/_next/static/dGrrQfBbQkqaleQ_11aBK/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KNJMG2M" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><main class="__variable_0351a5 __variable_1f211e __variable_a5b5f5 flex flex-col min-h-screen"><div class="scroll-percentage-container"><div class="scroll-percentage-bar" style="width:0%"></div></div><nav class="fixed w-full z-40" data-headlessui-state=""><div class="bg-gradient-to-b from-zinc-900 from-20% h-[200%] to-transparent absolute inset-0 z-0 pointer-events-none"></div><div class="container relative z-10"><div class="flex h-16 items-center justify-between"><div class="flex items-center justify-start w-full"><div><a class="hover:opacity-50 transition" href="/security-labs"><img alt="elastic security labs logo" fetchpriority="high" width="200" height="30" decoding="async" data-nimg="1" style="color:transparent" src="/security-labs/logo.svg"/></a></div><div class="hidden lg:ml-6 lg:block"><div class="flex space-x-4"><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/about"><span>About</span></a><div class="relative" data-headlessui-state=""><div><button class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" id="headlessui-menu-button-:R2kpm:" type="button" aria-haspopup="menu" aria-expanded="false" data-headlessui-state="">Topics<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="ml-1 -mr-1 h-4 w-4 text-zinc-400 relative top-[1px]"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z" clip-rule="evenodd"></path></svg></button></div></div><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/vulnerability-updates"><span>Vulnerability updates</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/reports"><span>Reports</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/tools"><span>Tools</span></a></div></div><div class="hidden lg:ml-auto lg:block"><div class="flex items-center space-x-4"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/false-file-immutability"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="https://www.elastic.co/security-labs/rss/feed.xml"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="h-4 w-4 mr-1"><path d="M3.75 3a.75.75 0 00-.75.75v.5c0 .414.336.75.75.75H4c6.075 0 11 4.925 11 11v.25c0 .414.336.75.75.75h.5a.75.75 0 00.75-.75V16C17 8.82 11.18 3 4 3h-.25z"></path><path d="M3 8.75A.75.75 0 013.75 8H4a8 8 0 018 8v.25a.75.75 0 01-.75.75h-.5a.75.75 0 01-.75-.75V16a6 6 0 00-6-6h-.25A.75.75 0 013 9.25v-.5zM7 15a2 2 0 11-4 0 2 2 0 014 0z"></path></svg><span class="hidden xl:block">Subscribe</span></a><a class="font-display inline-flex items-center justify-center rounded font-semibold disabled:!select-none disabled:!bg-gray-400 bg-blue-600 text-white hover:bg-blue-500 enabled:hover:text-white/80 transition-colors px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://cloud.elastic.co/registration?cta=cloud-registration&amp;tech=trial&amp;plcmt=navigation&amp;pg=security-labs">Start free trial</a><a class="font-display inline-flex items-center justify-center rounded font-semibold text-white disabled:!select-none disabled:!bg-gray-400 button px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://www.elastic.co/contact">Contact sales</a></div></div></div><div class="-mr-2 flex lg:hidden"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/false-file-immutability"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><button class="inline-flex items-center justify-center rounded-md p-2 text-gray-400 hover:bg-gray-700 hover:text-white focus:outline-none focus:ring-2 focus:ring-inset focus:ring-white" id="headlessui-disclosure-button-:R59m:" type="button" aria-expanded="false" data-headlessui-state=""><span class="sr-only">Open navigation menu</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="block h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div></div></div></nav><main class="mb-20 flex-1 flex flex-col"><div class="h-48 md:h-64"><div class="after:absolute after:block after:bg-blue-400 after:blur-3xl after:content-[&#x27; &#x27;] after:h-96 after:opacity-5 after:right-0 after:rounded-full after:top-20 after:w-1/2 after:z-0 before:absolute before:block before:blur-3xl before:bg-orange-400 before:content-[&#x27; &#x27;] before:h-96 before:left-0 before:opacity-5 before:rounded-full before:w-1/2 before:z-0 w-full h-full relative"><div class="relative z-10 w-full h-[125%] -top-[25%] bg-no-repeat bg-cover bg-bottom flex items-center justify-center" style="background-image:url(/security-labs/grid.svg)"></div></div></div><article class="px-4"><div class="max-w-7xl mx-auto relative z-10 flex flex-col space-y-4"><div class="eyebrow break-words"><time class="block mb-2 md:mb-0 md:inline-block article-published-date" dateTime="2024-07-11T00:00:00.000Z">11 July 2024</time><span class="hidden md:inline-block md:mx-2">•</span><a class="hover:text-blue-400 text-xs md:text-sm whitespace-nowrap author-name" href="/security-labs/author/gabriel-landau">Gabriel Landau</a></div><h1 class="font-bold leading-tighter text-3xl md:text-5xl"><span>Introducing a New Vulnerability Class: False File&nbsp;Immutability</span></h1><p class="text-zinc-200 text-base md:text-xl">This article introduces a previously-unnamed class of Windows vulnerability that demonstrates the dangers of assumption and describes some unintended security consequences.</p><div class="flex items-center mt-4 text-zinc-200 text-sm space-x-4 border-t border-white/25 pt-4"><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span>28 min read</span></span><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M9.568 3H5.25A2.25 2.25 0 003 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 005.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 009.568 3z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M6 6h.008v.008H6V6z"></path></svg><span><a class="hover:text-blue-400 whitespace-nowrap" href="/security-labs/category/security-research">Security research</a>, </span><span><a class="hover:text-blue-400 whitespace-nowrap" href="/security-labs/category/vulnerability-updates">Vulnerability updates</a></span></span></div></div><div class="max-w-7xl mx-auto"><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 sm:p-8 md:p-10 rounded-3xl mt-5 md:mt-10"><div class="relative w-full rounded-lg overflow-hidden aspect-video"><img alt="Introducing a New Vulnerability Class: False File Immutability" fetchpriority="high" decoding="async" data-nimg="fill" class="object-cover absolute h-full w-full" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" sizes="100vw" srcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2FSecurity%20Labs%20Images%2036.jpg&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2FSecurity%20Labs%20Images%2036.jpg&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2FSecurity%20Labs%20Images%2036.jpg&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2FSecurity%20Labs%20Images%2036.jpg&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2FSecurity%20Labs%20Images%2036.jpg&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2FSecurity%20Labs%20Images%2036.jpg&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2FSecurity%20Labs%20Images%2036.jpg&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2FSecurity%20Labs%20Images%2036.jpg&amp;w=3840&amp;q=75 3840w" src="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2FSecurity%20Labs%20Images%2036.jpg&amp;w=3840&amp;q=75"/><div class="absolute border border-white/50 inset-0 mix-blend-overlay rounded-lg z-10"></div></div></div></div><div class="lg:max-w-7xl mx-auto relative mt-12 lg:grid lg:grid-cols-4 lg:gap-8 items-start"><div class="flex justify-center lg:col-span-3"><div class="prose lg:prose-lg prose-invert w-full article-content"><div><h2 class="font-bold text-2xl md:text-4xl relative"><span id="introduction" class="absolute -top-32"></span>Introduction</h2>
<p>This article will discuss a previously-unnamed vulnerability class in Windows, showing how long-standing incorrect assumptions in the design of core Windows features can result in both undefined behavior and security vulnerabilities. We will demonstrate how one such vulnerability in the Windows 11 kernel can be exploited to achieve arbitrary code execution with kernel privileges.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="windows-file-sharing" class="absolute -top-32"></span>Windows file sharing</h2>
<p>When an application opens a file on Windows, it typically uses some form of the Win32 <a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew"><strong>CreateFile</strong></a> API.</p>
<pre><code>HANDLE CreateFileW(
  [in]           LPCWSTR               lpFileName,
  [in]           DWORD                 dwDesiredAccess,
  [in]           DWORD                 dwShareMode,
  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  [in]           DWORD                 dwCreationDisposition,
  [in]           DWORD                 dwFlagsAndAttributes,
  [in, optional] HANDLE                hTemplateFile
);</code></pre>
<p>Callers of <strong>CreateFile</strong> specify the access they want in <strong>dwDesiredAccess</strong>. For example, a caller would pass <strong>FILE_READ_DATA</strong> to be able to read data, or <strong>FILE_WRITE_DATA</strong> to be able to write data. The full set of access rights are <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/file-access-rights-constants">documented</a> on the Microsoft Learn website.</p>
<p>In addition to passing <strong>dwDesiredAccess</strong>, callers must pass a “sharing mode” in <strong>dwShareMode</strong>, which consists of zero or more of <strong>FILE_SHARE_READ</strong>, <strong>FILE_SHARE_WRITE</strong>, and <strong>FILE_SHARE_DELETE</strong>. You can think of a sharing mode as the caller declaring “I’m okay with others doing X to this file while I’m using it,” where X could be reading, writing, or renaming. For example, a caller that passes <strong>FILE_SHARE_WRITE</strong> allows others to write the file while they are working with it.</p>
<p>As a file is opened, the caller’s <strong>dwDesiredAccess</strong> is tested against the <strong>dwShareMode</strong> of all existing file handles. Simultaneously, the caller’s <strong>dwShareMode</strong> is tested against the previously-granted <strong>dwDesiredAccess</strong> of all existing handles to that file. If either of these tests fail, then <strong>CreateFile</strong> fails with a sharing violation.</p>
<p>Sharing isn’t mandatory. Callers can pass a share mode of zero to obtain exclusive access. Per Microsoft <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/creating-and-opening-files">documentation</a>:</p>
<blockquote>
<p>An open file that is not shared (dwShareMode set to zero) cannot be opened again, either by the application that opened it or by another application, until its handle has been closed. This is also referred to as exclusive access.</p>
</blockquote>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="sharing-enforcement" class="absolute -top-32"></span>Sharing enforcement</h3>
<p>In the kernel, sharing is enforced by filesystem drivers. As a file is opened, it’s the responsibility of the filesystem driver to call <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iocheckshareaccess"><strong>IoCheckShareAccess</strong></a> or <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iochecklinkshareaccess"><strong>IoCheckLinkShareAccess</strong></a> to see whether the requested <strong>DesiredAccess</strong>/<strong>ShareMode</strong> tuple is compatible with any existing handles to the file being opened. <a href="https://learn.microsoft.com/en-us/windows-server/storage/file-server/ntfs-overview">NTFS</a> is the primary filesystem on Windows, but it’s closed-source, so for illustrative purposes we’ll instead look at Microsoft’s FastFAT sample code performing <a href="https://github.com/Microsoft/Windows-driver-samples/blob/622212c3fff587f23f6490a9da939fb85968f651/filesys/fastfat/create.c#L6822-L6884">the same check</a>. Unlike an IDA decompilation, it even comes with comments!</p>
<pre><code>//
//  Check if the Fcb has the proper share access.
//

return IoCheckShareAccess( *DesiredAccess,
                           ShareAccess,
                           FileObject,
                           &amp;FcbOrDcb-&gt;ShareAccess,
                           FALSE );</code></pre>
<p>In addition to traditional read/write file operations, Windows lets applications map files into memory. Before we go deeper, it’s important to understand that <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/section-objects-and-views">section objects</a> are kernel parlance for <a href="https://learn.microsoft.com/en-us/windows/win32/memory/file-mapping">file mappings</a>; they are the same thing. This article focuses on the kernel, so it will primarily refer to them as section objects.</p>
<p>There are two types of section objects - data sections and executable image sections. Data sections are direct 1:1 mappings of files into memory. The file’s contents will appear in memory exactly as they do on disk. Data sections also have uniform memory permissions for the entire memory range. With respect to the underlying file, data sections can be either read-only or read-write. A read-write view of a file enables a process to read or write the file’s contents by reading/writing memory within its own address space.</p>
<p>Executable image sections (sometimes abbreviated to image sections) prepare <a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format">PE files</a> to be executed. Image sections must be created from PE files. Examples of PE files include EXE, DLL, SYS, CPL, SCR, and OCX files. The kernel processes the PEs specially to prepare them to be executed. Different PE regions will be mapped in memory with different page permissions, depending on their metadata. Image views are <a href="https://en.wikipedia.org/wiki/Copy-on-write">copy-on-write</a>, meaning any changes in memory will be saved to the process’s private working set — never written to the backing PE.</p>
<p>Let’s say application A wants to map a file into memory with a data section. First, it opens that file with an API such as <strong>ZwCreateFile</strong>, which returns a file handle. Next, it passes this file handle to an API such as <strong>ZwCreateSection</strong> which creates a section object that describes how the file will be mapped into memory; this yields a section handle. The process then uses the section handle to map a “view” of that section into the process address space, completing the memory mapping.</p>
<p></p>
<p>Once the file is successfully mapped, process A can close both the file and section handles, leaving zero open handles to the file. If process B later wants to use the file without the risk of it being modified externally, it would omit <strong>FILE_SHARE_WRITE</strong> when opening the file. <strong>IoCheckLinkShareAccess</strong> looks for open file handles, but since the handles were previously closed, it will not fail the operation.</p>
<p>This creates a problem for file sharing. Process B thinks it has a file open without risk of external modification, but process A can modify it through the memory mapping. To account for this, the filesystem must also call <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-mmdoesfilehaveuserwritablereferences"><strong>MmDoesFileHaveUserWritableReferences</strong></a>. This checks whether there are any active writable file mappings to the given file. We can see this check in the FastFAT example <a href="https://github.com/Microsoft/Windows-driver-samples/blob/622212c3fff587f23f6490a9da939fb85968f651/filesys/fastfat/create.c#L6858-L6870">here</a>:</p>
<pre><code>//
//  Do an extra test for writeable user sections if the user did not allow
//  write sharing - this is neccessary since a section may exist with no handles
//  open to the file its based against.
//

if ((NodeType( FcbOrDcb ) == FAT_NTC_FCB) &amp;&amp;
    !FlagOn( ShareAccess, FILE_SHARE_WRITE ) &amp;&amp;
    FlagOn( *DesiredAccess, FILE_EXECUTE | FILE_READ_DATA | FILE_WRITE_DATA | FILE_APPEND_DATA | DELETE | MAXIMUM_ALLOWED ) &amp;&amp;
    MmDoesFileHaveUserWritableReferences( &amp;FcbOrDcb-&gt;NonPaged-&gt;SectionObjectPointers )) {

    return STATUS_SHARING_VIOLATION;
}</code></pre>
<p>Windows requires PE files to be immutable (unmodifiable) while they are running. This prevents EXEs and DLLs from being changed on disk while they are running in memory. Filesystem drivers must use the <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-mmflushimagesection"><strong>MmFlushImageSection</strong></a> function to check whether there are any active image mappings of a PE before allowing <strong>FILE_WRITE_DATA</strong> access. We can see this in the <a href="https://github.com/Microsoft/Windows-driver-samples/blob/622212c3fff587f23f6490a9da939fb85968f651/filesys/fastfat/create.c#L3572-L3593">FastFAT example code</a>, and on <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/executable-images">Microsoft Learn</a>.</p>
<pre><code>//
//  If the user wants write access access to the file make sure there
//  is not a process mapping this file as an image. Any attempt to
//  delete the file will be stopped in fileinfo.c
//
//  If the user wants to delete on close, we must check at this
//  point though.
//

if (FlagOn(*DesiredAccess, FILE_WRITE_DATA) || DeleteOnClose) {

    Fcb-&gt;OpenCount += 1;
    DecrementFcbOpenCount = TRUE;

    if (!MmFlushImageSection( &amp;Fcb-&gt;NonPaged-&gt;SectionObjectPointers,
                              MmFlushForWrite )) {

        Iosb.Status = DeleteOnClose ? STATUS_CANNOT_DELETE :
                                      STATUS_SHARING_VIOLATION;
        try_return( Iosb );
    }
}</code></pre>
<p>Another way to think of this check is that <strong>ZwMapViewOfSection(SEC_IMAGE)</strong> implies no-write-sharing as long as the view exists.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="authenticode" class="absolute -top-32"></span>Authenticode</h2>
<p>The <a href="https://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/authenticode_pe.docx">Windows Authenticode Specification</a> describes a way to employ cryptography to “sign” PE files. A “digital signature” cryptographically attests that the PE was produced by a particular entity. Digital signatures are tamper-evident, meaning that any material modification of signed files should be detectable because the digital signature will no longer match. Digital signatures are typically appended to the end of PE files.</p>
<p></p>
<p>Authenticode can’t apply traditional hashing (e.g. <strong>sha256sum</strong>) in this case, because the act of appending the signature would change the file’s hash, breaking the signature it just generated. Instead, the Authenticode specification describes an algorithm to skip specific portions of the PE file that will be changed during the signing process. This algorithm is called <strong>authentihash</strong>. You can use authentihash with any hashing algorithm, such as SHA256. When a PE file is digitally signed, the file’s authentihash is what’s actually signed.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="code-integrity" class="absolute -top-32"></span>Code integrity</h3>
<p>Windows has a few different ways to validate Authenticode signatures. User mode applications can call <a href="https://learn.microsoft.com/en-us/windows/win32/api/wintrust/nf-wintrust-winverifytrust"><strong>WinVerifyTrust</strong></a> to validate a file’s signature in user mode. The Code Integrity (CI) subsystem, residing in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ci.dll</code>,  validates signatures in the kernel. If <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/bringup/device-guard-and-credential-guard">Hypervisor-Protected Code Integrity</a> is running, the Secure Kernel employs <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">skci.dll</code> to validate Authenticode. This article will focus on Code Integrity (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ci.dll</code>) in the regular kernel.</p>
<p>Code Integrity provides both Kernel Mode Code Integrity and User Mode Code Integrity, each serving a different set of functions.</p>
<p>Kernel Mode Code Integrity (KMCI):</p>
<ul>
<li>Enforces <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/install/driver-signing">Driver Signing Enforcement</a> and the <a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/microsoft-recommended-driver-block-rules#microsoft-vulnerable-driver-blocklist">Vulnerable Driver Blocklist</a></li>
</ul>
<p>User Mode Code Integrity (UMCI):</p>
<ul>
<li>CI validates the signatures of EXEs and DLLs before allowing them to load</li>
<li>Enforces <a href="https://learn.microsoft.com/en-us/windows/security/threat-protection/overview-of-threat-mitigations-in-windows-10#protected-processes">Protected Processes and Protected Process Light</a> signature requirements</li>
<li>Enforces <strong>ProcessSignaturePolicy</strong> mitigation (<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setprocessmitigationpolicy"><strong>SetProcessMitigationPolicy</strong></a>)</li>
<li>Enforces <a href="https://learn.microsoft.com/en-us/cpp/build/reference/integritycheck-require-signature-check?view=msvc-170">INTEGRITYCHECK</a> for <a href="https://x.com/GabrielLandau/status/1668353640833114131">FIPS 140-2 modules</a>.</li>
<li>Exposed to consumers as <a href="https://learn.microsoft.com/en-us/windows/apps/develop/smart-app-control/overview">Smart App Control</a></li>
<li>Exposed to businesses as <a href="https://learn.microsoft.com/en-us/mem/intune/protect/endpoint-security-app-control-policy">App Control for Business</a> (formerly WDAC)</li>
</ul>
<p>KMCI and UMCI implement different policies for different scenarios. For example, the policy for Protected Processes is different from that of INTEGRITYCHECK.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="incorrect-assumptions" class="absolute -top-32"></span>Incorrect assumptions</h2>
<p>Microsoft <a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">documentation</a> implies that files successfully opened without write sharing can’t be modified by another user or process.</p>
<pre><code>FILE_SHARE_WRITE
0x00000002
Enables subsequent open operations on a file or device to request write access. Otherwise, other processes cannot open the file or device if they request write access.</code></pre>
<p>If this flag is not specified, but the file or device has been opened for write access or has a file mapping with write access, the function fails.</p>
<p><em>Above, we discussed how sharing is enforced by the filesystem, but what if the filesystem doesn’t know that the file’s been modified?</em></p>
<p>Like most user mode memory, the Memory Manager (MM) in the kernel may page-out portions of file mappings when it deems necessary, such as when the system needs more free physical memory. Both data and executable image mappings may be paged-out. Executable image sections can never modify the backing file, so they’re effectively treated as read-only with respect to the backing PE file. As mentioned before, image sections are copy-on-write, meaning any in-memory changes immediately create a private copy of the given page.</p>
<p>When the memory manager needs to page-out a page from an image section, it can use the following decision tree:</p>
<ul>
<li>Never modified?  Discard it. We can read the contents back from the immutable file on disk.</li>
<li>Modified?  Save private copy it to the pagefile.<!-- -->
<ul>
<li>Example: If a security product hooks a function in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ntdll.dll</code>, MM will create a private copy of each modified page. Upon page-out, private pages will be written to the pagefile.</li>
</ul>
</li>
</ul>
<p>If those paged-out pages are later touched, the CPU will issue a page fault and the MM will restore the pages.</p>
<ul>
<li>Page never modified?  Read the original contents back from the immutable file on disk.</li>
<li>Page private?  Read it from the pagefile.</li>
</ul>
<p>Note the following exception: The memory manager may treat PE-relocated pages as unmodified, dynamically reapplying relocations during page faults.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="page-hashes" class="absolute -top-32"></span>Page hashes</h3>
<p>Page hashes are a list of hashes of each 4KB page within a PE file. Since pages are 4KB, page faults typically occur on 4KB of data at a time. Full Authenticode verification requires the entire contiguous PE file, which isn’t available during a page fault. Page hashes allow the MM to validate hashes of individual pages during page faults.</p>
<p>There are two types of page hashes, which we’ve coined static and dynamic. Static page hashes are stored within a PE’s digital signature if the developer passes <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/ph</code> to <a href="https://learn.microsoft.com/en-us/windows/win32/seccrypto/signtool"><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">signtool</code></a>. By pre-computing these, they are immediately available to the MM and CI upon module load.</p>
<p>CI can also compute them on-the-fly during signature validation, a mechanism we’re calling dynamic page hashes. Dynamic page hashes give CI flexibility to enforce page hashes even for files that were never signed with them.</p>
<p>Page hashes are not free - they use CPU and slow down page faults. They’re not used in most cases.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="attacking-code-integrity" class="absolute -top-32"></span>Attacking code integrity</h2>
<p>Imagine a scenario where a ransomware operator wants to ransom a hospital, so they send a phishing email to a hospital employee. The employee opens the email attachment and enables macros, running the ransomware. The ransomware employs a UAC bypass to immediately elevate to admin, then attempts to terminate any security software on the system so it can operate unhindered. Anti-Malware services run as <a href="https://learn.microsoft.com/en-us/windows/win32/services/protecting-anti-malware-services-">Protected Process Light</a> (PPL), protecting them from tampering by malware with admin rights, so the ransomware can’t terminate the Anti-Malware service.</p>
<p>If the ransomware could also run as a PPL, it could terminate the Anti-Malware product. The ransomware can’t launch itself directly as a PPL because UMCI prevents improperly-signed EXEs and DLLs from loading into PPL, as we discussed above. The ransomware might try to inject code into a PPL by modifying an EXE or DLL that’s already running, but the aforementioned <strong>MmFlushImageSection</strong> ensures in-use PE files remain immutable, so this isn’t possible.</p>
<p>We previously discussed how the filesystem is responsible for sharing checks. <em>What would happen if an attacker were to move the filesystem to another machine?</em></p>
<p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/what-is-a-network-redirector-">Network redirectors</a> allow the use of network paths with any API that accepts file paths. This is very convenient, allowing users and applications to easily open and memory-map files over the network. Any resulting I/O is transparently redirected to the remote machine. If a program is launched from a network drive, the executable images for the EXE and its DLLs will be transparently pulled from the network.</p>
<p>When a network redirector is in use, the server on the other end of the pipe needn’t be a Windows machine. It could be a Linux machine running <a href="https://en.wikipedia.org/wiki/Samba_(software)">Samba</a>, or even a python <a href="https://github.com/fortra/impacket/blob/d71f4662eaf12c006c2ea7f5ec09b418d9495806/examples/smbserver.py">impacket script</a> that “speaks” the <a href="https://learn.microsoft.com/en-us/windows-server/storage/file-server/file-server-smb-overview">SMB network protocol</a>. This means the server doesn’t have to honor Windows filesystem sharing semantics.</p>
<p>An attacker can employ a network redirector to modify a PPL’s DLL server-side, bypassing sharing restrictions. This means that PEs backing an executable image section are incorrectly assumed to be immutable. This is a class of vulnerability that we are calling <strong>False File Immutability</strong> (FFI).</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="paging-exploitation" class="absolute -top-32"></span>Paging exploitation</h3>
<p>If an attacker successfully exploits False File Immutability to inject code into an in-use PE, wouldn’t page hashes catch such an attack?  The answer is: sometimes. If we look at the following table, we can see that page hashes are enforced for kernel drivers and Protected Processes, but not for PPL, so let’s pretend we’re an attacker targeting PPL.</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th></th><th>Authenticode</th><th>Page hashes</th></tr></thead><tbody><tr><td>Kernel drivers</td><td>✅</td><td>✅</td></tr><tr><td>Protected Processes (PP-Full)</td><td>✅</td><td>✅</td></tr><tr><td>Protected Process Light (PPL)</td><td>✅</td><td>❌</td></tr></tbody></table></div>
<p>Last year at Black Hat Asia 2023 (<a href="https://www.blackhat.com/asia-23/briefings/schedule/#ppldump-is-dead-long-live-ppldump-31052">abstract</a>, <a href="http://i.blackhat.com/Asia-23/AS-23-Landau-PPLdump-Is-Dead-Long-Live-PPLdump.pdf">slides</a>, <a href="https://www.youtube.com/watch?v=5xteW8Tm410">recording</a>), we disclosed a vulnerability in the Windows kernel, showing how bad assumptions in paging can be exploited to inject code into PPL, defeating security features like <a href="https://learn.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection">LSA</a> &amp; <a href="https://learn.microsoft.com/en-us/windows/win32/services/protecting-anti-malware-services-">Anti-Malware Process Protection</a>. The attack leveraged False File Immutability assumptions for DLLs in PPLs, as we just described, though we hadn’t yet named the vulnerability class.</p>
<p></p>
<p>Alongside the presentation, we released the <a href="https://github.com/gabriellandau/PPLFault">PPLFault exploit</a> which demonstrates the vulnerability by dumping the memory of an otherwise-protected PPL. We also released the GodFault exploit chain, which combines the PPLFault Admin-to-PPL exploit with the AngryOrchard PPL-to-kernel exploit to achieve full read/write control of physical memory from user mode. We did this to motivate Microsoft to take action on a vulnerability that MSRC <a href="https://www.elastic.co/security-labs/forget-vulnerable-drivers-admin-is-all-you-need">declined to fix</a> because it did not meet their <a href="https://www.microsoft.com/en-us/msrc/windows-security-servicing-criteria">servicing criteria</a>. Thankfully, the Windows Defender team at Microsoft stepped up, <a href="https://x.com/GabrielLandau/status/1757818200127946922">releasing a fix</a> in February 2024 that enforces dynamic page hashes for executable images loaded over network redirectors, breaking PPLFault.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="new-research" class="absolute -top-32"></span>New research</h2>
<p>Above, we discussed Authenticode signatures embedded within PE files. In addition to embedded signatures, Windows supports a form of detached signature called a <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/install/catalog-files">security catalog</a>. Security catalogs (.cat files) are essentially a list of signed authentihashes. Every PE with an authentihash in that list is considered to be signed by that signer. Windows keeps a large collection of catalog files in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">C:\Windows\System32\CatRoot</code> which CI loads, validates, and caches.</p>
<p></p>
<p></p>
<p>A typical Windows system has over a thousand catalog files, many containing dozens or hundreds of authentihashes.</p>
<p></p>
<p>To use a security catalog, Code Integrity must first load it. This occurs in a few discrete steps. First, CI maps the file into kernel memory using <strong>ZwOpenFile</strong>, <strong>ZwCreateSection</strong>, and <strong>ZwMapViewOfSection</strong>. Once mapped, it validates the catalog’s digital signature using <strong>CI!MinCrypK_VerifySignedDataKModeEx</strong>. If the signature is valid, it parses the hashes with <strong>CI!I_MapFileHashes</strong>.</p>
<p></p>
<p>Breaking this down, we see a few key insights. First, <strong>ZwCreateSection(SEC_COMMIT)</strong> tells us that CI is creating a data section, not an image section. This is important because there is no concept of page hashes for data sections.</p>
<p>Next, the file is opened without <strong>FILE_SHARE_WRITE</strong>, meaning write sharing is denied. This is intended to prevent modification of the security catalog during processing. However, as we have shown above, this is a bad assumption and another example of False File Immutability. It should be possible, in theory, to perform a PPLFault-style attack on security catalog processing.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="planning-the-attack" class="absolute -top-32"></span>Planning the attack</h3>
<p></p>
<p>The general flow of the attack is as follows:</p>
<ol>
<li>The attacker will plant a security catalog on a storage device that they control. They will install a symbolic link to this catalog in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CatRoot</code> directory, so Windows knows where to find it.</li>
<li>The attacker asks the kernel to load a malicious unsigned kernel driver.</li>
<li>Code Integrity attempts to validate the driver, but it can’t find a signature or trusted authentihash, so it re-scans the CatRoot directory and finds the attacker’s new catalog.</li>
<li>CI maps the catalog into kernel memory and validates its signature. This generates page faults which are sent to the attacker’s storage device. The storage device returns a legitimate Microsoft-signed catalog.</li>
<li>The attacker empties the system working set, forcing all the previously-fetched catalog pages to be discarded.</li>
<li>CI begins parsing the catalog, generating new page faults. This time, the storage device injects the authentihash of their malicious driver.</li>
<li>CI finds the malicious driver’s authentihash in the catalog and loads the driver. At this point, the attacker has achieved arbitrary code execution in the kernel.</li>
</ol>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="implementation-and-considerations" class="absolute -top-32"></span>Implementation and considerations</h3>
<p>The plan is to use a PPLFault-style attack, but there are some important differences in this situation. PPLFault used an <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/opportunistic-locks">opportunistic lock</a> (oplock) to deterministically freeze the victim process’s initialization. This gave the attacker time to switch over to the payload and flush the system working set. Unfortunately, we couldn’t find any good opportunities for oplocks here. Instead, we’re going to pursue a probabilistic approach: rapidly toggling the security catalog between the malicious and benign versions.</p>
<p></p>
<p>The verification step touches every page of the catalog, which means all of those pages will be resident in memory when parsing begins. If the attacker changes the catalog on their storage device, it won’t be reflected in memory until after a subsequent page fault. To evict these pages from kernel memory, the attacker must empty the working set between <strong>MinCrypK_VerifySignedDataKModeEx</strong> and <strong>I_MapFileHashes</strong>.</p>
<p>This approach is inherently a race condition. There’s no built-in delays between signature verification and catalog parsing - it’s a tight race. We’ll need to employ several techniques to widen our window of opportunity.</p>
<p>Most security catalogs on the system are small, a few kilobytes. By choosing a large 4MB catalog, we can greatly increase the amount of time that CI spends parsing. Assuming catalog parsing is linear, we can choose an authentihash near the end of the catalog to maximize the time between signature verification and when CI reaches our tampered page. Further, we will create threads for each CPU on the system whose sole purpose is to consume CPU cycles. These threads run at higher priority than CI, so CI will be starved of CPU time. There will be one thread dedicated to repeatedly flushing pages from the system’s working set, and one thread repeatedly attempting to load the unsigned driver.</p>
<p>This attack has two main failure modes. First, if the payload Authentihash is read during the signature check, then the signature will be invalid and the catalog will be rejected.</p>
<p></p>
<p>Next, if an even number of toggles occur (including zero) between signature validation and parsing, then CI will parse the benign hash and reject our driver.</p>
<p></p>
<p>The attacker wins if CI validates a benign catalog then parses a malicious one.</p>
<p></p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="exploit-demo" class="absolute -top-32"></span>Exploit demo</h3>
<p>We named the exploit <strong>ItsNotASecurityBoundary</strong> as an homage to MSRC&#x27;s <a href="https://www.microsoft.com/en-us/msrc/windows-security-servicing-criteria">policy</a> that &quot;Administrator-to-kernel is not a security boundary.”  The code is in GitHub <a href="https://github.com/gabriellandau/ItsNotASecurityBoundary">here</a>.</p>
<p>Demo video <a href="https://drive.google.com/file/d/13Uw38ZrNeYwfoIuD76qlLgyXP8kRc8Nz/view?usp=sharing">here</a>.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="understanding-these-vulnerabilities" class="absolute -top-32"></span>Understanding these vulnerabilities</h2>
<p>In order to properly defend against these vulnerabilities, we first need to understand them better.</p>
<p>A double-read (aka double-fetch) vulnerability can occur when victim code reads the same value out of an attacker-controlled buffer more than once. The attacker may change the value of this buffer between the reads, resulting in unexpected victim behavior.</p>
<p>Imagine there is a page of memory shared between two processes for an IPC mechanism. The client and server send data back and forth using the following struct. To send an IPC request, a client first writes a request struct into the shared memory page, then signals an event to notify the server of a pending request.</p>
<pre><code>struct IPC_PACKET
{
    SIZE_T length;
    UCHAR data[];
};</code></pre>
<p>A double-read attack could look something like this:</p>
<p></p>
<p>First, the attacking client sets a packet’s structure’s length field to 16 bytes, then signals the server to indicate that a packet is ready for processing.  The victim server wakes up and allocates a 16-byte buffer using <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">malloc(pPacket-&gt;length)</code>.  Immediately afterwards, the attacker changes the length field to 32.  Next, the victim server attempts to copy the packet’s contents into the the new buffer by calling <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">memcpy(pBuffer, pPacket-&gt;data, pPacket-&gt;length)</code>, re-reading the value in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pPacket-&gt;length</code>, which is now 32.  The victim ends up copying 32 bytes into a 16-byte buffer, overflowing it.</p>
<p>Double-read vulnerabilities frequently apply to shared-memory scenarios. They commonly occur in drivers that operate on user-writable buffers. Due to False File Immutability, developers need to be aware that their scope is actually much wider, and includes all files writable by attackers. Denying write sharing does not necessarily prevent file modification.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="affected-operations" class="absolute -top-32"></span>Affected Operations</h3>
<p>What types of operations are affected by False File Immutability?</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th>Operation</th><th>API</th><th>Mitigations</th></tr></thead><tbody><tr><td>Image Sections</td><td><strong>CreateProcess</strong> <strong>LoadLibrary</strong></td><td>1. Enable Page Hashes</td></tr><tr><td>Data Sections</td><td><strong>MapViewOfFile</strong> <strong>ZwMapViewOfSection</strong></td><td>1. Avoid double reads\ 2. Copy the file to a heap buffer before processing\ 3. Prevent paging via MmProbeAndLockPages/VirtualLock</td></tr><tr><td>Regular I/O</td><td><strong>ReadFile</strong> <strong>ZwReadFile</strong></td><td>1. Avoid double reads\  2. Copy the file to a heap buffer before processing</td></tr></tbody></table></div>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="what-else-could-be-vulnerable" class="absolute -top-32"></span>What else could be vulnerable?</h3>
<p>Looking for potentially-vulnerable calls to <strong>ZwMapViewOfSection</strong> in the NT kernel yields quite a few interesting functions:</p>
<p></p>
<p>If we expand our search to regular file I/O, we find even more candidates. An important caveat, however, is that <strong>ZwReadFile</strong> may be used for more than just files. Only uses on files (or those which could be coerced into operating on files) could be vulnerable.</p>
<p></p>
<p>Looking outside of the NT kernel, we can find other drivers to investigate:</p>
<p></p>
<p></p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="dont-forget-about-user-mode" class="absolute -top-32"></span>Don’t forget about user mode</h3>
<p>We’ve mostly been discussing the kernel up to this point, but it’s important to note that any user mode application that calls <strong>ReadFile</strong>, <strong>MapViewOfFile</strong>, or <strong>LoadLibrary</strong> on an attacker-controllable file, denying write sharing for immutability, may be vulnerable. Here’s a few hypothetical examples.</p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="mapviewoffile" class="absolute -top-32"></span>MapViewOfFile</h4>
<p>Imagine an application that is split into two components - a low-privileged worker process with network access, and a privileged service that installs updates. The worker downloads updates and stages them to a specific folder. When the privileged service sees a new update staged, it first validates the signature before installing the update. An attacker could abuse FFI to modify the update after the signature check.</p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="readfile" class="absolute -top-32"></span>ReadFile</h4>
<p>Since files are subject to double-read vulnerabilities, anything that parses complex file formats may be vulnerable, including antivirus engines and search indexers.</p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="loadlibrary" class="absolute -top-32"></span>LoadLibrary</h4>
<p>Some applications rely on UMCI to prevent attackers from loading malicious DLLs into their processes. As we’ve shown with PPLFault, FFI can defeat UMCI.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="stopping-the-exploit" class="absolute -top-32"></span>Stopping the exploit</h2>
<p>Per their official servicing guidelines, MSRC won’t service Admin -&gt; Kernel vulnerabilities by default. In this parlance, servicing means “fix via security update.”  This type of vulnerability, however, allows malware to bypass <a href="https://learn.microsoft.com/en-us/windows/win32/services/protecting-anti-malware-services-">AV Process Protections</a>, leaving AV and EDR vulnerable to instant-kill attacks.</p>
<p>As a third-party, we can’t patch Code Integrity, so what can we do to protect our customers? To mitigate <strong>ItsNotASecurityBoundary</strong>, we created <strong>FineButWeCanStillEasilyStopIt</strong>, a filesystem minifilter driver that prevents Code Integrity from opening security catalogs over network redirectors. You can find it on GitHub <a href="https://github.com/gabriellandau/ItsNotASecurityBoundary/tree/main/FineButWeCanStillEasilyStopIt">here</a>.</p>
<p>FineButWeCanStillEasilyStopIt has to jump through some hoops to correctly identify the problematic behavior while minimizing false positives. Ideally, CI itself could be fixed with a few small changes. Let’s look at what that would take.</p>
<p></p>
<p>As mentioned above in the Affected Operations section, applications can mitigate double-read vulnerabilities by copying the file contents out of the file mapping into the heap, and exclusively using that heap copy for all subsequent operations. The kernel heap is called the <a href="https://learn.microsoft.com/en-us/windows/win32/memory/memory-pools">pool</a>, and the corresponding allocation function is <strong>ExAllocatePool</strong>.</p>
<p></p>
<p>An alternative mitigation strategy to break these types of exploits is to pin the pages of the file mapping into physical memory using an API such as <strong>MmProbeAndLockPages</strong>. This prevents eviction of those pages when the attacker empties the working set.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="end-user-detection-and-mitigation" class="absolute -top-32"></span>End-user detection and mitigation</h3>
<p>Fortunately, there is a way for end-users to mitigate this exploit without changes from Microsoft – Hypervisor Protected Code Integrity (HVCI). If HVCI is enabled, CI.dll doesn’t do catalog parsing at all. Instead, it sends the catalog contents to the Secure Kernel, which runs in a separate virtual machine on the same host. The Secure Kernel stores the received catalog contents in its own heap, from which signature validation and parsing are performed. Just like with the <strong>ExAllocatePool</strong> mitigation described above, the exploit is mitigated because file changes have no effect on the heap copy.</p>
<p>The probabilistic nature of this attack means that there are likely many failed attempts. Windows records these failures in the <strong>Microsoft-Windows-CodeIntegrity/Operational</strong> event log. Users can check this log for evidence of exploitation.</p>
<p></p>
<p></p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="disclosure" class="absolute -top-32"></span>Disclosure</h2>
<p>The disclosure timeline is as follows:</p>
<ul>
<li>2024-02-14: We reported ItsNotASecurityBoundary and FineButWeCanStillEasilyStopIt to MSRC as VULN-119340, suggesting <strong>ExAllocatePool</strong> and <strong>MmProbeAndLockPages</strong> as simple low-risk fixes</li>
<li>2024-02-29: The Windows Defender team reached out to coordinate disclosure</li>
<li>2024-04-23: Microsoft releases <a href="https://support.microsoft.com/en-us/topic/april-23-2024-kb5036980-os-builds-22621-3527-and-22631-3527-preview-5a0d6c49-e42e-4eb4-8541-33a7139281ed">KB5036980</a> Preview with the <strong>MmProbeAndLockPages</strong> fix</li>
<li>2024-05-14: Fix reaches GA for Windows 11 23H2 as <a href="https://support.microsoft.com/en-us/topic/may-14-2024-kb5037771-os-builds-22621-3593-and-22631-3593-e633ff2f-a021-4abb-bd2e-7f3687f166fe">KB5037771</a>; we have not tested any other platforms (Win10, Server, etc).</li>
<li>2024-06-14: MSRC closed the case, stating &quot;We have completed our investigation and determined that the case doesn&#x27;t meet our bar for servicing at this time. As a result, we have opened a next-version candidate bug for the issue, and it will be evaluated for upcoming releases. Thanks, again, for sharing this report with us.&quot;</li>
</ul>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="fixing-code-integrity" class="absolute -top-32"></span>Fixing Code Integrity</h2>
<p>Looking at the original implementation of <strong>CI!I_MapAndSizeDataFile</strong>, we can see the legacy code calling <strong>ZwCreateSection</strong> and <strong>ZwMapViewOfSection</strong>:</p>
<p></p>
<p>Contrast that with the new <strong>CI!CipMapAndSizeDataFileWithMDL</strong>, which follows that up with <strong>MmProbeAndLockPages</strong>:</p>
<p></p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="summary-and-conclusion" class="absolute -top-32"></span>Summary and conclusion</h2>
<p>Today we discussed and named a bug class: <strong>False File Immutability</strong>. We are aware of two public exploits that leverage it, PPLFault and ItsNotASecurityBoundary.</p>
<p><a href="https://github.com/gabriellandau/PPLFault">PPLFault</a>: Admin -&gt; PPL [-&gt; Kernel via GodFault]</p>
<ul>
<li>Exploits bad immutability assumptions about image section in CI/MM</li>
<li>Reported September 2022</li>
<li>Patched February 2024 (~510 days later)</li>
</ul>
<p><a href="https://github.com/gabriellandau/ItsNotASecurityBoundary">ItsNotASecurityBoundary</a>: Admin -&gt; Kernel</p>
<ul>
<li>Exploits bad immutability assumptions about data sections in CI</li>
<li>Reported February 2024</li>
<li>Patched May 2024 (~90 days later)</li>
</ul>
<p>If you are writing Windows code that operates on files, you need to be aware of the fact these files may be modified while you are working on them, even if you deny write sharing. See the Affected Operations section above for guidance on how to protect yourselves and your customers against these types of attacks.</p>
<p>ItsNotASecurityBoundary is not the end of FFI. There are other exploitable FFI vulnerabilities out there. My colleagues and I at Elastic Security Labs will continue exploring and reporting on FFI and beyond. We encourage you to follow along on X <a href="https://x.com/GabrielLandau">@GabrielLandau</a> and <a href="https://x.com/elasticseclabs">@ElasticSecLabs</a>.</p></div></div></div><div class="hidden lg:flex lg:col-span-1 text-sm lg:flex-col lg:space-y-6"><div class="toc"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Jump to section</h4><ul class="flex flex-col space-y-2"><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/false-file-immutability#introduction"><span>Introduction</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/false-file-immutability#windows-file-sharing"><span>Windows file&nbsp;sharing</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/false-file-immutability#sharing-enforcement"><span>Sharing&nbsp;enforcement</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/false-file-immutability#authenticode"><span>Authenticode</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/false-file-immutability#code-integrity"><span>Code&nbsp;integrity</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/false-file-immutability#incorrect-assumptions"><span>Incorrect&nbsp;assumptions</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/false-file-immutability#page-hashes"><span>Page&nbsp;hashes</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/false-file-immutability#attacking-code-integrity"><span>Attacking code&nbsp;integrity</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/false-file-immutability#paging-exploitation"><span>Paging&nbsp;exploitation</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/false-file-immutability#new-research"><span>New&nbsp;research</span></a></li></ul><button class="border-t border-white/20 w-full mt-3 py-2 flex items-center space-x-1 text-xs font-medium uppercase tracking-wide hover:text-white"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="w-3 h-3"><path d="M10.75 4.75a.75.75 0 00-1.5 0v4.5h-4.5a.75.75 0 000 1.5h4.5v4.5a.75.75 0 001.5 0v-4.5h4.5a.75.75 0 000-1.5h-4.5v-4.5z"></path></svg><span>Show more</span></button></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Elastic Security Labs Newsletter</h4><div><a target="_blank" class="button inline-flex" href="https://www.elastic.co/security-labs/newsletter?utm_source=security-labs">Sign Up</a></div></div></div></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl my-5 md:my-10 max-w-3xl mx-auto flex flex-col items-center shadow-2xl"><h4 class="font-bold leading-tight text-lg md:text-2xl">Share this article</h4><div class="flex flex-wrap items-center justify-center mt-4 space-x-4"><a class="flex items-center space-x-2 button" href="https://twitter.com/intent/tweet?text=Introducing a New Vulnerability Class: False File Immutability&amp;url=https://www.elastic.co/security-labs/false-file-immutability" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Twitter" title="Share this article on Twitter"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>Twitter</span></a><a class="flex items-center space-x-2 button" href="https://www.facebook.com/sharer/sharer.php?u=https://www.elastic.co/security-labs/false-file-immutability" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Facebook" title="Share this article on Facebook"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M22.5 12c0-5.799-4.701-10.5-10.5-10.5S1.5 6.201 1.5 12c0 5.301 3.901 9.699 9 10.401V14.4h-2.7v-2.7h2.7v-2.1c0-2.7 1.8-4.2 4.2-4.2 1.2 0 2.1.1 2.4.2v2.4h-1.5c-1.2 0-1.5.6-1.5 1.5v1.8h3l-.3 2.7h-2.7V22C18.599 21.3 22.5 17.301 22.5 12z"></path></svg><span>Facebook</span></a><a class="flex items-center space-x-2 button" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://www.elastic.co/security-labs/false-file-immutability&amp;title=Introducing a New Vulnerability Class: False File Immutability" target="_blank" rel="noopener noreferrer" aria-label="Share this article on LinkedIn" title="Share this article on LinkedIn"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"></path></svg><span>LinkedIn</span></a><a class="flex items-center space-x-2 button" href="https://reddit.com/submit?url=https://www.elastic.co/security-labs/false-file-immutability&amp;title=Introducing a New Vulnerability Class: False File Immutability" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Reddit" title="Share this article on Reddit"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M24 12C24 18.6274 18.6274 24 12 24C5.37258 24 0 18.6274 0 12C0 5.37258 5.37258 0 12 0C18.6274 0 24 5.37258 24 12ZM19.6879 11.0584C19.8819 11.3352 19.9916 11.6622 20.004 12C20.0091 12.3306 19.9205 12.656 19.7485 12.9384C19.5765 13.2208 19.3281 13.4488 19.032 13.596C19.0455 13.7717 19.0455 13.9483 19.032 14.124C19.032 16.812 15.9 18.996 12.036 18.996C8.172 18.996 5.04 16.812 5.04 14.124C5.02649 13.9483 5.02649 13.7717 5.04 13.596C4.80919 13.49 4.6042 13.335 4.43923 13.1419C4.27427 12.9487 4.15327 12.722 4.08462 12.4775C4.01598 12.2329 4.00133 11.9764 4.04169 11.7256C4.08205 11.4748 4.17646 11.2358 4.31837 11.0251C4.46028 10.8145 4.6463 10.6372 4.86354 10.5056C5.08078 10.3739 5.32404 10.2911 5.57646 10.2629C5.82889 10.2346 6.08444 10.2616 6.32541 10.3419C6.56638 10.4222 6.78701 10.5539 6.972 10.728C8.35473 9.79023 9.98146 9.27718 11.652 9.252L12.54 5.088C12.55 5.03979 12.5694 4.99405 12.5972 4.95341C12.625 4.91277 12.6605 4.87805 12.7018 4.85127C12.7431 4.82448 12.7894 4.80615 12.8378 4.79735C12.8862 4.78855 12.9359 4.78945 12.984 4.8L15.924 5.388C16.0676 5.14132 16.2944 4.9539 16.5637 4.85937C16.833 4.76484 17.1272 4.7694 17.3934 4.87222C17.6597 4.97505 17.8806 5.1694 18.0164 5.42041C18.1523 5.67141 18.1942 5.96262 18.1348 6.24177C18.0753 6.52092 17.9182 6.76972 17.6918 6.94352C17.4654 7.11732 17.1845 7.20473 16.8995 7.19006C16.6144 7.1754 16.3439 7.05962 16.1366 6.8635C15.9292 6.66738 15.7985 6.40378 15.768 6.12L13.2 5.58L12.42 9.324C14.0702 9.3594 15.6749 9.87206 17.04 10.8C17.2839 10.566 17.5902 10.4074 17.9221 10.3436C18.254 10.2797 18.5973 10.3132 18.9106 10.4401C19.2239 10.5669 19.4939 10.7817 19.6879 11.0584ZM8.20624 12.5333C8.07438 12.7307 8.004 12.9627 8.004 13.2C8.004 13.5183 8.13043 13.8235 8.35547 14.0485C8.58051 14.2736 8.88574 14.4 9.204 14.4C9.44134 14.4 9.67335 14.3296 9.87068 14.1978C10.068 14.0659 10.2218 13.8785 10.3127 13.6592C10.4035 13.4399 10.4272 13.1987 10.3809 12.9659C10.3346 12.7331 10.2204 12.5193 10.0525 12.3515C9.8847 12.1836 9.67089 12.0694 9.43811 12.0231C9.20533 11.9768 8.96405 12.0005 8.74478 12.0913C8.52551 12.1822 8.33809 12.336 8.20624 12.5333ZM12.012 17.424C13.0771 17.4681 14.1246 17.1416 14.976 16.5V16.548C15.0075 16.5173 15.0327 16.4806 15.05 16.4402C15.0674 16.3997 15.0766 16.3563 15.0772 16.3122C15.0777 16.2682 15.0696 16.2245 15.0533 16.1837C15.0369 16.1428 15.0127 16.1055 14.982 16.074C14.9513 16.0425 14.9146 16.0173 14.8742 16C14.8337 15.9826 14.7903 15.9734 14.7462 15.9728C14.7022 15.9723 14.6585 15.9804 14.6177 15.9967C14.5768 16.0131 14.5395 16.0373 14.508 16.068C13.7797 16.5904 12.895 16.8487 12 16.8C11.1061 16.8399 10.2255 16.5732 9.504 16.044C9.44182 15.993 9.36289 15.9669 9.28256 15.9708C9.20222 15.9748 9.12622 16.0085 9.06935 16.0653C9.01247 16.1222 8.97879 16.1982 8.97484 16.2786C8.97089 16.3589 8.99697 16.4378 9.048 16.5C9.89937 17.1416 10.9469 17.4681 12.012 17.424ZM14.0933 14.2458C14.2907 14.3776 14.5227 14.448 14.76 14.448L14.748 14.496C14.9107 14.4978 15.0721 14.4664 15.2223 14.4038C15.3725 14.3413 15.5084 14.2488 15.6218 14.1321C15.7352 14.0154 15.8236 13.8768 15.8818 13.7248C15.9399 13.5728 15.9665 13.4106 15.96 13.248C15.96 13.0107 15.8896 12.7787 15.7578 12.5813C15.6259 12.384 15.4385 12.2302 15.2192 12.1393C14.9999 12.0485 14.7587 12.0248 14.5259 12.0711C14.2931 12.1174 14.0793 12.2316 13.9115 12.3995C13.7436 12.5673 13.6294 12.7811 13.5831 13.0139C13.5368 13.2467 13.5605 13.4879 13.6513 13.7072C13.7422 13.9265 13.896 14.1139 14.0933 14.2458Z" fill="currentColor"></path></svg><span>Reddit</span></a></div></div></article></main><footer class="mt-auto text-xs md:text-sm"><div class="container py-6 flex flex-col md:flex-row gap-2 md:gap-0 justify-between items-center"><div class="text-zinc-300"><nav><ul class="flex space-x-4"><li><a class="hover:text-white font-medium" href="/security-labs/sitemap.xml">Sitemap</a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://elastic.co?utm_source=elastic-search-labs&amp;utm_medium=referral&amp;utm_campaign=search-labs&amp;utm_content=footer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="inline-block w-3 h-3"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 003 8.25v10.5A2.25 2.25 0 005.25 21h10.5A2.25 2.25 0 0018 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg><span>Elastic.co</span></a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://twitter.com/elasticseclabs"><svg class="w-4 h-4 inline-block w-3 h-3" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>@elasticseclabs</span></a></li></ul></nav></div><div class="flex flex-col space-y-1 text-zinc-300"><p>© <!-- -->2024<!-- -->. Elasticsearch B.V. All Rights Reserved.</p></div></div></footer></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"title":"Introducing a New Vulnerability Class: False File Immutability","slug":"false-file-immutability","date":"2024-07-11","description":"This article introduces a previously-unnamed class of Windows vulnerability that demonstrates the dangers of assumption and describes some unintended security consequences.","image":"Security Labs Images 36.jpg","body":{"raw":"\n## Introduction\n\nThis article will discuss a previously-unnamed vulnerability class in Windows, showing how long-standing incorrect assumptions in the design of core Windows features can result in both undefined behavior and security vulnerabilities. We will demonstrate how one such vulnerability in the Windows 11 kernel can be exploited to achieve arbitrary code execution with kernel privileges.\n\n\n## Windows file sharing\n\nWhen an application opens a file on Windows, it typically uses some form of the Win32 [**CreateFile**](https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew) API.\n\n``` c++\nHANDLE CreateFileW(\n  [in]           LPCWSTR               lpFileName,\n  [in]           DWORD                 dwDesiredAccess,\n  [in]           DWORD                 dwShareMode,\n  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,\n  [in]           DWORD                 dwCreationDisposition,\n  [in]           DWORD                 dwFlagsAndAttributes,\n  [in, optional] HANDLE                hTemplateFile\n);\n```\n\nCallers of **CreateFile** specify the access they want in **dwDesiredAccess**. For example, a caller would pass **FILE_READ_DATA** to be able to read data, or **FILE_WRITE_DATA** to be able to write data. The full set of access rights are [documented](https://learn.microsoft.com/en-us/windows/win32/fileio/file-access-rights-constants) on the Microsoft Learn website.\n\nIn addition to passing **dwDesiredAccess**, callers must pass a “sharing mode” in **dwShareMode**, which consists of zero or more of **FILE_SHARE_READ**, **FILE_SHARE_WRITE**, and **FILE_SHARE_DELETE**. You can think of a sharing mode as the caller declaring “I’m okay with others doing X to this file while I’m using it,” where X could be reading, writing, or renaming. For example, a caller that passes **FILE_SHARE_WRITE** allows others to write the file while they are working with it.\n\nAs a file is opened, the caller’s **dwDesiredAccess** is tested against the **dwShareMode** of all existing file handles. Simultaneously, the caller’s **dwShareMode** is tested against the previously-granted **dwDesiredAccess** of all existing handles to that file. If either of these tests fail, then **CreateFile** fails with a sharing violation.\n\nSharing isn’t mandatory. Callers can pass a share mode of zero to obtain exclusive access. Per Microsoft [documentation](https://learn.microsoft.com/en-us/windows/win32/fileio/creating-and-opening-files):\n\n\u003e An open file that is not shared (dwShareMode set to zero) cannot be opened again, either by the application that opened it or by another application, until its handle has been closed. This is also referred to as exclusive access.\n\n\n### Sharing enforcement\n\nIn the kernel, sharing is enforced by filesystem drivers. As a file is opened, it’s the responsibility of the filesystem driver to call [**IoCheckShareAccess**](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iocheckshareaccess) or [**IoCheckLinkShareAccess**](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iochecklinkshareaccess) to see whether the requested **DesiredAccess**/**ShareMode** tuple is compatible with any existing handles to the file being opened. [NTFS](https://learn.microsoft.com/en-us/windows-server/storage/file-server/ntfs-overview) is the primary filesystem on Windows, but it’s closed-source, so for illustrative purposes we’ll instead look at Microsoft’s FastFAT sample code performing [the same check](https://github.com/Microsoft/Windows-driver-samples/blob/622212c3fff587f23f6490a9da939fb85968f651/filesys/fastfat/create.c#L6822-L6884). Unlike an IDA decompilation, it even comes with comments!\n\n``` c++\n//\n//  Check if the Fcb has the proper share access.\n//\n\nreturn IoCheckShareAccess( *DesiredAccess,\n                           ShareAccess,\n                           FileObject,\n                           \u0026FcbOrDcb-\u003eShareAccess,\n                           FALSE );\n```\n\nIn addition to traditional read/write file operations, Windows lets applications map files into memory. Before we go deeper, it’s important to understand that [section objects](https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/section-objects-and-views) are kernel parlance for [file mappings](https://learn.microsoft.com/en-us/windows/win32/memory/file-mapping); they are the same thing. This article focuses on the kernel, so it will primarily refer to them as section objects.\n\nThere are two types of section objects - data sections and executable image sections. Data sections are direct 1:1 mappings of files into memory. The file’s contents will appear in memory exactly as they do on disk. Data sections also have uniform memory permissions for the entire memory range. With respect to the underlying file, data sections can be either read-only or read-write. A read-write view of a file enables a process to read or write the file’s contents by reading/writing memory within its own address space.\n\nExecutable image sections (sometimes abbreviated to image sections) prepare [PE files](https://learn.microsoft.com/en-us/windows/win32/debug/pe-format) to be executed. Image sections must be created from PE files. Examples of PE files include EXE, DLL, SYS, CPL, SCR, and OCX files. The kernel processes the PEs specially to prepare them to be executed. Different PE regions will be mapped in memory with different page permissions, depending on their metadata. Image views are [copy-on-write](https://en.wikipedia.org/wiki/Copy-on-write), meaning any changes in memory will be saved to the process’s private working set — never written to the backing PE.\n\nLet’s say application A wants to map a file into memory with a data section. First, it opens that file with an API such as **ZwCreateFile**, which returns a file handle. Next, it passes this file handle to an API such as **ZwCreateSection** which creates a section object that describes how the file will be mapped into memory; this yields a section handle. The process then uses the section handle to map a “view” of that section into the process address space, completing the memory mapping.\n\n![Diagram showing how a file is mapped into memory](/assets/images/false-file-immutability/image9.png)\n\nOnce the file is successfully mapped, process A can close both the file and section handles, leaving zero open handles to the file. If process B later wants to use the file without the risk of it being modified externally, it would omit **FILE_SHARE_WRITE** when opening the file. **IoCheckLinkShareAccess** looks for open file handles, but since the handles were previously closed, it will not fail the operation.\n\nThis creates a problem for file sharing. Process B thinks it has a file open without risk of external modification, but process A can modify it through the memory mapping. To account for this, the filesystem must also call [**MmDoesFileHaveUserWritableReferences**](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-mmdoesfilehaveuserwritablereferences). This checks whether there are any active writable file mappings to the given file. We can see this check in the FastFAT example [here](https://github.com/Microsoft/Windows-driver-samples/blob/622212c3fff587f23f6490a9da939fb85968f651/filesys/fastfat/create.c#L6858-L6870):\n\n``` c++\n//\n//  Do an extra test for writeable user sections if the user did not allow\n//  write sharing - this is neccessary since a section may exist with no handles\n//  open to the file its based against.\n//\n\nif ((NodeType( FcbOrDcb ) == FAT_NTC_FCB) \u0026\u0026\n    !FlagOn( ShareAccess, FILE_SHARE_WRITE ) \u0026\u0026\n    FlagOn( *DesiredAccess, FILE_EXECUTE | FILE_READ_DATA | FILE_WRITE_DATA | FILE_APPEND_DATA | DELETE | MAXIMUM_ALLOWED ) \u0026\u0026\n    MmDoesFileHaveUserWritableReferences( \u0026FcbOrDcb-\u003eNonPaged-\u003eSectionObjectPointers )) {\n\n    return STATUS_SHARING_VIOLATION;\n}\n```\n\nWindows requires PE files to be immutable (unmodifiable) while they are running. This prevents EXEs and DLLs from being changed on disk while they are running in memory. Filesystem drivers must use the [**MmFlushImageSection**](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-mmflushimagesection) function to check whether there are any active image mappings of a PE before allowing **FILE_WRITE_DATA** access. We can see this in the [FastFAT example code](https://github.com/Microsoft/Windows-driver-samples/blob/622212c3fff587f23f6490a9da939fb85968f651/filesys/fastfat/create.c#L3572-L3593), and on [Microsoft Learn](https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/executable-images).\n\n``` c++\n//\n//  If the user wants write access access to the file make sure there\n//  is not a process mapping this file as an image. Any attempt to\n//  delete the file will be stopped in fileinfo.c\n//\n//  If the user wants to delete on close, we must check at this\n//  point though.\n//\n\nif (FlagOn(*DesiredAccess, FILE_WRITE_DATA) || DeleteOnClose) {\n\n    Fcb-\u003eOpenCount += 1;\n    DecrementFcbOpenCount = TRUE;\n\n    if (!MmFlushImageSection( \u0026Fcb-\u003eNonPaged-\u003eSectionObjectPointers,\n                              MmFlushForWrite )) {\n\n        Iosb.Status = DeleteOnClose ? STATUS_CANNOT_DELETE :\n                                      STATUS_SHARING_VIOLATION;\n        try_return( Iosb );\n    }\n}\n```\n\nAnother way to think of this check is that **ZwMapViewOfSection(SEC_IMAGE)** implies no-write-sharing as long as the view exists.\n\n\n## Authenticode\n\nThe [Windows Authenticode Specification](https://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/authenticode_pe.docx) describes a way to employ cryptography to “sign” PE files. A “digital signature” cryptographically attests that the PE was produced by a particular entity. Digital signatures are tamper-evident, meaning that any material modification of signed files should be detectable because the digital signature will no longer match. Digital signatures are typically appended to the end of PE files.\n\n![Authenticode specification diagram showing a signature embedded within a PE](/assets/images/false-file-immutability/image19.png)\n\nAuthenticode can’t apply traditional hashing (e.g. **sha256sum**) in this case, because the act of appending the signature would change the file’s hash, breaking the signature it just generated. Instead, the Authenticode specification describes an algorithm to skip specific portions of the PE file that will be changed during the signing process. This algorithm is called **authentihash**. You can use authentihash with any hashing algorithm, such as SHA256. When a PE file is digitally signed, the file’s authentihash is what’s actually signed.\n\n\n### Code integrity\n\nWindows has a few different ways to validate Authenticode signatures. User mode applications can call [**WinVerifyTrust**](https://learn.microsoft.com/en-us/windows/win32/api/wintrust/nf-wintrust-winverifytrust) to validate a file’s signature in user mode. The Code Integrity (CI) subsystem, residing in ```ci.dll```,  validates signatures in the kernel. If [Hypervisor-Protected Code Integrity](https://learn.microsoft.com/en-us/windows-hardware/drivers/bringup/device-guard-and-credential-guard) is running, the Secure Kernel employs ```skci.dll``` to validate Authenticode. This article will focus on Code Integrity (```ci.dll```) in the regular kernel.\n\nCode Integrity provides both Kernel Mode Code Integrity and User Mode Code Integrity, each serving a different set of functions.\n\nKernel Mode Code Integrity (KMCI):\n - Enforces [Driver Signing Enforcement](https://learn.microsoft.com/en-us/windows-hardware/drivers/install/driver-signing) and the [Vulnerable Driver Blocklist](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/microsoft-recommended-driver-block-rules#microsoft-vulnerable-driver-blocklist)\n\nUser Mode Code Integrity (UMCI):\n - CI validates the signatures of EXEs and DLLs before allowing them to load\n - Enforces [Protected Processes and Protected Process Light](https://learn.microsoft.com/en-us/windows/security/threat-protection/overview-of-threat-mitigations-in-windows-10#protected-processes) signature requirements\n - Enforces **ProcessSignaturePolicy** mitigation ([**SetProcessMitigationPolicy**](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setprocessmitigationpolicy))\n - Enforces [INTEGRITYCHECK](https://learn.microsoft.com/en-us/cpp/build/reference/integritycheck-require-signature-check?view=msvc-170) for [FIPS 140-2 modules](https://x.com/GabrielLandau/status/1668353640833114131).\n - Exposed to consumers as [Smart App Control](https://learn.microsoft.com/en-us/windows/apps/develop/smart-app-control/overview)\n - Exposed to businesses as [App Control for Business](https://learn.microsoft.com/en-us/mem/intune/protect/endpoint-security-app-control-policy) (formerly WDAC)\n\nKMCI and UMCI implement different policies for different scenarios. For example, the policy for Protected Processes is different from that of INTEGRITYCHECK.\n\n\n## Incorrect assumptions\n\nMicrosoft [documentation](https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea) implies that files successfully opened without write sharing can’t be modified by another user or process.\n\n```\nFILE_SHARE_WRITE\n0x00000002\nEnables subsequent open operations on a file or device to request write access. Otherwise, other processes cannot open the file or device if they request write access.\n```\n\nIf this flag is not specified, but the file or device has been opened for write access or has a file mapping with write access, the function fails.\n\n*Above, we discussed how sharing is enforced by the filesystem, but what if the filesystem doesn’t know that the file’s been modified?*\n\nLike most user mode memory, the Memory Manager (MM) in the kernel may page-out portions of file mappings when it deems necessary, such as when the system needs more free physical memory. Both data and executable image mappings may be paged-out. Executable image sections can never modify the backing file, so they’re effectively treated as read-only with respect to the backing PE file. As mentioned before, image sections are copy-on-write, meaning any in-memory changes immediately create a private copy of the given page.\n\nWhen the memory manager needs to page-out a page from an image section, it can use the following decision tree:\n - Never modified?  Discard it. We can read the contents back from the immutable file on disk.\n - Modified?  Save private copy it to the pagefile.\n   - Example: If a security product hooks a function in ```ntdll.dll```, MM will create a private copy of each modified page. Upon page-out, private pages will be written to the pagefile.\n\nIf those paged-out pages are later touched, the CPU will issue a page fault and the MM will restore the pages.\n - Page never modified?  Read the original contents back from the immutable file on disk.\n - Page private?  Read it from the pagefile.\n\nNote the following exception: The memory manager may treat PE-relocated pages as unmodified, dynamically reapplying relocations during page faults.\n\n\n### Page hashes\n\nPage hashes are a list of hashes of each 4KB page within a PE file. Since pages are 4KB, page faults typically occur on 4KB of data at a time. Full Authenticode verification requires the entire contiguous PE file, which isn’t available during a page fault. Page hashes allow the MM to validate hashes of individual pages during page faults.\n\nThere are two types of page hashes, which we’ve coined static and dynamic. Static page hashes are stored within a PE’s digital signature if the developer passes ```/ph``` to [```signtool```](https://learn.microsoft.com/en-us/windows/win32/seccrypto/signtool). By pre-computing these, they are immediately available to the MM and CI upon module load.\n\nCI can also compute them on-the-fly during signature validation, a mechanism we’re calling dynamic page hashes. Dynamic page hashes give CI flexibility to enforce page hashes even for files that were never signed with them.\n\nPage hashes are not free - they use CPU and slow down page faults. They’re not used in most cases.\n\n\n## Attacking code integrity\n\nImagine a scenario where a ransomware operator wants to ransom a hospital, so they send a phishing email to a hospital employee. The employee opens the email attachment and enables macros, running the ransomware. The ransomware employs a UAC bypass to immediately elevate to admin, then attempts to terminate any security software on the system so it can operate unhindered. Anti-Malware services run as [Protected Process Light](https://learn.microsoft.com/en-us/windows/win32/services/protecting-anti-malware-services-) (PPL), protecting them from tampering by malware with admin rights, so the ransomware can’t terminate the Anti-Malware service.\n\nIf the ransomware could also run as a PPL, it could terminate the Anti-Malware product. The ransomware can’t launch itself directly as a PPL because UMCI prevents improperly-signed EXEs and DLLs from loading into PPL, as we discussed above. The ransomware might try to inject code into a PPL by modifying an EXE or DLL that’s already running, but the aforementioned **MmFlushImageSection** ensures in-use PE files remain immutable, so this isn’t possible.\n\nWe previously discussed how the filesystem is responsible for sharing checks. *What would happen if an attacker were to move the filesystem to another machine?*\n\n[Network redirectors](https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/what-is-a-network-redirector-) allow the use of network paths with any API that accepts file paths. This is very convenient, allowing users and applications to easily open and memory-map files over the network. Any resulting I/O is transparently redirected to the remote machine. If a program is launched from a network drive, the executable images for the EXE and its DLLs will be transparently pulled from the network.\n\nWhen a network redirector is in use, the server on the other end of the pipe needn’t be a Windows machine. It could be a Linux machine running [Samba](https://en.wikipedia.org/wiki/Samba_(software)), or even a python [impacket script](https://github.com/fortra/impacket/blob/d71f4662eaf12c006c2ea7f5ec09b418d9495806/examples/smbserver.py) that “speaks” the [SMB network protocol](https://learn.microsoft.com/en-us/windows-server/storage/file-server/file-server-smb-overview). This means the server doesn’t have to honor Windows filesystem sharing semantics.\n\nAn attacker can employ a network redirector to modify a PPL’s DLL server-side, bypassing sharing restrictions. This means that PEs backing an executable image section are incorrectly assumed to be immutable. This is a class of vulnerability that we are calling **False File Immutability** (FFI).\n\n\n### Paging exploitation\n\nIf an attacker successfully exploits False File Immutability to inject code into an in-use PE, wouldn’t page hashes catch such an attack?  The answer is: sometimes. If we look at the following table, we can see that page hashes are enforced for kernel drivers and Protected Processes, but not for PPL, so let’s pretend we’re an attacker targeting PPL.\n\n| | Authenticode | Page hashes |\n| ----- | ----- | ----- |\n| Kernel drivers | ✅ | ✅ |\n| Protected Processes (PP-Full) | ✅ | ✅ |\n| Protected Process Light (PPL) | ✅ | ❌ |\n\nLast year at Black Hat Asia 2023 ([abstract](https://www.blackhat.com/asia-23/briefings/schedule/#ppldump-is-dead-long-live-ppldump-31052), [slides](http://i.blackhat.com/Asia-23/AS-23-Landau-PPLdump-Is-Dead-Long-Live-PPLdump.pdf), [recording](https://www.youtube.com/watch?v=5xteW8Tm410)), we disclosed a vulnerability in the Windows kernel, showing how bad assumptions in paging can be exploited to inject code into PPL, defeating security features like [LSA](https://learn.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) \u0026 [Anti-Malware Process Protection](https://learn.microsoft.com/en-us/windows/win32/services/protecting-anti-malware-services-). The attack leveraged False File Immutability assumptions for DLLs in PPLs, as we just described, though we hadn’t yet named the vulnerability class.\n\n![A diagram of the PPLFault exploit](/assets/images/false-file-immutability/image5.png)\n\nAlongside the presentation, we released the [PPLFault exploit](https://github.com/gabriellandau/PPLFault) which demonstrates the vulnerability by dumping the memory of an otherwise-protected PPL. We also released the GodFault exploit chain, which combines the PPLFault Admin-to-PPL exploit with the AngryOrchard PPL-to-kernel exploit to achieve full read/write control of physical memory from user mode. We did this to motivate Microsoft to take action on a vulnerability that MSRC [declined to fix](https://www.elastic.co/security-labs/forget-vulnerable-drivers-admin-is-all-you-need) because it did not meet their [servicing criteria](https://www.microsoft.com/en-us/msrc/windows-security-servicing-criteria). Thankfully, the Windows Defender team at Microsoft stepped up, [releasing a fix](https://x.com/GabrielLandau/status/1757818200127946922) in February 2024 that enforces dynamic page hashes for executable images loaded over network redirectors, breaking PPLFault.\n\n\n## New research\n\nAbove, we discussed Authenticode signatures embedded within PE files. In addition to embedded signatures, Windows supports a form of detached signature called a [security catalog](https://learn.microsoft.com/en-us/windows-hardware/drivers/install/catalog-files). Security catalogs (.cat files) are essentially a list of signed authentihashes. Every PE with an authentihash in that list is considered to be signed by that signer. Windows keeps a large collection of catalog files in ```C:\\Windows\\System32\\CatRoot``` which CI loads, validates, and caches.\n\n![Simplified structure of a security catalog](/assets/images/false-file-immutability/image7.png)\n\n![A security catalog rendered through Windows Explorer](/assets/images/false-file-immutability/image21.png)\n\nA typical Windows system has over a thousand catalog files, many containing dozens or hundreds of authentihashes.\n\n![Security catalogs on a Windows 11 23H2 system](/assets/images/false-file-immutability/image16.png)\n\nTo use a security catalog, Code Integrity must first load it. This occurs in a few discrete steps. First, CI maps the file into kernel memory using **ZwOpenFile**, **ZwCreateSection**, and **ZwMapViewOfSection**. Once mapped, it validates the catalog’s digital signature using **CI!MinCrypK_VerifySignedDataKModeEx**. If the signature is valid, it parses the hashes with **CI!I_MapFileHashes**.\n\n![The Code Integrity catalog parsing process](/assets/images/false-file-immutability/image10.png)\n\nBreaking this down, we see a few key insights. First, **ZwCreateSection(SEC_COMMIT)** tells us that CI is creating a data section, not an image section. This is important because there is no concept of page hashes for data sections.\n\nNext, the file is opened without **FILE_SHARE_WRITE**, meaning write sharing is denied. This is intended to prevent modification of the security catalog during processing. However, as we have shown above, this is a bad assumption and another example of False File Immutability. It should be possible, in theory, to perform a PPLFault-style attack on security catalog processing.\n\n\n### Planning the attack\n\n![](/assets/images/false-file-immutability/image11.png)\n\nThe general flow of the attack is as follows:\n 1. The attacker will plant a security catalog on a storage device that they control. They will install a symbolic link to this catalog in the ```CatRoot``` directory, so Windows knows where to find it.\n 2. The attacker asks the kernel to load a malicious unsigned kernel driver.\n 3. Code Integrity attempts to validate the driver, but it can’t find a signature or trusted authentihash, so it re-scans the CatRoot directory and finds the attacker’s new catalog.\n 4. CI maps the catalog into kernel memory and validates its signature. This generates page faults which are sent to the attacker’s storage device. The storage device returns a legitimate Microsoft-signed catalog.\n 5. The attacker empties the system working set, forcing all the previously-fetched catalog pages to be discarded.\n 6. CI begins parsing the catalog, generating new page faults. This time, the storage device injects the authentihash of their malicious driver.\n 7. CI finds the malicious driver’s authentihash in the catalog and loads the driver. At this point, the attacker has achieved arbitrary code execution in the kernel.\n\n\n### Implementation and considerations\n\nThe plan is to use a PPLFault-style attack, but there are some important differences in this situation. PPLFault used an [opportunistic lock](https://learn.microsoft.com/en-us/windows/win32/fileio/opportunistic-locks) (oplock) to deterministically freeze the victim process’s initialization. This gave the attacker time to switch over to the payload and flush the system working set. Unfortunately, we couldn’t find any good opportunities for oplocks here. Instead, we’re going to pursue a probabilistic approach: rapidly toggling the security catalog between the malicious and benign versions.\n\n![The catalog being toggled between benign and malicious versions; only one hash changes](/assets/images/false-file-immutability/image12.png)\n\nThe verification step touches every page of the catalog, which means all of those pages will be resident in memory when parsing begins. If the attacker changes the catalog on their storage device, it won’t be reflected in memory until after a subsequent page fault. To evict these pages from kernel memory, the attacker must empty the working set between **MinCrypK_VerifySignedDataKModeEx** and **I_MapFileHashes**.\n\nThis approach is inherently a race condition. There’s no built-in delays between signature verification and catalog parsing - it’s a tight race. We’ll need to employ several techniques to widen our window of opportunity.\n\nMost security catalogs on the system are small, a few kilobytes. By choosing a large 4MB catalog, we can greatly increase the amount of time that CI spends parsing. Assuming catalog parsing is linear, we can choose an authentihash near the end of the catalog to maximize the time between signature verification and when CI reaches our tampered page. Further, we will create threads for each CPU on the system whose sole purpose is to consume CPU cycles. These threads run at higher priority than CI, so CI will be starved of CPU time. There will be one thread dedicated to repeatedly flushing pages from the system’s working set, and one thread repeatedly attempting to load the unsigned driver.\n\nThis attack has two main failure modes. First, if the payload Authentihash is read during the signature check, then the signature will be invalid and the catalog will be rejected.\n\n![Code Integrity rejecting a tampered security catalog](/assets/images/false-file-immutability/image17.png)\n\nNext, if an even number of toggles occur (including zero) between signature validation and parsing, then CI will parse the benign hash and reject our driver.\n\n![Passing the signature check, but the benign catalog is parsed](/assets/images/false-file-immutability/image6.png)\n\nThe attacker wins if CI validates a benign catalog then parses a malicious one.\n\n![Code Integrity validating a benign catalog, then parsing a malicious one](/assets/images/false-file-immutability/image20.png)\n\n\n### Exploit demo\n\nWe named the exploit **ItsNotASecurityBoundary** as an homage to MSRC's [policy](https://www.microsoft.com/en-us/msrc/windows-security-servicing-criteria) that \"Administrator-to-kernel is not a security boundary.”  The code is in GitHub [here](https://github.com/gabriellandau/ItsNotASecurityBoundary).\n\nDemo video [here](https://drive.google.com/file/d/13Uw38ZrNeYwfoIuD76qlLgyXP8kRc8Nz/view?usp=sharing).\n\n\n## Understanding these vulnerabilities\n\nIn order to properly defend against these vulnerabilities, we first need to understand them better.\n\nA double-read (aka double-fetch) vulnerability can occur when victim code reads the same value out of an attacker-controlled buffer more than once. The attacker may change the value of this buffer between the reads, resulting in unexpected victim behavior.\n\nImagine there is a page of memory shared between two processes for an IPC mechanism. The client and server send data back and forth using the following struct. To send an IPC request, a client first writes a request struct into the shared memory page, then signals an event to notify the server of a pending request.\n\n``` c\nstruct IPC_PACKET\n{\n    SIZE_T length;\n    UCHAR data[];\n};\n```\n\nA double-read attack could look something like this:\n\n![An example of a double-read exploit using shared memory](/assets/images/false-file-immutability/image18.png)\n\nFirst, the attacking client sets a packet’s structure’s length field to 16 bytes, then signals the server to indicate that a packet is ready for processing.  The victim server wakes up and allocates a 16-byte buffer using ```malloc(pPacket-\u003elength)```.  Immediately afterwards, the attacker changes the length field to 32.  Next, the victim server attempts to copy the packet’s contents into the the new buffer by calling ```memcpy(pBuffer, pPacket-\u003edata, pPacket-\u003elength)```, re-reading the value in ```pPacket-\u003elength```, which is now 32.  The victim ends up copying 32 bytes into a 16-byte buffer, overflowing it.\n\nDouble-read vulnerabilities frequently apply to shared-memory scenarios. They commonly occur in drivers that operate on user-writable buffers. Due to False File Immutability, developers need to be aware that their scope is actually much wider, and includes all files writable by attackers. Denying write sharing does not necessarily prevent file modification.\n\n\n### Affected Operations\n\nWhat types of operations are affected by False File Immutability?\n\n| Operation | API | Mitigations |\n| ----- | ----- | ----- |\n| Image Sections | **CreateProcess** **LoadLibrary** | 1. Enable Page Hashes |\n| Data Sections | **MapViewOfFile** **ZwMapViewOfSection** | 1. Avoid double reads\\ 2. Copy the file to a heap buffer before processing\\ 3. Prevent paging via MmProbeAndLockPages/VirtualLock |\n| Regular I/O | **ReadFile** **ZwReadFile** | 1. Avoid double reads\\  2. Copy the file to a heap buffer before processing |\n\n\n### What else could be vulnerable?\n\nLooking for potentially-vulnerable calls to **ZwMapViewOfSection** in the NT kernel yields quite a few interesting functions:\n\n![Potentially-vulnerable uses of **ZwMapViewOfSection** within the NT kernel](/assets/images/false-file-immutability/image8.png)\n\nIf we expand our search to regular file I/O, we find even more candidates. An important caveat, however, is that **ZwReadFile** may be used for more than just files. Only uses on files (or those which could be coerced into operating on files) could be vulnerable.\n\n![Potentially-vulnerable uses of **ZwReadFile** within the NT kernel](/assets/images/false-file-immutability/image14.png)\n\nLooking outside of the NT kernel, we can find other drivers to investigate:\n\n![Potentially-vulnerable uses of **ZwReadFile** in Windows 11 kernel drivers](/assets/images/false-file-immutability/image2.png)\n\n![Potentially-vulnerable uses of **ZwMapViewOfSection** in Windows 11 kernel drivers](/assets/images/false-file-immutability/image1.png)\n\n\n### Don’t forget about user mode\n\nWe’ve mostly been discussing the kernel up to this point, but it’s important to note that any user mode application that calls **ReadFile**, **MapViewOfFile**, or **LoadLibrary** on an attacker-controllable file, denying write sharing for immutability, may be vulnerable. Here’s a few hypothetical examples.\n\n\n#### MapViewOfFile\n\nImagine an application that is split into two components - a low-privileged worker process with network access, and a privileged service that installs updates. The worker downloads updates and stages them to a specific folder. When the privileged service sees a new update staged, it first validates the signature before installing the update. An attacker could abuse FFI to modify the update after the signature check.\n\n\n#### ReadFile\n\nSince files are subject to double-read vulnerabilities, anything that parses complex file formats may be vulnerable, including antivirus engines and search indexers.\n\n\n#### LoadLibrary\n\nSome applications rely on UMCI to prevent attackers from loading malicious DLLs into their processes. As we’ve shown with PPLFault, FFI can defeat UMCI.\n\n\n## Stopping the exploit\n\nPer their official servicing guidelines, MSRC won’t service Admin -\u003e Kernel vulnerabilities by default. In this parlance, servicing means “fix via security update.”  This type of vulnerability, however, allows malware to bypass [AV Process Protections](https://learn.microsoft.com/en-us/windows/win32/services/protecting-anti-malware-services-), leaving AV and EDR vulnerable to instant-kill attacks.\n\nAs a third-party, we can’t patch Code Integrity, so what can we do to protect our customers? To mitigate **ItsNotASecurityBoundary**, we created **FineButWeCanStillEasilyStopIt**, a filesystem minifilter driver that prevents Code Integrity from opening security catalogs over network redirectors. You can find it on GitHub [here](https://github.com/gabriellandau/ItsNotASecurityBoundary/tree/main/FineButWeCanStillEasilyStopIt). \n\nFineButWeCanStillEasilyStopIt has to jump through some hoops to correctly identify the problematic behavior while minimizing false positives. Ideally, CI itself could be fixed with a few small changes. Let’s look at what that would take.\n\n![Fixing catalog processing by copying the catalog to the heap](/assets/images/false-file-immutability/image13.png)\n\nAs mentioned above in the Affected Operations section, applications can mitigate double-read vulnerabilities by copying the file contents out of the file mapping into the heap, and exclusively using that heap copy for all subsequent operations. The kernel heap is called the [pool](https://learn.microsoft.com/en-us/windows/win32/memory/memory-pools), and the corresponding allocation function is **ExAllocatePool**.\n\n![Fixing catalog processing by locking the pages into RAM](/assets/images/false-file-immutability/image15.png)\n\nAn alternative mitigation strategy to break these types of exploits is to pin the pages of the file mapping into physical memory using an API such as **MmProbeAndLockPages**. This prevents eviction of those pages when the attacker empties the working set.\n\n\n### End-user detection and mitigation\n\nFortunately, there is a way for end-users to mitigate this exploit without changes from Microsoft – Hypervisor Protected Code Integrity (HVCI). If HVCI is enabled, CI.dll doesn’t do catalog parsing at all. Instead, it sends the catalog contents to the Secure Kernel, which runs in a separate virtual machine on the same host. The Secure Kernel stores the received catalog contents in its own heap, from which signature validation and parsing are performed. Just like with the **ExAllocatePool** mitigation described above, the exploit is mitigated because file changes have no effect on the heap copy.\n\nThe probabilistic nature of this attack means that there are likely many failed attempts. Windows records these failures in the **Microsoft-Windows-CodeIntegrity/Operational** event log. Users can check this log for evidence of exploitation.\n\n![**Microsoft-Windows-CodeIntegrity/Operational** event log showing an invalid driver signature](/assets/images/false-file-immutability/image23.png)\n\n![**Microsoft-Windows-CodeIntegrity/Operational** event log showing an invalid security catalog](/assets/images/false-file-immutability/image4.png)\n\n\n## Disclosure\n\nThe disclosure timeline is as follows:\n - 2024-02-14: We reported ItsNotASecurityBoundary and FineButWeCanStillEasilyStopIt to MSRC as VULN-119340, suggesting **ExAllocatePool** and **MmProbeAndLockPages** as simple low-risk fixes\n - 2024-02-29: The Windows Defender team reached out to coordinate disclosure\n - 2024-04-23: Microsoft releases [KB5036980](https://support.microsoft.com/en-us/topic/april-23-2024-kb5036980-os-builds-22621-3527-and-22631-3527-preview-5a0d6c49-e42e-4eb4-8541-33a7139281ed) Preview with the **MmProbeAndLockPages** fix\n - 2024-05-14: Fix reaches GA for Windows 11 23H2 as [KB5037771](https://support.microsoft.com/en-us/topic/may-14-2024-kb5037771-os-builds-22621-3593-and-22631-3593-e633ff2f-a021-4abb-bd2e-7f3687f166fe); we have not tested any other platforms (Win10, Server, etc).\n - 2024-06-14: MSRC closed the case, stating \"We have completed our investigation and determined that the case doesn't meet our bar for servicing at this time. As a result, we have opened a next-version candidate bug for the issue, and it will be evaluated for upcoming releases. Thanks, again, for sharing this report with us.\"\n\n\n## Fixing Code Integrity\n\nLooking at the original implementation of **CI!I_MapAndSizeDataFile**, we can see the legacy code calling **ZwCreateSection** and **ZwMapViewOfSection**:\n\n![The vulnerable **CI!I_MapAndSizeDataFile** implementation](/assets/images/false-file-immutability/image22.png)\n\nContrast that with the new **CI!CipMapAndSizeDataFileWithMDL**, which follows that up with **MmProbeAndLockPages**:\n\n![The new **CI!CipMapAndSizeDataFileWithMDL** has a mitigation](/assets/images/false-file-immutability/image3.png)\n\n\n## Summary and conclusion\n\nToday we discussed and named a bug class: **False File Immutability**. We are aware of two public exploits that leverage it, PPLFault and ItsNotASecurityBoundary.\n\n[PPLFault](https://github.com/gabriellandau/PPLFault): Admin -\u003e PPL [-\u003e Kernel via GodFault]\n - Exploits bad immutability assumptions about image section in CI/MM\n - Reported September 2022\n - Patched February 2024 (~510 days later)\n\n[ItsNotASecurityBoundary](https://github.com/gabriellandau/ItsNotASecurityBoundary): Admin -\u003e Kernel\n - Exploits bad immutability assumptions about data sections in CI\n - Reported February 2024\n - Patched May 2024 (~90 days later)\n\nIf you are writing Windows code that operates on files, you need to be aware of the fact these files may be modified while you are working on them, even if you deny write sharing. See the Affected Operations section above for guidance on how to protect yourselves and your customers against these types of attacks.\n\nItsNotASecurityBoundary is not the end of FFI. There are other exploitable FFI vulnerabilities out there. My colleagues and I at Elastic Security Labs will continue exploring and reporting on FFI and beyond. We encourage you to follow along on X [@GabrielLandau](https://x.com/GabrielLandau) and [@ElasticSecLabs](https://x.com/elasticseclabs).\n","code":"var Component=(()=\u003e{var d=Object.create;var r=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var u=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=\u003e{for(var n in e)r(t,n,{get:e[n],enumerable:!0})},o=(t,e,n,s)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let a of g(e))!f.call(t,a)\u0026\u0026a!==n\u0026\u0026r(t,a,{get:()=\u003ee[a],enumerable:!(s=p(e,a))||s.enumerable});return t};var y=(t,e,n)=\u003e(n=t!=null?d(m(t)):{},o(e||!t||!t.__esModule?r(n,\"default\",{value:t,enumerable:!0}):n,t)),b=t=\u003eo(r({},\"__esModule\",{value:!0}),t);var c=u((F,l)=\u003e{l.exports=_jsx_runtime});var P={};w(P,{default:()=\u003eI,frontmatter:()=\u003ev});var i=y(c()),v={title:\"Introducing a New Vulnerability Class: False File Immutability\",slug:\"false-file-immutability\",date:\"2024-07-11\",description:\"This article introduces a previously-unnamed class of Windows vulnerability that demonstrates the dangers of assumption and describes some unintended security consequences.\",author:[{slug:\"gabriel-landau\"}],image:\"Security Labs Images 36.jpg\",category:[{slug:\"security-research\"},{slug:\"vulnerability-updates\"}]};function h(t){let e=Object.assign({h2:\"h2\",p:\"p\",a:\"a\",strong:\"strong\",pre:\"pre\",code:\"code\",blockquote:\"blockquote\",h3:\"h3\",img:\"img\",ul:\"ul\",li:\"li\",em:\"em\",div:\"div\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\",ol:\"ol\",h4:\"h4\"},t.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{id:\"introduction\",children:\"Introduction\"}),`\n`,(0,i.jsx)(e.p,{children:\"This article will discuss a previously-unnamed vulnerability class in Windows, showing how long-standing incorrect assumptions in the design of core Windows features can result in both undefined behavior and security vulnerabilities. We will demonstrate how one such vulnerability in the Windows 11 kernel can be exploited to achieve arbitrary code execution with kernel privileges.\"}),`\n`,(0,i.jsx)(e.h2,{id:\"windows-file-sharing\",children:\"Windows file sharing\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"When an application opens a file on Windows, it typically uses some form of the Win32 \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew\",rel:\"nofollow\",children:(0,i.jsx)(e.strong,{children:\"CreateFile\"})}),\" API.\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:\"language-c++\",children:`HANDLE CreateFileW(\n  [in]           LPCWSTR               lpFileName,\n  [in]           DWORD                 dwDesiredAccess,\n  [in]           DWORD                 dwShareMode,\n  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,\n  [in]           DWORD                 dwCreationDisposition,\n  [in]           DWORD                 dwFlagsAndAttributes,\n  [in, optional] HANDLE                hTemplateFile\n);\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Callers of \",(0,i.jsx)(e.strong,{children:\"CreateFile\"}),\" specify the access they want in \",(0,i.jsx)(e.strong,{children:\"dwDesiredAccess\"}),\". For example, a caller would pass \",(0,i.jsx)(e.strong,{children:\"FILE_READ_DATA\"}),\" to be able to read data, or \",(0,i.jsx)(e.strong,{children:\"FILE_WRITE_DATA\"}),\" to be able to write data. The full set of access rights are \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/fileio/file-access-rights-constants\",rel:\"nofollow\",children:\"documented\"}),\" on the Microsoft Learn website.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"In addition to passing \",(0,i.jsx)(e.strong,{children:\"dwDesiredAccess\"}),\", callers must pass a \\u201Csharing mode\\u201D in \",(0,i.jsx)(e.strong,{children:\"dwShareMode\"}),\", which consists of zero or more of \",(0,i.jsx)(e.strong,{children:\"FILE_SHARE_READ\"}),\", \",(0,i.jsx)(e.strong,{children:\"FILE_SHARE_WRITE\"}),\", and \",(0,i.jsx)(e.strong,{children:\"FILE_SHARE_DELETE\"}),\". You can think of a sharing mode as the caller declaring \\u201CI\\u2019m okay with others doing X to this file while I\\u2019m using it,\\u201D where X could be reading, writing, or renaming. For example, a caller that passes \",(0,i.jsx)(e.strong,{children:\"FILE_SHARE_WRITE\"}),\" allows others to write the file while they are working with it.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"As a file is opened, the caller\\u2019s \",(0,i.jsx)(e.strong,{children:\"dwDesiredAccess\"}),\" is tested against the \",(0,i.jsx)(e.strong,{children:\"dwShareMode\"}),\" of all existing file handles. Simultaneously, the caller\\u2019s \",(0,i.jsx)(e.strong,{children:\"dwShareMode\"}),\" is tested against the previously-granted \",(0,i.jsx)(e.strong,{children:\"dwDesiredAccess\"}),\" of all existing handles to that file. If either of these tests fail, then \",(0,i.jsx)(e.strong,{children:\"CreateFile\"}),\" fails with a sharing violation.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Sharing isn\\u2019t mandatory. Callers can pass a share mode of zero to obtain exclusive access. Per Microsoft \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/fileio/creating-and-opening-files\",rel:\"nofollow\",children:\"documentation\"}),\":\"]}),`\n`,(0,i.jsxs)(e.blockquote,{children:[`\n`,(0,i.jsx)(e.p,{children:\"An open file that is not shared (dwShareMode set to zero) cannot be opened again, either by the application that opened it or by another application, until its handle has been closed. This is also referred to as exclusive access.\"}),`\n`]}),`\n`,(0,i.jsx)(e.h3,{id:\"sharing-enforcement\",children:\"Sharing enforcement\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"In the kernel, sharing is enforced by filesystem drivers. As a file is opened, it\\u2019s the responsibility of the filesystem driver to call \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iocheckshareaccess\",rel:\"nofollow\",children:(0,i.jsx)(e.strong,{children:\"IoCheckShareAccess\"})}),\" or \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iochecklinkshareaccess\",rel:\"nofollow\",children:(0,i.jsx)(e.strong,{children:\"IoCheckLinkShareAccess\"})}),\" to see whether the requested \",(0,i.jsx)(e.strong,{children:\"DesiredAccess\"}),\"/\",(0,i.jsx)(e.strong,{children:\"ShareMode\"}),\" tuple is compatible with any existing handles to the file being opened. \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows-server/storage/file-server/ntfs-overview\",rel:\"nofollow\",children:\"NTFS\"}),\" is the primary filesystem on Windows, but it\\u2019s closed-source, so for illustrative purposes we\\u2019ll instead look at Microsoft\\u2019s FastFAT sample code performing \",(0,i.jsx)(e.a,{href:\"https://github.com/Microsoft/Windows-driver-samples/blob/622212c3fff587f23f6490a9da939fb85968f651/filesys/fastfat/create.c#L6822-L6884\",rel:\"nofollow\",children:\"the same check\"}),\". Unlike an IDA decompilation, it even comes with comments!\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:\"language-c++\",children:`//\n//  Check if the Fcb has the proper share access.\n//\n\nreturn IoCheckShareAccess( *DesiredAccess,\n                           ShareAccess,\n                           FileObject,\n                           \u0026FcbOrDcb-\u003eShareAccess,\n                           FALSE );\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"In addition to traditional read/write file operations, Windows lets applications map files into memory. Before we go deeper, it\\u2019s important to understand that \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/section-objects-and-views\",rel:\"nofollow\",children:\"section objects\"}),\" are kernel parlance for \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/memory/file-mapping\",rel:\"nofollow\",children:\"file mappings\"}),\"; they are the same thing. This article focuses on the kernel, so it will primarily refer to them as section objects.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"There are two types of section objects - data sections and executable image sections. Data sections are direct 1:1 mappings of files into memory. The file\\u2019s contents will appear in memory exactly as they do on disk. Data sections also have uniform memory permissions for the entire memory range. With respect to the underlying file, data sections can be either read-only or read-write. A read-write view of a file enables a process to read or write the file\\u2019s contents by reading/writing memory within its own address space.\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Executable image sections (sometimes abbreviated to image sections) prepare \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/debug/pe-format\",rel:\"nofollow\",children:\"PE files\"}),\" to be executed. Image sections must be created from PE files. Examples of PE files include EXE, DLL, SYS, CPL, SCR, and OCX files. The kernel processes the PEs specially to prepare them to be executed. Different PE regions will be mapped in memory with different page permissions, depending on their metadata. Image views are \",(0,i.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Copy-on-write\",rel:\"nofollow\",children:\"copy-on-write\"}),\", meaning any changes in memory will be saved to the process\\u2019s private working set \\u2014 never written to the backing PE.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Let\\u2019s say application A wants to map a file into memory with a data section. First, it opens that file with an API such as \",(0,i.jsx)(e.strong,{children:\"ZwCreateFile\"}),\", which returns a file handle. Next, it passes this file handle to an API such as \",(0,i.jsx)(e.strong,{children:\"ZwCreateSection\"}),\" which creates a section object that describes how the file will be mapped into memory; this yields a section handle. The process then uses the section handle to map a \\u201Cview\\u201D of that section into the process address space, completing the memory mapping.\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image9.png\",alt:\"Diagram showing how a file is mapped into memory\",width:\"1440\",height:\"308\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Once the file is successfully mapped, process A can close both the file and section handles, leaving zero open handles to the file. If process B later wants to use the file without the risk of it being modified externally, it would omit \",(0,i.jsx)(e.strong,{children:\"FILE_SHARE_WRITE\"}),\" when opening the file. \",(0,i.jsx)(e.strong,{children:\"IoCheckLinkShareAccess\"}),\" looks for open file handles, but since the handles were previously closed, it will not fail the operation.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"This creates a problem for file sharing. Process B thinks it has a file open without risk of external modification, but process A can modify it through the memory mapping. To account for this, the filesystem must also call \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-mmdoesfilehaveuserwritablereferences\",rel:\"nofollow\",children:(0,i.jsx)(e.strong,{children:\"MmDoesFileHaveUserWritableReferences\"})}),\". This checks whether there are any active writable file mappings to the given file. We can see this check in the FastFAT example \",(0,i.jsx)(e.a,{href:\"https://github.com/Microsoft/Windows-driver-samples/blob/622212c3fff587f23f6490a9da939fb85968f651/filesys/fastfat/create.c#L6858-L6870\",rel:\"nofollow\",children:\"here\"}),\":\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:\"language-c++\",children:`//\n//  Do an extra test for writeable user sections if the user did not allow\n//  write sharing - this is neccessary since a section may exist with no handles\n//  open to the file its based against.\n//\n\nif ((NodeType( FcbOrDcb ) == FAT_NTC_FCB) \u0026\u0026\n    !FlagOn( ShareAccess, FILE_SHARE_WRITE ) \u0026\u0026\n    FlagOn( *DesiredAccess, FILE_EXECUTE | FILE_READ_DATA | FILE_WRITE_DATA | FILE_APPEND_DATA | DELETE | MAXIMUM_ALLOWED ) \u0026\u0026\n    MmDoesFileHaveUserWritableReferences( \u0026FcbOrDcb-\u003eNonPaged-\u003eSectionObjectPointers )) {\n\n    return STATUS_SHARING_VIOLATION;\n}\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Windows requires PE files to be immutable (unmodifiable) while they are running. This prevents EXEs and DLLs from being changed on disk while they are running in memory. Filesystem drivers must use the \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-mmflushimagesection\",rel:\"nofollow\",children:(0,i.jsx)(e.strong,{children:\"MmFlushImageSection\"})}),\" function to check whether there are any active image mappings of a PE before allowing \",(0,i.jsx)(e.strong,{children:\"FILE_WRITE_DATA\"}),\" access. We can see this in the \",(0,i.jsx)(e.a,{href:\"https://github.com/Microsoft/Windows-driver-samples/blob/622212c3fff587f23f6490a9da939fb85968f651/filesys/fastfat/create.c#L3572-L3593\",rel:\"nofollow\",children:\"FastFAT example code\"}),\", and on \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/executable-images\",rel:\"nofollow\",children:\"Microsoft Learn\"}),\".\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:\"language-c++\",children:`//\n//  If the user wants write access access to the file make sure there\n//  is not a process mapping this file as an image. Any attempt to\n//  delete the file will be stopped in fileinfo.c\n//\n//  If the user wants to delete on close, we must check at this\n//  point though.\n//\n\nif (FlagOn(*DesiredAccess, FILE_WRITE_DATA) || DeleteOnClose) {\n\n    Fcb-\u003eOpenCount += 1;\n    DecrementFcbOpenCount = TRUE;\n\n    if (!MmFlushImageSection( \u0026Fcb-\u003eNonPaged-\u003eSectionObjectPointers,\n                              MmFlushForWrite )) {\n\n        Iosb.Status = DeleteOnClose ? STATUS_CANNOT_DELETE :\n                                      STATUS_SHARING_VIOLATION;\n        try_return( Iosb );\n    }\n}\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Another way to think of this check is that \",(0,i.jsx)(e.strong,{children:\"ZwMapViewOfSection(SEC_IMAGE)\"}),\" implies no-write-sharing as long as the view exists.\"]}),`\n`,(0,i.jsx)(e.h2,{id:\"authenticode\",children:\"Authenticode\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"The \",(0,i.jsx)(e.a,{href:\"https://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/authenticode_pe.docx\",rel:\"nofollow\",children:\"Windows Authenticode Specification\"}),\" describes a way to employ cryptography to \\u201Csign\\u201D PE files. A \\u201Cdigital signature\\u201D cryptographically attests that the PE was produced by a particular entity. Digital signatures are tamper-evident, meaning that any material modification of signed files should be detectable because the digital signature will no longer match. Digital signatures are typically appended to the end of PE files.\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image19.png\",alt:\"Authenticode specification diagram showing a signature embedded within a PE\",width:\"864\",height:\"1024\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Authenticode can\\u2019t apply traditional hashing (e.g. \",(0,i.jsx)(e.strong,{children:\"sha256sum\"}),\") in this case, because the act of appending the signature would change the file\\u2019s hash, breaking the signature it just generated. Instead, the Authenticode specification describes an algorithm to skip specific portions of the PE file that will be changed during the signing process. This algorithm is called \",(0,i.jsx)(e.strong,{children:\"authentihash\"}),\". You can use authentihash with any hashing algorithm, such as SHA256. When a PE file is digitally signed, the file\\u2019s authentihash is what\\u2019s actually signed.\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"code-integrity\",children:\"Code integrity\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Windows has a few different ways to validate Authenticode signatures. User mode applications can call \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/api/wintrust/nf-wintrust-winverifytrust\",rel:\"nofollow\",children:(0,i.jsx)(e.strong,{children:\"WinVerifyTrust\"})}),\" to validate a file\\u2019s signature in user mode. The Code Integrity (CI) subsystem, residing in \",(0,i.jsx)(e.code,{children:\"ci.dll\"}),\",  validates signatures in the kernel. If \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows-hardware/drivers/bringup/device-guard-and-credential-guard\",rel:\"nofollow\",children:\"Hypervisor-Protected Code Integrity\"}),\" is running, the Secure Kernel employs \",(0,i.jsx)(e.code,{children:\"skci.dll\"}),\" to validate Authenticode. This article will focus on Code Integrity (\",(0,i.jsx)(e.code,{children:\"ci.dll\"}),\") in the regular kernel.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Code Integrity provides both Kernel Mode Code Integrity and User Mode Code Integrity, each serving a different set of functions.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Kernel Mode Code Integrity (KMCI):\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Enforces \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows-hardware/drivers/install/driver-signing\",rel:\"nofollow\",children:\"Driver Signing Enforcement\"}),\" and the \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/microsoft-recommended-driver-block-rules#microsoft-vulnerable-driver-blocklist\",rel:\"nofollow\",children:\"Vulnerable Driver Blocklist\"})]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"User Mode Code Integrity (UMCI):\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"CI validates the signatures of EXEs and DLLs before allowing them to load\"}),`\n`,(0,i.jsxs)(e.li,{children:[\"Enforces \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/security/threat-protection/overview-of-threat-mitigations-in-windows-10#protected-processes\",rel:\"nofollow\",children:\"Protected Processes and Protected Process Light\"}),\" signature requirements\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Enforces \",(0,i.jsx)(e.strong,{children:\"ProcessSignaturePolicy\"}),\" mitigation (\",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setprocessmitigationpolicy\",rel:\"nofollow\",children:(0,i.jsx)(e.strong,{children:\"SetProcessMitigationPolicy\"})}),\")\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Enforces \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/cpp/build/reference/integritycheck-require-signature-check?view=msvc-170\",rel:\"nofollow\",children:\"INTEGRITYCHECK\"}),\" for \",(0,i.jsx)(e.a,{href:\"https://x.com/GabrielLandau/status/1668353640833114131\",rel:\"nofollow\",children:\"FIPS 140-2 modules\"}),\".\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Exposed to consumers as \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/apps/develop/smart-app-control/overview\",rel:\"nofollow\",children:\"Smart App Control\"})]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Exposed to businesses as \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/mem/intune/protect/endpoint-security-app-control-policy\",rel:\"nofollow\",children:\"App Control for Business\"}),\" (formerly WDAC)\"]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"KMCI and UMCI implement different policies for different scenarios. For example, the policy for Protected Processes is different from that of INTEGRITYCHECK.\"}),`\n`,(0,i.jsx)(e.h2,{id:\"incorrect-assumptions\",children:\"Incorrect assumptions\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Microsoft \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea\",rel:\"nofollow\",children:\"documentation\"}),\" implies that files successfully opened without write sharing can\\u2019t be modified by another user or process.\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`FILE_SHARE_WRITE\n0x00000002\nEnables subsequent open operations on a file or device to request write access. Otherwise, other processes cannot open the file or device if they request write access.\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"If this flag is not specified, but the file or device has been opened for write access or has a file mapping with write access, the function fails.\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.em,{children:\"Above, we discussed how sharing is enforced by the filesystem, but what if the filesystem doesn\\u2019t know that the file\\u2019s been modified?\"})}),`\n`,(0,i.jsx)(e.p,{children:\"Like most user mode memory, the Memory Manager (MM) in the kernel may page-out portions of file mappings when it deems necessary, such as when the system needs more free physical memory. Both data and executable image mappings may be paged-out. Executable image sections can never modify the backing file, so they\\u2019re effectively treated as read-only with respect to the backing PE file. As mentioned before, image sections are copy-on-write, meaning any in-memory changes immediately create a private copy of the given page.\"}),`\n`,(0,i.jsx)(e.p,{children:\"When the memory manager needs to page-out a page from an image section, it can use the following decision tree:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Never modified?  Discard it. We can read the contents back from the immutable file on disk.\"}),`\n`,(0,i.jsxs)(e.li,{children:[\"Modified?  Save private copy it to the pagefile.\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Example: If a security product hooks a function in \",(0,i.jsx)(e.code,{children:\"ntdll.dll\"}),\", MM will create a private copy of each modified page. Upon page-out, private pages will be written to the pagefile.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"If those paged-out pages are later touched, the CPU will issue a page fault and the MM will restore the pages.\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Page never modified?  Read the original contents back from the immutable file on disk.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Page private?  Read it from the pagefile.\"}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"Note the following exception: The memory manager may treat PE-relocated pages as unmodified, dynamically reapplying relocations during page faults.\"}),`\n`,(0,i.jsx)(e.h3,{id:\"page-hashes\",children:\"Page hashes\"}),`\n`,(0,i.jsx)(e.p,{children:\"Page hashes are a list of hashes of each 4KB page within a PE file. Since pages are 4KB, page faults typically occur on 4KB of data at a time. Full Authenticode verification requires the entire contiguous PE file, which isn\\u2019t available during a page fault. Page hashes allow the MM to validate hashes of individual pages during page faults.\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"There are two types of page hashes, which we\\u2019ve coined static and dynamic. Static page hashes are stored within a PE\\u2019s digital signature if the developer passes \",(0,i.jsx)(e.code,{children:\"/ph\"}),\" to \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/seccrypto/signtool\",rel:\"nofollow\",children:(0,i.jsx)(e.code,{children:\"signtool\"})}),\". By pre-computing these, they are immediately available to the MM and CI upon module load.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"CI can also compute them on-the-fly during signature validation, a mechanism we\\u2019re calling dynamic page hashes. Dynamic page hashes give CI flexibility to enforce page hashes even for files that were never signed with them.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Page hashes are not free - they use CPU and slow down page faults. They\\u2019re not used in most cases.\"}),`\n`,(0,i.jsx)(e.h2,{id:\"attacking-code-integrity\",children:\"Attacking code integrity\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Imagine a scenario where a ransomware operator wants to ransom a hospital, so they send a phishing email to a hospital employee. The employee opens the email attachment and enables macros, running the ransomware. The ransomware employs a UAC bypass to immediately elevate to admin, then attempts to terminate any security software on the system so it can operate unhindered. Anti-Malware services run as \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/services/protecting-anti-malware-services-\",rel:\"nofollow\",children:\"Protected Process Light\"}),\" (PPL), protecting them from tampering by malware with admin rights, so the ransomware can\\u2019t terminate the Anti-Malware service.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"If the ransomware could also run as a PPL, it could terminate the Anti-Malware product. The ransomware can\\u2019t launch itself directly as a PPL because UMCI prevents improperly-signed EXEs and DLLs from loading into PPL, as we discussed above. The ransomware might try to inject code into a PPL by modifying an EXE or DLL that\\u2019s already running, but the aforementioned \",(0,i.jsx)(e.strong,{children:\"MmFlushImageSection\"}),\" ensures in-use PE files remain immutable, so this isn\\u2019t possible.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"We previously discussed how the filesystem is responsible for sharing checks. \",(0,i.jsx)(e.em,{children:\"What would happen if an attacker were to move the filesystem to another machine?\"})]}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/what-is-a-network-redirector-\",rel:\"nofollow\",children:\"Network redirectors\"}),\" allow the use of network paths with any API that accepts file paths. This is very convenient, allowing users and applications to easily open and memory-map files over the network. Any resulting I/O is transparently redirected to the remote machine. If a program is launched from a network drive, the executable images for the EXE and its DLLs will be transparently pulled from the network.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"When a network redirector is in use, the server on the other end of the pipe needn\\u2019t be a Windows machine. It could be a Linux machine running \",(0,i.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Samba_(software)\",rel:\"nofollow\",children:\"Samba\"}),\", or even a python \",(0,i.jsx)(e.a,{href:\"https://github.com/fortra/impacket/blob/d71f4662eaf12c006c2ea7f5ec09b418d9495806/examples/smbserver.py\",rel:\"nofollow\",children:\"impacket script\"}),\" that \\u201Cspeaks\\u201D the \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows-server/storage/file-server/file-server-smb-overview\",rel:\"nofollow\",children:\"SMB network protocol\"}),\". This means the server doesn\\u2019t have to honor Windows filesystem sharing semantics.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"An attacker can employ a network redirector to modify a PPL\\u2019s DLL server-side, bypassing sharing restrictions. This means that PEs backing an executable image section are incorrectly assumed to be immutable. This is a class of vulnerability that we are calling \",(0,i.jsx)(e.strong,{children:\"False File Immutability\"}),\" (FFI).\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"paging-exploitation\",children:\"Paging exploitation\"}),`\n`,(0,i.jsx)(e.p,{children:\"If an attacker successfully exploits False File Immutability to inject code into an in-use PE, wouldn\\u2019t page hashes catch such an attack?  The answer is: sometimes. If we look at the following table, we can see that page hashes are enforced for kernel drivers and Protected Processes, but not for PPL, so let\\u2019s pretend we\\u2019re an attacker targeting PPL.\"}),`\n`,(0,i.jsx)(e.div,{className:\"table-container\",children:(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{}),(0,i.jsx)(e.th,{children:\"Authenticode\"}),(0,i.jsx)(e.th,{children:\"Page hashes\"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Kernel drivers\"}),(0,i.jsx)(e.td,{children:\"\\u2705\"}),(0,i.jsx)(e.td,{children:\"\\u2705\"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Protected Processes (PP-Full)\"}),(0,i.jsx)(e.td,{children:\"\\u2705\"}),(0,i.jsx)(e.td,{children:\"\\u2705\"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Protected Process Light (PPL)\"}),(0,i.jsx)(e.td,{children:\"\\u2705\"}),(0,i.jsx)(e.td,{children:\"\\u274C\"})]})]})]})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Last year at Black Hat Asia 2023 (\",(0,i.jsx)(e.a,{href:\"https://www.blackhat.com/asia-23/briefings/schedule/#ppldump-is-dead-long-live-ppldump-31052\",rel:\"nofollow\",children:\"abstract\"}),\", \",(0,i.jsx)(e.a,{href:\"http://i.blackhat.com/Asia-23/AS-23-Landau-PPLdump-Is-Dead-Long-Live-PPLdump.pdf\",rel:\"nofollow\",children:\"slides\"}),\", \",(0,i.jsx)(e.a,{href:\"https://www.youtube.com/watch?v=5xteW8Tm410\",rel:\"nofollow\",children:\"recording\"}),\"), we disclosed a vulnerability in the Windows kernel, showing how bad assumptions in paging can be exploited to inject code into PPL, defeating security features like \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection\",rel:\"nofollow\",children:\"LSA\"}),\" \u0026 \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/services/protecting-anti-malware-services-\",rel:\"nofollow\",children:\"Anti-Malware Process Protection\"}),\". The attack leveraged False File Immutability assumptions for DLLs in PPLs, as we just described, though we hadn\\u2019t yet named the vulnerability class.\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image5.png\",alt:\"A diagram of the PPLFault exploit\",width:\"1334\",height:\"563\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Alongside the presentation, we released the \",(0,i.jsx)(e.a,{href:\"https://github.com/gabriellandau/PPLFault\",rel:\"nofollow\",children:\"PPLFault exploit\"}),\" which demonstrates the vulnerability by dumping the memory of an otherwise-protected PPL. We also released the GodFault exploit chain, which combines the PPLFault Admin-to-PPL exploit with the AngryOrchard PPL-to-kernel exploit to achieve full read/write control of physical memory from user mode. We did this to motivate Microsoft to take action on a vulnerability that MSRC \",(0,i.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/forget-vulnerable-drivers-admin-is-all-you-need\",rel:\"nofollow\",children:\"declined to fix\"}),\" because it did not meet their \",(0,i.jsx)(e.a,{href:\"https://www.microsoft.com/en-us/msrc/windows-security-servicing-criteria\",rel:\"nofollow\",children:\"servicing criteria\"}),\". Thankfully, the Windows Defender team at Microsoft stepped up, \",(0,i.jsx)(e.a,{href:\"https://x.com/GabrielLandau/status/1757818200127946922\",rel:\"nofollow\",children:\"releasing a fix\"}),\" in February 2024 that enforces dynamic page hashes for executable images loaded over network redirectors, breaking PPLFault.\"]}),`\n`,(0,i.jsx)(e.h2,{id:\"new-research\",children:\"New research\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Above, we discussed Authenticode signatures embedded within PE files. In addition to embedded signatures, Windows supports a form of detached signature called a \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows-hardware/drivers/install/catalog-files\",rel:\"nofollow\",children:\"security catalog\"}),\". Security catalogs (.cat files) are essentially a list of signed authentihashes. Every PE with an authentihash in that list is considered to be signed by that signer. Windows keeps a large collection of catalog files in \",(0,i.jsx)(e.code,{children:\"C:\\\\Windows\\\\System32\\\\CatRoot\"}),\" which CI loads, validates, and caches.\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image7.png\",alt:\"Simplified structure of a security catalog\",width:\"1440\",height:\"42\"})}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image21.png\",alt:\"A security catalog rendered through Windows Explorer\",width:\"810\",height:\"511\"})}),`\n`,(0,i.jsx)(e.p,{children:\"A typical Windows system has over a thousand catalog files, many containing dozens or hundreds of authentihashes.\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image16.png\",alt:\"Security catalogs on a Windows 11 23H2 system\",width:\"1012\",height:\"502\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"To use a security catalog, Code Integrity must first load it. This occurs in a few discrete steps. First, CI maps the file into kernel memory using \",(0,i.jsx)(e.strong,{children:\"ZwOpenFile\"}),\", \",(0,i.jsx)(e.strong,{children:\"ZwCreateSection\"}),\", and \",(0,i.jsx)(e.strong,{children:\"ZwMapViewOfSection\"}),\". Once mapped, it validates the catalog\\u2019s digital signature using \",(0,i.jsx)(e.strong,{children:\"CI!MinCrypK_VerifySignedDataKModeEx\"}),\". If the signature is valid, it parses the hashes with \",(0,i.jsx)(e.strong,{children:\"CI!I_MapFileHashes\"}),\".\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image10.png\",alt:\"The Code Integrity catalog parsing process\",width:\"1000\",height:\"402\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Breaking this down, we see a few key insights. First, \",(0,i.jsx)(e.strong,{children:\"ZwCreateSection(SEC_COMMIT)\"}),\" tells us that CI is creating a data section, not an image section. This is important because there is no concept of page hashes for data sections.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Next, the file is opened without \",(0,i.jsx)(e.strong,{children:\"FILE_SHARE_WRITE\"}),\", meaning write sharing is denied. This is intended to prevent modification of the security catalog during processing. However, as we have shown above, this is a bad assumption and another example of False File Immutability. It should be possible, in theory, to perform a PPLFault-style attack on security catalog processing.\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"planning-the-attack\",children:\"Planning the attack\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image11.png\",alt:\"\",width:\"1440\",height:\"738\"})}),`\n`,(0,i.jsx)(e.p,{children:\"The general flow of the attack is as follows:\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"The attacker will plant a security catalog on a storage device that they control. They will install a symbolic link to this catalog in the \",(0,i.jsx)(e.code,{children:\"CatRoot\"}),\" directory, so Windows knows where to find it.\"]}),`\n`,(0,i.jsx)(e.li,{children:\"The attacker asks the kernel to load a malicious unsigned kernel driver.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Code Integrity attempts to validate the driver, but it can\\u2019t find a signature or trusted authentihash, so it re-scans the CatRoot directory and finds the attacker\\u2019s new catalog.\"}),`\n`,(0,i.jsx)(e.li,{children:\"CI maps the catalog into kernel memory and validates its signature. This generates page faults which are sent to the attacker\\u2019s storage device. The storage device returns a legitimate Microsoft-signed catalog.\"}),`\n`,(0,i.jsx)(e.li,{children:\"The attacker empties the system working set, forcing all the previously-fetched catalog pages to be discarded.\"}),`\n`,(0,i.jsx)(e.li,{children:\"CI begins parsing the catalog, generating new page faults. This time, the storage device injects the authentihash of their malicious driver.\"}),`\n`,(0,i.jsx)(e.li,{children:\"CI finds the malicious driver\\u2019s authentihash in the catalog and loads the driver. At this point, the attacker has achieved arbitrary code execution in the kernel.\"}),`\n`]}),`\n`,(0,i.jsx)(e.h3,{id:\"implementation-and-considerations\",children:\"Implementation and considerations\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"The plan is to use a PPLFault-style attack, but there are some important differences in this situation. PPLFault used an \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/fileio/opportunistic-locks\",rel:\"nofollow\",children:\"opportunistic lock\"}),\" (oplock) to deterministically freeze the victim process\\u2019s initialization. This gave the attacker time to switch over to the payload and flush the system working set. Unfortunately, we couldn\\u2019t find any good opportunities for oplocks here. Instead, we\\u2019re going to pursue a probabilistic approach: rapidly toggling the security catalog between the malicious and benign versions.\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image12.png\",alt:\"The catalog being toggled between benign and malicious versions; only one hash changes\",width:\"1051\",height:\"763\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"The verification step touches every page of the catalog, which means all of those pages will be resident in memory when parsing begins. If the attacker changes the catalog on their storage device, it won\\u2019t be reflected in memory until after a subsequent page fault. To evict these pages from kernel memory, the attacker must empty the working set between \",(0,i.jsx)(e.strong,{children:\"MinCrypK_VerifySignedDataKModeEx\"}),\" and \",(0,i.jsx)(e.strong,{children:\"I_MapFileHashes\"}),\".\"]}),`\n`,(0,i.jsx)(e.p,{children:\"This approach is inherently a race condition. There\\u2019s no built-in delays between signature verification and catalog parsing - it\\u2019s a tight race. We\\u2019ll need to employ several techniques to widen our window of opportunity.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Most security catalogs on the system are small, a few kilobytes. By choosing a large 4MB catalog, we can greatly increase the amount of time that CI spends parsing. Assuming catalog parsing is linear, we can choose an authentihash near the end of the catalog to maximize the time between signature verification and when CI reaches our tampered page. Further, we will create threads for each CPU on the system whose sole purpose is to consume CPU cycles. These threads run at higher priority than CI, so CI will be starved of CPU time. There will be one thread dedicated to repeatedly flushing pages from the system\\u2019s working set, and one thread repeatedly attempting to load the unsigned driver.\"}),`\n`,(0,i.jsx)(e.p,{children:\"This attack has two main failure modes. First, if the payload Authentihash is read during the signature check, then the signature will be invalid and the catalog will be rejected.\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image17.png\",alt:\"Code Integrity rejecting a tampered security catalog\",width:\"1440\",height:\"85\"})}),`\n`,(0,i.jsx)(e.p,{children:\"Next, if an even number of toggles occur (including zero) between signature validation and parsing, then CI will parse the benign hash and reject our driver.\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image6.png\",alt:\"Passing the signature check, but the benign catalog is parsed\",width:\"1113\",height:\"257\"})}),`\n`,(0,i.jsx)(e.p,{children:\"The attacker wins if CI validates a benign catalog then parses a malicious one.\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image20.png\",alt:\"Code Integrity validating a benign catalog, then parsing a malicious one\",width:\"1112\",height:\"271\"})}),`\n`,(0,i.jsx)(e.h3,{id:\"exploit-demo\",children:\"Exploit demo\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"We named the exploit \",(0,i.jsx)(e.strong,{children:\"ItsNotASecurityBoundary\"}),\" as an homage to MSRC's \",(0,i.jsx)(e.a,{href:\"https://www.microsoft.com/en-us/msrc/windows-security-servicing-criteria\",rel:\"nofollow\",children:\"policy\"}),' that \"Administrator-to-kernel is not a security boundary.\\u201D  The code is in GitHub ',(0,i.jsx)(e.a,{href:\"https://github.com/gabriellandau/ItsNotASecurityBoundary\",rel:\"nofollow\",children:\"here\"}),\".\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Demo video \",(0,i.jsx)(e.a,{href:\"https://drive.google.com/file/d/13Uw38ZrNeYwfoIuD76qlLgyXP8kRc8Nz/view?usp=sharing\",rel:\"nofollow\",children:\"here\"}),\".\"]}),`\n`,(0,i.jsx)(e.h2,{id:\"understanding-these-vulnerabilities\",children:\"Understanding these vulnerabilities\"}),`\n`,(0,i.jsx)(e.p,{children:\"In order to properly defend against these vulnerabilities, we first need to understand them better.\"}),`\n`,(0,i.jsx)(e.p,{children:\"A double-read (aka double-fetch) vulnerability can occur when victim code reads the same value out of an attacker-controlled buffer more than once. The attacker may change the value of this buffer between the reads, resulting in unexpected victim behavior.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Imagine there is a page of memory shared between two processes for an IPC mechanism. The client and server send data back and forth using the following struct. To send an IPC request, a client first writes a request struct into the shared memory page, then signals an event to notify the server of a pending request.\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:\"language-c\",children:`struct IPC_PACKET\n{\n    SIZE_T length;\n    UCHAR data[];\n};\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"A double-read attack could look something like this:\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image18.png\",alt:\"An example of a double-read exploit using shared memory\",width:\"1137\",height:\"557\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"First, the attacking client sets a packet\\u2019s structure\\u2019s length field to 16 bytes, then signals the server to indicate that a packet is ready for processing.  The victim server wakes up and allocates a 16-byte buffer using \",(0,i.jsx)(e.code,{children:\"malloc(pPacket-\u003elength)\"}),\".  Immediately afterwards, the attacker changes the length field to 32.  Next, the victim server attempts to copy the packet\\u2019s contents into the the new buffer by calling \",(0,i.jsx)(e.code,{children:\"memcpy(pBuffer, pPacket-\u003edata, pPacket-\u003elength)\"}),\", re-reading the value in \",(0,i.jsx)(e.code,{children:\"pPacket-\u003elength\"}),\", which is now 32.  The victim ends up copying 32 bytes into a 16-byte buffer, overflowing it.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Double-read vulnerabilities frequently apply to shared-memory scenarios. They commonly occur in drivers that operate on user-writable buffers. Due to False File Immutability, developers need to be aware that their scope is actually much wider, and includes all files writable by attackers. Denying write sharing does not necessarily prevent file modification.\"}),`\n`,(0,i.jsx)(e.h3,{id:\"affected-operations\",children:\"Affected Operations\"}),`\n`,(0,i.jsx)(e.p,{children:\"What types of operations are affected by False File Immutability?\"}),`\n`,(0,i.jsx)(e.div,{className:\"table-container\",children:(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:\"Operation\"}),(0,i.jsx)(e.th,{children:\"API\"}),(0,i.jsx)(e.th,{children:\"Mitigations\"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Image Sections\"}),(0,i.jsxs)(e.td,{children:[(0,i.jsx)(e.strong,{children:\"CreateProcess\"}),\" \",(0,i.jsx)(e.strong,{children:\"LoadLibrary\"})]}),(0,i.jsx)(e.td,{children:\"1. Enable Page Hashes\"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Data Sections\"}),(0,i.jsxs)(e.td,{children:[(0,i.jsx)(e.strong,{children:\"MapViewOfFile\"}),\" \",(0,i.jsx)(e.strong,{children:\"ZwMapViewOfSection\"})]}),(0,i.jsx)(e.td,{children:\"1. Avoid double reads\\\\ 2. Copy the file to a heap buffer before processing\\\\ 3. Prevent paging via MmProbeAndLockPages/VirtualLock\"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Regular I/O\"}),(0,i.jsxs)(e.td,{children:[(0,i.jsx)(e.strong,{children:\"ReadFile\"}),\" \",(0,i.jsx)(e.strong,{children:\"ZwReadFile\"})]}),(0,i.jsx)(e.td,{children:\"1. Avoid double reads\\\\  2. Copy the file to a heap buffer before processing\"})]})]})]})}),`\n`,(0,i.jsx)(e.h3,{id:\"what-else-could-be-vulnerable\",children:\"What else could be vulnerable?\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Looking for potentially-vulnerable calls to \",(0,i.jsx)(e.strong,{children:\"ZwMapViewOfSection\"}),\" in the NT kernel yields quite a few interesting functions:\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image8.png\",alt:\"Potentially-vulnerable uses of ZwMapViewOfSection within the NT kernel\",width:\"710\",height:\"485\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"If we expand our search to regular file I/O, we find even more candidates. An important caveat, however, is that \",(0,i.jsx)(e.strong,{children:\"ZwReadFile\"}),\" may be used for more than just files. Only uses on files (or those which could be coerced into operating on files) could be vulnerable.\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image14.png\",alt:\"Potentially-vulnerable uses of ZwReadFile within the NT kernel\",width:\"711\",height:\"520\"})}),`\n`,(0,i.jsx)(e.p,{children:\"Looking outside of the NT kernel, we can find other drivers to investigate:\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image2.png\",alt:\"Potentially-vulnerable uses of ZwReadFile in Windows 11 kernel drivers\",width:\"579\",height:\"606\"})}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image1.png\",alt:\"Potentially-vulnerable uses of ZwMapViewOfSection in Windows 11 kernel drivers\",width:\"651\",height:\"340\"})}),`\n`,(0,i.jsx)(e.h3,{id:\"dont-forget-about-user-mode\",children:\"Don\\u2019t forget about user mode\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"We\\u2019ve mostly been discussing the kernel up to this point, but it\\u2019s important to note that any user mode application that calls \",(0,i.jsx)(e.strong,{children:\"ReadFile\"}),\", \",(0,i.jsx)(e.strong,{children:\"MapViewOfFile\"}),\", or \",(0,i.jsx)(e.strong,{children:\"LoadLibrary\"}),\" on an attacker-controllable file, denying write sharing for immutability, may be vulnerable. Here\\u2019s a few hypothetical examples.\"]}),`\n`,(0,i.jsx)(e.h4,{id:\"mapviewoffile\",children:\"MapViewOfFile\"}),`\n`,(0,i.jsx)(e.p,{children:\"Imagine an application that is split into two components - a low-privileged worker process with network access, and a privileged service that installs updates. The worker downloads updates and stages them to a specific folder. When the privileged service sees a new update staged, it first validates the signature before installing the update. An attacker could abuse FFI to modify the update after the signature check.\"}),`\n`,(0,i.jsx)(e.h4,{id:\"readfile\",children:\"ReadFile\"}),`\n`,(0,i.jsx)(e.p,{children:\"Since files are subject to double-read vulnerabilities, anything that parses complex file formats may be vulnerable, including antivirus engines and search indexers.\"}),`\n`,(0,i.jsx)(e.h4,{id:\"loadlibrary\",children:\"LoadLibrary\"}),`\n`,(0,i.jsx)(e.p,{children:\"Some applications rely on UMCI to prevent attackers from loading malicious DLLs into their processes. As we\\u2019ve shown with PPLFault, FFI can defeat UMCI.\"}),`\n`,(0,i.jsx)(e.h2,{id:\"stopping-the-exploit\",children:\"Stopping the exploit\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Per their official servicing guidelines, MSRC won\\u2019t service Admin -\u003e Kernel vulnerabilities by default. In this parlance, servicing means \\u201Cfix via security update.\\u201D  This type of vulnerability, however, allows malware to bypass \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/services/protecting-anti-malware-services-\",rel:\"nofollow\",children:\"AV Process Protections\"}),\", leaving AV and EDR vulnerable to instant-kill attacks.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"As a third-party, we can\\u2019t patch Code Integrity, so what can we do to protect our customers? To mitigate \",(0,i.jsx)(e.strong,{children:\"ItsNotASecurityBoundary\"}),\", we created \",(0,i.jsx)(e.strong,{children:\"FineButWeCanStillEasilyStopIt\"}),\", a filesystem minifilter driver that prevents Code Integrity from opening security catalogs over network redirectors. You can find it on GitHub \",(0,i.jsx)(e.a,{href:\"https://github.com/gabriellandau/ItsNotASecurityBoundary/tree/main/FineButWeCanStillEasilyStopIt\",rel:\"nofollow\",children:\"here\"}),\".\"]}),`\n`,(0,i.jsx)(e.p,{children:\"FineButWeCanStillEasilyStopIt has to jump through some hoops to correctly identify the problematic behavior while minimizing false positives. Ideally, CI itself could be fixed with a few small changes. Let\\u2019s look at what that would take.\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image13.png\",alt:\"Fixing catalog processing by copying the catalog to the heap\",width:\"1000\",height:\"494\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"As mentioned above in the Affected Operations section, applications can mitigate double-read vulnerabilities by copying the file contents out of the file mapping into the heap, and exclusively using that heap copy for all subsequent operations. The kernel heap is called the \",(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/memory/memory-pools\",rel:\"nofollow\",children:\"pool\"}),\", and the corresponding allocation function is \",(0,i.jsx)(e.strong,{children:\"ExAllocatePool\"}),\".\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image15.png\",alt:\"Fixing catalog processing by locking the pages into RAM\",width:\"1000\",height:\"493\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"An alternative mitigation strategy to break these types of exploits is to pin the pages of the file mapping into physical memory using an API such as \",(0,i.jsx)(e.strong,{children:\"MmProbeAndLockPages\"}),\". This prevents eviction of those pages when the attacker empties the working set.\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"end-user-detection-and-mitigation\",children:\"End-user detection and mitigation\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Fortunately, there is a way for end-users to mitigate this exploit without changes from Microsoft \\u2013 Hypervisor Protected Code Integrity (HVCI). If HVCI is enabled, CI.dll doesn\\u2019t do catalog parsing at all. Instead, it sends the catalog contents to the Secure Kernel, which runs in a separate virtual machine on the same host. The Secure Kernel stores the received catalog contents in its own heap, from which signature validation and parsing are performed. Just like with the \",(0,i.jsx)(e.strong,{children:\"ExAllocatePool\"}),\" mitigation described above, the exploit is mitigated because file changes have no effect on the heap copy.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"The probabilistic nature of this attack means that there are likely many failed attempts. Windows records these failures in the \",(0,i.jsx)(e.strong,{children:\"Microsoft-Windows-CodeIntegrity/Operational\"}),\" event log. Users can check this log for evidence of exploitation.\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image23.png\",alt:\"Microsoft-Windows-CodeIntegrity/Operational event log showing an invalid driver signature\",width:\"626\",height:\"438\"})}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image4.png\",alt:\"Microsoft-Windows-CodeIntegrity/Operational event log showing an invalid security catalog\",width:\"626\",height:\"438\"})}),`\n`,(0,i.jsx)(e.h2,{id:\"disclosure\",children:\"Disclosure\"}),`\n`,(0,i.jsx)(e.p,{children:\"The disclosure timeline is as follows:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"2024-02-14: We reported ItsNotASecurityBoundary and FineButWeCanStillEasilyStopIt to MSRC as VULN-119340, suggesting \",(0,i.jsx)(e.strong,{children:\"ExAllocatePool\"}),\" and \",(0,i.jsx)(e.strong,{children:\"MmProbeAndLockPages\"}),\" as simple low-risk fixes\"]}),`\n`,(0,i.jsx)(e.li,{children:\"2024-02-29: The Windows Defender team reached out to coordinate disclosure\"}),`\n`,(0,i.jsxs)(e.li,{children:[\"2024-04-23: Microsoft releases \",(0,i.jsx)(e.a,{href:\"https://support.microsoft.com/en-us/topic/april-23-2024-kb5036980-os-builds-22621-3527-and-22631-3527-preview-5a0d6c49-e42e-4eb4-8541-33a7139281ed\",rel:\"nofollow\",children:\"KB5036980\"}),\" Preview with the \",(0,i.jsx)(e.strong,{children:\"MmProbeAndLockPages\"}),\" fix\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"2024-05-14: Fix reaches GA for Windows 11 23H2 as \",(0,i.jsx)(e.a,{href:\"https://support.microsoft.com/en-us/topic/may-14-2024-kb5037771-os-builds-22621-3593-and-22631-3593-e633ff2f-a021-4abb-bd2e-7f3687f166fe\",rel:\"nofollow\",children:\"KB5037771\"}),\"; we have not tested any other platforms (Win10, Server, etc).\"]}),`\n`,(0,i.jsx)(e.li,{children:`2024-06-14: MSRC closed the case, stating \"We have completed our investigation and determined that the case doesn't meet our bar for servicing at this time. As a result, we have opened a next-version candidate bug for the issue, and it will be evaluated for upcoming releases. Thanks, again, for sharing this report with us.\"`}),`\n`]}),`\n`,(0,i.jsx)(e.h2,{id:\"fixing-code-integrity\",children:\"Fixing Code Integrity\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Looking at the original implementation of \",(0,i.jsx)(e.strong,{children:\"CI!I_MapAndSizeDataFile\"}),\", we can see the legacy code calling \",(0,i.jsx)(e.strong,{children:\"ZwCreateSection\"}),\" and \",(0,i.jsx)(e.strong,{children:\"ZwMapViewOfSection\"}),\":\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image22.png\",alt:\"The vulnerable CI!I_MapAndSizeDataFile implementation\",width:\"682\",height:\"556\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Contrast that with the new \",(0,i.jsx)(e.strong,{children:\"CI!CipMapAndSizeDataFileWithMDL\"}),\", which follows that up with \",(0,i.jsx)(e.strong,{children:\"MmProbeAndLockPages\"}),\":\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/false-file-immutability/image3.png\",alt:\"The new CI!CipMapAndSizeDataFileWithMDL has a mitigation\",width:\"394\",height:\"501\"})}),`\n`,(0,i.jsx)(e.h2,{id:\"summary-and-conclusion\",children:\"Summary and conclusion\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Today we discussed and named a bug class: \",(0,i.jsx)(e.strong,{children:\"False File Immutability\"}),\". We are aware of two public exploits that leverage it, PPLFault and ItsNotASecurityBoundary.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://github.com/gabriellandau/PPLFault\",rel:\"nofollow\",children:\"PPLFault\"}),\": Admin -\u003e PPL [-\u003e Kernel via GodFault]\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Exploits bad immutability assumptions about image section in CI/MM\"}),`\n`,(0,i.jsx)(e.li,{children:\"Reported September 2022\"}),`\n`,(0,i.jsx)(e.li,{children:\"Patched February 2024 (~510 days later)\"}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://github.com/gabriellandau/ItsNotASecurityBoundary\",rel:\"nofollow\",children:\"ItsNotASecurityBoundary\"}),\": Admin -\u003e Kernel\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Exploits bad immutability assumptions about data sections in CI\"}),`\n`,(0,i.jsx)(e.li,{children:\"Reported February 2024\"}),`\n`,(0,i.jsx)(e.li,{children:\"Patched May 2024 (~90 days later)\"}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"If you are writing Windows code that operates on files, you need to be aware of the fact these files may be modified while you are working on them, even if you deny write sharing. See the Affected Operations section above for guidance on how to protect yourselves and your customers against these types of attacks.\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"ItsNotASecurityBoundary is not the end of FFI. There are other exploitable FFI vulnerabilities out there. My colleagues and I at Elastic Security Labs will continue exploring and reporting on FFI and beyond. We encourage you to follow along on X \",(0,i.jsx)(e.a,{href:\"https://x.com/GabrielLandau\",rel:\"nofollow\",children:\"@GabrielLandau\"}),\" and \",(0,i.jsx)(e.a,{href:\"https://x.com/elasticseclabs\",rel:\"nofollow\",children:\"@ElasticSecLabs\"}),\".\"]})]})}function k(t={}){let{wrapper:e}=t.components||{};return e?(0,i.jsx)(e,Object.assign({},t,{children:(0,i.jsx)(h,t)})):h(t)}var I=k;return b(P);})();\n;return Component;"},"_id":"articles/false-file-immutability.mdx","_raw":{"sourceFilePath":"articles/false-file-immutability.mdx","sourceFileName":"false-file-immutability.mdx","sourceFileDir":"articles","contentType":"mdx","flattenedPath":"articles/false-file-immutability"},"type":"Article","imageUrl":"/assets/images/false-file-immutability/Security Labs Images 36.jpg","readingTime":"28 min read","series":"","url":"/false-file-immutability","headings":[{"level":2,"title":"Introduction","href":"#introduction"},{"level":2,"title":"Windows file sharing","href":"#windows-file-sharing"},{"level":3,"title":"Sharing enforcement","href":"#sharing-enforcement"},{"level":2,"title":"Authenticode","href":"#authenticode"},{"level":3,"title":"Code integrity","href":"#code-integrity"},{"level":2,"title":"Incorrect assumptions","href":"#incorrect-assumptions"},{"level":3,"title":"Page hashes","href":"#page-hashes"},{"level":2,"title":"Attacking code integrity","href":"#attacking-code-integrity"},{"level":3,"title":"Paging exploitation","href":"#paging-exploitation"},{"level":2,"title":"New research","href":"#new-research"},{"level":3,"title":"Planning the attack","href":"#planning-the-attack"},{"level":3,"title":"Implementation and considerations","href":"#implementation-and-considerations"},{"level":3,"title":"Exploit demo","href":"#exploit-demo"},{"level":2,"title":"Understanding these vulnerabilities","href":"#understanding-these-vulnerabilities"},{"level":3,"title":"Affected Operations","href":"#affected-operations"},{"level":3,"title":"What else could be vulnerable?","href":"#what-else-could-be-vulnerable"},{"level":3,"title":"Don’t forget about user mode","href":"#dont-forget-about-user-mode"},{"level":4,"title":"MapViewOfFile","href":"#mapviewoffile"},{"level":4,"title":"ReadFile","href":"#readfile"},{"level":4,"title":"LoadLibrary","href":"#loadlibrary"},{"level":2,"title":"Stopping the exploit","href":"#stopping-the-exploit"},{"level":3,"title":"End-user detection and mitigation","href":"#end-user-detection-and-mitigation"},{"level":2,"title":"Disclosure","href":"#disclosure"},{"level":2,"title":"Fixing Code Integrity","href":"#fixing-code-integrity"},{"level":2,"title":"Summary and conclusion","href":"#summary-and-conclusion"}],"author":[{"title":"Gabriel Landau","slug":"gabriel-landau","description":"Principal Software Engineer, Elastic","image":"gabriel-landau.jpg","body":{"raw":"","code":"var Component=(()=\u003e{var g=Object.create;var i=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var d=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var p=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),j=(t,e)=\u003e{for(var n in e)i(t,n,{get:e[n],enumerable:!0})},s=(t,e,n,o)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let r of d(e))!f.call(t,r)\u0026\u0026r!==n\u0026\u0026i(t,r,{get:()=\u003ee[r],enumerable:!(o=m(e,r))||o.enumerable});return t};var _=(t,e,n)=\u003e(n=t!=null?g(x(t)):{},s(e||!t||!t.__esModule?i(n,\"default\",{value:t,enumerable:!0}):n,t)),b=t=\u003es(i({},\"__esModule\",{value:!0}),t);var l=p((F,c)=\u003e{c.exports=_jsx_runtime});var D={};j(D,{default:()=\u003eC,frontmatter:()=\u003eM});var a=_(l()),M={title:\"Gabriel Landau\",description:\"Principal Software Engineer, Elastic\",image:\"gabriel-landau.jpg\",slug:\"gabriel-landau\"};function u(t){return(0,a.jsx)(a.Fragment,{})}function w(t={}){let{wrapper:e}=t.components||{};return e?(0,a.jsx)(e,Object.assign({},t,{children:(0,a.jsx)(u,t)})):u(t)}var C=w;return b(D);})();\n;return Component;"},"_id":"authors/gabriel-landau.mdx","_raw":{"sourceFilePath":"authors/gabriel-landau.mdx","sourceFileName":"gabriel-landau.mdx","sourceFileDir":"authors","contentType":"mdx","flattenedPath":"authors/gabriel-landau"},"type":"Author","imageUrl":"/assets/images/authors/gabriel-landau.jpg","url":"/authors/gabriel-landau"}],"category":[{"title":"Security research","slug":"security-research","body":{"raw":"","code":"var Component=(()=\u003e{var x=Object.create;var s=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var l=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),d=(t,e)=\u003e{for(var r in e)s(t,r,{get:e[r],enumerable:!0})},c=(t,e,r,a)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let o of _(e))!j.call(t,o)\u0026\u0026o!==r\u0026\u0026s(t,o,{get:()=\u003ee[o],enumerable:!(a=f(e,o))||a.enumerable});return t};var h=(t,e,r)=\u003e(r=t!=null?x(g(t)):{},c(e||!t||!t.__esModule?s(r,\"default\",{value:t,enumerable:!0}):r,t)),p=t=\u003ec(s({},\"__esModule\",{value:!0}),t);var i=l((X,u)=\u003e{u.exports=_jsx_runtime});var D={};d(D,{default:()=\u003eC,frontmatter:()=\u003ey});var n=h(i()),y={title:\"Security research\",slug:\"security-research\"};function m(t){return(0,n.jsx)(n.Fragment,{})}function M(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var C=M;return p(D);})();\n;return Component;"},"_id":"categories/security-research.mdx","_raw":{"sourceFilePath":"categories/security-research.mdx","sourceFileName":"security-research.mdx","sourceFileDir":"categories","contentType":"mdx","flattenedPath":"categories/security-research"},"type":"Category","url":"/categories/security-research"},{"title":"Vulnerability updates","slug":"vulnerability-updates","body":{"raw":"","code":"var Component=(()=\u003e{var m=Object.create;var o=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var d=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var _=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),g=(t,e)=\u003e{for(var n in e)o(t,n,{get:e[n],enumerable:!0})},u=(t,e,n,s)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let a of d(e))!p.call(t,a)\u0026\u0026a!==n\u0026\u0026o(t,a,{get:()=\u003ee[a],enumerable:!(s=x(e,a))||s.enumerable});return t};var j=(t,e,n)=\u003e(n=t!=null?m(f(t)):{},u(e||!t||!t.__esModule?o(n,\"default\",{value:t,enumerable:!0}):n,t)),b=t=\u003eu(o({},\"__esModule\",{value:!0}),t);var c=_((X,i)=\u003e{i.exports=_jsx_runtime});var D={};g(D,{default:()=\u003eC,frontmatter:()=\u003ey});var r=j(c()),y={title:\"Vulnerability updates\",slug:\"vulnerability-updates\"};function l(t){return(0,r.jsx)(r.Fragment,{})}function M(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(l,t)})):l(t)}var C=M;return b(D);})();\n;return Component;"},"_id":"categories/vulnerability-updates.mdx","_raw":{"sourceFilePath":"categories/vulnerability-updates.mdx","sourceFileName":"vulnerability-updates.mdx","sourceFileDir":"categories","contentType":"mdx","flattenedPath":"categories/vulnerability-updates"},"type":"Category","url":"/categories/vulnerability-updates"}]},"seriesArticles":null},"__N_SSG":true},"page":"/[slug]","query":{"slug":"false-file-immutability"},"buildId":"dGrrQfBbQkqaleQ_11aBK","assetPrefix":"/security-labs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>