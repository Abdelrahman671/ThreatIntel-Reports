<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="An in-depth look at the Golang Windows calls" /><meta name="author" content="Leandro Fróes" /><meta property="og:locale" content="en" /><meta name="description" content="Just some of my research notes regarding Malware Analysis, Reverse Engineering and Windows Internals." /><meta property="og:description" content="Just some of my research notes regarding Malware Analysis, Reverse Engineering and Windows Internals." /><link rel="canonical" href="https://leandrofroes.github.io/posts/An-in-depth-look-at-Golang-Windows-calls/" /><meta property="og:url" content="https://leandrofroes.github.io/posts/An-in-depth-look-at-Golang-Windows-calls/" /><meta property="og:site_name" content="Leandro’s blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-04-17T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="An in-depth look at the Golang Windows calls" /><meta name="twitter:site" content="@leandrofr0es" /><meta name="twitter:creator" content="@Leandro Fróes" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Leandro Fróes"},"dateModified":"2023-04-17T00:00:00+00:00","datePublished":"2023-04-17T00:00:00+00:00","description":"Just some of my research notes regarding Malware Analysis, Reverse Engineering and Windows Internals.","headline":"An in-depth look at the Golang Windows calls","mainEntityOfPage":{"@type":"WebPage","@id":"https://leandrofroes.github.io/posts/An-in-depth-look-at-Golang-Windows-calls/"},"url":"https://leandrofroes.github.io/posts/An-in-depth-look-at-Golang-Windows-calls/"}</script><title>An in-depth look at the Golang Windows calls | Leandro's blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Leandro's blog"><meta name="application-name" content="Leandro's blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.1/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="https://avatars.githubusercontent.com/u/29361779" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Leandro's blog</a></div><div class="site-subtitle font-italic">Malware Researcher & Reverse Engineer</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/leandrofroes" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/leandrofr0es" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['',''].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>An in-depth look at the Golang Windows calls</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>An in-depth look at the Golang Windows calls</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1681689600" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Apr 17, 2023 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href=""></a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5396 words"> <em>29 min</em> read</span></div></div></div><div class="post-content"><style> body { text-align: justify; }</style><p>Hi! This is my very first blog entry! I’ve created this blog to do both force myself to publish more of my study notes as well as to share as much as I can online so I hope you enjoy it. =)</p><h2 id="disclaimer"><span class="mr-2">Disclaimer</span><a href="#disclaimer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>It’s important to mention this research is a work in progress and might receive updates in the future. If you find anything wrong here please let me know and I’ll be happy to fix it!<li>The code snippets presented in this blogpost were obtained from the Golang source code. To make it easier to understand I added some more comments on it and removed some parts of the code for better visualization.<li>When I started this research I found no one talking about these internals aspects, specially how those could be abused so I’m assuming what I’m presenting here is a kind of “novel approach” (uuuh, fancy… hahaha). If you know someone that did this kind of work in the past please let me know! I would love to check it.</ul><h2 id="motivation"><span class="mr-2">Motivation</span><a href="#motivation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>At the end of last year (2022) I had to analyze some obfuscated and trojanized Go malwares, basically perform some triage to know more about what it does and how it does the stuff. Due to the Go nuances and runtime aspects my first approach was analyze it statically and after some time into it I thought I was wasting too much time for what should be just a simple triage in the first place.</p><p>That said, I decided to go to a dynamic approach and my first idea was something that I think most part of RE people would do: trace the API calls. In order to do that I used <a href="http://www.rohitab.com/apimonitor">API Monitor</a> cause it’s easy to use and very powerful. Unfortunatelly the output was very noisy and not that complete and I was not happy with it. This experiment made me ask myself why it’s that noisy? How are those Windows API calls performed? And this is how I started this research.</p><h2 id="from-a-golang-function-to-the-windows-api"><span class="mr-2">From a Golang function to the Windows API</span><a href="#from-a-golang-function-to-the-windows-api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The big question we want to answer in this blogpost is: what happens when an application compiled using Go calls a function? Regardless what it does in the middle the program would need to either compile the Windows libraries statically or call into the OS functions at some point (e.g. calling the exported function, performing the syscall directly, etc)</p><h3 id="a-simple-go-call"><span class="mr-2">A simple Go call</span><a href="#a-simple-go-call" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>To answer that question, let’s take the <code class="language-plaintext highlighter-rouge">Hostname</code> function from the <a href="https://pkg.go.dev/os">os</a> package as an example:</p><div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">package</span> <span class="n">os</span>

<span class="c">// Hostname returns the host name reported by the kernel.</span>
<span class="k">func</span> <span class="n">Hostname</span><span class="p">()</span> <span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">hostname</span><span class="p">()</span>
<span class="p">}</span>
</pre></table></code></div></div><p>As we can see, this function is just a wrapper for another function named <code class="language-plaintext highlighter-rouge">hostname</code>, also defined in the <code class="language-plaintext highlighter-rouge">os</code> package:</p><div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="k">func</span> <span class="n">hostname</span><span class="p">()</span> <span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// Use PhysicalDnsHostname to uniquely identify host in a cluster</span>
	<span class="k">const</span> <span class="n">format</span> <span class="o">=</span> <span class="n">windows</span><span class="o">.</span><span class="n">ComputerNamePhysicalDnsHostname</span>

	<span class="n">n</span> <span class="o">:=</span> <span class="kt">uint32</span><span class="p">(</span><span class="m">64</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="n">b</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">uint16</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">:=</span> <span class="n">windows</span><span class="o">.</span><span class="n">GetComputerNameEx</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="m">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="c">// Our target</span>
		<span class="k">if</span> <span class="n">err</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">syscall</span><span class="o">.</span><span class="n">UTF16ToString</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="o">:</span><span class="n">n</span><span class="p">]),</span> <span class="no">nil</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">syscall</span><span class="o">.</span><span class="n">ERROR_MORE_DATA</span> <span class="p">{</span>
			<span class="k">return</span> <span class="s">""</span><span class="p">,</span> <span class="n">NewSyscallError</span><span class="p">(</span><span class="s">"ComputerNameEx"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c">// If we received an ERROR_MORE_DATA, but n doesn't get larger,</span>
		<span class="c">// something has gone wrong and we may be in an infinite loop</span>
		<span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="kt">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="s">""</span><span class="p">,</span> <span class="n">NewSyscallError</span><span class="p">(</span><span class="s">"ComputerNameEx"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Despite some checks performed this function is very simple, it just calls a function named <code class="language-plaintext highlighter-rouge">GetComputerNameEx</code> in the <code class="language-plaintext highlighter-rouge">windows</code> package in order to get the hostname. The curious thing about it is that the name of this function is also the name of a <a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcomputernamew">Windows API function</a> that is also used to retrieve the hostname.</p><p>Doing a quick search in the <a href="https://github.com/golang/go">Go source code</a> we can find the function implementation and notice it ends up calling a function named <code class="language-plaintext highlighter-rouge">Syscall</code>:</p><div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">func</span> <span class="n">GetComputerNameEx</span><span class="p">(</span><span class="n">nametype</span> <span class="kt">uint32</span><span class="p">,</span> <span class="n">buf</span> <span class="o">*</span><span class="kt">uint16</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span><span class="kt">uint32</span><span class="p">)</span> <span class="p">(</span><span class="n">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">r1</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">e1</span> <span class="o">:=</span> <span class="n">syscall</span><span class="o">.</span><span class="n">Syscall</span><span class="p">(</span><span class="n">procGetComputerNameExW</span><span class="o">.</span><span class="n">Addr</span><span class="p">(),</span> <span class="m">3</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">nametype</span><span class="p">),</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">buf</span><span class="p">)),</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
	<span class="k">if</span> <span class="n">r1</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">errnoErr</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>
</pre></table></code></div></div><p>To understand what’s going on here let’s start looking at the <code class="language-plaintext highlighter-rouge">procGetComputerNameExW</code> variable being passed as the first parameter to the <code class="language-plaintext highlighter-rouge">Syscall</code> function.</p><p>Checking a bit more into the <code class="language-plaintext highlighter-rouge">windows</code> package source we can see this <code class="language-plaintext highlighter-rouge">procGetComputerNameExW</code> variable being initialized earlier using both the <code class="language-plaintext highlighter-rouge">NewLazyDLL</code> and <code class="language-plaintext highlighter-rouge">NewProc</code> functions:</p><div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">moddwmapi</span>   <span class="o">=</span> <span class="n">NewLazySystemDLL</span><span class="p">(</span><span class="s">"dwmapi.dll"</span><span class="p">)</span>
<span class="n">modiphlpapi</span> <span class="o">=</span> <span class="n">NewLazySystemDLL</span><span class="p">(</span><span class="s">"iphlpapi.dll"</span><span class="p">)</span>
<span class="n">modkernel32</span> <span class="o">=</span> <span class="n">NewLazySystemDLL</span><span class="p">(</span><span class="s">"kernel32.dll"</span><span class="p">)</span> <span class="c">// Our target module</span>
<span class="n">modmswsock</span>  <span class="o">=</span> <span class="n">NewLazySystemDLL</span><span class="p">(</span><span class="s">"mswsock.dll"</span><span class="p">)</span>
<span class="n">modnetapi32</span> <span class="o">=</span> <span class="n">NewLazySystemDLL</span><span class="p">(</span><span class="s">"netapi32.dll"</span><span class="p">)</span>

<span class="c">// reducted</span>

<span class="n">procGetCommTimeouts</span> <span class="o">=</span> <span class="n">modkernel32</span><span class="o">.</span><span class="n">NewProc</span><span class="p">(</span><span class="s">"GetCommTimeouts"</span><span class="p">)</span>
<span class="n">procGetCommandLineW</span> <span class="o">=</span> <span class="n">modkernel32</span><span class="o">.</span><span class="n">NewProc</span><span class="p">(</span><span class="s">"GetCommandLineW"</span><span class="p">)</span>
<span class="n">procGetComputerNameExW</span> <span class="o">=</span> <span class="n">modkernel32</span><span class="o">.</span><span class="n">NewProc</span><span class="p">(</span><span class="s">"GetComputerNameExW"</span><span class="p">)</span> <span class="c">// Our target function</span>
<span class="n">procGetComputerNameW</span> <span class="o">=</span> <span class="n">modkernel32</span><span class="o">.</span><span class="n">NewProc</span><span class="p">(</span><span class="s">"GetComputerNameW"</span><span class="p">)</span>
<span class="n">procGetConsoleMode</span> <span class="o">=</span> <span class="n">modkernel32</span><span class="o">.</span><span class="n">NewProc</span><span class="p">(</span><span class="s">"GetConsoleMode"</span><span class="p">)</span>
</pre></table></code></div></div><p>The first thing to notice here is that there’s a lot of real Windows API function and DLL names being passed to those functions. At this point we can start to assume this might have something to do with the API itself, so let’s keep going!</p><p>What those two functions being used do is simply initialize the <code class="language-plaintext highlighter-rouge">procGetComputerNameExW</code> variable as a <code class="language-plaintext highlighter-rouge">LazyProc</code> and that will basically allow it to have access to the <code class="language-plaintext highlighter-rouge">Addr</code> function, which is the function being called in the parameter for the <code class="language-plaintext highlighter-rouge">syscall.Syscall</code> call:</p><div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="c">// NewLazyDLL creates new LazyDLL associated with DLL file.</span>
<span class="k">func</span> <span class="n">NewLazyDLL</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="n">LazyDLL</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">LazyDLL</span><span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="n">name</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">LazyDLL</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Name</span> <span class="kt">string</span>

	<span class="c">// System determines whether the DLL must be loaded from the</span>
	<span class="c">// Windows System directory, bypassing the normal DLL search</span>
	<span class="c">// path.</span>
	<span class="n">System</span> <span class="kt">bool</span>

	<span class="n">mu</span>  <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
	<span class="n">dll</span> <span class="o">*</span><span class="n">DLL</span> <span class="c">// non nil once DLL is loaded</span>
<span class="p">}</span>

<span class="c">// NewProc returns a LazyProc for accessing the named procedure in the DLL d.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span><span class="n">LazyDLL</span><span class="p">)</span> <span class="n">NewProc</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="n">LazyProc</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">LazyProc</span><span class="p">{</span><span class="n">l</span><span class="o">:</span> <span class="n">d</span><span class="p">,</span> <span class="n">Name</span><span class="o">:</span> <span class="n">name</span><span class="p">}</span>
<span class="p">}</span>

<span class="c">// A LazyProc implements access to a procedure inside a LazyDLL.</span>
<span class="c">// It delays the lookup until the Addr function is called.</span>
<span class="k">type</span> <span class="n">LazyProc</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Name</span> <span class="kt">string</span>

	<span class="n">mu</span>   <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
	<span class="n">l</span>    <span class="o">*</span><span class="n">LazyDLL</span>
	<span class="n">proc</span> <span class="o">*</span><span class="n">Proc</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="resolving-the-windows-api-functions"><span class="mr-2">Resolving the Windows API functions</span><a href="#resolving-the-windows-api-functions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Once the <code class="language-plaintext highlighter-rouge">Addr</code> function is called it performs some calls here and there but the important function it calls is named <code class="language-plaintext highlighter-rouge">Find</code>. This function calls a function named <code class="language-plaintext highlighter-rouge">Load</code> followed by one named <code class="language-plaintext highlighter-rouge">FindProc</code>:</p><div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="c">// Addr returns the address of the procedure represented by p.</span>
<span class="c">// The return value can be passed to Syscall to run the procedure.</span>
<span class="c">// It will panic if the procedure cannot be found.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">LazyProc</span><span class="p">)</span> <span class="n">Addr</span><span class="p">()</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="n">p</span><span class="o">.</span><span class="n">mustFind</span><span class="p">()</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">proc</span><span class="o">.</span><span class="n">Addr</span><span class="p">()</span>
<span class="p">}</span>

<span class="c">// mustFind is like Find but panics if search fails.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">LazyProc</span><span class="p">)</span> <span class="n">mustFind</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">e</span> <span class="o">:=</span> <span class="n">p</span><span class="o">.</span><span class="n">Find</span><span class="p">()</span>
	<span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">LazyProc</span><span class="p">)</span> <span class="n">Find</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c">// Non-racy version of:</span>
	<span class="c">// if p.proc == nil {</span>
	<span class="k">if</span> <span class="n">atomic</span><span class="o">.</span><span class="n">LoadPointer</span><span class="p">((</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">.</span><span class="n">proc</span><span class="p">)))</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span> <span class="c">// Check if the func addr is not resolved already</span>
		<span class="n">p</span><span class="o">.</span><span class="n">mu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
		<span class="k">defer</span> <span class="n">p</span><span class="o">.</span><span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">proc</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">e</span> <span class="o">:=</span> <span class="n">p</span><span class="o">.</span><span class="n">l</span><span class="o">.</span><span class="n">Load</span><span class="p">()</span> <span class="c">// Attempt to load the module</span>
			<span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">e</span>
			<span class="p">}</span>
			<span class="n">proc</span><span class="p">,</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">p</span><span class="o">.</span><span class="n">l</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">FindProc</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">Name</span><span class="p">)</span> <span class="c">// Resolve export function addr</span>
			<span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">e</span>
			<span class="p">}</span>
			<span class="c">// Non-racy version of:</span>
			<span class="c">// p.proc = proc</span>
			<span class="n">atomic</span><span class="o">.</span><span class="n">StorePointer</span><span class="p">((</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">.</span><span class="n">proc</span><span class="p">)),</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">proc</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>
</pre></table></code></div></div><p>If you’re a bit familiar with Windows and RE you probably already figured what’s going on here. The <code class="language-plaintext highlighter-rouge">Load</code> function is responsible for loading the module in which exports the requested Windows API function and <code class="language-plaintext highlighter-rouge">FindProc</code> resolves the exported function address. This steps are performed using the classic combination of <code class="language-plaintext highlighter-rouge">LoadLibrary</code> + <code class="language-plaintext highlighter-rouge">GetProcAddress</code>:</p><div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
</pre><td class="rouge-code"><pre><span class="k">func</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span><span class="n">LazyDLL</span><span class="p">)</span> <span class="n">Load</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c">// Non-racy version of:</span>
	<span class="c">// if d.dll != nil {</span>
	<span class="k">if</span> <span class="n">atomic</span><span class="o">.</span><span class="n">LoadPointer</span><span class="p">((</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">.</span><span class="n">dll</span><span class="p">)))</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span> <span class="c">// Check if the module is loaded already</span>
		<span class="k">return</span> <span class="no">nil</span>
	<span class="p">}</span>
	<span class="n">d</span><span class="o">.</span><span class="n">mu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="n">d</span><span class="o">.</span><span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">dll</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="no">nil</span>
	<span class="p">}</span>

	<span class="c">// kernel32.dll is special, since it's where LoadLibraryEx comes from.</span>
	<span class="c">// The kernel already special-cases its name, so it's always</span>
	<span class="c">// loaded from system32.</span>
	<span class="k">var</span> <span class="n">dll</span> <span class="o">*</span><span class="n">DLL</span>
	<span class="k">var</span> <span class="n">err</span> <span class="kt">error</span>
	<span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">Name</span> <span class="o">==</span> <span class="s">"kernel32.dll"</span> <span class="p">{</span>
		<span class="n">dll</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">LoadDLL</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">Name</span><span class="p">)</span> <span class="c">// Wrapper to syscall_loadlibrary</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dll</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">loadLibraryEx</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">System</span><span class="p">)</span> <span class="c">// Wrapper to LoadLibraryExW</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">err</span>
	<span class="p">}</span>

	<span class="c">// Non-racy version of:</span>
	<span class="c">// d.dll = dll</span>
	<span class="n">atomic</span><span class="o">.</span><span class="n">StorePointer</span><span class="p">((</span><span class="o">*</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">.</span><span class="n">dll</span><span class="p">)),</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">dll</span><span class="p">))</span>
	<span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">LoadDLL</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="n">dll</span> <span class="o">*</span><span class="n">DLL</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">namep</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">UTF16PtrFromString</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
	<span class="p">}</span>
	<span class="n">h</span><span class="p">,</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">syscall_loadlibrary</span><span class="p">(</span><span class="n">namep</span><span class="p">)</span> <span class="c">// Perform the LoadLibraryA call</span>
	<span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DLLError</span><span class="p">{</span>
			<span class="n">Err</span><span class="o">:</span>     <span class="n">e</span><span class="p">,</span>
			<span class="n">ObjName</span><span class="o">:</span> <span class="n">name</span><span class="p">,</span>
			<span class="n">Msg</span><span class="o">:</span>     <span class="s">"Failed to load "</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="n">Error</span><span class="p">(),</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">d</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">DLL</span><span class="p">{</span>
		<span class="n">Name</span><span class="o">:</span>   <span class="n">name</span><span class="p">,</span>
		<span class="n">Handle</span><span class="o">:</span> <span class="n">h</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">d</span><span class="p">,</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="c">// loadLibraryEx wraps the Windows LoadLibraryEx function.</span>
<span class="c">//</span>
<span class="c">// See https://msdn.microsoft.com/en-us/library/windows/desktop/ms684179(v=vs.85).aspx</span>
<span class="c">//</span>
<span class="c">// If name is not an absolute path, LoadLibraryEx searches for the DLL</span>
<span class="c">// in a variety of automatic locations unless constrained by flags.</span>
<span class="c">// See: https://msdn.microsoft.com/en-us/library/ff919712%28VS.85%29.aspx</span>
<span class="k">func</span> <span class="n">loadLibraryEx</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">,</span> <span class="n">system</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">DLL</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">loadDLL</span> <span class="o">:=</span> <span class="n">name</span>
	<span class="k">var</span> <span class="n">flags</span> <span class="kt">uintptr</span>
	<span class="k">if</span> <span class="n">system</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">canDoSearchSystem32</span><span class="p">()</span> <span class="p">{</span>
			<span class="n">flags</span> <span class="o">=</span> <span class="n">LOAD_LIBRARY_SEARCH_SYSTEM32</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">isBaseName</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
			<span class="c">// WindowsXP or unpatched Windows machine</span>
			<span class="c">// trying to load "foo.dll" out of the system</span>
			<span class="c">// folder, but LoadLibraryEx doesn't support</span>
			<span class="c">// that yet on their system, so emulate it.</span>
			<span class="n">systemdir</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">GetSystemDirectory</span><span class="p">()</span>
			<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
			<span class="p">}</span>
			<span class="n">loadDLL</span> <span class="o">=</span> <span class="n">systemdir</span> <span class="o">+</span> <span class="s">"</span><span class="se">\\</span><span class="s">"</span> <span class="o">+</span> <span class="n">name</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">h</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">LoadLibraryEx</span><span class="p">(</span><span class="n">loadDLL</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span> <span class="c">// Wrapper to syscall.Syscall using procLoadLibraryExW</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">DLL</span><span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="n">name</span><span class="p">,</span> <span class="n">Handle</span><span class="o">:</span> <span class="n">h</span><span class="p">},</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="c">// FindProc searches DLL d for procedure named name and returns *Proc</span>
<span class="c">// if found. It returns an error if search fails.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span><span class="n">DLL</span><span class="p">)</span> <span class="n">FindProc</span><span class="p">(</span><span class="n">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="n">proc</span> <span class="o">*</span><span class="n">Proc</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">namep</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">BytePtrFromString</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
	<span class="p">}</span>
	<span class="n">a</span><span class="p">,</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">syscall_getprocaddress</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">Handle</span><span class="p">,</span> <span class="n">namep</span><span class="p">)</span> <span class="c">// Perform the GetProcAddress call</span>
	<span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DLLError</span><span class="p">{</span>
			<span class="n">Err</span><span class="o">:</span>     <span class="n">e</span><span class="p">,</span>
			<span class="n">ObjName</span><span class="o">:</span> <span class="n">name</span><span class="p">,</span>
			<span class="n">Msg</span><span class="o">:</span>     <span class="s">"Failed to find "</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">" procedure in "</span> <span class="o">+</span> <span class="n">d</span><span class="o">.</span><span class="n">Name</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="n">Error</span><span class="p">(),</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Proc</span><span class="p">{</span>
		<span class="n">Dll</span><span class="o">:</span>  <span class="n">d</span><span class="p">,</span>
		<span class="n">Name</span><span class="o">:</span> <span class="n">name</span><span class="p">,</span>
		<span class="n">addr</span><span class="o">:</span> <span class="n">a</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="no">nil</span>
<span class="p">}</span>
</pre></table></code></div></div><p>What version of the LoadLibrary function it uses? It depends. During the runtime initialization it uses <a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibraryA</a> to load kernel32.dll and <a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryExA</a> to load the rest of the modules the runtime requires. All the other modules are loaded via <a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryexw">LoadLibraryExW</a>. Of course this can change in future versions of Go so what really matters here is that the module will be loaded.</p><p>Once the address of the desired function is obtained it’s returned by the previously mentioned <code class="language-plaintext highlighter-rouge">Addr</code> function and passed to the <code class="language-plaintext highlighter-rouge">syscall.Syscall</code> function.</p><p>Very nice, right?! This is exactly how Golang resolves the address of (almost) all the Windows API functions required by a Golang application. So yes, it’s basically the classic <a href="https://learn.microsoft.com/en-us/windows/win32/dlls/run-time-dynamic-linking">runtime linking</a> approach.</p><p>Now you might be wondering: ok, the desired Windows API functions are resolved using <code class="language-plaintext highlighter-rouge">GetProcAddress</code>, but how is the address of <code class="language-plaintext highlighter-rouge">GetProcAddress</code> function resolved? Well, there’s no magic here. The <code class="language-plaintext highlighter-rouge">GetProcAddress</code> address, along with other functions the runtime package depends on are present in every Golang application Import Table, so their addresses are resolved by the Windows Loader in load time.</p><p> <a href="/assets/images/die_it_go.png" class="popup img-link "><img data-src="/assets/images/die_it_go.png" alt="" class="lazyload" data-proofer-ignore></a> <em>Example of the Import Table of a Golang application using <a href="https://github.com/horsicq/Detect-It-Easy">DIE</a> </em></p><p>Another question that you might ask is: are literally all the Windows API functions resolved this way? Well, not exactly. As mentioned already, some functions used by the runtime package would be resolved by the Windows loader, but there’s some others that seems to be “optional” (but still part of the runtime package and still resolved) that would take a different path and do not rely on those “Syscall” calls. Those would use calls with the <code class="language-plaintext highlighter-rouge">stdcall</code> prefix. However, regardless the path it takes those would still rely on <code class="language-plaintext highlighter-rouge">GetProcAddress</code> and will take the same “final path”. We’ll learn more about it in a bit.</p><p>Since most part of the functions we care about (the ones that are not part of the runtime) are resolved using the <code class="language-plaintext highlighter-rouge">Syscall</code> path we’ll focus on those.</p><p>That said, if we search for some function named like “syscall_whatever” (e.g. <code class="language-plaintext highlighter-rouge">syscall_CreateFile</code>) in a tool like IDA we’ll always see exactly the functions we discussed being called (i.e. <code class="language-plaintext highlighter-rouge">Addr</code> followed by a <code class="language-plaintext highlighter-rouge">Syscall&lt;n&gt;</code>).</p><p> <a href="/assets/images/create_file_syscall.png" class="popup img-link "><img data-src="/assets/images/create_file_syscall.png" alt="" class="lazyload" data-proofer-ignore></a> <em>Disassembly view of syscall_CreateFile in IDA</em></p><p>If you want to play with what we’ve learned so far here’s a nice exercise for you: a way to monitor what Windows API functions are being resolved by a Go application is setting a conditional breakpoint at <a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> using <a href="https://github.com/x64dbg/x64dbg">x64dbg</a> and logging the second parameter to the call (lpProcName). Then you can use something like <code class="language-plaintext highlighter-rouge">{utf8@rdx}</code> (x64 environment in this case) as the log text and <code class="language-plaintext highlighter-rouge">0</code> as the break condition to make sure it will not break. By doing so you’re going to see functions from all the packages being resolved in the <code class="language-plaintext highlighter-rouge">Log</code> output:</p><p> <a href="/assets/images/x64dbg_go_funcs.png" class="popup img-link "><img data-src="/assets/images/x64dbg_go_funcs.png" alt="" class="lazyload" data-proofer-ignore></a> <em>Example of the functions resolved by a Go application using x64dbg</em></p><p>Since both the runtime package and the other dependencies would rely on <code class="language-plaintext highlighter-rouge">GetProcAddress</code> the output would be a bit noisy, but still interesting. By the end of this article we’ll learn how to filter the noise and only get the functions being resolved by the main package.</p><p>Now that we kind of understand part of the chain the remanining question is: how are the calls actually performed? How the Go package interacts with the Windows API? We saw functions like <code class="language-plaintext highlighter-rouge">syscall_getprocaddress</code> being called or even the <code class="language-plaintext highlighter-rouge">syscall.Syscall</code> one, but what exactly happens there?</p><p>Before we move forward I would like to give a step back and introduce a few more concepts to make the rest of the reading easier to follow.</p><h2 id="goroutines"><span class="mr-2">Goroutines</span><a href="#goroutines" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>A <a href="https://go.dev/tour/concurrency/1">goroutine</a> can be defined as a function executing concurrently with other goroutines in the same address space. Go implements an architecture that uses way less resources than the regular threads to execute code. Some examples that make goroutines kind of better in terms of performance when compared against the regular multithreading model is that usually it’s stack start very small (around 2KB) and it doesn’t need to switch to kernel mode or save too much registers in the context switch.</p><p>All the goroutines are handled by an usermode scheduler implemented in the Go runtime package. During execution the Go runtime creates a few threads and schedules the goroutines onto those OS threads to be executed. Once a goroutine is blocked in an operation (e.g. sleep, network input, channel operations) the scheduler changes the context to other goroutines, with no impact in the real threads. This architecture makes Go applications very performatic cause although they’re multithread some of the negative impacts caused by the classic multithread approach are handled by the runtime.</p><p>Of course regardless this abstraction the code would still end up going through the real thread, but the key here is the design of the language.</p><h2 id="the-go-scheduler"><span class="mr-2">The Go Scheduler</span><a href="#the-go-scheduler" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Go implements a scheduler that works in an M:N model, where <code class="language-plaintext highlighter-rouge">M</code> goroutines are scheduled onto <code class="language-plaintext highlighter-rouge">N</code> OS threads throughout the program execution. The scheduler manages three types of resources:</p><ul><li><code class="language-plaintext highlighter-rouge">G</code>: represents a goroutine and contains information about the code to execute.<li><code class="language-plaintext highlighter-rouge">M</code>: represents an OS thread and where to execute the goroutine code.<li><code class="language-plaintext highlighter-rouge">P</code>: represents a “processor”. Basically a resource that is required to execute Go code. The max number of Ps is defined in the GOMAXPROCS var.</ul><p>Each <code class="language-plaintext highlighter-rouge">M</code> must be associated to a <code class="language-plaintext highlighter-rouge">P</code> and a <code class="language-plaintext highlighter-rouge">P</code> can have multiple <code class="language-plaintext highlighter-rouge">M</code>, but only one can be executing. The scheduler works with a global and a local queue of goroutines and manages their execution using a work sharing/stealing model.</p><p>And how Go creates/handles these structures for each thread? It uses the <a href="https://learn.microsoft.com/en-us/windows/win32/procthread/thread-local-storage">Windows Thread Local Storage (TLS)</a> mechanism.</p><h2 id="the-go-system-calls"><span class="mr-2">The Go system calls</span><a href="#the-go-system-calls" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Alright, now let’s go back to the <code class="language-plaintext highlighter-rouge">GetComputerNameEx</code> function. Remember the <code class="language-plaintext highlighter-rouge">syscall.Syscall</code> call? It turns out that Golang defines several functions using the “Syscall” prefix and those are all wrappers to another function named <code class="language-plaintext highlighter-rouge">SyscallN</code>:</p><div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="c">//go:linkname syscall_Syscall syscall.Syscall</span>
<span class="c">//go:nosplit</span>
<span class="k">func</span> <span class="n">syscall_Syscall</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">nargs</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">err</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">syscall_SyscallN</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">//go:linkname syscall_Syscall6 syscall.Syscall6</span>
<span class="c">//go:nosplit</span>
<span class="k">func</span> <span class="n">syscall_Syscall6</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">nargs</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">,</span> <span class="n">a5</span><span class="p">,</span> <span class="n">a6</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">err</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">syscall_SyscallN</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">,</span> <span class="n">a5</span><span class="p">,</span> <span class="n">a6</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">//go:linkname syscall_Syscall9 syscall.Syscall9</span>
<span class="c">//go:nosplit</span>
<span class="k">func</span> <span class="n">syscall_Syscall9</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">nargs</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">,</span> <span class="n">a5</span><span class="p">,</span> <span class="n">a6</span><span class="p">,</span> <span class="n">a7</span><span class="p">,</span> <span class="n">a8</span><span class="p">,</span> <span class="n">a9</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">err</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">syscall_SyscallN</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">,</span> <span class="n">a5</span><span class="p">,</span> <span class="n">a6</span><span class="p">,</span> <span class="n">a7</span><span class="p">,</span> <span class="n">a8</span><span class="p">,</span> <span class="n">a9</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">//go:linkname syscall_Syscall12 syscall.Syscall12</span>
<span class="c">//go:nosplit</span>
<span class="k">func</span> <span class="n">syscall_Syscall12</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">nargs</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">,</span> <span class="n">a5</span><span class="p">,</span> <span class="n">a6</span><span class="p">,</span> <span class="n">a7</span><span class="p">,</span> <span class="n">a8</span><span class="p">,</span> <span class="n">a9</span><span class="p">,</span> <span class="n">a10</span><span class="p">,</span> <span class="n">a11</span><span class="p">,</span> <span class="n">a12</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">err</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">syscall_SyscallN</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">,</span> <span class="n">a5</span><span class="p">,</span> <span class="n">a6</span><span class="p">,</span> <span class="n">a7</span><span class="p">,</span> <span class="n">a8</span><span class="p">,</span> <span class="n">a9</span><span class="p">,</span> <span class="n">a10</span><span class="p">,</span> <span class="n">a11</span><span class="p">,</span> <span class="n">a12</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// etc</span>
</pre></table></code></div></div><p>The rule for the number following the “Syscall” prefix is based on the number of arguments the function takes. The <code class="language-plaintext highlighter-rouge">Syscall</code> takes up to 3 arguments, the <code class="language-plaintext highlighter-rouge">Syscall6</code> takes from 4 to 6, the <code class="language-plaintext highlighter-rouge">Syscall9</code> takes from 7 to 9 and so on.</p><p>Why Go implements it this way? I’m not sure, maybe to avoid the need to create a “Syscall” function for each number of arguments (e.g. Syscall1, Syscall2, Syscall3, etc), making it more generic?! I don’t know. The “downside” of this approach is that the number of parameters provided by Go to an API function might not be precise (e.g. CreateFileW would be invoked using 9 parameters but the real API call takes only 7). Either way, that would still work cause Windows would not care about it and only handle the real parameters.</p><p>Anyway, let’s see how <code class="language-plaintext highlighter-rouge">SyscallN</code> is implemented in the <a href="https://github.com/golang/go/tree/master/src/runtime">runtime</a> package:</p><div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="k">func</span> <span class="n">syscall_SyscallN</span><span class="p">(</span><span class="n">trap</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="n">args</span> <span class="o">...</span><span class="kt">uintptr</span><span class="p">)</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">err</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">nargs</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

	<span class="c">// asmstdcall expects it can access the first 4 arguments</span>
	<span class="c">// to load them into registers.</span>
	<span class="k">var</span> <span class="n">tmp</span> <span class="p">[</span><span class="m">4</span><span class="p">]</span><span class="kt">uintptr</span>
	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">nargs</span> <span class="o">&lt;</span> <span class="m">4</span><span class="o">:</span>
		<span class="nb">copy</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="o">:</span><span class="p">],</span> <span class="n">args</span><span class="p">)</span>
		<span class="n">args</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="o">:</span><span class="p">]</span>
	<span class="k">case</span> <span class="n">nargs</span> <span class="o">&gt;</span> <span class="n">maxArgs</span><span class="o">:</span> <span class="c">// Check if the number of args is more than the suported value</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">"runtime: SyscallN has too many arguments"</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="n">lockOSThread</span><span class="p">()</span>
	<span class="k">defer</span> <span class="n">unlockOSThread</span><span class="p">()</span>
	<span class="c">// What we actually care about</span>
	<span class="n">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">getg</span><span class="p">()</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">syscall</span> <span class="c">// Init the Golang system call structure</span>
	<span class="n">c</span><span class="o">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">trap</span> <span class="c">// Set the Windows API function address</span>
	<span class="n">c</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">nargs</span><span class="p">)</span> <span class="c">// Set the number of arguments</span>
	<span class="n">c</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">noescape</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">[</span><span class="m">0</span><span class="p">])))</span> <span class="c">// Set the arguments array</span>
	<span class="n">cgocall</span><span class="p">(</span><span class="n">asmstdcallAddr</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="c">// Call the asmcgocall</span>
	<span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">r2</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">err</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In this function we’ll focus on 2 things: the <code class="language-plaintext highlighter-rouge">c</code> variable initialization and the call to the <code class="language-plaintext highlighter-rouge">cgocall</code> function.</p><p>Regarding the initialization, remember the <code class="language-plaintext highlighter-rouge">g</code> we talked about in the scheduler introduction? The <code class="language-plaintext highlighter-rouge">getg()</code> function is the one responsible for getting the current goroutine information. In the snippet above it also access the <code class="language-plaintext highlighter-rouge">m</code> structure inside the <code class="language-plaintext highlighter-rouge">g</code>, which as we learned represents the thread the goroutine is associated to. It then access another structure named <code class="language-plaintext highlighter-rouge">syscall</code> and assign it to the <code class="language-plaintext highlighter-rouge">c</code> variable.</p><p>This <code class="language-plaintext highlighter-rouge">syscall</code> is of the type <code class="language-plaintext highlighter-rouge">libcall</code> and this structure defines all the information the Go runtime needs to perform a Windows API call:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>// Defined inside the "m" struct in the "runtime" package

syscall   libcall // stores syscall parameters on windows

// reducted

type libcall struct {
	fn   uintptr // Windows function address
	n    uintptr // Number of parameters
	args uintptr // Parameters array
	r1   uintptr // Return values
	r2   uintptr // Floating point return value
	err  uintptr // Error number
}
</pre></table></code></div></div><p>Now that we know more about the <code class="language-plaintext highlighter-rouge">libcall</code> structure definition, the <code class="language-plaintext highlighter-rouge">SyscallN</code> operations start to be easier to understand. The initialization steps are the following:</p><ul><li><code class="language-plaintext highlighter-rouge">c := &amp;getg().m.syscall</code>: initialize <code class="language-plaintext highlighter-rouge">c</code> with the <code class="language-plaintext highlighter-rouge">libcall</code> structure, allowing it to access the required Windows API information.<li><code class="language-plaintext highlighter-rouge">c.fn = trap</code>: set the resolved Windows API address (first parameter of <code class="language-plaintext highlighter-rouge">SyscallN</code>).<li><code class="language-plaintext highlighter-rouge">c.n = uintptr(nargs)</code>: set the number of arguments based on the <code class="language-plaintext highlighter-rouge">Syscall&lt;n&gt;</code> function used.<li><code class="language-plaintext highlighter-rouge">c.args = uintptr(noescape(unsafe.Pointer(&amp;args[0])))</code>: set the array of arguments to be used in the API function (second parameter of <code class="language-plaintext highlighter-rouge">SyscallN</code>)</ul><p>Once it’s all set the <code class="language-plaintext highlighter-rouge">c</code> variable is then passed to the <code class="language-plaintext highlighter-rouge">cgocall</code> call as a parameter (a structure pointer), along with another variable named <code class="language-plaintext highlighter-rouge">asmstdcall</code> (a function pointer).</p><p>One thing that is important to mention is that for x86 binaries there’s no <code class="language-plaintext highlighter-rouge">SyscallN</code> so the <code class="language-plaintext highlighter-rouge">cgocall</code> is called by the <code class="language-plaintext highlighter-rouge">Syscall&lt;n&gt;</code> functions directly:</p><p> <a href="/assets/images/syscall_wrapper_x64.png" class="popup img-link "><img data-src="/assets/images/syscall_wrapper_x64.png" alt="" class="lazyload" data-proofer-ignore></a> <em>Example of a Syscall call in x64</em></p><p> <a href="/assets/images/syscall_wrapper_x86.png" class="popup img-link "><img data-src="/assets/images/syscall_wrapper_x86.png" alt="" class="lazyload" data-proofer-ignore></a> <em>Example of a Syscall call in x86</em></p><p>Now that we’ve learned a bit more about it all, remember the <code class="language-plaintext highlighter-rouge">syscall_getprocaddress</code> and <code class="language-plaintext highlighter-rouge">syscall_loadlibrary</code> calls? Since they are kind of special due to the fact they are resolved by the Windows loader they would not rely on the “Syscall” path, but as mentioned already the “final path” to actually perform the OS call is still the same. As we can see the steps it performs are pretty much the same of <code class="language-plaintext highlighter-rouge">SyscallN</code>:</p><div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="c">//go:linkname syscall_loadlibrary syscall.loadlibrary</span>
<span class="c">//go:nosplit</span>
<span class="c">//go:cgo_unsafe_args</span>
<span class="k">func</span> <span class="n">syscall_loadlibrary</span><span class="p">(</span><span class="n">filename</span> <span class="o">*</span><span class="kt">uint16</span><span class="p">)</span> <span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">err</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">lockOSThread</span><span class="p">()</span>
	<span class="k">defer</span> <span class="n">unlockOSThread</span><span class="p">()</span>
	<span class="n">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">getg</span><span class="p">()</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">syscall</span>
	<span class="n">c</span><span class="o">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">getLoadLibrary</span><span class="p">()</span> <span class="c">// Get the address at the IAT</span>
	<span class="n">c</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="m">1</span> <span class="c">// Hardcoded argc</span>
	<span class="n">c</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">noescape</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">filename</span><span class="p">)))</span>
	<span class="n">cgocall</span><span class="p">(</span><span class="n">asmstdcallAddr</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
	<span class="n">KeepAlive</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
	<span class="n">handle</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">r1</span>
	<span class="k">if</span> <span class="n">handle</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">err</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c">//go:linkname syscall_getprocaddress syscall.getprocaddress</span>
<span class="c">//go:nosplit</span>
<span class="c">//go:cgo_unsafe_args</span>
<span class="k">func</span> <span class="n">syscall_getprocaddress</span><span class="p">(</span><span class="n">handle</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="n">procname</span> <span class="o">*</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">outhandle</span><span class="p">,</span> <span class="n">err</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">lockOSThread</span><span class="p">()</span>
	<span class="k">defer</span> <span class="n">unlockOSThread</span><span class="p">()</span>
	<span class="n">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">getg</span><span class="p">()</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">syscall</span>
	<span class="n">c</span><span class="o">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">getGetProcAddress</span><span class="p">()</span> <span class="c">// Get the address at the IAT</span>
	<span class="n">c</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="m">2</span> <span class="c">// Hardcoded argc</span>
	<span class="n">c</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="kt">uintptr</span><span class="p">(</span><span class="n">noescape</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">)))</span>
	<span class="n">cgocall</span><span class="p">(</span><span class="n">asmstdcallAddr</span><span class="p">,</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
	<span class="n">KeepAlive</span><span class="p">(</span><span class="n">procname</span><span class="p">)</span>
	<span class="n">outhandle</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">r1</span>
	<span class="k">if</span> <span class="n">outhandle</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">err</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="cgocall--asmcgocall"><span class="mr-2">cgocall &amp; asmcgocall</span><a href="#cgocall--asmcgocall" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>At this point we know that <code class="language-plaintext highlighter-rouge">cgocall</code> function receives both a variable named <code class="language-plaintext highlighter-rouge">asmstdcall</code> and a pointer to the <code class="language-plaintext highlighter-rouge">c</code> structure as parameters.</p><p>This function is responsible for things such as call the <code class="language-plaintext highlighter-rouge">entersyscall</code> function in order to not block neither other goroutines nor the garbage collector and then call <code class="language-plaintext highlighter-rouge">exitsyscall</code> that blocks until this <code class="language-plaintext highlighter-rouge">m</code> can run Go code without violating the <code class="language-plaintext highlighter-rouge">GOMAXPROCS</code> limit. Though this is not that important for our goal, the step that matters for us here is a call performed to a function named <a href="https://github.com/golang/go/blob/master/src/runtime/asm_amd64.s#L832">asmcgocall</a>, passing the <code class="language-plaintext highlighter-rouge">asmstdcall</code> variable and the <code class="language-plaintext highlighter-rouge">c</code> structure to it (the <code class="language-plaintext highlighter-rouge">fn</code> and <code class="language-plaintext highlighter-rouge">arg</code> arguments passed to <code class="language-plaintext highlighter-rouge">cgocall</code>):</p><div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c">// runtime.cgocall(_cgo_Cfunc_f, frame)</span>

<span class="k">func</span> <span class="n">cgocall</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">arg</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)</span> <span class="kt">int32</span> <span class="p">{</span>

	<span class="c">// reducted</span>

	<span class="n">errno</span> <span class="o">:=</span> <span class="n">asmcgocall</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="c">// func asmcgocall(fn, arg unsafe.Pointer) int32</span>
</pre></table></code></div></div><p> <a href="/assets/images/cgocall_ida.png" class="popup img-link "><img data-src="/assets/images/cgocall_ida.png" alt="" class="lazyload" data-proofer-ignore></a> <em>Disassemlby view of the cgocall call</em></p><p>Since we’re in a x64 environment due to the Go ABI the first parameter would be passed via <code class="language-plaintext highlighter-rouge">RAX</code> and the second via <code class="language-plaintext highlighter-rouge">RBX</code>.</p><p>The <code class="language-plaintext highlighter-rouge">asmcgocall</code> function switches to a system-allocated stack and then calls the <a href="https://github.com/golang/go/blob/master/src/runtime/sys_windows_amd64.s#L15">asmstdcall</a> function (the variable passed to <code class="language-plaintext highlighter-rouge">cgocall</code>).</p><p>Both <code class="language-plaintext highlighter-rouge">asmcgocall</code> and <code class="language-plaintext highlighter-rouge">asmstdcall</code> functions are gcc-compiled functions written by cgo hence the attempt to switch to what Go calls the “system stack” to be safer to run gcc-compiled code.</p><p> <a href="/assets/images/asmcgocall_ida.png" class="popup img-link "><img data-src="/assets/images/asmcgocall_ida.png" alt="" class="lazyload" data-proofer-ignore></a> <em>Disassemlby view of the asmcgocall call</em></p><h2 id="asmstdcall-the-magic-call-gate"><span class="mr-2">asmstdcall: the “magic call gate”</span><a href="#asmstdcall-the-magic-call-gate" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>We finally reached the most important function in this whole chain! The <code class="language-plaintext highlighter-rouge">asmstdcall</code> is the Go runtime function responsible for calling the real Windows API function. This function receives a single parameter passed through <code class="language-plaintext highlighter-rouge">RCX</code> in x64 and <code class="language-plaintext highlighter-rouge">ESP+4</code> in x86. And what is received via this parameter? The famous <code class="language-plaintext highlighter-rouge">c</code> structure!</p><p>The image bellow is an example of the <code class="language-plaintext highlighter-rouge">asmstdcall</code> in a x64 environment. I added some comments in each assembly instruction to make it easier to understand:</p><p> <a href="/assets/images/asmstdcall_ida.png" class="popup img-link "><img data-src="/assets/images/asmstdcall_ida.png" alt="" class="lazyload" data-proofer-ignore></a> <em>asmstdcall view in IDA</em></p><p>Overall this function would simply prepare the registers for the API call (copy the parameters to the proper registers, use the stack if needed, etc), perform the call to the API itself and then set the results of it into the <code class="language-plaintext highlighter-rouge">c</code> structure.</p><p>To summarize everything we’ve learned so far I’ve created a very simple image with the Go call flow:</p><p> <a href="/assets/images/go_calls_graph.png" class="popup img-link "><img data-src="/assets/images/go_calls_graph.png" alt="" class="lazyload" data-proofer-ignore></a> <em>General overview of how Go handles the API calls</em></p><p>This explanation finishes up the whole flow of how binaries written in Go would resolve and call the Windows API functions.</p><h2 id="tracing-golang-windows-api-calls-with-gftrace"><span class="mr-2">Tracing Golang Windows API calls with gftrace</span><a href="#tracing-golang-windows-api-calls-with-gftrace" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>As we can see, <code class="language-plaintext highlighter-rouge">asmstdcall</code> is a very powerful function, not only because it’s the one that performs the real Windows API call, but also because it manipulates all the relevant information needed for that call (e.g. function address, parameters, return value etc).</p><p>After a lot of tests I also noticed this function is present in a lot of Go versions (if not all), making this function very portable and reliable. I didn’t test all of the Go versions but I can say for sure it was there in a lot of different versions.</p><p>With that in mind, I decided to create a tool to “abuse” the Go runtime behavior, specifically the <code class="language-plaintext highlighter-rouge">asmstdcall</code> function and this was how I ended up creating a Windows API tracing tool I named <a href="https://github.com/leandrofroes/gftrace/">gftrace</a>.</p><h3 id="how-it-works"><span class="mr-2">How it works?</span><a href="#how-it-works" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The way it works is very straight forward, it injects the <code class="language-plaintext highlighter-rouge">gftrace.dll</code> file into a suspended process (the filepath is passed through the command line) and this DLL performs a mid-function hook inside the <code class="language-plaintext highlighter-rouge">asmstdcall</code> function. The main thread of the target process is then resumed and the target program starts. At this point, every Windows API call performed by the Go application is analyzed by <code class="language-plaintext highlighter-rouge">gftrace</code> and it decides if the obtained information needs to be logged or not based on the filters provided by the user. The tool will only log the functions specified by the user in the <a href="https://github.com/leandrofroes/gftrace/blob/master/tracer/gftrace.cfg">gftrace.cfg</a> file.</p><p>The tool collects all the API information manipulated by <code class="language-plaintext highlighter-rouge">asmstdcall</code> (the <code class="language-plaintext highlighter-rouge">c</code> information), formats it and prints to the user. Since the hook is performed after the API call itself <code class="language-plaintext highlighter-rouge">gftrace</code> is also able to collect the API function return value.</p><p>As an example, the following is part of the output generated by the tool against the Sunshuttle malware:</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="gp">C:\Users\User&gt;</span>gftrace.exe sunshuttle.exe
<span class="go">
- CreateFileW("config.dat.tmp", 0x80000000, 0x3, 0x0, 0x3, 0x1, 0x0) = 0xffffffffffffffff (-1)
- CreateFileW("config.dat.tmp", 0xc0000000, 0x3, 0x0, 0x2, 0x80, 0x0) = 0x198 (408)
- CreateFileW("config.dat.tmp", 0xc0000000, 0x3, 0x0, 0x3, 0x80, 0x0) = 0x1a4 (420)
- WriteFile(0x1a4, 0xc000112780, 0xeb, 0xc0000c79d4, 0x0) = 0x1 (1)
- GetAddrInfoW("reyweb.com", 0x0, 0xc000031f18, 0xc000031e88) = 0x0 (0)
- WSASocketW(0x2, 0x1, 0x0, 0x0, 0x0, 0x81) = 0x1f0 (496)
- WSASend(0x1f0, 0xc00004f038, 0x1, 0xc00004f020, 0x0, 0xc00004eff0, 0x0) = 0x0 (0)
- WSARecv(0x1f0, 0xc00004ef60, 0x1, 0xc00004ef48, 0xc00004efd0, 0xc00004ef18, 0x0) = 0xffffffff (-1)
- GetAddrInfoW("reyweb.com", 0x0, 0xc000031f18, 0xc000031e88) = 0x0 (0)
- WSASocketW(0x2, 0x1, 0x0, 0x0, 0x0, 0x81) = 0x200 (512)
- WSASend(0x200, 0xc00004f2b8, 0x1, 0xc00004f2a0, 0x0, 0xc00004f270, 0x0) = 0x0 (0)
- WSARecv(0x200, 0xc00004f1e0, 0x1, 0xc00004f1c8, 0xc00004f250, 0xc00004f198, 0x0) = 0xffffffff (-1)

[...]
</span></pre></table></code></div></div><h3 id="the-simpler-the-better"><span class="mr-2">The simpler the better</span><a href="#the-simpler-the-better" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Most part of the time in order to monitor API calls you need to hook them in some way and also have a prototype for the function, otherwise would be tricky to guess the number of parameters the function takes as well as the type of those parameters.</p><p><code class="language-plaintext highlighter-rouge">gftrace</code> uses the information provided by <code class="language-plaintext highlighter-rouge">c</code> to figure what is the name of the function being called and the number of arguments it takes. It also tries to figure the type of the parameters by performing some simple checks to determine if it’s a string, an address, etc. By doing so it does not require any function prototype in order to work and it’s able to trace every single API function performed by a Go application. The only information the user needs to provide in the <code class="language-plaintext highlighter-rouge">gftrace.cfg</code> file is a list of the API function names to trace. Simple like that!</p><h3 id="ignoring-the-runtime-noise"><span class="mr-2">Ignoring the runtime noise</span><a href="#ignoring-the-runtime-noise" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>During my tests I noticed that one of the last initilization functions called in Golang applications is a <code class="language-plaintext highlighter-rouge">init</code> function in the <code class="language-plaintext highlighter-rouge">os</code> package. This <code class="language-plaintext highlighter-rouge">init</code> function performs a call to <code class="language-plaintext highlighter-rouge">syscall_GetCommandLine</code> and that call ends up being a call to the Windows <a href="https://learn.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-getcommandlinew">GetCommandLineW</a> function.</p><p>What <code class="language-plaintext highlighter-rouge">gftrace</code> does is use <code class="language-plaintext highlighter-rouge">GetCommandLineW</code> as a kind of sentinel. It waits for this call to happen and only after that it starts to trace the API calls according to the user filters. By doing so it avoids resolving and printing all the API calls performed by the runtime package, making the tool output very clean and focused on the <code class="language-plaintext highlighter-rouge">main</code> package calls.</p><h3 id="some-other-interesting-aspects"><span class="mr-2">Some other interesting aspects</span><a href="#some-other-interesting-aspects" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>After spending some time playing with the tool I noticed some interesting things regarding the Windows API calls Go uses:</p><ol><li>It always rely on the unicode version of the Windows functions (CreateFileW, CreateProcessW, GetComputerNameExW, etc).<li>Due to the Go design some calls would be very noisy by default before the call to the desired function. As an example, when you execute a command via <code class="language-plaintext highlighter-rouge">cmd</code> in Go it would first perform several calls to <code class="language-plaintext highlighter-rouge">CreateFileW</code> before a call to <code class="language-plaintext highlighter-rouge">CreateProcessW</code>.<li>Memory and thread management functions such as <code class="language-plaintext highlighter-rouge">VirtualAlloc</code>, <code class="language-plaintext highlighter-rouge">GetThreadContext</code>, <code class="language-plaintext highlighter-rouge">CreateThread</code>, etc are usually used several times by the runtime and probably will not be used by the <code class="language-plaintext highlighter-rouge">main</code> package.</ol><p>I created a config file in <code class="language-plaintext highlighter-rouge">gftrace</code> project that considers it all. It does not includes the regular functions used by the runtime and also only filters by the unicode versions. For item 3 it’s up to the user to figure what function is more interesting for each scenario.</p><h3 id="why-gftrace-might-be-a-good-option"><span class="mr-2">Why gftrace might be a good option?</span><a href="#why-gftrace-might-be-a-good-option" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Of course it would always be a matter of preference, there’s some amazing tools available that can handle API tracing, but here’s some reasons I believe <code class="language-plaintext highlighter-rouge">gftrace</code> is also a nice option:</p><ol><li>Golang binaries might be a pain to reverse sometimes so this tool can be very handy for fast malware triage for example since it’s very easy and fast to use.<li>It performs a single hook in the runtime package without touching any Windows API function and does not require function prototypes. Those things make the tool very portable, fast and reliable.<li>It’s designed for Go applications specifically so it handles all the runtime nuances such as the runtime calls noise before the calls from the <code class="language-plaintext highlighter-rouge">main</code> package.</ol><p>If you want to check how to configure and use the tool make sure you check the <a href="https://github.com/leandrofroes/gftrace">project page</a>!</p><h2 id="final-thoughts"><span class="mr-2">Final thoughts</span><a href="#final-thoughts" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>I need to say I had a lot of fun in this research and eventually I still play with it all. It made me learn A LOT about how Golang Internals work. There’s a few other details I didn’t put here in this blogpost but I might update it in the future.</p><p>Regarding the source code, I’ve tried to put as much comments as possible and also make it very clean in order to be easy and nice to people use to study, etc. The tool is still under development and probably has a lot of things to be improved so please threat it as a PoC code for now.</p><p>Anyway, I hope you enjoyed the reading.</p><p>Happy reversing!</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/reverse-engineering/'>Reverse-Engineering</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/windows/" class="post-tag no-text-decoration" >Windows</a> <a href="/tags/golang/" class="post-tag no-text-decoration" >Golang</a> <a href="/tags/reverse-engineering/" class="post-tag no-text-decoration" >Reverse Engineering</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=An%20in-depth%20look%20at%20the%20Golang%20Windows%20calls%20-%20Leandro's%20blog&url=https%3A%2F%2Fleandrofroes.github.io%2Fposts%2FAn-in-depth-look-at-Golang-Windows-calls%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=An%20in-depth%20look%20at%20the%20Golang%20Windows%20calls%20-%20Leandro's%20blog&u=https%3A%2F%2Fleandrofroes.github.io%2Fposts%2FAn-in-depth-look-at-Golang-Windows-calls%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fleandrofroes.github.io%2Fposts%2FAn-in-depth-look-at-Golang-Windows-calls%2F&text=An%20in-depth%20look%20at%20the%20Golang%20Windows%20calls%20-%20Leandro's%20blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Reversing-a-recent-IcedID-Crypter/">Reversing a recent IcedID Crypter</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/reverse-engineering/">Reverse Engineering</a> <a class="post-tag" href="/tags/windows/">Windows</a> <a class="post-tag" href="/tags/golang/">Golang</a> <a class="post-tag" href="/tags/malware-analysis/">Malware Analysis</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Reversing-a-recent-IcedID-Crypter/"><div class="card-body"> <em class="small" data-ts="1688428800" data-df="ll" > Jul 4, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Reversing a recent IcedID Crypter</h3><div class="text-muted small"><p> Intro Last week a friend shared a sample of a recent IcedID malware using an interesting Crypter and although there’s nothing new regarding the final payload (it’s just the classical IcedID Lite...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"><div class="btn btn-outline-primary disabled" prompt="Older"><p>-</p></div><a href="/posts/Reversing-a-recent-IcedID-Crypter/" class="btn btn-outline-primary" prompt="Newer"><p>Reversing a recent IcedID Crypter</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/reverse-engineering/">Reverse Engineering</a> <a class="post-tag" href="/tags/windows/">Windows</a> <a class="post-tag" href="/tags/golang/">Golang</a> <a class="post-tag" href="/tags/malware-analysis/">Malware Analysis</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/leandrofr0es">Leandro</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0">Using the <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> theme <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a>.</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1.11.6/dayjs.min.js,npm/dayjs@1.11.6/locale/en.min.js,npm/dayjs@1.11.6/plugin/relativeTime.min.js,npm/dayjs@1.11.6/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
