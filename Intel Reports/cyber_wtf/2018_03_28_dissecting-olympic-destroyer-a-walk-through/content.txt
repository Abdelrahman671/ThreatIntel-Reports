<!DOCTYPE html>
<html lang="pt">

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Dissecting Olympic Destroyer â a walk-through | cyber.wtf</title>

    <!-- Bootstrap -->
    <link rel="stylesheet" href="/css/bootstrap-3.3.6/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/bootstrap-icons-1.5.0/bootstrap-icons.min.css">

    <link rel="shortcut icon" href="/images/favicon.png">

    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml"> 

</head>

    <body>
      <div class="container">

        <header class="row">
  <div class="col-lg-8 col-lg-offset-2">
    <a class="logo-link" href="/">
      <img src="/images/cyber-chrome_slim.png">
    </a>
  </div>
</header>

<div class="row">
  <div class="col-lg-8 col-lg-offset-2">
    <div class="menu">
      <ul>
          <li><a href="/">Home</a></li>
          |
          <li><a href="/category" title="Category List">Category List</a>
          <!--<li><a href="/casts">*casts</a></li>-->
          |
          <li><a href="/wtf">WTF?</a></li>
          |
          <li class="rss_feed"><a href="/feed.xml" title="Atom Feed Posts"><i class="bi bi-rss"></i></a></li>
      </ul>
    </div>
  </div>
</div>



        <div class="row">
          <div class="col-lg-8 col-lg-offset-2">
            <main>
            <div class="post">

  <header class="post-header">
    <h1>Dissecting Olympic Destroyer â a walk-through</h1>
  </header>

  <article class="post-content">
  <div class="post">

  <header class="post-header">
    <div class="meta">
        Mar 28, 2018
         â¢
            <div class="author-container">
                <span class="author-name">Robert Michel</span>
                
                <div class="author-info active">
                  <img src="/images/authors/NA.png" alt="Robert Michel's Bild">
                  <div class="author-text">
                    <span><h4>Robert Michel</h4> </span>
                    <p>Active since: 2011</p>
                    <p style="margin-top: 0.5em"></p>
                  </div>
                </div>
                
            </div>
          
        
        
        â¢ 
    </div>
  </header>

  <article class="post-content">
  <h1 id="introduction">Introduction</h1>

<p>After a destructive cyber attack had hit this yearâs olympics, the malware was quickly dubbed <em>Olympic Destroyer.</em>Â  <a href="https://blog.talosintelligence.com/2018/02/olympic-destroyer.html">Talos were fast to provide initial coverage</a>. A malware explicitly designed to sabotage the computer systems of the Olympic opening ceremony sounded very interesting, but other duties were more pressing at that time, so analysis for pure curiosity had to wait.Â  A few weeks later I had some free evenings on my hands and decided to combine a few interests of mine: Listening to music, consuming high quality whisky and analyzing malware â regrettably one of those things is frowned upon at work, and itâs not malware analysis. ;)</p>

<p>I had most of the binaries reversed and already written up a few pages, when <a href="https://securelist.com/olympicdestroyer-is-here-to-trick-the-industry/84295/">Kaspersky released an article</a> with some more details than previously publicly known. Having finished my work and focusing on the technical aspects of Olympic Destroyer, I think I can add several technical details about the malware. In the following expect plain and straight-forward binary analysis and reverse engineering in the form of a walk-through.</p>

<p>Olympic Destroyer comes in two types. The first one is a little bit simpler. It was discovered by Talos, who published it in their comprehensive blog post. One example of this type has the Sha256 of <code class="language-plaintext highlighter-rouge">edb1ff2521fb4bf748111f92786d260d40407a2e8463dcd24bb09f908ee13eb9</code>.</p>

<p>The second type of the binary has, to the best of my knowledge, not yet been explicitly named, but it was implicitly analyzed by Kaspersky in their also very comprehensive blog post. One example has the Sha256 sum of <code class="language-plaintext highlighter-rouge">e8349cfcc422310c259688b0226cb14f5196a6daad77b622405282aeac89ab06</code>.</p>

<p>In the following blog post I will mainly describe the first type of Olympic Destroyer. At the end I will discuss the main differences between the two types, which revolve around the usage or non-usage of the well-known tool PsExec.</p>

<h1 id="the-orchestrator">The Orchestrator</h1>

<p>In this part we will cover the innermost functionality of the Olympic Destroyer. As orientation point we will use the <em>main()</em> function, from where on we will cover the single function calls step by step. Luckily Olympic Destroyer runs single threaded â except for the spreading functionality â which makes it easier to follow the execution one call after another.</p>

<p>The analyzed orchestrator has a Sha256 of <code class="language-plaintext highlighter-rouge">edb1ff2521fb4bf748111f92786d260d40407a2e8463dcd24bb09f908ee13eb9</code> and is 0x1C6800 (~1.7MB) in size. A lot of this size is made up of five resources, whose role will be explained later on. IDA detects 756 functions of which not even ten were automatically identified by IDA FLIRT in version 6.9, which made the analysis more time consuming. IDA version 6.95 seems to have a newer FLIRT database and a lot of functions are identified automatically, as I realized way too late.</p>

<h2 id="configuration--or-not">Configuration â or not</h2>

<p>The <em>main()</em> function is located at <code class="language-plaintext highlighter-rouge">0x004071E0</code>. It creates a structure on the local stack, which I called âconfigâ when starting to reverse the binary. Over the time I discovered that it is merely a state or a singleton data container - nonetheless I kept the name âconfigâ for reasons of consistency. This structure is carried throughout many of the subsequent function calls, most of the time in the form of <em>thiscalls</em> in the <em>ecx</em> register. You can find the whole structure in the appendix section below.</p>

<p>It contains different type of data, like simple integers, which for example describe the bitness of the OS with either the value 32 or 64 by dynamically resolving and calling <em>IsWow64Process</em>. Yes, the author(s) actually use full integers instead of encoding this information in a simple bit Â¯\_(ã)_/Â¯.</p>

<figure class="figure-posts" style="width: 65%; display:block; margin: auto; margin-bottom: 1em;">
  <div class="image-container" id="/images/posts/2018/03/1.png"> 
    <a href="#img/images/posts/2018/03/1.png">
      <img src="/images/posts/2018/03/1.png" alt="" class="img-responsive" />
      </a>
      <a href="#/images/posts/2018/03/1.png" class="lightbox" id="img/images/posts/2018/03/1.png">
        <span style="background-image: url(/images/posts/2018/03/1.png)"></span>
      </a>
      <figcaption class="figcaption-posts">Figure 1: Detecting the bitness of the system</figcaption>
    </div>
  </figure>

<p>More interesting are probably the different paths of files dropped to the filesystem during runtime, which are also stored in this structure. I will describe them when writing about the resources.</p>

<p>Additionally, we find some security related variables, like the security token information of the current user, which is gathered by calling <em>GetTokenInformation(TokenUser)</em> and comparing the result against âS-1-5-18â (Local System), âS-1-5-19â (NT Authority Local Service), and âS-1-5-20â (NT Authority Network Service).</p>

<p>Most important is probably the vector of objects, which contains domain names and domain credentials, that are used to spread laterally through the network. More about this later on when I will cover the lateral movement.</p>

<p>After the config structure is initialized in <code class="language-plaintext highlighter-rouge">0x00406390</code> by nulling its members, it is dynamically filled with its respective values in the subsequent call to 0x00406500, where most of the previously mentioned values and information is generated. From then on, the config is ready for use and most values are only read instead of written â except for the file paths, which are generated more or less randomly on the fly when used and of course the credential vector, which gets expanded a few calls later.</p>

<h2 id="magical-code-injections">Magical Code Injections</h2>

<p>With a call to <code class="language-plaintext highlighter-rouge">0x004066C0</code> Olympic Destroyer checks for the existence of two files, which it uses to mark and avoid multiple runs of itself:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">C:\&lt;MD5(Computer Name)&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">%SystemDrive%\Users\Public\&lt;MD5(Computer Name\User Name)&gt;</code></li>
</ol>

<p>If one of those files is found, the function which I called âselfDeleteInjectBinaryâ at <code class="language-plaintext highlighter-rouge">0x00405DD0</code> is executed. Most of this function is already described in Endgameâs blogpost at <a href="https://www.endgame.com/blog/technical-blog/stopping-olympic-destroyer-new-process-injection-insights">https://www.endgame.com/blog/technical-blog/stopping-olympic-destroyer-new-process-injection-insights</a>, but somehow they either misinterpreted the feature, or missed the main point of the shellcode. Iâm not sure what their intention was, but their blog post somehow does not say what the shellcode actually does Â¯\_(ã)_/Â¯.</p>

<p>Olympic Destroyer starts an invisible ânotepad.exeâ by using the flags <em>CREATE_NO_WINDOW</em> in <em>dwCreationFlags</em> as well as <em>STARTF_USESHOWWINDOW</em> in <em>StartupInfo.dwFlags</em> and <em>SW_HIDE</em> in <em>StartupInfo.wShowWindow</em> before calling <em>CreateProcessW.</em></p>

<figure class="figure-posts" style="width: 100%; display:block; margin: auto; margin-bottom: 1em;">
  <div class="image-container" id="/images/posts/2018/03/2.png"> 
    <a href="#img/images/posts/2018/03/2.png">
      <img src="/images/posts/2018/03/2.png" alt="" class="img-responsive" />
      </a>
      <a href="#/images/posts/2018/03/2.png" class="lightbox" id="img/images/posts/2018/03/2.png">
        <span style="background-image: url(/images/posts/2018/03/2.png)"></span>
      </a>
      <figcaption class="figcaption-posts">Figure 2: Starting an invisible Notepad</figcaption>
    </div>
  </figure>

<p>Then it injects two blocks of data/code into the running notepad by calling <em>VirtualAllocEx</em> and <em>WriteProcessMemory</em>. The first block contains addresses of APIs and the path to the current executable, the second one is a shellcode which uses the addresses of the first block. By calling <em>CreateRemoteThread</em> the execution of the shellcode within notepad is started.</p>

<p>After this injection, the main process exits by calling <em>ExitProcess</em> while the execution of the injected thread runs in the process space of notepad. But all the shellcode does, is a simple delayed self-deletion mechanism:
First it sleeps a configurable number of seconds. In our case it is five seconds. After that, the shellcode looks for the original path of Olympic Destroyer, which was passed by the first injected memory block by checking <em>GetFileAttributesW</em> != <em>INVALID_FILE_ATTRIBUTES</em>. Then it tries to open the file with <em>CreateFileW</em>, gets the file size by calling <em>GetFileSize</em> and then loops over the file size and calls <em>WriteFile</em> with always one zero byte until the whole file is overwritten with zeros. After closing the file handle, the file is finally deleted with <em>DeleteFile</em> and the shellcode calls <em>ExitProcess</em> to end its execution.</p>

<p>To sum it up: The code injection is simply a nulling and deletion mechanism to hide the traces of the main binary.</p>

<h2 id="setting-the-markers-for-self-deletion">Setting the markers for self-deletion</h2>

<p>The two files, which mark multiple runs of Olympic Destroyer, mentioned in the previous paragraph, are then created:</p>

<figure class="figure-posts" style="width: 50%; display:block; margin: auto; margin-bottom: 1em;">
  <div class="image-container" id="/images/posts/2018/03/3.png"> 
    <a href="#img/images/posts/2018/03/3.png">
      <img src="/images/posts/2018/03/3.png" alt="" class="img-responsive" />
      </a>
      <a href="#/images/posts/2018/03/3.png" class="lightbox" id="img/images/posts/2018/03/3.png">
        <span style="background-image: url(/images/posts/2018/03/3.png)"></span>
      </a>
      <figcaption class="figcaption-posts">Figure 3: Create infection markers</figcaption>
    </div>
  </figure>

<p>Depending on the rights under which the binary is running, the markers in <code class="language-plaintext highlighter-rouge">C:\</code> and <code class="language-plaintext highlighter-rouge">%COMMON_DOCUMENTS%</code> are created. From then on, a second run of Olympic Destroyer will wipe the original executable.</p>

<h2 id="stealing-credentials">Stealing credentials</h2>

<p>In the following call to <code class="language-plaintext highlighter-rouge">0x004065A0</code>, we will dive into a very important feature of Olympic Destroyer: The stealing of credentials from the current system, which are later used for lateral movement.</p>

<p>Olympic Destroyer contains five resources of type âBINâ. All of those resources are encrypted with AES. The calculation of the key is hard coded in the binary and can be described as a trivial MD5 hash of the string â123â. This hash is then concatenated twice in order to reach a key length of 256 bits for the AES algorithm. The evaluation of whether those shenanigans of symmetric cryptography with a hard coded key makes sense is left as an exercise for the reader. :)</p>

<p>When stealing the credentials, at first the resource 101 is decrypted, written to a more or less randomly generated filename in %tmp%. âMore or lessâ because the algorithm is based on calls to <em>GetTickCount()</em> with <em>Sleeps</em> in between the calls.</p>

<p>After writing the decrypted resource to disk, a proper random string is generated by calling <em>CoCreateGuid</em>. The <em>GUID</em> is then used as the name for a named pipe in the form <code class="language-plaintext highlighter-rouge">\\.\pipe\</code>, which is created by calling <em>CreateNamedPipeW</em> and then used as inter process communication mechanism with the process, which is then started from the file written to %tmp%.</p>

<h3 id="resource-101">Resource 101</h3>

<p>When resource 101 is started, it also gets the name of the pipe to communicate with its parent process as well as the password â123â as arguments. The main task of resource 101 is to use the password to decrypt and execute another resource of type âBMPâ embedded in the file of resource 101 and send a buffer with stolen credentials to its parent process. So, itâs a simple loader which transfers a buffer via IPC.</p>

<p>The BMP resource is a DLL called âBrowserPwd.dllâ. This DLL is not written to disk but parsed and loaded in memory. It seems that its only purpose is to steal credentials from the browsers Internet Explorer, Firefox and Chrome. In order to work with Firefox and Chrome, an SQLite library is compiled into the DLL, which makes up most of the DLLâs code.</p>

<ul>
  <li>For Internet Explorer it uses COM to iterate over the browsers history and then reads all autocomplete passwords from the registry in <code class="language-plaintext highlighter-rouge">Software\Microsoft\Internet Explorer\IntelliForms\Storage2</code> and decrypts them using the WinAPI <em>CryptUnprotectData</em>.</li>
  <li>For Firefox, the credentials are stolen from <em>sqlite _and</em> logins.json_. The <em>nss3.dll</em> from Firefox is used to decrypt the protected passwords.</li>
  <li>For Chrome, the userâs database in <code class="language-plaintext highlighter-rouge">[â¦]\Application Data\Google\Chrome\User Data\Default\Login Data</code> is copied temporarily and then the credentials are read and decrypted by calling the WinAPI <em>CryptUnprotectData</em>.</li>
</ul>

<p>All stolen credentials are returned in a buffer which uses a special style of separating the single items. This buffer is constructed within the DLL and returned to its original loader, which is resource 101:</p>

<figure class="figure-posts" style="width: 90%; display:block; margin: auto; margin-bottom: 1em;">
  <div class="image-container" id="/images/posts/2018/03/4.png"> 
    <a href="#img/images/posts/2018/03/4.png">
      <img src="/images/posts/2018/03/4.png" alt="" class="img-responsive" />
      </a>
      <a href="#/images/posts/2018/03/4.png" class="lightbox" id="img/images/posts/2018/03/4.png">
        <span style="background-image: url(/images/posts/2018/03/4.png)"></span>
      </a>
      <figcaption class="figcaption-posts">Figure 4: Stolen credentials are formatted in a certain way</figcaption>
    </div>
  </figure>

<p>This buffer is then sent from the loader via the named pipe to its parent process:</p>

<figure class="figure-posts" style="width: 90%; display:block; margin: auto; margin-bottom: 1em;">
  <div class="image-container" id="/images/posts/2018/03/5.png"> 
    <a href="#img/images/posts/2018/03/5.png">
      <img src="/images/posts/2018/03/5.png" alt="" class="img-responsive" />
      </a>
      <a href="#/images/posts/2018/03/5.png" class="lightbox" id="img/images/posts/2018/03/5.png">
        <span style="background-image: url(/images/posts/2018/03/5.png)"></span>
      </a>
      <figcaption class="figcaption-posts">Figure 5: The loader of resource 101 uses the named pipe to transfer the buffer with the stolen credentials</figcaption>
    </div>
  </figure>

<h3 id="resource-102-and-103">Resource 102 and 103</h3>

<p>After resource 101 was executed, a second attempt to steal credentials is started, in case the current process could acquire debug privileges during initialization of the config object. In case it has those right, depending on the architecture of the operating system, either resource 102 (x86) or 103 (x64) is started. Both executables have the same logic as resource 101 â decrypt and load a DLL in memory, execute the DLL and return its buffer via IPC â Â only the payload in form of their internal DLL, the resource of type âBMPâ, is different. Everything else stays the same.</p>

<p>So, the question is, what are the DLLs in the resources of resource 102 and 103? For 103, the x64 version, I did not look into it in order to save some time, but I assume itâs the very same payload as in 102, only for x64 systems. For 102, which is an x86 binary, the loaded internal DLL seems to be a custom version of the well-known penetration testing tool Mimikatz, which, besides other nifty features, can dump credentials from a Windows system. I did not spend too much time in the analysis of this DLL, but a swift look (as in â1-2 hoursâ), compared with several matching functions, structures and strings from the original code of Mimikatz are strong indicators that this DLL has actually Mimikatzâ credential dumping capability. This assumption was also verified by dynamic analysis, where the binary was actually stealing the credentials of my analysis machine. Additionally, the author(s) of Olympic Destroyer named this DLL âkiwi86.dllâ, which is a reference to the nickname âgentilkiwiâ, who is the author of Mimikatz.</p>

<p>After receiving the stolen credentials via the named pipes, Olympic Destroyer parses the received buffers and saves the credentials in its config structure. Then it returns its control flow to the main function.</p>

<h2 id="saving-the-credentials--or-how-to-build-a-network-worm">Saving the Credentials â Or how to build a network worm</h2>

<p>Back in the main function, right after stealing credentials from browsers and by the power of Mimikatz, Olympic Destroyer creates a copy of itself in the %tmp% folder in <code class="language-plaintext highlighter-rouge">0x00404040</code>. If this copy succeeds, the copied file is modified in the next function call toÂ  <code class="language-plaintext highlighter-rouge">0x00401FB0</code>. Here the whole file is read into a buffer in the processâ memory. Then this buffer is searched for the byte marker <code class="language-plaintext highlighter-rouge">9E EC 87 D4 89 16 42 09 55 E2 74 E4 79 0B 42 4C</code>. Those bytes mark the beginning of the serialized credentials vector as an array:</p>

<figure class="figure-posts" style="width: 70%; display:block; margin: auto; margin-bottom: 1em;">
  <div class="image-container" id="/images/posts/2018/03/6.png"> 
    <a href="#img/images/posts/2018/03/6.png">
      <img src="/images/posts/2018/03/6.png" alt="" class="img-responsive" />
      </a>
      <a href="#/images/posts/2018/03/6.png" class="lightbox" id="img/images/posts/2018/03/6.png">
        <span style="background-image: url(/images/posts/2018/03/6.png)"></span>
      </a>
      <figcaption class="figcaption-posts">Figure 6: Hex dump of Olympic Destroyer</figcaption>
    </div>
  </figure>

<p>I tried to mark the single elements of the array in different colors to describe them, but it turns out my MS Paint skills are really bad. So, youâll just get two pseudo structs defining what you can see around the red marked bytes:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">credentials</span>
<span class="p">{</span>
  <span class="n">byte</span> <span class="n">marker</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
  <span class="n">WORD</span> <span class="n">numberOfElements</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">CREDENTIAL</span> <span class="n">credentialArray</span><span class="p">[</span><span class="n">numberOfElements</span><span class="p">];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">CREDENTIAL</span>
<span class="p">{</span>
  <span class="n">WORD</span> <span class="n">lengthOfUsername</span><span class="p">;</span>
  <span class="n">WORD</span> <span class="n">lengthOfPassword</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">userName</span><span class="p">[</span><span class="n">lengthOfUsername</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">password</span><span class="p">[</span><span class="n">lengthOfPassword</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In our case there are 0x2C stolen credentials. The first block of credentials has a <code class="language-plaintext highlighter-rouge">username\domain</code> string of 0x1B bytes length and has a password of 0x0C bytes length. Then the second block of credentials follows, and so on.</p>

<p>Once Olympic Destroyer has located the array in its buffer, the array is written over with the serialized version of the current credentials vector of the config object. Then the executable modified in memory is written back to disk in the %tmp% directory.</p>

<p>In other words: The list of credentials, which was present when Olympic Destroyer was executed first, is now updated with all credentials stolen during runtime.</p>

<h2 id="resource-104-and-105--preparing-the-next-steps">Resource 104 and 105 â Preparing the next steps</h2>

<p>After updating a copy of itself with all stolen credentials, the execution flow returns to the main function where two consecutive calls to 0x00403F30 prepare the network spreading algorithm and the destructive parts. Both calls take a resource name as a first parameter for input and return a string with a path to a file. In this function Olympic Destroyer takes the same decryption algorithm as previously described and decrypts the resources 104 and 105. Both files are not yet executed but written to disk with a random filename in the %tmp% folder.</p>

<p>Resource 104 is a simple copy of the well-known tool âPsExecâ which can be used to execute commands and files on remote computers. It will come into play when I describe the lateral movement.</p>

<p>Resource 105 though is the actual âDestroyerâ of Olympic Destroyer.</p>

<h2 id="starting-the-destroyer--fulfilling-the-real-purpose">Starting the Destroyer â Fulfilling the real purpose</h2>

<p>After writing resource 104 and 105 to %tmp%, the function at <code class="language-plaintext highlighter-rouge">0x00404220</code> is called with the path to resource 105 as an argument. Here nothing magical happens. The file from the resource is simply executed without a visible window/console and the function returns:</p>

<figure class="figure-posts" style="width: 90%; display:block; margin: auto; margin-bottom: 1em;">
  <div class="image-container" id="/images/posts/2018/03/7.png"> 
    <a href="#img/images/posts/2018/03/7.png">
      <img src="/images/posts/2018/03/7.png" alt="" class="img-responsive" />
      </a>
      <a href="#/images/posts/2018/03/7.png" class="lightbox" id="img/images/posts/2018/03/7.png">
        <span style="background-image: url(/images/posts/2018/03/7.png)"></span>
      </a>
      <figcaption class="figcaption-posts">Figure 7: Starting an invisible process</figcaption>
    </div>
  </figure>

<p>From here on the destroyer from resource 105 is running. It has its own chapter later on.</p>

<h2 id="lateral-movement">Lateral Movement</h2>

<p>Once the destroyer part of Olympic Destroyer has been started in its own process, the main function calls <code class="language-plaintext highlighter-rouge">0x00406ED0</code> to start the network spreading routine.</p>

<p>At first two sanity checks are made by calling <em>GetFileAttributesA</em> in order to ensure that PsExec from resource 104 and the copy of Olympic Destroyer with the updated credentials list in the %tmp% folder exist. If both checks pass, a list of potential targets within the local network is built:
With a call to <code class="language-plaintext highlighter-rouge">0x00406DD0</code> Olympic Destroyer utilizes the <em>GetIpNetTable</em> API to enumerate all IPv4 addresses of the current ARP cache, thus getting all IP addresses the local machine had access to - considering ARP cache timeouts which can remove older entries, of course.</p>

<p>The list of IPv4 addresses is then passed to the function at <code class="language-plaintext highlighter-rouge">0x004054E0</code>, along with a pointer to the config object as well as the path to PsExec and the updated copy of Olympic Destroyer in the %tmp% folder. I think it is noteworthy that passing both paths to the files in %tmp% is completely superfluous, since they are already a part of the config object, which is also passed as argument.</p>

<p>The function at <code class="language-plaintext highlighter-rouge">0x004054E0</code> is the heart of the spreading algorithm:
First, it reads the updated copy of Olympic Destroyer into memory. Then it initializes a new structure with all information passed as arguments as well as some additional information, which is somehow not really used later on. After that it calls <code class="language-plaintext highlighter-rouge">0x00407680</code>, where the spreading in the network begins:
For each IP address, a new thread is spawned, which starts at <code class="language-plaintext highlighter-rouge">0x00407D40</code>. This thread then loops over all credentials of the config object, trying to use WMI via COM objects in order to infect remote computers:</p>

<figure class="figure-posts" style="width: 100%; display:block; margin: auto; margin-bottom: 1em;">
  <div class="image-container" id="/images/posts/2018/03/8.png"> 
    <a href="#img/images/posts/2018/03/8.png">
      <img src="/images/posts/2018/03/8.png" alt="" class="img-responsive" />
      </a>
      <a href="#/images/posts/2018/03/8.png" class="lightbox" id="img/images/posts/2018/03/8.png">
        <span style="background-image: url(/images/posts/2018/03/8.png)"></span>
      </a>
      <figcaption class="figcaption-posts">Figure 8: Remote command execution</figcaption>
    </div>
  </figure>

<p>The first important function for that is at <code class="language-plaintext highlighter-rouge">0x004045D0</code> (called <em>executeRemoteCmdline</em>), which gets one IP and one pair of credentials as input, as well as one command line to execute on the target machine - <em>outPtr</em> is used to transport the return value. The whole function is a mess of COM calls, but Iâll try to explain their meaning anyways. Words in italic are quotes from the binary:
This function creates a COM object of CLSID <code class="language-plaintext highlighter-rouge">{4590F811-1D3A-11D0-891F-00AA004B2E24}</code> and IID <code class="language-plaintext highlighter-rouge">{dc12a687-737f-11cf-884d-00aa004b2e24}</code> in order to remotely execute WMI commands. Then a connection to <code class="language-plaintext highlighter-rouge">\\\root\CIMV2</code> is created and the credentials are applied by calling <em>CoSetProxyBlanket</em>. With the class <code class="language-plaintext highlighter-rouge">Win32_Process</code> and the function <em>Create</em> a <em>Commandline</em> is executed on the remote computer. With <code class="language-plaintext highlighter-rouge">Select * From Win32_ProcessStopTrace</code> the event for the termination of the remote process is registered in order to read its <em>ExitStatus</em> code afterwards.
The executed command line is rather simple:</p>

<div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"cmd.exe /c (ping 0.0.0.0 &gt; nul) &amp;&amp; if exist </span><span class="nv">%programdata%</span><span class="s2">\\evtchk.txt (exit 5) else ( type nul &gt; </span><span class="nv">%programdata%</span><span class="s2">\\evtchk.txt)"</span>
</code></pre></div></div>

<p>With the execution of <em>ping</em> a short delay is introduced, since the execution waits for <em>ping</em> to fail four times to ping the address <em>0.0.0.0</em>. Then, in case the file <code class="language-plaintext highlighter-rouge">%programdata%\evtchk.txt</code> exists on the target system, the execution returns the exit code five. Otherwise said file is created and the execution finishes with its standard error code of zero.</p>

<p>The return value of the remote command line is then read and is returned via <em>outPtr</em> as a function argument from 0x004045D0. Interestingly the <em>outPtr</em> is only written to in case of a successful remote execution. All error cases leave the <em>outPtr</em> untouched. As the memory address of the target of <em>outPtr</em> is initialized with zeros, the caller of <code class="language-plaintext highlighter-rouge">0x004045D0</code> is unable to distinguish between an error during the remote code execution (e.g. because of false credentials or an unavailable IP) and the successful write of <code class="language-plaintext highlighter-rouge">%programdata%\evtchk.txt</code> file on the remote machine. Â¯\_(ã)_/Â¯</p>

<p>At <code class="language-plaintext highlighter-rouge">0x00404C30</code> the second interesting function (called <em>writeFileToRemoteRegistryAndExecuteCommandlineVbs)</em> is located. It takes the target IP address as well as the credentials as input. It is very similar to the function <code class="language-plaintext highlighter-rouge">0x004045D0</code> described previously. The main difference is that by using the <em>StdRegProv</em> class and the function <em>SetBinaryValue</em> a registry key in <em>HKEY_CURRENT_USER\Environment</em> with the name <em>Data</em> is created on the remote computer. The value of the registry key an executable file, but interestingly it is not the copy of Olympic Destroyer with the updated credential list in %tmp%, as I would have expected, but it is the binary which is currently executed and thus does not contain any of the current systemâs credentials:</p>

<figure class="figure-posts" style="width: 100%; display:block; margin: auto; margin-bottom: 1em;">
  <div class="image-container" id="/images/posts/2018/03/9.png"> 
    <a href="#img/images/posts/2018/03/9.png">
      <img src="/images/posts/2018/03/9.png" alt="" class="img-responsive" />
      </a>
      <a href="#/images/posts/2018/03/9.png" class="lightbox" id="img/images/posts/2018/03/9.png">
        <span style="background-image: url(/images/posts/2018/03/9.png)"></span>
      </a>
      <figcaption class="figcaption-posts">Figure 9: The remote spreading algorithm spreads the wrong binary</figcaption>
    </div>
  </figure>

<p>After the binary is written to the remote registry, the function at <code class="language-plaintext highlighter-rouge">0x00404C30</code> calls the function at <code class="language-plaintext highlighter-rouge">0x004044B0</code>. Here the function <em>Create</em> of the COM class <em>Win32_Process</em> is used to remotely execute another command line. This command line is already known from the Talos blog post. For readability I pretty-printed the commands:</p>

<div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cmd.exe</span> <span class="na">/c 
</span><span class="o">(</span>
<span class="nb">echo</span> <span class="kd">strPath</span> <span class="o">=</span> <span class="kd">Wscript</span>.ScriptFullName 
<span class="o">&amp;</span> <span class="nb">echo</span>.Set <span class="kd">FSO</span> <span class="o">=</span> <span class="kd">CreateObject</span><span class="se">^(</span>\<span class="s2">"Scripting.FileSystemObject\"</span><span class="se">^)</span> 
<span class="o">&amp;</span> <span class="nb">echo</span>.FSO.DeleteFile <span class="kd">strPath</span><span class="o">,</span> <span class="m">1</span> 
<span class="o">&amp;</span> <span class="nb">echo</span>.Set <span class="kd">oReg</span> <span class="o">=</span> <span class="kd">GetObject</span><span class="se">^(</span>\<span class="s2">"winmgmts:{impersonationLevel=impersonate}</span><span class="err">!</span><span class="s2">\\\\.\\root\\default:StdRegProv\"</span><span class="se">^)</span> 
<span class="o">&amp;</span> <span class="nb">echo</span>.oReg.GetBinaryValue <span class="se">^&amp;</span><span class="kd">H80000001</span><span class="o">,</span> \<span class="s2">"Environment\"</span><span class="o">,</span> \<span class="s2">"Data\"</span><span class="o">,</span> <span class="kd">arrBytes</span> 
<span class="o">&amp;</span> <span class="nb">echo</span>.Set <span class="kd">writer</span> <span class="o">=</span> <span class="kd">FSO</span>.OpenTextFile<span class="se">^(</span>\<span class="s2">"</span><span class="nv">%ProgramData%</span><span class="s2">\\</span><span class="nv">%COMPUTERNAME%</span><span class="s2">.exe\"</span><span class="o">,</span> <span class="m">2</span><span class="o">,</span> <span class="kd">True</span><span class="se">^)</span> 
<span class="o">&amp;</span> <span class="nb">echo</span>.For <span class="kd">i</span> <span class="o">=</span> <span class="kd">LBound</span><span class="se">^(</span><span class="kd">arrBytes</span><span class="se">^)</span> <span class="kd">to</span> <span class="kd">UBound</span><span class="se">^(</span><span class="kd">arrBytes</span><span class="se">^)</span> 
<span class="o">&amp;</span> <span class="nb">echo</span>.s <span class="o">=</span> <span class="kd">s</span> <span class="se">^&amp;</span> <span class="kd">Chr</span><span class="se">^(</span><span class="kd">arrBytes</span><span class="se">^(</span><span class="kd">i</span><span class="se">^)^)</span> 
<span class="o">&amp;</span> <span class="nb">echo</span>.Next 
<span class="o">&amp;</span> <span class="nb">echo</span>.writer.write <span class="kd">s</span> 
<span class="o">&amp;</span> <span class="nb">echo</span>.writer.close
<span class="o">)</span> <span class="o">&gt;</span> <span class="nv">%ProgramData%</span>\\_wfrcmd.vbs <span class="o">&amp;&amp;</span> <span class="nb">cscript.exe</span> <span class="nv">%ProgramData%</span>\\_wfrcmd.vbs <span class="o">&amp;&amp;</span> <span class="nv">%ProgramData%</span>\\<span class="nv">%COMPUTERNAME%</span>.exe
</code></pre></div></div>

<p>The first set of echos outputs parts of a VB script, which are then written to <code class="language-plaintext highlighter-rouge">%ProgramData%\_wfrcmd.vbs</code> by using the redirect operator â&gt;â. Afterwards this file is executed via the <em>cscript</em> interpreter before the executable <code class="language-plaintext highlighter-rouge">%ProgramData%\%COMPUTERNAME%.exe</code> is executed. This executable is created during the runtime of the newly created VB script, which basically just reads the executable stored in <code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER\Environment\Data</code> and writes it to <code class="language-plaintext highlighter-rouge">%ProgramData%\%COMPUTERNAME%.exe</code>.</p>

<p>Back in <code class="language-plaintext highlighter-rouge">0x00405170</code>, the function at <code class="language-plaintext highlighter-rouge">0x004045D0</code> (<em>executeRemoteCmdline</em>) is called a second time. This time it removes the file <code class="language-plaintext highlighter-rouge">%programdata%\evtchk.txt</code>, which was previously checked or created on the remote computer by executing the command line <code class="language-plaintext highlighter-rouge">del %programdata%\evtchk.txt</code>.</p>

<p>To state the obvious, in case it got lost in all the text: <code class="language-plaintext highlighter-rouge">%programdata%\evtchk.txt</code> is intended as a mutex object on the remote computer, which marks that a remote infection is currently ongoing. This avoids that two computers running Olympic Destroyerâs infection routine infect the same target at the very same time. Yet, as this file is deleted right after the infection, it does not avoid multiple infections of the same target in general, but only in parallel.</p>

<p>While all previously mentioned remote infection threads are running, the main thread waits for their termination by calling <em>WaitForMultipleObjects</em>, where it waits for all spawned threads to finish.</p>

<p>Once all threads are finished and back in the function <code class="language-plaintext highlighter-rouge">0x00406ED0</code>, the control flow enters a loop, which iterates over all credentials and passes them to the function at <code class="language-plaintext highlighter-rouge">0x00406780</code>. This function also has the purpose of enumerating network targets. Once again COM objects are involved:
One main part of this function is the call to <em>NetGetDCName</em>, which gets the name of the primary domain controller. This name is formatted into the string <code class="language-plaintext highlighter-rouge">_%s\\root\\directory\\LDAP_</code> in order to use it with the same COM objects as before during the remote code execution (CLSID <code class="language-plaintext highlighter-rouge">{4590F811-1D3A-11D0-891F-00AA004B2E24}</code> and IID <code class="language-plaintext highlighter-rouge">{dc12a687-737f-11cf-884d-00aa004b2e24}</code>) by using the credentials, which are passed as function arguments. If everything works so far, the statement â<em>SELECT ds_cn FROM ds_computer</em>â is executed in order to get all computer names from the current domain. Then, for each computer, by calling <em>GetAddrInfoW</em> and <em>ntohl</em> the domain names are resolved to IPs. A vector of IPs is returned from <code class="language-plaintext highlighter-rouge">0x00406780</code>. The IPs are then passed to the already known function at <code class="language-plaintext highlighter-rouge">0x004054E0</code> in order to infect those computers remotely.</p>

<p>When this IP enumeration and remote infection loop is finished, some objects and memory is cleaned up before the control flow returns back to the main function.</p>

<h2 id="self-deletion--or-how-to-hide-your-traces-well-at-least-one-of-the-many">Self-Deletion â Or how to hide your traces, well, at least one of the manyâ¦</h2>

<p>The last step in the main function, before freeing the remaining objects and memory, is the call to the already described function âselfDeleteInjectBinaryâ at <code class="language-plaintext highlighter-rouge">0x00405DD0</code>. This time the sleep interval is only three instead of five seconds. So the spawned process tries to wipe the binary of the parent process every three seconds until it succeeds. The control flow of Olympic Destroyer then leaves the <em>main</em> function and the process exits, which will make the wiping of the binary possible.</p>

<p>I think it is noteworthy that none of the other dropped files are deleted. Everything in %tmp% remains and also all infection markers described previously are still there.</p>

<h1 id="the-destroyer">The Destroyer</h1>

<p>A big part of this componentâs functionality can be described in one picture by looking at the main function:</p>

<figure class="figure-posts" style="width: 100%; display:block; margin: auto; margin-bottom: 1em;">
  <div class="image-container" id="/images/posts/2018/03/10.png"> 
    <a href="#img/images/posts/2018/03/10.png">
      <img src="/images/posts/2018/03/10.png" alt="" class="img-responsive" />
      </a>
      <a href="#/images/posts/2018/03/10.png" class="lightbox" id="img/images/posts/2018/03/10.png">
        <span style="background-image: url(/images/posts/2018/03/10.png)"></span>
      </a>
      <figcaption class="figcaption-posts">Figure 10: Destroyer main function</figcaption>
    </div>
  </figure>

<p>After giving itself the <em>SeShutdownPrivilege</em> and bluntly ignoring all potential erroneous API calls, the Destroyer calls the function at <code class="language-plaintext highlighter-rouge">0x00401000</code> (â<em>execProcAndWaitForTerminate</em>â) five times in a row in order to:</p>

<ol>
  <li>Delete all shadow copies without prompt to avoid restoring the system</li>
  <li>Silently delete all backups created by the tool <em>wbadmin</em></li>
  <li>Ignore all failures during boot and avoid starting the recovery mode</li>
  <li>Clear system logs</li>
  <li>Clear security logs</li>
</ol>

<p>Then the function at <code class="language-plaintext highlighter-rouge">0x004012E8</code> (âdeactivateAllActiveServicesâ) is called. The name in the screenshot is already a spoiler of the actual functionality: All services of the local computer are disabled. This is done by iterating over all possible types of services by calling <em>EnumServicesStatusW</em> with the <code class="language-plaintext highlighter-rouge">dwServiceType</code> parameter set to <code class="language-plaintext highlighter-rouge">0x13F</code> and <code class="language-plaintext highlighter-rouge">dwServiceState</code> to <code class="language-plaintext highlighter-rouge">SERVICE_STATE_ALL</code>, and then calling <code class="language-plaintext highlighter-rouge">ChangeServiceConfigW(SERVICE_DISABLED)</code> for each service.
In combination with the previously disabled recovery mode and deleted backups, this bricks the local system on the next boot.</p>

<p>Back in the main function a thread is spawned which executes the function <code class="language-plaintext highlighter-rouge">0x004016BF</code> (âwiperThreadâ). The main thread then sleeps for a fixed single hour before shutting down the system â no matter what the wiper thread did or didnât do in the meantime. Note that this might also interrupt the spreading routine of Olympic Destroyer, which might still run.</p>

<p>The first thing the wiper thread does is setting its own thread priority to <em>THREAD_PRIORITY_TIME_CRITICAL</em> in order to get as much CPU cycles as possible. Then it recursively iterates over all available network resources with the APIs <em>WNetOpenEnumW</em> and <em>WNetEnumResourceW</em>. Each available resource is temporarily mounted by calling <em>WNetAddConnection2W(CONNECT_TEMPORARY)</em>, yet the parameters for the username and password are set to zero, thus the current userâs credentials are used. It is important to note that the stolen credentials are not used here. This decouples the Destroyer logically from its parent process.
For each successfully mounted resource the function at <code class="language-plaintext highlighter-rouge">0x00401441</code> is called.
This function is also best described with a screenshot:</p>

<figure class="figure-posts" style="width: 65%; display:block; margin: auto; margin-bottom: 1em;">
  <div class="image-container" id="/images/posts/2018/03/11.png"> 
    <a href="#img/images/posts/2018/03/11.png">
      <img src="/images/posts/2018/03/11.png" alt="" class="img-responsive" />
      </a>
      <a href="#/images/posts/2018/03/11.png" class="lightbox" id="img/images/posts/2018/03/11.png">
        <span style="background-image: url(/images/posts/2018/03/11.png)"></span>
      </a>
      <figcaption class="figcaption-posts">Figure 11: Remote wiping functionality</figcaption>
    </div>
  </figure>

<p>This function simply iterates recursively over all folders, starting at the mountpoint which is provided as an argument, and then destroys each single file that it finds:</p>

<ol>
  <li>Files equal or smaller to 1MB in size are completely written over with zeros</li>
  <li>For files bigger than 1MB only the first 4096 bytes are nulled. Yet for most files this should be enough to render them useless</li>
</ol>

<p>The wiper thread does not communicate with the main thread and there is no synchronization in any way. No matter if the wiping already finished or not, the system is shut down after one hour.
It might be a simple mistake to shut the system down after a fixed time: The wiping may not have wiped everything it can reach, or it could have already finished and the local computer is still useable until the shutdown. Additionally the remote spreading could still be ongoing.</p>

<p>Yet, I think it is more likely that this feature is a well-planned and sophisticated time bomb: Imagine Olympic Destroyer spreading through a network, wiping all it could wipe for one hour, when suddenly one system after another shuts down and is unable to boot.</p>

<h1 id="different-types-of-olympic-destroyer">Different types of Olympic Destroyer</h1>

<p>As mentioned in the introduction, I found two different types of Olympic Destroyer. The simpler type was described previously. The second type has the very same functionality, it only adds a few more functions. Those additional functions have the purpose of extending the spreading functionality of Olympic Destroyer by leveraging <em>PsExec</em>, which was written to %tmp% but then ignored by the simpler version.</p>

<h2 id="using-psexec">Using PsExec</h2>

<p>The additional function call is placed right after writing/checking the file <code class="language-plaintext highlighter-rouge">%programdata%\evtchk.txt</code> and before the spreading function which uses COM objects and spreads the version of Olympic Destroyer which was not updated with the stolen credentials. This bugged behavior of spreading the wrong binary over COM exists in both versions.</p>

<p>The additional call to PsExec is done in the following way:</p>

<figure class="figure-posts" style="width: 70%; display:block; margin: auto; margin-bottom: 1em;">
  <div class="image-container" id="/images/posts/2018/03/12.png"> 
    <a href="#img/images/posts/2018/03/12.png">
      <img src="/images/posts/2018/03/12.png" alt="" class="img-responsive" />
      </a>
      <a href="#/images/posts/2018/03/12.png" class="lightbox" id="img/images/posts/2018/03/12.png">
        <span style="background-image: url(/images/posts/2018/03/12.png)"></span>
      </a>
      <figcaption class="figcaption-posts">Figure 12: Format string for calling PsExec</figcaption>
    </div>
  </figure>

<p>PsExec is started with several parameters:</p>

<ul>
  <li>The first three parameter identify the target computer and the credentials which are applied</li>
  <li>Then the dialogue to confirm the EULA of PsExec is skipped with âaccepteulaâ</li>
  <li>â-dâ runs PsExec in a non-interactive way, which means that the caller does not wait for PsExec to terminate</li>
  <li>With â-sâ the remote process is started with System rights (in case the credentials allow that)</li>
  <li>â-câ and â-fâ specify that the actually executed file is copied to the target computer and overwritten in case it already exists</li>
  <li>The last parameter is the remotely executed file, which is obviously Olympic Destroyer</li>
</ul>

<p>This time the remotely executed binary is the copy of Olympic Destroyer in %tmp%, which was updated with the credentials stolen during the current run.</p>

<p>The output buffer returned from PsExec is parsed for the string âstartedâ, which indicates to Olympic Destroyer that its call was successful. A successful remote infection using PsExec breaks the loop which iterates over the credentials for a fixed target computer. Thus the target is only infected once and the bugged COM infection is avoided.</p>

<h2 id="a-crippled-worm-and-a-capable-worm">A crippled worm and a capable worm</h2>

<p>The simple version of Olympic Destroyer has some spreading functionality, although it is broken in the sense that the wrong binary is spread through the network. By not spreading the updated version of Olympic Destroyer, which contains the credentials stolen during the run, it loses a crucial part of its spreading capability:</p>

<p>Assume we have a computer âAâ with a logged in user who has the rights which allow remote spreading of Olympic Destroyer. And a computer âBâ, which is in reach of A, but where no user is logged in. A third computer âCâ is only reachable over B but not over A.
If the simple version of Olympic Destroyer is executed on computer A, it will use the stolen credentials to infect computer B. But on computer B there are no credentials to steal, so it wonât be able to infect computer C.</p>

<p>In other words: The simple version of Olympic Destroyer can only spread to computers which are âone hopâ in distance.
Yet, in most cases this should still be enough to infect a whole network, since a central Domain Controller is usually connected to most computers in the network.</p>

<p>Spreading the more advanced version including the stolen credentials gives Olympic Destroyer even better worming capabilities, since it gathers more and more credentials as it spreads further and further through a network.
In the previous example computer C could be infected from computer B by using the credentials stolen on computer A.</p>

<h2 id="crunching-some-numbers">Crunching some numbers</h2>

<p>In order to verify my findings with the two versions of Olympic Destroyer, I grabbed 36 different samples which are identified as Olympic Destroyer and compared their sets of stolen credentials. One sample had and empty list of credentials, so I discarded it.</p>

<p>It turns out that 23 of those samples are from the simple version type. All of them contained the same set of credentials, which were already described by Talos. They are for the domains <code class="language-plaintext highlighter-rouge">g18.internal</code> and <code class="language-plaintext highlighter-rouge">Pyeongchang2018.com</code>. All of the samples contained additional credentials stolen from various sandbox systems and virtual machines of researchers, who probably uploaded the files from the %tmp% folder to Virus Total during their analysis.</p>

<p>I could not find a single sample which contained only a subset of the credentials stolen from the <code class="language-plaintext highlighter-rouge">g18.internal</code> and <code class="language-plaintext highlighter-rouge">Pyeongchang2018.com</code> domains. If you strip the credentials from sandboxes and researchers, all 23 samples contain the same set of crendetials. This supports the findings that the simple version of Olympic Destroyer has a broken spreading algorithm.</p>

<p>In contrast to that, 12 samples of the total 36 are from the ATOS network with the domain <code class="language-plaintext highlighter-rouge">ww930</code>, as partially described by Kaspersky. Apparently the more capable version of Olympic Destroyer was spreading here, thus the differences in the list of credentials is bigger. The first pair of credentials in this set can be found in all 12 samples. But the rest of the credentials is a mix stolen from different computers in the same network. We can see that the worm took different paths when spreading though the network, acquiring the credentials of at least five different computers.</p>

<p>After removing the credentials from researchers and sandboxes, we are left with five unique sets of credentials. If one subset of credentials is one letter, the sets can be described as A, AB, AC, AD and ADE. This shows that the more capable version of Olympic Destroyer actually inherits its list of stolen credentials to the infected systems.
The samples in question are:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1942f14326f8ffa3afc83946ba9ec06abe983a211939f0e58362f85dd2a6b96a
25089ec24167f3caa413a9e1965c7dfc661219f45305187070a1e360b03f869c
6d7d35b4ce45fae4a048f7e371f23d1edc4c3b6998ab49febfd7d33f13b030a5
9085926d0beacc97f65c86c207fa31183c5373e9a26fb0678fbcd26ab65d6e64
90c956e8983116359662f8b82ae156b378d3fae02c07a18827b4c65f0b5fe9ef
</code></pre></div></div>

<p>It is likely that there are more samples out there which give a better picture of the way Olympic Destroyer wormed itself through the ATOS network.</p>

<h2 id="pe-timestamps">PE timestamps</h2>

<p>As the blog article of Kasperky has already shown, the author(s) of Olympic Destroyer had quite the fun in planting false flags. So, the compilation time stamps of the PE files should be taken with a grain of salt, as they can be easily forged.
Nonetheless they provide an interesting picture.</p>

<p>Simple version of Olympic Destroyer, PE timestamps ordered ascending:</p>

<figure>

  <table>
    <thead>
      <tr>
        <th style="text-align: left">Name</th>
        <th style="text-align: left">Compilation Timestamp</th>
        <th style="text-align: left">Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="text-align: left">Resource 104</td>
        <td style="text-align: left">2016-06-28 18:43:09</td>
        <td style="text-align: left">Copy of PsExec</td>
      </tr>
      <tr>
        <td style="text-align: left">Resource 105</td>
        <td style="text-align: left">2017-12-27 09:03:48</td>
        <td style="text-align: left">Destroyer</td>
      </tr>
      <tr>
        <td style="text-align: left">DLL in Resource 101</td>
        <td style="text-align: left">2017-12-27 11:44:17</td>
        <td style="text-align: left">Browser Password Stealer</td>
      </tr>
      <tr>
        <td style="text-align: left">DLL in Resource 102</td>
        <td style="text-align: left">2017-12-27 11:44:21</td>
        <td style="text-align: left">Windows Account Password Stealer</td>
      </tr>
      <tr>
        <td style="text-align: left">Resource 101</td>
        <td style="text-align: left">2017-12-27 11:44:30</td>
        <td style="text-align: left">Loader for internal DLL</td>
      </tr>
      <tr>
        <td style="text-align: left">Resource 103</td>
        <td style="text-align: left">2017-12-27 11:44:35</td>
        <td style="text-align: left">Loader for internal x64 DLL</td>
      </tr>
      <tr>
        <td style="text-align: left">Resource 102</td>
        <td style="text-align: left">2017-12-27 11:44:40</td>
        <td style="text-align: left">Loader for internal DLL</td>
      </tr>
      <tr>
        <td style="text-align: left">Main binary</td>
        <td style="text-align: left">2017-12-27 11:44:47</td>
        <td style="text-align: left">Olympic Destroyer</td>
      </tr>
    </tbody>
  </table>

  <figcaption>Figure 13: PE timestamps for simple version of Olympic Destroyer<br />
(Note that I did not extract the time stamp for the DLL in the resource of resource 103)</figcaption>
</figure>

<p>The PE time stamps of the more complex version in ascending order:</p>

<figure>

  <table>
    <thead>
      <tr>
        <th style="text-align: left">Name</th>
        <th style="text-align: left">Compilation Timestamp</th>
        <th style="text-align: left">Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="text-align: left">Resource 104</td>
        <td style="text-align: left">2016-06-28 18:43:09</td>
        <td style="text-align: left">Copy of PsExec</td>
      </tr>
      <tr>
        <td style="text-align: left">Resource 105</td>
        <td style="text-align: left">2017-12-27 09:03:48</td>
        <td style="text-align: left">Destroyer</td>
      </tr>
      <tr>
        <td style="text-align: left">DLL in Resource 101</td>
        <td style="text-align: left">2017-12-27 11:38:53</td>
        <td style="text-align: left">Browser Password Stealer</td>
      </tr>
      <tr>
        <td style="text-align: left">DLL in Resource 102</td>
        <td style="text-align: left">2017-12-27 11:38:58</td>
        <td style="text-align: left">Windows Account Password Stealer</td>
      </tr>
      <tr>
        <td style="text-align: left">Resource 101</td>
        <td style="text-align: left">2017-12-27 11:39:06</td>
        <td style="text-align: left">Loader for internal DLL</td>
      </tr>
      <tr>
        <td style="text-align: left">Resource 103</td>
        <td style="text-align: left">2017-12-27 11:39:11</td>
        <td style="text-align: left">Loader for internal x64 DLL</td>
      </tr>
      <tr>
        <td style="text-align: left">Resource 102</td>
        <td style="text-align: left">2017-12-27 11:39:17</td>
        <td style="text-align: left">Loader for internal DLL</td>
      </tr>
      <tr>
        <td style="text-align: left">Main binary</td>
        <td style="text-align: left">2017-12-27 11:39:22</td>
        <td style="text-align: left">Olympic Destroyer</td>
      </tr>
    </tbody>
  </table>

  <figcaption>Figure 14: PE timestamps for more compelx version of Olympic Destroyer</figcaption>
</figure>

<p>Some of those values actually make sense, although they might have been crafted in order to do so. The DLLs which are resources of resource 101 and 102 have to be compiled before they can be embedded as resources, so their time stamps come first. The same goes for all resource which are embedded in them main binary of Olympic Destroyer.
PsExec in resource 104 is the original copy of PsExec, thus has the original time stamp.
A time difference of four to nine seconds for each binary sounds realistic, given only a few dependencies on external libraries. Unfortunately, the compilation with the biggest external dependencies, the DLL in resource 101 where SQLite is used, seems to be the first binary in the build chain. This is where I would have expected to see the biggest gaps in between the time stamps. But as it is the start of the build chain, we cannot compare it to any binary built before it.
By looking at the gaps, we can also see that everything except the destroyer part seem to be compiled in one block.
Also the more complex version of Olympic Destroyer seems to be compiled five minutes before the simpler version. Most probably the attacker(s) just compiled the first set of Olympic Destroyer, before commenting out the one function using PsExec (implicitly removing all the used sub-functions), and then recompiled the whole set.</p>

<p>It is noteworthy to point out that both versions of Olympic Destroyer use the very same copy of the destroyer component. Not only the compilation time stamps are the same, but also their hash sums.</p>

<h1 id="summary">Summary</h1>

<p>This article has shown the innermost working of the malware called Olympic Destroyer. We have seen that by pure reverse engineering of the malware samples, a plethora of information can be obtained and deduced.</p>

<p>The analysis indicates that Olympic Destroyer consists of two completely independent parts: The first one is a framework for network spreading using resource 101 to 104 in order to spread as fast and as far as possible in the local network. The second one is the destructive component. Both parts work completely independent from each other. Resource 101 to 103 have a strong logical dependency on the main binary by receiving the decryption key as well as the name of the named pipe as arguments. And the main binary depends on the information returned from the resources 101 to 103 formatted in a certain way. In contrast to that, the destroyer in resource 105 is only dropped and executed in a fire and forget manor. No arguments, return values or status codes are exchanged.
So I think it is correct to state that everything except the destroyer is merely a vehicle in form of a spreading framework to deliver a payload. And the delivered payload is the destroyer. In theory every other payload could be delivered by simply exchanging the resource 105.</p>

<p>We have also seen that Olympic Destroyer comes in two different versions, which have been spread in two different networks. The spreading algorithm differs in the way that credentials stolen on one system are not carried on to the next infected system in one version.
It is unknown to me why the differences exist. Reading the Kasperky article indicates that the attackers already had a strong foothold in the <em>g18.internal</em> and <em>Pyeongchang2018.com</em> network. So it might have been enough to spread only one hop from the initial infected machine.Â  This decision could also be influenced by the defensive mechanisms employed at the targeted network. A proper network monitoring tool should mark the execution of PsExec as red flag, which might have been the reason to remove this part of the spreading algorithm.
The analysis of stolen credentials in the network of <em>ATOS</em> indicates that the attackers had a weaker foothold in the network, since, juding by the samples I looked at, only two sets of credentials were stolen on the initial infection (compared to 44 in the simpler variant). All other credentials were added during the spreading in the network. This weak foothold might have been the cause to go with a more aggressive spreading algorithm.</p>

<h1 id="appendix">Appendix</h1>

<p>Config structure as used in Olympic Destroyer:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">config</span>
<span class="p">{</span>
  <span class="n">DWORD</span> <span class="n">credentialsVectorStart</span><span class="p">;</span>
  <span class="n">DWORD</span> <span class="n">credentialsVectorEnd</span><span class="p">;</span>
  <span class="n">DWORD</span> <span class="n">credentialsVectorMaxSize</span><span class="p">;</span>
  <span class="n">CRITICAL_SECTION</span> <span class="n">critSect</span><span class="p">;</span>
  <span class="n">WSADATA</span> <span class="n">wsadata</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">ressourceHpath</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">randomTempPath</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">ressourceIpath</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">selfModulePath</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">domainName</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">accountName</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">domainAndAccountName</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">v13</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
  <span class="n">DWORD</span> <span class="n">bitness</span><span class="p">;</span>
  <span class="n">DWORD</span> <span class="n">bVersionGreaterEqualVista</span><span class="p">;</span>
  <span class="n">DWORD</span> <span class="n">bVersionSmallerEqualXP</span><span class="p">;</span>
  <span class="n">DWORD</span> <span class="n">bHasSelfDebugPrivs</span><span class="p">;</span>
  <span class="n">DWORD</span> <span class="n">bIsServiceOrAdmin</span><span class="p">;</span>
  <span class="n">DWORD</span> <span class="n">bIsUserAccount</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Hashes used for analysis:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>edb1ff2521fb4bf748111f92786d260d40407a2e8463dcd24bb09f908ee13eb9
01e640a91d32230cd3f45e1594177393415585dbeba9ddbd31be2139935058d3
137148fe8223bc88661ac941ea1a648ad0fb6e49c359acd06781abd0a0493c01
1942f14326f8ffa3afc83946ba9ec06abe983a211939f0e58362f85dd2a6b96a
2239d109d7c01682c99a721d654643b7d8f4431887ecad6fb2d043dbdacfe226
25089ec24167f3caa413a9e1965c7dfc661219f45305187070a1e360b03f869c
254fbeb13f8d2dc36de3a3ffca653608d1b3420a20a20248d330500785b3945c
2bcbb1c165a6e31e085306224de3410249df50742ca3af069d58c7fd75d2d8c4
2bf9f3703b48bf1578a43479444107b33ff6ecea108b364fc73913a639c511d4
2c28f3b297a990b9d7a7163bac57ab68228c66109bb7a593702e556cdd455cce
3131a8208dc7441bf26592d7fed2ba5d9f9994e21d9b8396b4d2cda76a8a44d7
36a65a47cc464aac45a5d27372ea3b3584726d354f0792b9a77bfbe0cd0558bd
41a6d6f1dca75abc924960ee701b0df0e7adc8b7501ac4e2c00743d7266df7d3
5181fe760f456719b0ec505370df0b38055a5a3b202e1d50948fc92383a61c18
569fbe4f66fa09fb375fb87915da79dbafb1ef62d9a20849d1beea4eadb8e805
5d85fba3ff021b35bfba30d5d56b957ef084d818778ff77550bcf65755aa7849
5f37829988e827f05b42774db94e8a15e87e9de12e61b89c91bf5fddee90650c
6d7d35b4ce45fae4a048f7e371f23d1edc4c3b6998ab49febfd7d33f13b030a5
6f6e9dde888d2368c1c9973769a5ea76bbf634105ed4f8adf1e74624f39454ad
725efe161b8d0024cd330e3a3da194b46d16be14d57392fbfdf1ea71415d67b1
75fa1309be8fdca4a6df345a009b47938503d5227149838334581b08d40b7e2f
9085926d0beacc97f65c86c207fa31183c5373e9a26fb0678fbcd26ab65d6e64
90c956e8983116359662f8b82ae156b378d3fae02c07a18827b4c65f0b5fe9ef
98d4f0e8f91d7f4f1a3058b1a30220e3460cc821be704acfcb7fa2eb0c88818c
99ca9d41c2ea6a18436fbc173ce8f3e94b5a3d592d9e4fa978120d140d96aefa
a9f66d9dd3fd0f977381e83c1379fe664f22ebdd5695258fc388465cd3749562
af33d399d9cb8026d796daf95f5bda9da96bb021ad93c001a21aa38005f2faa7
b30b4acf05898c8a6338f5df6c3df7d7f06df8e67ccd773ffd83b5b8acff4cb8
bdfb1a9f59be657b5375689b357ef8e70e1e7332f52c2e79ab3be796e06858d1
ca8be57bbd2f3169d0c1c4b5145e8f955ea69ddde701f94a2b29c661389b3aa2
cc2b47bffc260d992c602dbdbce1fb2ed982df883956cad9beac1ee0784650f6
d17d32048aae06ec60b693cd83e1cf184e8c2e4d1f0299a28423fdc624f56bb8
d2e43c41acd40324813d51df99fa127b86d8e384671dcc77f748d86afc3993a5
e2153c73ec9fd15dc8389523515a96c3477fce5503be78ff82ab3cc7e9386e83
e4dd30d5d85c4aaf05e01d8f40fb0e01e4e8ba99e82ec58946c045ce53783bde
e8349cfcc422310c259688b0226cb14f5196a6daad77b622405282aeac89ab06
f99610f8e36eb65e75979ef3ea4b7382bfb0bf2b72191cefccaaa19283d23606
</code></pre></div></div>

  </article>

  

</div>

  </article>

</div>

            </main>
          </div>
        </div>

        <div class="row">
  <div class="col-lg-8 col-lg-offset-2">
    <footer>
      <a href="https://www.gdata.de/business">G DATA Advanced Analytics</a>
      |
      <a href="/imprint">Imprint</a>
      |
      <a href="/privacy-policy">Privacy Policy</a>
    </footer>
  </div>
</div>


      </div>
    </body>
</html>
