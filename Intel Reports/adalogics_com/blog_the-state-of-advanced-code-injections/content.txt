<!DOCTYPE html>
<html lang="en">

<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-17200781-20"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-17200781-20',
        {'storeGac': false});
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- fonts -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link
        href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;1,600;1,700;1,800;1,900&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css">
    <!-- syles -->
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/july-version/css/custom-footer.css">
    <link rel="stylesheet" href="/css/train.css">
    <link rel="stylesheet" href="/css/service.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.10.22/css/jquery.dataTables.min.css">

    <script src="/js/jquery.min.js"></script>

    <link rel="stylesheet" type="text/css" href="/codemirror/lib/codemirror.css">
    <link rel="stylesheet" type="text/css" href="/codemirror/theme/darcula.css">
    <!--<link rel="stylesheet" type="text/css" href="/codemirror/theme/default.css">-->
    <link rel="stylesheet" type="text/css" href="/codemirror/theme/cobalt.css">
    <script type="text/javascript" src="/codemirror/lib/codemirror.js"></script>

    <script src="/codemirror/mode/gas/gas.js"></script>
    <script src="/codemirror/mode/python/python.js"></script>
    <script src="/codemirror/mode/shell/shell.js"></script>
    <script src="/codemirror/mode/clike/clike.js"></script>
    <script src="/codemirror/mode/llvm/llvm.js"></script>
    <script src="/codemirror/mode/go/go.js"></script>
    
        <title>The state of advanced code injections</title>
    
    <link rel="shortcut icon" type="image/png" href="/img/content/business/favico.png">
    <script src="/js/jquery.min.js"></script>
    <script src="https://cdn.datatables.net/1.10.22/js/jquery.dataTables.min.js"></script>
    <link href="/css/prism.css" rel="stylesheet" />

    
</head>

<body>
    <!-- header start
    ========================================= -->
    <style>
    .fab:hover {
        color:  purple!important;
        transition: color:  .2s ease-out;
    }
    .custom-nav-item {
        padding:  10px 20px;
        font-size: 14px;
    }
    .custom-nav-item a {
        color: #74788d !important;
    }
    #custom-nav-bar {
        transition: box-shadow .2s ease-out;
    }
    #custom-nav-bar.with-shadow {
        box-shadow: 0px 4px 20px rgb(5 47 97 / 8%);
    }
    .navbar-container {
        margin-left:  auto;
        margin-right:  auto;
        display: flex;
        height: 100%;
        width: 100%;
        /*padding:  0 15px;*/
    }
    @media (min-width: 768px) and (max-width: 992px) {
        .navbar-container {
            max-width: 720px;
        }
    }
    @media (min-width: 1200px) {
        .navbar-container {
            max-width:  1140px;
        }
    }
    @media (min-width: 992px) and (max-width: 1200px) {
        .navbar-container {
            max-width: 960px;
        }
    }

</style>
<div style="position:fixed; top: 0; left: 0; right: 0; background-color: white; z-index: 1030; display: flex; align-items; height: 85px; " id="custom-nav-bar">
    <div class="navbar-container">
        <div style="flex: 1; display: flex; align-items:center; line-height: 1.6">
            <a href="/" style="line-height:1.6; height: 35px">
                <img src="https://adalogics.com/img/logos/logoH.png" class="logo-dark" alt="" height="35" />
            </a>
        </div>
        <div style="flex: 4; display: flex; align-items:center; justify-content: center; line-height:1.6">
            <div class="custom-nav-item">
                <a href="/cyber-secruity-services">Services</a>
            </div>
            <div class="custom-nav-item">
                <a href="/courses">Training</a>
            </div>
            <div class="custom-nav-item">
                <a href="/about-us">About</a>
            </div>
            <div class="custom-nav-item">
                <a href="/blog">Blog</a>
            </div>
            <div class="custom-nav-item">
                <a href="/contact">Contact</a>
            </div>
        </div>
        <div style="display: flex; justify-content: center; align-items: center; flex: 1">
            <div>
                <a href="https://twitter.com/adalogics?lang=en">
                    <i class="fab fa-twitter-square" style="font-size: 30px; color: #828282"></i>
                </a>
            </div>
            <div>
                <a href="https://github.com/AdaLogics">
                    <i class="fab fa-github-square" style="font-size: 30px; color: #828282; margin-left: 10px"></i>
                </a>
            </div>
        </div>
    </div>
</div>

<script>
    $(window).on( 'scroll', function(){
        if($(window).scrollTop()>90) {
            if(!$("#custom-nav-bar").hasClass("with-shadow")) {
                $("#custom-nav-bar").addClass("with-shadow");
            }
        }
        if($(window).scrollTop()<90) {
            if($("#custom-nav-bar").hasClass("with-shadow")) {
                $("#custom-nav-bar").removeClass("with-shadow");
            }
        }
    });
</script>
    <!--<header class="header">
        <div class="auto__container">
            <div class="header__inner">
                <div class="logo__outer">
                    <a href="/"><img src="/img/logos/logoH.png" alt=""></a>
                </div>
                
                <div class="social__nav">
                    <a href="https://twitter.com/ADALogics" class="social__nav-link">
                        <i class="fab fa-twitter-square"></i>
                    </a>
                    <a href="https://github.com/adaLogics" class="social__nav-link">
                        <i class="fab fa-github-square"></i>
                    </a>
                </div>
                <div class="ham" id="menuBtn">
                    <i class="fas fa-bars"></i>
                </div>
            </div>
        </div>
    </header>-->





<div class="blog-post-body">  
  <h1>The state of advanced code injections</h1>
<span style="margin: 10px 0 10px 5px; display: block">13th august 2019</span>
<div style="display: block; padding: 10px 0; margin-bottom: 30px">
	
	<div style="display: flex">
		<div style="display: flex; align-items: center">
			<div style="padding-right: 10px">
	  			<img style="height: 55px; border-radius: 30px;" src="/img/content/David3.png">
	  		</div>
	  		<div style="display: flex; flex-direction: column">
		  		<div>
		  			David Korczynski,
		  		</div>
		  		<div>
		  			<i style="color:#404040">Security Research &amp; Security Engineering</i> 
		  		</div>
		  		 <div>
		  			<a target="_blank" href="https://twitter.com/Davkorcz" style="color: #828282; background: white; border-radius: 3px; padding: 3px"><i class="fab fa-twitter"></i></a>
		  		</div>
		  	</div>
	  	</div>	  	
	</div>
	
</div>
					
	<p>
		In the last few years there has been a significant interest in code injection techniques from both attackers and defenders. These techniques enable the attacker to execute arbitrary code within the address space of some target process (which is why code injections often are also called process injections), and attackers, both malware and pentesters, increasingly use these techniques to bypass anti-malware systems and endpoint protection systems in order to execute their payloads. Many of these injection techniques are already described in various blog posts, such as the excellent ones by Endgame <a href="https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process"><b>here</b></a> and <a href="https://www.endgame.com/blog/technical-blog/hunting-memory"><b>here</b></a>, and most recently a large survey was conducted by researchers from SafeBreach at the most recent Blackhat event with the content available <a href="https://www.blackhat.com/us-19/briefings/schedule/#process-injection-techniques---gotta-catch-them-all-16010"><b>here</b></a>. However, many of these surveys are closely attached to the core programmatic aspects of the injections, whereas they leave out elements of why injections are necessarily important and when they are used. In this blog post we will cover the state of code injections from a more general setting such as their motivation, some of their technical details as well as highlight examples of attacks that have used them. Finally, we give a short view into the future. 
	</p>
	<p>
		Understanding code injections from beginner to advanced is one of the courses that we  offer as part of <a href="/cyber-security-training"><b>our software security training</b></a>. We currently have a public event scheduled for the upcoming 44CON in London 9th-11th September 2019 and you can find the necessary information <a href="https://44con.com/44con-training/code-injections-from-beginner-to-advanced-for-defenders-and-attackers/"><b>here</b></a>. In this course we will teach you the core of these techniques as well as how to develop sophisticated payloads that rely on code injections. Please consider attending the training and the conference! 
	</p>						
		
	<h2 class="blog-subtitle">Motivation for code injections, for defenders and attackers</h2>

	<p>
		In a general sense, attackers use code injection techniques to mitigate defensive systems. This includes everything from bypassing host-based intrusion prevention systems, evading malware sandboxes and avoiding analysis by forensic tools. Naturally, malware has used these techniques for quite a while and even in back in 2013 Palo Alto reported that 13.5% of malware samples used code injections, described in <a href="https://media.paloaltonetworks.com/documents/The-Modern-Malware-Review-March-2013.pdf"><b>the modern malware review report</b></a> on page 16 under "analysis avoidance ''. In their report they also give an interesting insight about the motivation for code injections, namely "<i>Code injection was observed in 13.5 percent of samples. This technique is notable in particular because it allows malware to hide within another running process. This has the effect of the malware out of view if a user checks the task manager and can also foil some attempts at application white-listing on the host</i>". Wayne Low documents even before then, in 2012, the first analysis of the Gapz malware that explicility used a novel code injection technique that - due to it's novelty - bypassed host-based intrusion prevention systems <a href="https://www.virusbulletin.com/virusbulletin/2012/10/code-injection-return-oriented-programming"><b>here</b></a>. Interestingly, the injection that Gapz deployed used techniques and ideas described around a decade earlier called <a href="https://web.archive.org/web/20060904080018/http://security.tombom.co.uk/shatter.html"><b>shatter</b></a> attacks, which was even presented at Blackhat in 2004 <a href="https://www.blackhat.com/presentations/bh-usa-04/bh-us-04-moore/bh-us-04-moore-whitepaper.pdf"><b>here</b></a>. 
	</p>	
	<p>
		In the years 2013-2019 the amount of code injections has continued to grow. There are currently many reports by anti-malware companies documenting the code injections in malware and I think it's fair to say that now, when a new malware is discovered, it's more often than not the case that it uses code injection techniques. A recent survey of techniques by SafeBreach documents 14 techniques invented in 2017-2019, and this leaves out 7 shatter-like attacks that they do not go in details with as well as a whole domain of techniques in the process hollowing space, in which several new variants have been discovered in recent years. Furthermore,  malware samples are currently not limiting their injection lifecycle to only one injection technique, but a recent report shows that <a href="https://www.bromium.com/dridex-threat-analysis-july-2019-variant/"><b>Dridex combines five different injection techniques</b></a>. 
	</p>
	<p>
		Code injections are not only used by malware. Pentesters, and red teams in general, rely on these techniques to take control of the systems once they have gotten access to the system. For example, the famous <a href="https://www.offensive-security.com/metasploit-unleashed/about-meterpreter/"><b>Meterpreter</b></a> used by pentesters rely on code injection as well as related techniques, e.g. self-loading DLLs. <a href="https://www.shellterproject.com"><b>Shellterpro</b></a> is another well-known pentester tool that is heavily based on code injections. As defensive systems get better, understanding the design space of code injections can significantly enhance the skills of red teamers, as it allows you to manually construct payloads and write injection tools that bypass the specific defensive perimeter of your target. An example of custom tools developed for the purposes of penetration testing was given at Blackhat in 2014 <a href="https://www.blackhat.com/docs/us-14/materials/us-14-Mesbahi-One-Packer-To-Rule-Them-All-WP.pdf"><b>here</b></a>. 
	</p>
	<h2 class="blog-subtitle" style="font-size: 2rem">Brief overviev of code injection foundations</h2>
	<p>
		In this section we give a brief introduction to some of the more common-known injection techniques.
	</p>
	<h2 class="blog-subtitle">Traditional remote thread creation</h2>

	<p>
		This is the most well known injection technique and simply achieves execution in the target process by instantiating a remote thread. The general procedure is to get access to the target process using <code>OpenProcess</code>, allocating memory in the process using <code>VirtualAlloc</code>, writing malicious code to the allocated memory with <code>WriteProcessMemory</code> and finally having this code execute using <code>CreateRemoteThread</code>. Naturally, there are many variations of this injection technique, both in terms of getting access to the remote process, writing memory to the targets address space and also initiating execution. For example, instead of opening an existing process, the malware can create a new process with <code>CreateProcess</code> and inject its code in this new process or rely on lower-level APIs like <code>NtOpenProcess</code>. The attack can also write to memory using <code>NtWriteVirtualMemory</code> and creating the remote thread can be performed with a variety of lower-level APIs like <code>RtlCreateUserThread</code>, <code>NtCreateThreadEx</code> and <code>ZwCreateThreadEx</code>. This technique is perhaps the most commonly used by malware and example reports include <a href="https://www.trendmicro.de/cloud-content/us/pdfs/security-intelligence/white-papers/wp_w32-tinba-tinybanker.pdf?_ga=2.231395871.1631440968.1565650174-166280822.1565650174"><b>Tinba</b></a> and <a href="https://securelist.com/the-banking-trojan-emotet-detailed-analysis/69560/"><b>Emotet</b></a>.
		
	</p>
	<p>
		In general, we can construct a similar-looking attack in many ways. The primitive for writing memory to the target process need not be <code>WriteProcessMemory</code>, but can be any way of memory sharing. This includes memory mapped files by way of APIs like <code>ZwCreateSection</code> and <code>ZwMapViewOfSection</code> and also globally shared memory. Furthermore, from a programmatic perpective we can also use asynchronous procedure calls rather than explicitly starting a new thread in the remote process, which we discuss below.
	</p>
	<p class="center-holder">
		<figure>
			<img src="/img/content/ThreadCreationInjection.png" alt="img" style="width: 100%">
			<figcaption>Remote thread creation as decompiled by Ghidra.</figcaption>
		</figure>
	</p>
	<h2 class="blog-subtitle">Remote thread hijacking</h2>
	<p>		
		A technique that is closely aligned with creating a remote thread is to hijack a remote thread instead of creating a new one in the target process. From a high-level point of view, the difference between this technique and the previous one is that the previous technique creates a new thread in the target whereas this technique hijacks execution of an exisiting one. One way to do this is to create a new process, by way of <code>CreateProcess</code>, in suspended mode and overwrite the entry point of the newly-started process such that it points to our attacker-controlled code instead. This effectively means the <code>CreateRemoteThread</code> call from before gets substituted with <code>ResumeThread</code>. A more aggressive approach is to simply suspend thread execution in the target process and then substitute the thread using <code>SuspendThread</code>. Code execution is then achieved by exchanging the thread context using <code>GetThreadContext</code> and <code>SetThreadContext</code> such that the registers of the thread context points to attacker-controlled memory. Naturally, since the thread execution of the target process is suspended it is in many scenarios desirable to restore faithful execution in the target process in order for the system to continue execution unnoticed. 
	
	</p>
	<p>
		The attacker can also initiate execution of the attacker-controlled memory in the remote process through asynchronous procedure calls such as <code>QueueUserAPC</code>, <code>NtQueueApcThread</code>, <code>ZwQueueApcThread</code> and <code>RtlQueueApcWow64Thread</code>. However, one of the drawbacks of doing this, however, is that the remote thread must be in an alertable state to trigger the APC. 
	</p>

	<h2 class="blog-subtitle">Reflective DLL injection</h2>
	<p>
		In the previous methods we were mainly concerned with how to achieve code execution in the remote process. However, a question that comes up once you achieve code execution is <i>what</i> code to execute. In most cases just executing shellcode doesn't do the job as the attacker desires to have more comprehensive control. Reflective DLL injection is a technique that focuses on this aspect of the code-injection design space using a self-loadable DLL file. Specifically, reflective DLL injection is a technique that creates a DLL such that the DLL has a minimal Windows loader as an exported function. When this function is triggered the DLL will load itself inside the process of which it has been written, thus avoiding the need to be loaded from disk by the regular Windows loader. As such, it is not necessary to, for example, rely on calls like <code>LoadLibrary</code> to load a fully-fledged library inside the target process. Rather, the attacker can simply allocate space in the remote process, write the raw DLL content there, and then execute the exported function in the DLL itself. <a href="https://securingtomorrow.mcafee.com/other-blogs/mcafee-labs/lazarus-resurfaces-targets-global-banks-bitcoin-users/"><b>Lazarus</b></a> is an example of malware that uses reflective DLL injection and pentesters published at Blackhat a white paper on a novel packer that uses reflective DLL injection <a href="https://www.blackhat.com/docs/us-14/materials/us-14-Mesbahi-One-Packer-To-Rule-Them-All-WP.pdf"><b>here</b></a>. 
	</p>	
	<p class="center-holder">
		<figure>
			<img src="/img/content/ReflectiveDLLInjection.png" alt="img" style="width: 100%">
			<figcaption>Custom loading of PE sections in reflective DLL injection. Code for the reflective loader can be found <a href="https://github.com/stephenfewer/ReflectiveDLLInjection/blob/master/dll/src/ReflectiveLoader.c"><b>here</b></a>.</figcaption>
		</figure>
	</p>							
	<h2 class="blog-subtitle">Process hollowing</h2>
	<p>
		A technique closely related to hijacking a remote thread is to simply substitute the entire memory of the remote process with attacker-controlled memory. Process hollowing does this. The steps in process hollowing is to create a process in suspended mode, then deallocate the memory of the suspended process (this is where the "hollow" comes from), write an attacker-controlled image to the target process and then resume execution of the target process. Effectively, the goal is to explicitly hide execution of the malicious code in disguise of a benign process. Process hollowing is a commong techniques in malware samples, with an example report found <a href="https://www.bromium.com/dridex-threat-analysis-july-2019-variant/"><b>here</b></a>. 
	</p>	
	<p class="center-holder">
		<figure>
			<img src="/img/content/ProcessHollowing.png" alt="img" style="width: 100%">
			<figcaption>Unloading of the main module and then reallocating memory for the new executable in ProcessHollowing. Source code can be found <a href="https://github.com/theevilbit/injection/blob/master/ProcessHollowing/ProcessHollowing/ProcessHollowing.cpp"><b>here</b></a>.</figcaption>
		</figure>
	</p>
	<h2>Example of advanced techniques</h2>
	<p>
		The majority of injections observed in the wild are of the types described in the previous section. However, (mostly) in recent years several novel techniques have been discovered that rely on approaches outside the scope of the previous techniques. These novel techniques use different API calls to achieve their code injection, sometimes rely on exploit-like techniques such as return oriented programming and are quite often specific to certain target applications. However, on an abstract level they still remain close to our most basic techniques as they still have to (1) communicate with the target process; (2) ensure attacker-controlled memory is written to the process and (3) trigger execution of attacker-controlled code in the process. It is important to emphasize in this blog post we only highlight some examples of these techniques rather than an exhaustive list. In particular, we have prioritised selection of techniques that have been documented to be used in attacks. 
	</p>
	<h2 class="blog-subtitle">Ghostwriting</h2>
	<p>
		The main idea of GhostWriting is to force the target process to write malicious content in it's address space and force this code to be executed without calling any of <code>OpenProcess</code>, <code>VirtualAlloc</code> or <code>CreateRemoteThread</code>, or similar. GhostWriting achieves this by selecting two atomic gadgets (ROP gadgets), one that writes the value of a register to an address given by the value of a different register (<code>mov [reg1], reg2</code>) and another gadget that simply represents an eternal loop <code>jmp 0x0</code>. The technique then makes use of <code>SuspendThread</code>, <code>GetThreadContext</code>, <code>SetThreadContext</code> and <code>ResumeThread</code> to continuously overwrite memory in the target process. Specifically, it continuously sets the registers such that they overwrite a given address with the desired content, and then jumps to the eternal loop. As SetThreadContext allows the attacker to control the registers it is easy to overwrite the stack - or any other address in the target process - with whichever content the attacker desires. After the <code>mov [reg1], reg2</code> gadget executes it returns to the eternal loop gadget, and the attacker gains control over the execution simply by calling <code>SuspendThread</code>, such that the execution does not run in the eternal loop forever. Rather, the "eternal loop" is used as a temporary safe-state for the attacker to ensure consistency in the target process. 
		A concrete example of using this is to to create a stackframe to <code>NtProtectVirtualMemory</code> that sets the necessary permissions for attacker-written shellcode. However, the technique used for achieving write-what-where and execute-on-demand is far more general and can be used to write any type of code to the target, e.g. a fully functioning PE file. 
	</p>	
	<p>
		A quite interesting aspect of GhostWriting is that the technique was first made public in 2007, yet it still remains largely one or the more sophisticated techniques. The original blog post explaining the technique is available <a href="http://blog.txipinet.com/2007/04/05/69-a-paradox-writing-to-another-process-without-openning-it-nor-actually-writing-to-it/"><b>here</b>.</a>
	</p>						
	<p class="center-holder">
		<figure>
			<img src="/img/content/GhostWriting.png" alt="img" style="width: 100%">
			<figcaption>Shellcode written by the original GhostWriting code. The source can be found <a href="http://blog.txipinet.com/2007/04/05/69-a-paradox-writing-to-another-process-without-openning-it-nor-actually-writing-to-it/"><b>here</b></a>.</figcaption>
		</figure>
	</p>		
	<p class="center-holder">
		<figure>
			<img src="/img/content/GhostWritingWriteFunction.png" alt="img" style="width: 100%">
			<figcaption>The main function that GhostWriting uses to continuously write desired content in target process. By setting registers in the thread context so they point to selected gadgets GhostWriting maintains control of the target process.</figcaption>
		</figure>
	</p>												
	<h5>PowerLoader and PowerLoaderEx</h5>
	<p>					
		The idea behind PowerLoad is to abuse shared sections in Windows and overwrite several function pointers inside <code>explorer.exe</code> to point to attacker-controlled memory in the shared section. Since this shared section is non executable PowerLoader relies on a ROP chain to execute shellcode within <code>explorer.exe</code>. In more detail, PowerLoader first gets a handle to a window in <code>explorer.exe</code>. This window contains a pointer to a CTray class object, which is used for handling messages sent to the particular window. PowerLoader then uses <code>SetWindowLongPtr</code> to replace this CTray object, such that it now points to memory in a shared section. Within this shared section, PowerLoader writes its malicious code, which is a combination of a ROP chain as well as shellcode. PowerLoader then triggers the execution of the ROP chain by sending the window a message, using <code>SendNotifyMessage</code>. The ROP chain then overwrites a function within ntdll called <code>atan</code> with shellcode and transfers execution to this shellcode. This technique was first used by the Gapz malware and has since been generalised by researchers from Ensilo, that made the attack non-specific to the shared sections. You can find the source code for PowerLoaderEx <a href="https://github.com/BreakingMalware/PowerLoaderEx"><b>here</b></a>
		
	</p>	
	<p class="center-holder">
		<figure>
			<img src="/img/content/explorer_exe_vuln.png" alt="img" style="width: 100%">
			<figcaption>Message handler in explorer that PowerLoader hijacks.</figcaption>
		</figure>
	</p>						
	<h2 class="blog-subtitle">AtomBombing</h2>
	<p>
		AtomBombing is another technique that uses ROP chains to get code execution in the remote process. Specifically, AtomBombing abuses the global atom table in Windows to share memory between processes and undocumented asynchronous procedure calls to force the target process into calling various functions on behalf of the injecting process. The injecting process writes a ROP chain and shellcode to the global atom table using the Windows function <code>GlobalAddAtom</code>. The injector then uses <code>NtQueueApcThread</code> to force the injected process to call <code>GlobalGetAtomName</code> to store the ROP chain and shellcode inside the target process. To invoke execution, the injector again uses <code>NtQueueApcThread</code> to force the injected process to call <code>SetThreadContext</code> to set eip and esp. Eip is set to the address of <code>ZwAllocateVirtualMemory</code> and esp is set to point to the beginning of the ROP chain. The injection is, therefore, achieved with a combination of <code>NtQueueApcThread</code> and <code>GlobalAddAtom</code>. An interesting aspect of AtomBombing is that not long after the publication of the technique an updated version of the infamous Dridex malware was <a href="https://securityintelligence.com/dridexs-cold-war-enter-atombombing/"><b>discovered</b></a>, that had adopted a modified version of the AtomBombing technique, and this is still being used in <a href="https://www.bromium.com/dridex-threat-analysis-july-2019-variant/"><b>2019</b></a>. 
		
	</p>	
	<h2 class="blog-subtitle">Process Doppelganging</h2>  
	<p>
		The idea behind doppelganging is to improve the limitations of process hollowing, namely how the executable memory is written into the target process. Doppelganging achieves this by way of Windows Transactions. Doppelganging loads a benign executable using <code>CreateTransaction</code> and <code>CreateFileTransacted</code>, but then overwrites the content of the transacted file with malicious code, using <code>WriteFile</code>. Doppelganging then creates a section that holds the tainted transaction, i.e. the transaction that holds the malicious memory, and then performs a rollback on the transaction. The rollback will undo the changes performed by the transaction, which in Doppelganging's context is the overwriting of the benign file, so the changes to the benign file won't actually be commited to the file system. However, the caveat here is that the content of the section still contains the tainted code. Now, doppelganging proceeds to create the target process with the content of the malicious section. Doppelganging creates the process in a low-level way using <code>NtCreateProcess</code>, and, therefore, has to perform various set-ups for the process to accurately execute, such as setting up process parameters and create the process's main threads. An example of Process Doppelganging in the wild was <a href="https://blog.malwarebytes.com/threat-analysis/2018/08/process-doppelganging-meets-process-hollowing_osiris/"><b>discovered in early 2018</b></a>. 
	</p>	

	<h2 class="blog-subtitle">Earlybird</h2>
	<p>
		Early bird refers to a technique that performs a somewhat traditional code injection via remote thread instantiation early in the process initialisation phase. Specifically, the attacker creates a new process in suspended mode and then proceeds to allocate and write memory to the process. In order to trigger execution the malware uses an asynchronous procedure call and enforces execution of the APC call using the  <code>NtTestAlert</code> function. The technique was discussed by researcher from <a href="https://www.cyberbit.com/blog/endpoint-security/new-early-bird-code-injection-technique-discovered/"><b>Cyberbit</b></a> and even though it received its own name, it is closely related to earlier techniques traditional injection. This is also confirmed by the fact that the injection <a href="https://research.checkpoint.com/dorkbot-an-investigation/"><b>dates back to at least 2012.</b></a> 
	</p>		
	<p class="center-holder">
		<figure>
			<img src="/img/content/EarlyBird.png" alt="img">
			<figcaption>Code snippet of Earlybird injection.</figcaption>
		</figure>
	</p>							
	<h2 class="blog-subtitle">ctrl-inject</h2>
	<p>
		The ctrl-c key combination is a well-known pattern for exiting and shutting down applications. The ctrl-inject injection technique exploits the underlying features that makes this hotkey possible. Specifically, when a user presses the ctrl + c keyword in a console application a system process (<code>csrss.exe</code>) invokes a function called <code>CtrlRoutine</code> in a new thread of the given console application. The <code>CtrlRoutine</code> fetches the given handler for the control signal (ctrl + c) which contains a function pointer that will be called, which effectively is used to handle the signal. In short, the technique overwrites this signal handler with a malicious function pointer, such that whenever the signal occurs the malicious handler will be called.  
	</p>	
	<p>
		The strengths of ctrl-inject is that the technique does not rely on any function calls like <code>CreateRemoteThread</code>, <code>ResumeThread</code> or <code>SetThreadContext</code>, but rather triggers execution through the <code>csrss.exe</code> process. The technique that triggers the execution is a simple ctrl-c signal which in many scenarios is considered harmless and unsuspicious. The drawback of the technique is that it only works with console based applications. 
	</p>	
	<p class="center-holder">
		<figure>
			<img src="/img/content/ctrlinjectTriggerPoint.png" alt="img" style="width: 100%">
			<figcaption>Code that triggers the injection in ctrl-inject. Source code can be found <a href="https://github.com/theevilbit/injection/blob/master/Ctrlinject/Ctrlinject/Ctrlinject.cpp"><b>here</b></a></figcaption>
		</figure>
	</p>							
	<h2 class="blog-subtitle">PROPagate</h2>
	<p>
		This technique was discovered in late 2017 and uses functionality of window subclassing to gain code execution in remote processes. Windows subclassing enables programmers to reuse functionality in existing controls by adding functionality and features to them. Whenever a window is subclassed, the messages to the original window is intercepted by the subclassing window which executes its own handlers before sending them on to the parent. You can read more about subclassing <a href="https://docs.microsoft.com/en-us/windows/win32/controls/subclassing-overview">here</a>. Whenever a window is subclassed it gets a new property called either <codeU>xSubclassInfo</code> or <code>CC32SubclassInfo</code> and stores the data structures related to these properties in its address space. This property points to a data structure inside the subclassed process which contains a function pointer that gets executed in the event of a message being sent to the window. The idea behind PROPagate is then to write a malicious data structure inside the remote process and use the <code>SetProp</code> function call to point to this handler. The attacker then uses <code>SendNotifyMessage</code> to trigger the malicious function handler. Roughly 8 months after the first documentation of PROPagate by <a href="http://www.hexacorn.com/blog/2017/10/26/propagate-a-new-code-injection-trick/"><b>Adam</b></a>, FireEye <a href="https://www.fireeye.com/blog/threat-research/2018/06/rig-ek-delivering-monero-miner-via-propagate-injection-technique.html"><b>discovered</b></a> the RIG Exploit Kit delivering a dropper that used PROPagate.
	</p>	
	<p class="center-holder">
		<figure>
			<img src="/img/content/PROPagate.png" alt="img" style="width: 100%">
			<figcaption>The code that will trigger the PROPagate injection by setting the <code>UxSubclassInfo</code> property within the target window to a have a fake handler. Source code can be found <a href="https://github.com/theevilbit/injection/blob/master/PROPagate/PROPagate/PROPagate.cpp"><b>here</b></a></figcaption>
		</figure>
	</p>		
	<h2 class="blog-subtitle">Shatter-style attacks</h2>
	<p>
		The final category of code injections that we cover in this course is called Shatter attacks. The basic idea behind these injections is to misuse the message-oriented way that windows are architectured within Windows. Specifically, whenever applications use windows they control these in a message-oriented ways which is a very modular and effective way of managing windows. For example, when a key is pressed a messaged is sent to the currently active window stating this key was pressed. However, the way these messages are handled by the active window is through message handlers, i.e. data structures, and at certain times these can be overwritten with attacker controlled memory. Since a window can send messages to other windows on the desktop and we can overwrite memory using previously mentioned primitives, we can start to construct code injections by overwriting the message handlers in our target processes and then sending messages that trigger the respective handlers. 
	</p>
	<p>
		Shatter attackers were first presented by Chris Paget (Now Kristine Paget) in <a href="https://web.archive.org/web/20060904080018/http://security.tombom.co.uk/shatter.html"><b>2002</b></a>, however, the technique remains relevant. Recently, <a href="https://twitter.com/Hexacorn"><b>Hexacorn</b></a> and <a href="https://modexp.wordpress.com/2019/04/25/seven-window-injection-methods/"><b>Odzhan</b></a> presented seven new ways of doing this. 
	</p>
	<h2 class="blog-subtitle">Future outlooks</h2>
	<p>
		Code injections are continuously being used and there is a trend of increasingly more novel techniques being researched by defenders as well. For example, even in 2019 alone <a href="https://modexp.wordpress.com/"><b>modexp</b></a> has presented at least 15 novel injections (many inspired by Hexacorn), and modern malware samples use long chains of code injections to execute on the target system, such as the recent <a href="https://www.bromium.com/dridex-threat-analysis-july-2019-variant/"><b>Dridex</b></a> that uses five in total. The novel techniques are much more specific than the traditional injection attacks, and are now targeted internal structurse within the target processes rather than relying purely on common APIs. We can safely expect more exploit-like scenarios in the future and also new ways of enforcing process separation. Furthermore, even Academia is now in the field as well, both researching how we can use system-wide execution to construct highly sophisticated malware that operates across many processes (<a href="https://www.usenix.org/conference/woot16/workshop-program/presentation/ispoglou"><b>malwash</b></a>) and <a href="https://acmccs.github.io/papers/p1691-korczynskiA.pdf"><b>how to generically analyse novel injection techniques</b></a>. Code injections are here to stay and the complexity of them will increase. We highly recommend getting started with these techniques if you aren't already, and also predict that we will find more defensive tools and techniques being developed in the near future.  
		
	</p>
	<h2 class="blog-subtitle">Conclusions</h2>
	<p>
		Code injections, also known as process injections, is an important topic in terms of post-exploitation strategies. Attackers, including both malware and pentesters, use these injections to execute code in otherwise benign processes as a way to bypass white-lists deployed by the defense products, e.g. host-based intrusion prevention and endpoint protection systems. From a defenders point of view we need to ensure our defense systems are aware of these tricks - and derivates hereof - in order to ensure our automated procedures are sound. Furthermore, from an attackers point of view, e.g. a pentester, these techniques can be of great benefit in order to secure access to a target machine. In this blog post we gave a motivation for both defenders and attackers on why studying code injections is relevant, and also highlighted technical aspects of several code injection techniques and attacks that use them.
	</p>
</div>


<footer class="custom-footer">
    <div class="navbar-container">
        <div style="display: flex; flex-direction: row; width:100%; font-size: 14px; line-height: 1.6">
            <div style="display: flex; flex: 2; width: 180px; flex-direction: column  ">
                <div style="height: 40px">
                    <img src="/img/logos/logo.png" alt="" style="height: 100%">
                </div>
                <div style="color: white; font-size: 14px">
                    ADA Logics is committed to delivering the highest quality software security training and services.
                </div>
                <div style="margin-top: 20px">
                    <a href="https://twitter.com/adalogics?lang=en">
                        <i class="fab fa-twitter-square" style="font-size: 30px; color: #828282"></i>
                    </a>
                
                    <a href="https://github.com/AdaLogics">
                        <i class="fab fa-github-square" style="font-size: 30px; color: #828282; margin-left: 10px"></i>
                    </a>
                </div>
            </div>
            <div style="flex: 1">
                
            </div>
            <div style="display: flex; flex: 1; flex-direction: column; color: white">
                    <div>
                        <a href="/" class="custom-footer-link">Home</a>
                    </div>
                    <div>
                        <a href="/courses" class="custom-footer-link">Training</a>
                    </div>
                    <div>
                        <a href="/about-us" class="custom-footer-link">About Us</a>
                    </div>
                    <div>
                        <a href="/blog" class="custom-footer-link">Blog</a>
                    </div>
                    <div>
                        <a href="/contact" class="custom-footer-link">Contact</a>
                    </div>
                </div>
        </div>
    </div>
</footer>
    
    


    <!-- footer end
    ========================================= -->
    <script src="/js/main2.js"></script>
    <script src="/js/prism.js"></script>

</body>

</html>