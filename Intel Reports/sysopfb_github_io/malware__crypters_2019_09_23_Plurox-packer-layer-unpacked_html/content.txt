<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Diving into Pluroxs DNS based protection layer | Random RE</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Diving into Pluroxs DNS based protection layer" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Intro Recently saw someone mentioning a sample of Plurox performing code flow obfuscation based on the result of a DNS request, kind of interesting and I have apparently lost the link to the person that originally mentioned the hash… so if you recognize it let me know and I’ll update this post." />
<meta property="og:description" content="Intro Recently saw someone mentioning a sample of Plurox performing code flow obfuscation based on the result of a DNS request, kind of interesting and I have apparently lost the link to the person that originally mentioned the hash… so if you recognize it let me know and I’ll update this post." />
<link rel="canonical" href="/malware,/crypters/2019/09/23/Plurox-packer-layer-unpacked.html" />
<meta property="og:url" content="/malware,/crypters/2019/09/23/Plurox-packer-layer-unpacked.html" />
<meta property="og:site_name" content="Random RE" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-09-23T16:31:12+00:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"Diving into Pluroxs DNS based protection layer","dateModified":"2019-09-23T16:31:12+00:00","datePublished":"2019-09-23T16:31:12+00:00","url":"/malware,/crypters/2019/09/23/Plurox-packer-layer-unpacked.html","mainEntityOfPage":{"@type":"WebPage","@id":"/malware,/crypters/2019/09/23/Plurox-packer-layer-unpacked.html"},"description":"Intro Recently saw someone mentioning a sample of Plurox performing code flow obfuscation based on the result of a DNS request, kind of interesting and I have apparently lost the link to the person that originally mentioned the hash… so if you recognize it let me know and I’ll update this post.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Random RE" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Random RE</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Diving into Pluroxs DNS based protection layer</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-09-23T16:31:12+00:00" itemprop="datePublished">Sep 23, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="intro">Intro</h1>
<p>Recently saw someone mentioning a sample of Plurox performing code flow obfuscation based on the result of a DNS request, kind of interesting and I have apparently lost the link to the person that originally mentioned the hash… so if you recognize it let me know and I’ll update this post.</p>

<p>The file we’ll be looking at is 0385038427750543d98ce02a2a24aef45a937ef226a53fc3f995b5cea513b1c8</p>

<p>PDB:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>E:\OldSoftware\Generating\Crypto\crypto.pdb
</code></pre></div></div>

<h1 id="strings">Strings</h1>
<p>Encoded strings is pretty common in malware and especially in protection layers such as crypters/packers and droppers/loaders.</p>

<p>Near the entry point of the sample we’ll find a call instruction with an immediate access of the stack. You find this pretty frequently in frameworks that use shellcode such as Metasploit, it’s basically getting the address of the data immediately following the call instruction.
<img src="/assets/plurox_packer/jump_over_encoded_data.png" alt="Jump over data using call" title="Jump over data using call" /></p>

<p><img src="/assets/plurox_packer/get_address_of_string_block.png" alt="Get data address" title="Get data address" /></p>

<p>What are we doing with this data? Further down we find a loop using XOR while loading the first DWORD of the data as the XOR key.</p>

<p><img src="/assets/plurox_packer/setup_and_xor_string_block.png" alt="XOR loop" title="XOR loop" /></p>

<p>Doing this statically in python:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Python</span><span class="o">&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">GetManyBytes</span><span class="p">(</span><span class="mh">0x43f007</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">)</span>
<span class="n">Python</span><span class="o">&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
<span class="n">Python</span><span class="o">&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>
<span class="n">Python</span><span class="o">&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="n">Python</span><span class="o">&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">Python</span><span class="o">&gt;</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
<span class="n">Python</span><span class="o">&gt;</span>  <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^=</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>
<span class="n">Python</span><span class="o">&gt;</span>
<span class="n">Python</span><span class="o">&gt;</span><span class="n">data</span>
<span class="err">�</span><span class="n">AZ</span><span class="err">�$</span><span class="mi">9</span><span class="err">���</span><span class="n">R</span><span class="err"></span><span class="mi">9</span><span class="err">�</span><span class="n">GetProcAddress</span>
<span class="n">Python</span><span class="o">&gt;</span><span class="n">data</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">)</span>
<span class="p">[</span><span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s">'</span><span class="se">\x12\xf1\x0e\x03</span><span class="s">AZ</span><span class="se">\xf1</span><span class="s">$9</span><span class="se">\x99\xaf\xfa</span><span class="s">R</span><span class="se">\x03</span><span class="s">9</span><span class="se">\x98</span><span class="s">GetProcAddress'</span><span class="p">),</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s">'VirtualFree'</span><span class="p">),</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s">'UnmapViewOfFile'</span><span class="p">),</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s">'htonl'</span><span class="p">),</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s">'ntdll.dll'</span><span class="p">),</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s">'ws2_32.dll'</span><span class="p">),</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s">'ExitProcess'</span><span class="p">),</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s">'gethostbyname'</span><span class="p">),</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s">'LoadLibraryA'</span><span class="p">),</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s">'VirtualAlloc'</span><span class="p">),</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s">'User32.dll'</span><span class="p">),</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s">'RtlDecompressBuffer'</span><span class="p">),</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s">'WSAStartup'</span><span class="p">),</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s">'VirtualProtect'</span><span class="p">),</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s">'google-public-dns-b.google.com'</span><span class="p">),</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s">''</span><span class="p">),</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s">''</span><span class="p">),</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s">'</span><span class="se">\x8f</span><span class="s">'</span><span class="p">),</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">b</span><span class="s">',</span><span class="se">\xe1</span><span class="s">T</span><span class="se">\r\x08\x08\xfb\xfb\xf7\xf7\xfb\xfb\xf7\xf7\xfb\xfb\xf7\xf7\xfb\xfb\xf7\xf7</span><span class="s">'</span><span class="p">)]</span>

</code></pre></div></div>

<p>This is our string block along with the domain that will be resolved, the function names and domain immediately make me think this is more related to a protection or crypter layer as opposed to directly associated with the underlying malware Plurox. Assumptions however are just things that need to be proven.</p>

<p>Continuing on with the code it will enumerate it’s own memory space looking for the start value ‘MZ’.</p>

<p><img src="/assets/plurox_packer/find_start_address_in_memory.png" alt="Find beginning of PE file in memory" title="Find beginning of PE file in memory" /></p>

<p>After finding that address it begins utilizing the bytes at the beginning of the decoded string block, turns out these values are headers used to identify two blocks of data that will be saved off.</p>

<p><img src="/assets/plurox_packer/find_data_blocks_by_8byte_chunks.png" alt="Find data blocks by 8byte chunks" title="Find data blocks by 8byte chunks" /></p>

<p>After saving off those chunks of data it will perform the resolution of the domain from the decoded strings.</p>

<p><img src="/assets/plurox_packer/resolve_domain_store_ip.png" alt="Resolve domain" title="Resolve domain" /></p>

<p>It will then use that resolved IP as the DWORD XOR key for the smaller layer that was previously saved off.</p>

<p><img src="/assets/plurox_packer/xor_decode_first_layer.png" alt="XOR decode first layer" title="XOR decode first layer" /></p>

<p>This layer is designed to rebuild the larger blob that was previously saved off and then XOR decoded and LZNT decompressed if needed. Unfortunately the values used to rebuild are not static, you will need the number of bytes to copy over and the number of bytes to skip. Pulling out these values is possible through a number of ways but probably the easiest is to simply regex them out of the decoded layer.</p>

<p><img src="/assets/plurox_packer/plurox_compare_edit.png" alt="Comparison of decoded layer2" title="Comparison of decoded layer2" /></p>

<p>So for creating an unpacker we need to do the following steps:</p>

<pre><code class="language-psuedocode">1. Load the PE file in memory mapped form
2. Get the OEP (entry point)
3. Find the encoded blob of strings
4. Find the two data blobs using the byte chunks from the decoded strings
5. Find the XOR key
6. Decode the second layer code
7. Get the value for bytes copied and bytes skipped
8. Rebuild the encoded payload using values from 7
9. Decode rebuilt payload
10. Check if compressed
11. Write to disk
</code></pre>

<p>Some of the pieces from above will be quickly glossed over because they are self explanatory, if these pieces are more technically advanced than you are ready for you can skip them by all means and just read the comments that way you can hopefully understand my thought process while I constructed the code which could be beneficial while learning.</p>

<p>For loading the PE file into memory and getting the OEP we will use pefile in python.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
	<span class="n">fdata</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">'rb'</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
	<span class="n">pe</span> <span class="o">=</span> <span class="n">pefile</span><span class="o">.</span><span class="n">PE</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">fdata</span><span class="p">)</span>
	<span class="n">oep</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">OPTIONAL_HEADER</span><span class="o">.</span><span class="n">AddressOfEntryPoint</span>
	<span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
	<span class="n">memmapped</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">get_memory_mapped_image</span><span class="p">()</span>
</code></pre></div></div>

<p>At this point we want to try to limit our scope, the encoded blob of strings appears to normally be near the OEP so we can probably try to brute it out within a limited scope of bytes.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">data</span> <span class="o">=</span> <span class="n">memmapped</span><span class="p">[</span><span class="n">oep</span><span class="p">:</span><span class="n">oep</span><span class="o">+</span><span class="mh">0x1000</span><span class="p">]</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">24</span><span class="p">):</span>
		<span class="n">test_k</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">])</span>
		<span class="n">test_v</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mh">0x100</span><span class="p">])</span>
		<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">test_v</span><span class="p">)):</span>
			<span class="n">test_v</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">^=</span> <span class="n">test_k</span><span class="p">[</span><span class="n">j</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">test_k</span><span class="p">)]</span>
		<span class="k">if</span> <span class="s">'Alloc'</span> <span class="ow">in</span> <span class="n">test_v</span> <span class="ow">or</span> <span class="s">'Process'</span> <span class="ow">in</span> <span class="n">test_v</span> <span class="ow">or</span> <span class="s">'Decompress'</span> <span class="ow">in</span> <span class="n">test_v</span><span class="p">:</span>
			<span class="k">print</span><span class="p">(</span><span class="s">"Found it"</span><span class="p">)</span>
			<span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
			<span class="k">break</span>
</code></pre></div></div>

<p>So we are looping through the first 0x1000 bytes after the OEP to try to find encoded string bytes. After finding the start we just need to XOR decode the chunk which is semi redundant because we just did it for our testing loop and then split up the strings. Technically we only need the first 16 bytes but I figured it’d be good to add in code that can quickly parse and dump the strings to look for the different domains being used.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">if</span> <span class="n">found</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
		<span class="n">blob</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mh">0x100</span><span class="p">])</span>
		<span class="n">key</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">])</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">blob</span><span class="p">)):</span>
			<span class="n">blob</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^=</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>
		<span class="k">if</span> <span class="s">'</span><span class="se">\x00\x00\x00</span><span class="s">'</span> <span class="ow">in</span> <span class="n">blob</span><span class="p">:</span>
			<span class="n">conf</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">blob</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'</span><span class="se">\x00\x00\x00</span><span class="s">'</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">conf</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>Next we will pull out the two blobs using the first 16 bytes from the decoded strings</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="n">off1</span> <span class="o">=</span> <span class="n">fdata</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">conf</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">8</span><span class="p">])</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">fdata</span><span class="p">[</span><span class="n">off1</span><span class="o">+</span><span class="mi">8</span><span class="p">:]</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">conf</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">8</span><span class="p">])</span>
		<span class="n">blob1</span> <span class="o">=</span> <span class="n">fdata</span><span class="p">[</span><span class="n">off1</span><span class="o">+</span><span class="mi">8</span><span class="p">:</span><span class="n">off1</span><span class="o">+</span><span class="n">l</span><span class="o">+</span><span class="mi">8</span><span class="p">]</span>
		
		<span class="n">off2</span> <span class="o">=</span> <span class="n">fdata</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">conf</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">8</span><span class="p">:</span><span class="mi">16</span><span class="p">])</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">fdata</span><span class="p">[</span><span class="n">off2</span><span class="o">+</span><span class="mi">8</span><span class="p">:]</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">conf</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">8</span><span class="p">:</span><span class="mi">16</span><span class="p">])</span>
		<span class="n">blob2</span> <span class="o">=</span> <span class="n">fdata</span><span class="p">[</span><span class="n">off2</span><span class="o">+</span><span class="mi">8</span><span class="p">:</span><span class="n">off2</span><span class="o">+</span><span class="n">l</span><span class="o">+</span><span class="mi">8</span><span class="p">]</span>
</code></pre></div></div>

<p>Now we’re going to do something a little interesting, this is why I enjoy writing scripts like this also. After gathering enough samples and dumping enough layer2s we can start to see byte patterns emerge, now we could just resolve the domain and boom we have our XOR key but that’s no fun. So if you go back up to the comparison picture you’ll notice some overlap of bytes in the decoded layer2 but more importantly I noticed the 4 bytes after the first 3 bytes remain pretty static across many samples tested.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="n">known_val</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="s">'</span><span class="se">\x01\xc0\x6a\x04</span><span class="s">'</span><span class="p">)</span>
</code></pre></div></div>

<p>So to get the XOR key we just need to XOR the known value with the encoded bytes in the same place and then fixup the key position because we went 3 bytes in instead of 4.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="n">key</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">blob1</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">7</span><span class="p">])</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)):</span>
			<span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^=</span> <span class="n">known_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">+</span><span class="n">key</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">blob1</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">)):</span>
			<span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^=</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>
</code></pre></div></div>

<p>Now we have our layer2 decoded code that we can regex out the values we need.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="n">matches</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'''</span><span class="se">\xb9</span><span class="s">.</span><span class="se">\x00\x00\x00\xf3\xa4\x83\xc6</span><span class="s">.</span><span class="se">\x83\xe8</span><span class="s">'''</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">chunk_length</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">addval</span><span class="p">)</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack_from</span><span class="p">(</span><span class="s">'&lt;BBIBHB'</span><span class="p">,</span><span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">out</span> <span class="o">=</span> <span class="s">""</span>
			<span class="n">total_block</span> <span class="o">=</span> <span class="n">chunk_length</span> <span class="o">+</span> <span class="n">addval</span>
</code></pre></div></div>

<p>So we can now fixup our other blob of data by copying over the chunks.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">blob2</span><span class="p">):</span>
				<span class="n">out</span> <span class="o">+=</span> <span class="n">blob2</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">chunk_length</span><span class="p">]</span>
				<span class="n">i</span> <span class="o">+=</span> <span class="n">total_block</span>
			<span class="n">out2</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</code></pre></div></div>

<p>Then we just XOR using the same key and check if we need to decompress.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">out2</span><span class="p">)):</span>
				<span class="n">out2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^=</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>
			<span class="k">if</span> <span class="s">'MZ'</span> <span class="o">!=</span> <span class="n">out2</span><span class="p">[:</span><span class="mi">2</span><span class="p">]:</span>
				<span class="n">out3</span> <span class="o">=</span> <span class="n">lznt_p</span><span class="o">.</span><span class="n">decompress_data</span><span class="p">(</span><span class="n">out2</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">out3</span> <span class="o">=</span> <span class="n">out2</span>
			<span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="s">'_embedded.bin'</span><span class="p">,</span> <span class="s">'wb'</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">out3</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">print</span><span class="p">(</span><span class="s">"Unknown layer2!"</span><span class="p">)</span>
</code></pre></div></div>

<p>Writing public unpackers basically is doing QA or quality assurance for the guys writing the packers but sometimes it’s good to do to prove or disprove a theory such as the one I stated above about this layer being a packer layer versus related to Plurox. It’s also good because it can prove beneficial to aspiring malware researchers out there, it’s usually easier to learn through mimicry so hopefully the above is useful to someone out there.</p>

<p>Now after unpacking a few samples I noticed a few interesting things:</p>
<ul>
  <li>There’s more than one domain used by this</li>
  <li>This is indeed a packer used by more than just Plurox</li>
</ul>

<p>I only did a few samples but I found the following domains being leveraged:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>google-public-dns-b.google.com
google-public-dns-a.google.com
example.com
</code></pre></div></div>

<p>I also pretty quickly found a sample that unpacks to a DarkComet sample:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MD5 	7e12e4b19e000e30385fc995db4fe837
SHA-1 	2dacc210e01f380765c7b9fe0dcf7f650f98bbde
SHA-256 	e0bdab9458543ac59ce6030e3b66dd503c2c35c04596eb3e9e30188223946155
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[+] Printing Config to screen
   [-] Key: CHANGEDATE	 Value: 0
   [-] Key: COMBOPATH	 Value: 3
   [-] Key: DIRATTRIB	 Value: 0
   [-] Key: EDTDATE	 Value: 16/04/2007
   [-] Key: EDTPATH	 Value: Soft\olp32.exe
   [-] Key: FILEATTRIB	 Value: 0
   [-] Key: FTPHOST	 Value: 
   [-] Key: FTPPASS	 Value: 
   [-] Key: FTPPORT	 Value: 
   [-] Key: FTPROOT	 Value: 
   [-] Key: FTPSIZE	 Value: 
   [-] Key: FTPUPLOADK	 Value: 
   [-] Key: FTPUSER	 Value: 
   [-] Key: FWB	 Value: 0
   [-] Key: GENCODE	 Value: 8Ub1461JKvo2
   [-] Key: INSTALL	 Value: 1
   [-] Key: KEYNAME	 Value: OLP Software
   [-] Key: MELT	 Value: 0
   [-] Key: MUTEX	 Value: CMQCKTN
   [-] Key: NETDATA	 Value: 185.146.157.143:1604
   [-] Key: OFFLINEK	 Value: 1
   [-] Key: PERSINST	 Value: 0
   [-] Key: PWD	 Value: 
   [-] Key: SID	 Value: VM
[+] End of Config
</code></pre></div></div>

<p>Some other samples using the protection layer:</p>

<p>Azorult:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MD5 	2cf6634a78c734876377d13f7cd4c178
SHA-1 	d63616dd6e69218c709fffce76834406ab52e6f6
SHA-256 	6e70a71063acdd9570fea8698d090d87e4767f80a643e121839b4449924f2d8c
</code></pre></div></div>

<p>Baldr:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MD5 	21661041c0912c97cbc9f1e16e5f5d06
SHA-1 	19117be8e15e08acba72a1d7c732bf2e87cb4992
SHA-256 	f1ea3330bf0b5bf426328d41b0faae689366070b4013e92fe87cc1de55eba2c6
</code></pre></div></div>

<p>Clipboard crypto wallet replacer</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MD5 	ea3a524f3375232661bbee54367d92ba
SHA-1 	9a000e8d1b11c7d35af1f54c626e812b41ab0e64
SHA-256 	bdde9b0ca484ca08e0572b846f2a7ba989d999898ce1c095d0b4b678993b8d28
</code></pre></div></div>

<p>References:</p>
<ol>
  <li>https://github.com/erocarrera/pefile</li>
  <li>https://github.com/google/rekall/blob/master/rekall-core/rekall/plugins/filesystems/lznt1.py</li>
  <li>https://github.com/rapid7/metasploit-framework</li>
  <li>https://github.com/kevthehermit/RATDecoders</li>
</ol>


  </div><a class="u-url" href="/malware,/crypters/2019/09/23/Plurox-packer-layer-unpacked.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Random RE</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Random RE</li><li><a class="u-email" href="mailto:sysopfb@gmail.com">sysopfb@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/sysopfb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">sysopfb</span></a></li><li><a href="https://www.twitter.com/sysopfb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">sysopfb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Place for me to dump random RE posts mostly revolving around Malware.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
