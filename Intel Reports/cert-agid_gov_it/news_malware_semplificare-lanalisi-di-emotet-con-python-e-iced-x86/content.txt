<!DOCTYPE html>
<!--[if IE 8]><html class="no-js ie89 ie8" lang="it"><![endif]-->
<!--[if IE 9]><html class="no-js ie89 ie9" lang="it"><![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<html class="no-js" lang="it-IT"
xmlns:og="http://opengraphprotocol.org/schema/"
xmlns:fb="http://www.facebook.com/2008/fbml"
prefix="og: http://ogp.me/ns#">
<!--<![endif]-->


<head>
  <meta charset="UTF-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="preload" href="/wp-content/themes/cert-agid/build/IWT.min.js" as="script">
  <link href='https://fonts.googleapis.com/css?family=Titillium+Web:300,400,400i,600,700,' rel='stylesheet' type='text/css' />

  <link rel="stylesheet" href="/wp-content/themes/cert-agid/assets/css/brands.min.css">
  <link rel="stylesheet" href="/wp-content/themes/cert-agid/assets/css/fa-all.css">
  <link rel="icon" type="image/png" href="/wp-content/themes/cert-agid/assets/images/favicon.png">

  <script src="/wp-content/themes/cert-agid/build/vendor/modernizr.js"></script>
  <link media="all" rel="stylesheet" href="/wp-content/themes/cert-agid/style.css?v=2">
  <link media="all" rel="stylesheet" href="/wp-content/themes/cert-agid/build/build.css?v=1">
  
  <script src="/wp-content/themes/cert-agid/assets/js/jquery-1.12.4.min.js"></script>

  <title>Semplificare l&#8217;analisi di Emotet con Python e iced x86 &#8211; CERT-AGID</title>
<meta name='robots' content='max-image-preview:large' />
	<style>img:is([sizes="auto" i], [sizes^="auto," i]) { contain-intrinsic-size: 3000px 1500px }</style>
	<script type="text/javascript">
/* <![CDATA[ */
window._wpemojiSettings = {"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/15.0.3\/72x72\/","ext":".png","svgUrl":"https:\/\/s.w.org\/images\/core\/emoji\/15.0.3\/svg\/","svgExt":".svg","source":{"concatemoji":"https:\/\/cert-agid.gov.it\/wp-includes\/js\/wp-emoji-release.min.js?ver=6.7.1"}};
/*! This file is auto-generated */
!function(i,n){var o,s,e;function c(e){try{var t={supportTests:e,timestamp:(new Date).valueOf()};sessionStorage.setItem(o,JSON.stringify(t))}catch(e){}}function p(e,t,n){e.clearRect(0,0,e.canvas.width,e.canvas.height),e.fillText(t,0,0);var t=new Uint32Array(e.getImageData(0,0,e.canvas.width,e.canvas.height).data),r=(e.clearRect(0,0,e.canvas.width,e.canvas.height),e.fillText(n,0,0),new Uint32Array(e.getImageData(0,0,e.canvas.width,e.canvas.height).data));return t.every(function(e,t){return e===r[t]})}function u(e,t,n){switch(t){case"flag":return n(e,"\ud83c\udff3\ufe0f\u200d\u26a7\ufe0f","\ud83c\udff3\ufe0f\u200b\u26a7\ufe0f")?!1:!n(e,"\ud83c\uddfa\ud83c\uddf3","\ud83c\uddfa\u200b\ud83c\uddf3")&&!n(e,"\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc65\udb40\udc6e\udb40\udc67\udb40\udc7f","\ud83c\udff4\u200b\udb40\udc67\u200b\udb40\udc62\u200b\udb40\udc65\u200b\udb40\udc6e\u200b\udb40\udc67\u200b\udb40\udc7f");case"emoji":return!n(e,"\ud83d\udc26\u200d\u2b1b","\ud83d\udc26\u200b\u2b1b")}return!1}function f(e,t,n){var r="undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?new OffscreenCanvas(300,150):i.createElement("canvas"),a=r.getContext("2d",{willReadFrequently:!0}),o=(a.textBaseline="top",a.font="600 32px Arial",{});return e.forEach(function(e){o[e]=t(a,e,n)}),o}function t(e){var t=i.createElement("script");t.src=e,t.defer=!0,i.head.appendChild(t)}"undefined"!=typeof Promise&&(o="wpEmojiSettingsSupports",s=["flag","emoji"],n.supports={everything:!0,everythingExceptFlag:!0},e=new Promise(function(e){i.addEventListener("DOMContentLoaded",e,{once:!0})}),new Promise(function(t){var n=function(){try{var e=JSON.parse(sessionStorage.getItem(o));if("object"==typeof e&&"number"==typeof e.timestamp&&(new Date).valueOf()<e.timestamp+604800&&"object"==typeof e.supportTests)return e.supportTests}catch(e){}return null}();if(!n){if("undefined"!=typeof Worker&&"undefined"!=typeof OffscreenCanvas&&"undefined"!=typeof URL&&URL.createObjectURL&&"undefined"!=typeof Blob)try{var e="postMessage("+f.toString()+"("+[JSON.stringify(s),u.toString(),p.toString()].join(",")+"));",r=new Blob([e],{type:"text/javascript"}),a=new Worker(URL.createObjectURL(r),{name:"wpTestEmojiSupports"});return void(a.onmessage=function(e){c(n=e.data),a.terminate(),t(n)})}catch(e){}c(n=f(s,u,p))}t(n)}).then(function(e){for(var t in e)n.supports[t]=e[t],n.supports.everything=n.supports.everything&&n.supports[t],"flag"!==t&&(n.supports.everythingExceptFlag=n.supports.everythingExceptFlag&&n.supports[t]);n.supports.everythingExceptFlag=n.supports.everythingExceptFlag&&!n.supports.flag,n.DOMReady=!1,n.readyCallback=function(){n.DOMReady=!0}}).then(function(){return e}).then(function(){var e;n.supports.everything||(n.readyCallback(),(e=n.source||{}).concatemoji?t(e.concatemoji):e.wpemoji&&e.twemoji&&(t(e.twemoji),t(e.wpemoji)))}))}((window,document),window._wpemojiSettings);
/* ]]> */
</script>
<style id='wp-emoji-styles-inline-css' type='text/css'>

	img.wp-smiley, img.emoji {
		display: inline !important;
		border: none !important;
		box-shadow: none !important;
		height: 1em !important;
		width: 1em !important;
		margin: 0 0.07em !important;
		vertical-align: -0.1em !important;
		background: none !important;
		padding: 0 !important;
	}
</style>
<link rel='stylesheet' id='wp-block-library-css' href='https://cert-agid.gov.it/wp-includes/css/dist/block-library/style.min.css?ver=6.7.1' type='text/css' media='all' />
<style id='highcode-highcode-style-inline-css' type='text/css'>
.wp-block-highcode-highcode{border-radius:.3em;display:block;font-family:monospace;font-size:1em;margin:1.3em auto;max-height:28em;overflow:auto;padding:1.2em!important;white-space:pre;width:100%}

</style>
<style id='classic-theme-styles-inline-css' type='text/css'>
/*! This file is auto-generated */
.wp-block-button__link{color:#fff;background-color:#32373c;border-radius:9999px;box-shadow:none;text-decoration:none;padding:calc(.667em + 2px) calc(1.333em + 2px);font-size:1.125em}.wp-block-file__button{background:#32373c;color:#fff;text-decoration:none}
</style>
<style id='global-styles-inline-css' type='text/css'>
:root{--wp--preset--aspect-ratio--square: 1;--wp--preset--aspect-ratio--4-3: 4/3;--wp--preset--aspect-ratio--3-4: 3/4;--wp--preset--aspect-ratio--3-2: 3/2;--wp--preset--aspect-ratio--2-3: 2/3;--wp--preset--aspect-ratio--16-9: 16/9;--wp--preset--aspect-ratio--9-16: 9/16;--wp--preset--color--black: #000000;--wp--preset--color--cyan-bluish-gray: #abb8c3;--wp--preset--color--white: #ffffff;--wp--preset--color--pale-pink: #f78da7;--wp--preset--color--vivid-red: #cf2e2e;--wp--preset--color--luminous-vivid-orange: #ff6900;--wp--preset--color--luminous-vivid-amber: #fcb900;--wp--preset--color--light-green-cyan: #7bdcb5;--wp--preset--color--vivid-green-cyan: #00d084;--wp--preset--color--pale-cyan-blue: #8ed1fc;--wp--preset--color--vivid-cyan-blue: #0693e3;--wp--preset--color--vivid-purple: #9b51e0;--wp--preset--gradient--vivid-cyan-blue-to-vivid-purple: linear-gradient(135deg,rgba(6,147,227,1) 0%,rgb(155,81,224) 100%);--wp--preset--gradient--light-green-cyan-to-vivid-green-cyan: linear-gradient(135deg,rgb(122,220,180) 0%,rgb(0,208,130) 100%);--wp--preset--gradient--luminous-vivid-amber-to-luminous-vivid-orange: linear-gradient(135deg,rgba(252,185,0,1) 0%,rgba(255,105,0,1) 100%);--wp--preset--gradient--luminous-vivid-orange-to-vivid-red: linear-gradient(135deg,rgba(255,105,0,1) 0%,rgb(207,46,46) 100%);--wp--preset--gradient--very-light-gray-to-cyan-bluish-gray: linear-gradient(135deg,rgb(238,238,238) 0%,rgb(169,184,195) 100%);--wp--preset--gradient--cool-to-warm-spectrum: linear-gradient(135deg,rgb(74,234,220) 0%,rgb(151,120,209) 20%,rgb(207,42,186) 40%,rgb(238,44,130) 60%,rgb(251,105,98) 80%,rgb(254,248,76) 100%);--wp--preset--gradient--blush-light-purple: linear-gradient(135deg,rgb(255,206,236) 0%,rgb(152,150,240) 100%);--wp--preset--gradient--blush-bordeaux: linear-gradient(135deg,rgb(254,205,165) 0%,rgb(254,45,45) 50%,rgb(107,0,62) 100%);--wp--preset--gradient--luminous-dusk: linear-gradient(135deg,rgb(255,203,112) 0%,rgb(199,81,192) 50%,rgb(65,88,208) 100%);--wp--preset--gradient--pale-ocean: linear-gradient(135deg,rgb(255,245,203) 0%,rgb(182,227,212) 50%,rgb(51,167,181) 100%);--wp--preset--gradient--electric-grass: linear-gradient(135deg,rgb(202,248,128) 0%,rgb(113,206,126) 100%);--wp--preset--gradient--midnight: linear-gradient(135deg,rgb(2,3,129) 0%,rgb(40,116,252) 100%);--wp--preset--font-size--small: 13px;--wp--preset--font-size--medium: 20px;--wp--preset--font-size--large: 36px;--wp--preset--font-size--x-large: 42px;--wp--preset--spacing--20: 0.44rem;--wp--preset--spacing--30: 0.67rem;--wp--preset--spacing--40: 1rem;--wp--preset--spacing--50: 1.5rem;--wp--preset--spacing--60: 2.25rem;--wp--preset--spacing--70: 3.38rem;--wp--preset--spacing--80: 5.06rem;--wp--preset--shadow--natural: 6px 6px 9px rgba(0, 0, 0, 0.2);--wp--preset--shadow--deep: 12px 12px 50px rgba(0, 0, 0, 0.4);--wp--preset--shadow--sharp: 6px 6px 0px rgba(0, 0, 0, 0.2);--wp--preset--shadow--outlined: 6px 6px 0px -3px rgba(255, 255, 255, 1), 6px 6px rgba(0, 0, 0, 1);--wp--preset--shadow--crisp: 6px 6px 0px rgba(0, 0, 0, 1);}:where(.is-layout-flex){gap: 0.5em;}:where(.is-layout-grid){gap: 0.5em;}body .is-layout-flex{display: flex;}.is-layout-flex{flex-wrap: wrap;align-items: center;}.is-layout-flex > :is(*, div){margin: 0;}body .is-layout-grid{display: grid;}.is-layout-grid > :is(*, div){margin: 0;}:where(.wp-block-columns.is-layout-flex){gap: 2em;}:where(.wp-block-columns.is-layout-grid){gap: 2em;}:where(.wp-block-post-template.is-layout-flex){gap: 1.25em;}:where(.wp-block-post-template.is-layout-grid){gap: 1.25em;}.has-black-color{color: var(--wp--preset--color--black) !important;}.has-cyan-bluish-gray-color{color: var(--wp--preset--color--cyan-bluish-gray) !important;}.has-white-color{color: var(--wp--preset--color--white) !important;}.has-pale-pink-color{color: var(--wp--preset--color--pale-pink) !important;}.has-vivid-red-color{color: var(--wp--preset--color--vivid-red) !important;}.has-luminous-vivid-orange-color{color: var(--wp--preset--color--luminous-vivid-orange) !important;}.has-luminous-vivid-amber-color{color: var(--wp--preset--color--luminous-vivid-amber) !important;}.has-light-green-cyan-color{color: var(--wp--preset--color--light-green-cyan) !important;}.has-vivid-green-cyan-color{color: var(--wp--preset--color--vivid-green-cyan) !important;}.has-pale-cyan-blue-color{color: var(--wp--preset--color--pale-cyan-blue) !important;}.has-vivid-cyan-blue-color{color: var(--wp--preset--color--vivid-cyan-blue) !important;}.has-vivid-purple-color{color: var(--wp--preset--color--vivid-purple) !important;}.has-black-background-color{background-color: var(--wp--preset--color--black) !important;}.has-cyan-bluish-gray-background-color{background-color: var(--wp--preset--color--cyan-bluish-gray) !important;}.has-white-background-color{background-color: var(--wp--preset--color--white) !important;}.has-pale-pink-background-color{background-color: var(--wp--preset--color--pale-pink) !important;}.has-vivid-red-background-color{background-color: var(--wp--preset--color--vivid-red) !important;}.has-luminous-vivid-orange-background-color{background-color: var(--wp--preset--color--luminous-vivid-orange) !important;}.has-luminous-vivid-amber-background-color{background-color: var(--wp--preset--color--luminous-vivid-amber) !important;}.has-light-green-cyan-background-color{background-color: var(--wp--preset--color--light-green-cyan) !important;}.has-vivid-green-cyan-background-color{background-color: var(--wp--preset--color--vivid-green-cyan) !important;}.has-pale-cyan-blue-background-color{background-color: var(--wp--preset--color--pale-cyan-blue) !important;}.has-vivid-cyan-blue-background-color{background-color: var(--wp--preset--color--vivid-cyan-blue) !important;}.has-vivid-purple-background-color{background-color: var(--wp--preset--color--vivid-purple) !important;}.has-black-border-color{border-color: var(--wp--preset--color--black) !important;}.has-cyan-bluish-gray-border-color{border-color: var(--wp--preset--color--cyan-bluish-gray) !important;}.has-white-border-color{border-color: var(--wp--preset--color--white) !important;}.has-pale-pink-border-color{border-color: var(--wp--preset--color--pale-pink) !important;}.has-vivid-red-border-color{border-color: var(--wp--preset--color--vivid-red) !important;}.has-luminous-vivid-orange-border-color{border-color: var(--wp--preset--color--luminous-vivid-orange) !important;}.has-luminous-vivid-amber-border-color{border-color: var(--wp--preset--color--luminous-vivid-amber) !important;}.has-light-green-cyan-border-color{border-color: var(--wp--preset--color--light-green-cyan) !important;}.has-vivid-green-cyan-border-color{border-color: var(--wp--preset--color--vivid-green-cyan) !important;}.has-pale-cyan-blue-border-color{border-color: var(--wp--preset--color--pale-cyan-blue) !important;}.has-vivid-cyan-blue-border-color{border-color: var(--wp--preset--color--vivid-cyan-blue) !important;}.has-vivid-purple-border-color{border-color: var(--wp--preset--color--vivid-purple) !important;}.has-vivid-cyan-blue-to-vivid-purple-gradient-background{background: var(--wp--preset--gradient--vivid-cyan-blue-to-vivid-purple) !important;}.has-light-green-cyan-to-vivid-green-cyan-gradient-background{background: var(--wp--preset--gradient--light-green-cyan-to-vivid-green-cyan) !important;}.has-luminous-vivid-amber-to-luminous-vivid-orange-gradient-background{background: var(--wp--preset--gradient--luminous-vivid-amber-to-luminous-vivid-orange) !important;}.has-luminous-vivid-orange-to-vivid-red-gradient-background{background: var(--wp--preset--gradient--luminous-vivid-orange-to-vivid-red) !important;}.has-very-light-gray-to-cyan-bluish-gray-gradient-background{background: var(--wp--preset--gradient--very-light-gray-to-cyan-bluish-gray) !important;}.has-cool-to-warm-spectrum-gradient-background{background: var(--wp--preset--gradient--cool-to-warm-spectrum) !important;}.has-blush-light-purple-gradient-background{background: var(--wp--preset--gradient--blush-light-purple) !important;}.has-blush-bordeaux-gradient-background{background: var(--wp--preset--gradient--blush-bordeaux) !important;}.has-luminous-dusk-gradient-background{background: var(--wp--preset--gradient--luminous-dusk) !important;}.has-pale-ocean-gradient-background{background: var(--wp--preset--gradient--pale-ocean) !important;}.has-electric-grass-gradient-background{background: var(--wp--preset--gradient--electric-grass) !important;}.has-midnight-gradient-background{background: var(--wp--preset--gradient--midnight) !important;}.has-small-font-size{font-size: var(--wp--preset--font-size--small) !important;}.has-medium-font-size{font-size: var(--wp--preset--font-size--medium) !important;}.has-large-font-size{font-size: var(--wp--preset--font-size--large) !important;}.has-x-large-font-size{font-size: var(--wp--preset--font-size--x-large) !important;}
:where(.wp-block-post-template.is-layout-flex){gap: 1.25em;}:where(.wp-block-post-template.is-layout-grid){gap: 1.25em;}
:where(.wp-block-columns.is-layout-flex){gap: 2em;}:where(.wp-block-columns.is-layout-grid){gap: 2em;}
:root :where(.wp-block-pullquote){font-size: 1.5em;line-height: 1.6;}
</style>
<script type="text/javascript" src="https://cert-agid.gov.it/wp-includes/js/jquery/jquery.min.js?ver=3.7.1" id="jquery-core-js"></script>
<script type="text/javascript" src="https://cert-agid.gov.it/wp-includes/js/jquery/jquery-migrate.min.js?ver=3.4.1" id="jquery-migrate-js"></script>
<link rel="https://api.w.org/" href="https://cert-agid.gov.it/wp-json/" /><link rel="alternate" title="JSON" type="application/json" href="https://cert-agid.gov.it/wp-json/wp/v2/posts/1513" /><link rel="canonical" href="https://cert-agid.gov.it/news/malware/semplificare-lanalisi-di-emotet-con-python-e-iced-x86/" />
<link rel='shortlink' href='https://cert-agid.gov.it/?p=1513' />
<link rel="alternate" title="oEmbed (JSON)" type="application/json+oembed" href="https://cert-agid.gov.it/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fcert-agid.gov.it%2Fnews%2Fmalware%2Fsemplificare-lanalisi-di-emotet-con-python-e-iced-x86%2F" />
<link rel="alternate" title="oEmbed (XML)" type="text/xml+oembed" href="https://cert-agid.gov.it/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fcert-agid.gov.it%2Fnews%2Fmalware%2Fsemplificare-lanalisi-di-emotet-con-python-e-iced-x86%2F&#038;format=xml" />
<meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@certagid" /><meta property="og:title" content="Semplificare l&#8217;analisi di Emotet con Python e iced x86"/><meta property="og:type" content="article"/><meta property="og:url" content="https://cert-agid.gov.it/news/malware/semplificare-lanalisi-di-emotet-con-python-e-iced-x86/"/><meta property="og:site_name" content="CERT-AGID"/><meta property="og:description" content="Semplificare l&#8217;analisi di Emotet con Python e iced x86"/><meta property="og:image" content="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-130-300x212.png"/></head>

<body class="post-template-default single single-post postid-1513 single-format-standard t-certagid">
  <ul class="Skiplinks js-fr-bypasslinks u-hiddenPrint">
    <li><a href="#main">Vai al contenuto</a></li>
    <li><a class="js-fr-offcanvas-open" href="#menu" aria-controls="menu" aria-label="accedi al menu" title="accedi al menu">Vai alla navigazione del sito</a></li>
  </ul>





  <header class="Header  u-hiddenPrint">
    <div class="Header-banner ">
      <div class="u-layout-wide Grid Grid--alignMiddle u-layoutCenter">
	<div class="Grid-cell"  aria-hidden="true" style="padding: 5px 0;">
	  <div style="float:right;">

	    <ul class="top-menu u-hidden u-sm-hidden u-md-inlineBlock u-lg-inlineBlock" >

	    </ul>


          </div>
        </div>
      </div>
    </div>


    <div class="Header-navbar ">
	<div class="u-layout-wide Grid Grid--alignMiddle u-layoutCenter">
        <div class="Header-logo Grid-cell" aria-hidden="true">
          <a href="https://cert-agid.gov.it/" tabindex="-1">
            <img src="/wp-content/themes/cert-agid/assets/images/cert-agid-logo-white.svg" alt="Logo CERT-AGID">
          </a>
        </div>

        <div class="Header-title Grid-cell u-xs-larger">
          <h1 class="Header-titleLink">
            <a href="https://cert-agid.gov.it/" class="u-xs-font-reduced" style="text-decoration: none !important; padding-top:13px;">
              CERT-AGID	      
              <br class="Header-subTitle-break">
	      
	      <span class="Header-subTitle">
Computer Emergency Response Team<br>AGID              </span>
            </a>
          </h1>
        </div>


	<div class="Header-logo2 Grid-cell u-size3of12 u-sm-size2of12 u-md-size4of12 u-lg-size4of12 u-hidden u-sm-block u-md-block u-lg-block">

 	    <div class="title u-hidden u-sm-hidden u-md-inlineBlock u-lg-inlineBlock" style="float:right; vertical-align:middle;">
              <a href="https://www.agid.gov.it">Agenzia per<br>l'Italia Digitale</a>
	    </div>

            <div class="u-hidden u-sm-hidden u-md-inlineBlock u-lg-inlineBlock" style="float:right; padding-top:6px; vertical-align: middle;">  
	      <a href="https://www.agid.gov.it" tabindex="-1">
                <img class="logo" 
                     src="/wp-content/themes/cert-agid/assets/images/logo-agid.svg" 
                     alt="Logo AgID - Agenzia per l'Italia Digitale">
	      </a>
	    </div>

	</div>

        <div class="Header-searchTrigger Grid-cell">
          <button aria-controls="header-search" class="js-Header-search-trigger Icon Icon-search " title="attiva il form di ricerca" aria-label="attiva il form di ricerca" aria-hidden="false"></button>
          <button aria-controls="header-search" class="js-Header-search-trigger Icon Icon-close u-hidden " title="disattiva il form di ricerca" aria-label="disattiva il form di ricerca" aria-hidden="true"></button>
        </div>
	
	<div class="Header-utils Grid-cell">
          <div class="Header-social Headroom-hideme">
            <p>Seguici su</p>
            <ul class="Header-socialIcons">              <li>
                <a href="https://cert-agid.gov.it/feed/" title="RSS">
                  <span class="Icon Icon-rss"></span>
                  <span class="u-hiddenVisually">RSS</span>
                </a>
              </li>
              <li>
                <a href="https://t.me/certagid" title="Telegram">
                  <span class="fab fa-telegram-plane"></span>
                  <span class="u-hiddenVisually">Telegram</span>
                </a>
              </li>
              <li>
                <a href="https://twitter.com/agidcert" title="X / Twitter">
                  <span class="fa-brands fa-x-twitter"></span>
                  <span class="u-hiddenVisually">X / Twitter</span>
                </a>
              </li>
</ul>
	  </div>
          <div class="Header-search" id="header-search">
            <form class="Form" action="/">
              <div class="Form-field Form-field--withPlaceholder Grid u-background-white u-color-grey-30 u-borderRadius-s" role="search">
                <input name="s" class="Form-input Form-input--ultraLean Grid-cell u-sizeFill u-text-r-s u-color-black u-text-r-xs u-borderRadius-s" required id="cerca" value="">
                <label class="Form-label u-color-grey-50 u-text-r-xxs" for="cerca">cerca nel sito</label>
                <button class="clickable Grid-cell u-sizeFit Icon-search Icon--rotated u-color-grey-50 u-padding-all-s u-textWeight-700" title="Avvia la ricerca" aria-label="Avvia la ricerca"></button>
              </div>
            </form>
          </div>
        </div>
    
        <div class="Header-toggle Grid-cell">
          <a class="Hamburger-toggleContainer js-fr-offcanvas-open u-nojsDisplayInlineBlock u-lg-hidden u-md-hidden" href="#menu" aria-controls="menu" aria-label="accedi al menu" title="accedi al menu">
        		<span class="Hamburger-toggle" role="presentation"></span>
            <span class="Header-toggleText" role="presentation">Menu</span>          </a>
        </div>

      </div>
    </div>
    <!-- Header-navbar -->


    <div class="Headroom-hideme u-textCenter u-hidden u-sm-hidden u-md-block u-lg-block">
        <nav class="Megamenu Megamenu--default js-megamenu " data-rel=".Offcanvas .Treeview"></nav>
    </div>
  </header>

  <!-- Print header -->
  <header class="Header-print u-margin-top-xxl u-blockPrint u-hidden">
    <div class="u-layout-wide u-layout-r-withGutter u-layoutCenter">

      <div class="Grid Grid--withGutter Grid--alignMiddle">
        <div class="Grid-cell u-sizeFull" aria-hidden="true">
            
            <div class="Grid Grid--alignMiddle">
              <img class="Grid-cell Footer-logo u-sizeFit" src="/wp-content/themes/cert-agid/assets/images/cert-agid-logo-black.svg" alt="Logo del CERT-PA">
              
              <span class="Grid-cell Footer-siteName u-sizeFit" >CERT-AGID</span>

              <div class="Grid-cell u-sizeFill u-color-print u-text-xl">
                <a href="https://cert-agid.gov.it/" class="Print-link">https://cert-agid.gov.it/</a>
              </div>
            </div>

        </div>
      </div>
    </div>
  </header>

  <section class="Offcanvas Offcanvas--right Offcanvas--modal js-fr-offcanvas u-jsVisibilityHidden u-nojsDisplayNone u-hiddenPrint" id="menu">
    <h2 class="u-hiddenVisually">Menu di navigazione</h2>
    <div class="Offcanvas-content u-background-white">
        <div class="Offcanvas-toggleContainer u-background-70 u-jsHidden">
            <a class="Hamburger-toggleContainer u-block u-color-white u-padding-bottom-xxl u-padding-left-s u-padding-top-xxl js-fr-offcanvas-close" aria-controls="menu" aria-label="esci dalla navigazione" title="esci dalla navigazione" href="#">
              <span class="Hamburger-toggle is-active" aria-hidden="true"></span>
            </a>
        </div>
        <nav>
            <ul class="Linklist Linklist--padded Treeview Treeview--default js-Treeview u-text-r-xs" style="max-width: 180rem !important;">
<li id="menu-item-42" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children menu-item-42"><a href="#">Documentazione</a>
<ul class="sub-menu">
	<li id="menu-item-43" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-43"><a href="https://cert-agid.gov.it/documenti-agid/">Documenti AGID</a></li>
	<li id="menu-item-163" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-163"><a href="https://cert-agid.gov.it/pillole-informative/">Pillole informative</a></li>
	<li id="menu-item-3285" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-3285"><a href="https://cert-agid.gov.it/scarica-il-modulo-accreditamento-feed-ioc/">Flusso IoC</a></li>
</ul>
</li>
<li id="menu-item-13" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-13"><a href="https://cert-agid.gov.it/chi-siamo/">Chi siamo</a></li>
<li id="menu-item-50" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-50"><a href="https://cert-agid.gov.it/contatti/">Contatti</a></li>
<li id="menu-item-16" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children menu-item-16"><a href="https://cert-agid.gov.it/strumenti/">Strumenti</a>
<ul class="sub-menu">
	<li id="menu-item-8727" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-8727"><a href="https://cert-agid.gov.it/hashr/">hashr</a></li>
	<li id="menu-item-3922" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-3922"><a href="https://cert-agid.gov.it/verifica-https-cms/">Verifica HTTPS e CMS</a></li>
	<li id="menu-item-4778" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-4778"><a href="https://cert-agid.gov.it/statistiche/">Statistiche sulle campagne italiane di malware e phishing</a></li>
</ul>
</li>
<li id="menu-item-90" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children menu-item-90"><a href="https://cert-agid.gov.it/glossario/">Glossario</a>
<ul class="sub-menu">
	<li id="menu-item-91" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-91"><a href="https://cert-agid.gov.it/glossario/0day/">0day</a></li>
	<li id="menu-item-92" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-92"><a href="https://cert-agid.gov.it/glossario/botnet/">Botnet</a></li>
	<li id="menu-item-93" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-93"><a href="https://cert-agid.gov.it/glossario/data-breach/">Data breach</a></li>
	<li id="menu-item-94" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-94"><a href="https://cert-agid.gov.it/glossario/ddos-dos/">DDOS-DOS</a></li>
	<li id="menu-item-95" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-95"><a href="https://cert-agid.gov.it/glossario/deep-dark-web/">Deep-Dark web</a></li>
	<li id="menu-item-96" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-96"><a href="https://cert-agid.gov.it/glossario/defacing/">Defacing</a></li>
	<li id="menu-item-97" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-97"><a href="https://cert-agid.gov.it/glossario/exploit/">Exploit</a></li>
	<li id="menu-item-98" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-98"><a href="https://cert-agid.gov.it/glossario/mitm/">MITM</a></li>
	<li id="menu-item-99" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-99"><a href="https://cert-agid.gov.it/glossario/osint-closint/">OSINT-CLOSINT</a></li>
	<li id="menu-item-100" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-100"><a href="https://cert-agid.gov.it/glossario/phishing/">Phishing</a></li>
	<li id="menu-item-101" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-101"><a href="https://cert-agid.gov.it/glossario/privilege-escalation/">Privilege escalation</a></li>
	<li id="menu-item-102" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-102"><a href="https://cert-agid.gov.it/glossario/spam/">Spam</a></li>
	<li id="menu-item-103" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-103"><a href="https://cert-agid.gov.it/glossario/spoofing/">Spoofing</a></li>
	<li id="menu-item-104" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-104"><a href="https://cert-agid.gov.it/glossario/sqli-sql-injection/">SQLi-SQL Injection</a></li>
	<li id="menu-item-105" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-105"><a href="https://cert-agid.gov.it/glossario/xss/">XSS</a></li>
</ul>
</li>
<li id="menu-item-44" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children menu-item-44"><a href="#">Link utili</a>
<ul class="sub-menu">
	<li id="menu-item-45" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-45"><a href="https://www.agid.gov.it/">Agenzia per l&#8217;Italia Digitale</a></li>
	<li id="menu-item-10" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-10"><a href="https://csirt.gov.it">CSIRT Italia</a></li>
	<li id="menu-item-47" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-47"><a href="https://www.cert.garr.it/">CERT-GARR</a></li>
	<li id="menu-item-49" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-49"><a href="https://www.commissariatodips.it/profilo/cnaipic/index.html">CNAIPIC</a></li>
	<li id="menu-item-48" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-48"><a href="https://www.difesa.it/smd/cor/cert-difesa/25338.html">CERT-DIFESA</a></li>
</ul>
</li>
            </ul>
        </nav>
    </div>

   <script type="text/javascript">
	jQuery('.menu-item-has-children > a').addClass('Megamenu-submenu');
   </script>	
  </section>


  <div id="main">
    <div class="main-overlaid"></div>
    <div class="u-layout-wide u-layoutCenter u-layout-r-withGutters">
  
      <div class="Grid Grid-print">

	<div class="menu-menu-categorie-container"><ul id="menu-menu-categorie" class="menu"></li>
</li>
</li>
</li>
</ul></div>	 

        <!-- BREADCRUMB -->
        <div class="Grid-cell u-sizeFull u-md-size2of12 u-lg-size2of12 u-hiddenPrint"></div>

        <div class="Grid-cell u-sizeFull u-md-size8of12 u-lg-size8of12 u-hiddenPrint">
          <section class="u-layout-wide u-layoutCenter u-padding-top-xl u-padding-r-left u-padding-r-right">
            <nav aria-label="sei qui:" role="navigation">
              <ul class="Breadcrumb">
                <li class="Breadcrumb-item"><a class="Breadcrumb-link u-color-50 u-lineHeight-l" href="https://cert-agid.gov.it/">Home</a></li>
                <li class="Breadcrumb-item">
                  <a class="Breadcrumb-link u-color-50 u-lineHeight-l" href="https://cert-agid.gov.it/category/malpedia/">
                    Malpedia                  </a>
                </li>
                <li class="Breadcrumb-item"><span class="u-lineHeight-l" href="/">Semplificare l&#8217;analisi di Emotet con Python e iced x86</span></li>
              </ul>
	    </nav>

	    <div class="u-padding-top-l" style="border-bottom: 1px solid #aaaaaa"></div>
          </section>
        </div>

        <div class="Grid-cell u-sizeFull u-md-size2of12 u-lg-size2of12 u-hiddenPrint"></div>


        <!-- NEWS -->
        <div class="Grid-cell u-sizeFull u-md-size2of12 u-lg-size2of12"></div>

        <div class="Grid-cell u-sizeFull u-md-size8of12 u-lg-size8of12 u-margin-bottom-xl">
          <article id="post-1513" class="u-layout-wide u-layoutCenter u-padding-r-all Post-text post-1513 post type-post status-publish format-standard has-post-thumbnail hentry category-malpedia category-malware tag-emotet">
	    <h1 class="u-text-h2 u-titlePrint WP-Title" style="margin: 2rem 0 !important; ">Semplificare l&#8217;analisi di Emotet con Python e iced x86</h1>

    	    <div class="u-text-l u-color-50 u-margin-top-xs">31/12/2020</div>
	    <br>			<a class="tag-item u-textClean u-textWeight-700 u-text-r-xxs u-color-80-commented u-color-print " href="https://cert-agid.gov.it/tag/emotet/">
				emotet			</a>

            <div class="News-prose u-margin-top-xl">
		
<p>In questi giorni l&#8217;Italia è interessata da campagne Emotet che fanno uso di payload offuscati che rendono l&#8217;analisi statica piuttosto tediosa. In questo caso infatti l&#8217;uso di un debugger non si rileva molto utile.<br>La variante di Emotet analizzata impiega varie tecniche di offuscazione del codice, una di queste è nota come CFO (Control Flow Obfuscation); l&#8217;analisi con il debugger permette di ricostruire stringhe ed API utilizzate ma non aiuta ad avere una visione d&#8217;insieme del codice eseguito.</p>



<p>In questo articolo vedremo come semplificare l&#8217;analisi di Emotet utilizzando Python e la libreria <a href="https://github.com/0xd4d/iced/tree/master/src/rust/iced-x86-py">iced x86</a> per processare il codice offuscato di Emotet.</p>



<p>Ma prima, introduciamo un po&#8217; di contesto sul campione analizzato.</p>



<h2 class="wp-block-heading">Macro, powershell e packer</h2>



<p>Il campione che abbiamo deciso di analizzare risale a qualche giorno fa.<br>La catena di infezione ha inizio con un documento Word (pre 2007) con una macro malevola.</p>



<p>Questa si presenta, come spesso accade, offuscata tramite l&#8217;utilizzo di linee di codice irrilevante.<br>Si riporta di seguito un estratto.</p>



<pre style="font-family: monospace; overflow: auto; font-size:0.9em; background-color:#f0f0f0; max-height:30em;">Function S619csvpd1v4xzk5kc(Xoyqcbzwjyi6tqiw0z)
   GoTo GKsgQaAGE
Dim NmmcJMB As String 'POyDeJ
Open "dVMtDJ.ecCLuZ.vNWxUB" For Binary As 154
Open "GmQlB.gLlkBCq.ohnmP" For Binary As 154
Open "asHdBA.RNUGfJo.UEIiMmoM" For Binary As 154
Put #154, , NmmcJMB
Close #154
GKsgQaAGE:
GoTo fIjVkJj
Dim jFUMUmIIJ As String 'NskblDD
Open "fRHrGnFp.uWltAIHCI.WYWvIWr" For Binary As 146
Open "qQeaRICAm.KgqZFRWRC.cuPrnUFxk" For Binary As 146
Open "ShUECDIR.otrtDOGBA.OugaBFHlJ" For Binary As 146
Put #146, , jFUMUmIIJ
Close #146
fIjVkJj:
GoTo hTTQEJEAC
Dim OybSq As String 'kEafA
Open "umMOXxmA.SfYuGDN.ueONFAEFD" For Binary As 227
Open "eIQhLAGS.forvJhMB.LGyFI" For Binary As 227
Open "TifoEDtFB.fukVJAvIS.dlciFGDA" For Binary As 227
Put #227, , OybSq
Close #227
hTTQEJEAC:
HBYVV = ""
S619csvpd1v4xzk5kc = HBYVV + VBA.Replace _
(Xoyqcbzwjyi6tqiw0z, "qq" + ")(s2)" + "(", W5ya1q1z48ltq3z_)
   GoTo mJsZBCEFo
Dim jUDsXM As String 'gtpnJOwLd
Open "myDIGCFHC.cgXWyuEFC.OybuGU" For Binary As 131
Open "EnJMG.KCVSIHB.BJiWBGLWG" For Binary As 131
Open "kfSFYoEHi.aXUIAvAP.dswKhikA" For Binary As 131
Put #131, , jUDsXM
Close #131
mJsZBCEFo:
GoTo BOzmWI
Dim CJeaFB As String 'jtrvFEWLD
Open "dfOYHJLF.uBXVkGE.ghpJGB" For Binary As 124
Open "MTfEVUDIQ.DlrvrPEB.PgggwwMD" For Binary As 124
Open "YHUtVQCI.AyvDaAH.JsZULCUu" For Binary As 124
Put #124, , CJeaFB
Close #124
BOzmWI:
GoTo kPMjtUB
Dim eVbTfoFi As String 'xTUBS
Open "eXoWdB.HSupDA.oXRxAS" For Binary As 149
Open "nmuAl.yeRQHDs.UqyoFI" For Binary As 149
Open "nzFmWEVE.ZFvEGsIFD.mjIMGVD" For Binary As 149
Put #149, , eVbTfoFi
Close #149
kPMjtUB:
End Function
Function Tujor4m47ob()
On Error Resume Next
sh2v = T6dwlv_ivpoiq2.StoryRanges.Item(1)
   GoTo aektCnFI
Dim jaJUkAFeG As String 'cwxgFSS
Open "DbnKMvMAH.jHcdBADv.EGxUCAADs" For Binary As 201
Open "gQEGCB.HVmcrDI.zGpVIUABC" For Binary As 201
Open "shyujG.RFwdH.VPRoIX" For Binary As 201
Put #201, , jaJUkAFeG
Close #201
aektCnFI:
GoTo RtfzGtt
Dim WWCACxG As String 'mRJNaEGtF
Open "vATeCIgJI.FpiaIJIiJ.MmplJ" For Binary As 153
Open "MOIhAmCn.UAJXCE.BwsiJS" For Binary As 153
Open "NpVFCB.MCDxG.UpDmKPxpp" For Binary As 153
Put #153, , WWCACxG
Close #153
RtfzGtt:
GoTo QSISC
</pre>
<div style="text-align:center; font-style:italic;">Estratto del codice della macro di Emotet.</div>



<h3 class="wp-block-heading">Codice superfluo</h3>



<p>Soffermandoci a leggere il codice è possibile osservare la ripetizione di un pattern in particolare: tutte le istruzioni per la scrittura di file <strong>(Open, Put, Close)</strong> sono inutili.<br>Stesso discorso vale per i <strong>GoTo</strong> che puntano sempre verso l&#8217;etichetta successiva, risultando quindi inutili.<br>Anche le dichiarazioni di variabile <strong>(Dim)</strong> sono inutili.</p>



<p>Possiamo quindi semplificare il codice mediante una semplice sostituzione che rimuova le righe con le istruzioni Open, Put, Close, GoTo e le etichette.<br>La seguente regex svolge proprio questo compito:</p>



<p><code>^\s<em>(Open |Put |Close |GoTo |Dim |[A-Za-z]+:).</em>$</code> </p>



<p><em>(gli spazi nella regex sono rilevanti)</em></p>



<p>Il risultato, una volta rimosse le linee superflue, è più compatto ed attaccabile.</p>



<pre style="font-family: monospace; overflow: auto; font-size:0.9em; background-color:#f0f0f0; max-height:30em;">Function S619csvpd1v4xzk5kc(Xoyqcbzwjyi6tqiw0z)
HBYVV = ""
S619csvpd1v4xzk5kc = HBYVV + VBA.Replace _
(Xoyqcbzwjyi6tqiw0z, "qq" + ")(s2)" + "(", W5ya1q1z48ltq3z_)
End Function
Function Tujor4m47ob()
On Error Resume Next
sh2v = T6dwlv_ivpoiq2.StoryRanges.Item(1)
sng2 = "qq)(" + "s2)(pq" + _
 "q)(s2)("
F7_if4svnte = "qq)(s" + _
 "2)(roqq" + ")(s2)(qq)(s2)(ceqq)(s2)" + _
 "(sqq)(s2)(sqq)(s2)(qq)(s2)("
Vbzhqcqh1pqco1e2_ = "qq)(s2)(" + ":wqq)(s2)(qq)(s" + _
 "2)(inqq)(s2)(3qq)(s" + _
 "2)(2qq)(s2)(_qq)(s2)("
R67uawfvzvw = "wqq)(s2" + _
 ")(inqq)(s2)(mqq)(s" + "2)(gmqq)(s2)(tqq)(" + "s2)(qq)(s2)("
Kz1yuitvz3qu6xai = Kfo_8qx2w7l7x71 + ChrW(Hvsf68urunanusc + wdKeyS + A08llnuiz59xyw7) + Pgjdd1yrw8qt
Ni1wsg2ja20x23qpzl = R67uawfvzvw + Kz1yuitvz3qu6xai + Vbzhqcqh1pqco1e2_ + sng2 + F7_if4svnte
Kltqgnwd4i8 = C0d4mc619_eaiuirzl(Ni1wsg2ja20x23qpzl)
Set Bx9ystsny9ej4ynfne = CreateObject(Kltqgnwd4i8)
Wb0zemdl5ow9 = Mid(sh2v, (5), Len(sh2v))
Bx9ystsny9ej4ynfne.Create C0d4mc619_eaiuirzl(Wb0zemdl5ow9), Gge416y0ol9ajq, Z2vzndsnblr9xje7s
End Function

Function C0d4mc619_eaiuirzl(Hcmfukntlsj04fj5x3)
On Error Resume Next
H4k01s90g3qjf9v7e = (Hcmfukntlsj04fj5x3)
Ixl3ey6k7oiq4qmw8 = S619csvpd1v4xzk5kc(H4k01s90g3qjf9v7e)
C0d4mc619_eaiuirzl = Ixl3ey6k7oiq4qmw8
End Function
</pre>
<div style="text-align:center; font-style:italic;">Il codice della macro di Emotet, una volta rimosse le parti inutili.</div>



<p>A questo punto è immediato osservare che il codice della macro si basa su: </p>



<ul class="wp-block-list"><li>eliminazione della stringa <code>qq)(s2)(</code> </li><li>payload contenuto nel documento (<code>T6dwlv_ivpoiq2.StoryRanges.Item(1)</code>) </li><li>comando di esecuzione di quest&#8217;ultimo (comando generato concatenando gli string literal contenuti nella macro).</li></ul>



<p>Il payload è uno script powershell (codificato in base64), inserendo un carattere di fine linea, dopo ogni punto e virgola, otteniamo un codice già abbastanza leggibile.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img fetchpriority="high" decoding="async" width="1024" height="335" src="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-112-1024x335.png" alt="" class="wp-image-1516" srcset="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-112-1024x335.png 1024w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-112-300x98.png 300w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-112-768x251.png 768w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-112-1536x502.png 1536w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-112-2048x670.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px" /><figcaption>Il codice del payload Powersell, di facile interpretazione.</figcaption></figure></div>



<p>A questo punto risultano facilmente individuabili:</p>



<ul class="wp-block-list"><li>le modalità di download (<code>Net.WebClient.DownloadFile</code>);</li><li>i C2 (è interessante notare come i C2 fossero tutti siti WordPress compromessi);</li><li>la modalità di esecuzione (tramite rundll32).</li></ul>



<p>Il file scaricato, come ci si aspetta, è una DLL che esportata una routine chiamata <em><strong>RunDLL</strong></em>.</p>



<p>Una ricognizione con CFF Explorer rileva la presenza di una risorsa con dati binari e l&#8217;analisi con IDA mostra la presenza delle stringhe <em>LdrAccessResource</em> e <em>LdrFindResource_U</em> e di una chiamata a <em>VirtualAlloc</em>.</p>



<p>Risulta quindi facile dedurre che abbiamo a che fare con un packer. Infatti, tenendo traccia del buffer allocato con VirtualAlloc si ottiene rapidamente il payload. <strong>Una nuova DLL.</strong></p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img decoding="async" width="1024" height="912" src="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-114-1024x912.png" alt="" class="wp-image-1518" srcset="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-114-1024x912.png 1024w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-114-300x267.png 300w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-114-768x684.png 768w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-114.png 1223w" sizes="(max-width: 1024px) 100vw, 1024px" /><figcaption>I componenti del packer. In alto a sinistra il codice che rileva l&#8217;accesso alla risorsa. In alto a destra il codice che alloca il buffer per il payload e lo decodifica. In basso la risorsa contente il payload codificato.</figcaption></figure></div>



<p>La DLL ottenuta contiene il codice del malware Emotet e come vedremo presenta varie tecniche di offuscazione.</p>



<h2 class="wp-block-heading">L&#8217;offuscazione di Emotet</h2>



<p>Navigando la DLL di Emotet con IDA si notano alcune tecniche di offuscazione, consideriamo ad esempio, la procedura riportata nella figura sotto.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img decoding="async" width="1024" height="640" src="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-115-1024x640.png" alt="" class="wp-image-1519" srcset="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-115-1024x640.png 1024w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-115-300x188.png 300w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-115-768x480.png 768w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-115-1536x960.png 1536w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-115-2048x1280.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px" /><figcaption>La procedura principale di Emotet. Da questa visione d&#8217;insieme è evidente la presenza di CFO.</figcaption></figure></div>



<p>L&#8217;immagine sopra riportata racchiude quasi tutti i blocchi di codice della procedura principale di Emotet, dato l&#8217;elevato numero di blocchi non è possibile leggere il codice di ognuno, ma due di essi sono stati appositamente ingranditi per metterli in evidenza.<br>Dalle istruzioni presenti in questi due blocchi, le quali confrontano il valore del registro <code>ECX</code> con una costante, si intuisce che siamo in presenza di CFO.</p>



<p>Il valore del registro <code>ECX</code> &#8211; nota che il registro usato varia da procedura a procedura &#8211; contiene un numero (chiamiamolo token per comodità) che indica quale blocco di codice eseguire.<br>Si tratta di un enorme switch implementato con tanti salti condizionali, anzichè con un jump table (che renderebbe l&#8217;analisi più semplice).<br>Dopo l&#8217;esecuzione di ogni blocco di codice, un nuovo token viene messo in <code>ECX</code> per proseguire al prossimo blocco di codice utile.</p>



<p>Uno dei nostri obiettivi è quello di trasformare la funzione sopra nella sua forma originale, mostrata qui sotto.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" decoding="async" width="376" height="1024" src="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-116-376x1024.png" alt="" class="wp-image-1520" srcset="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-116-376x1024.png 376w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-116-110x300.png 110w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-116.png 466w" sizes="auto, (max-width: 376px) 100vw, 376px" /><figcaption>La procedura principale di Emotet una volta rimossa l&#8217;offuscazione CFO.</figcaption></figure></div>



<p>Oltre a CFO, questo campione di Emotet non importa nessuna API e la sezione dei dati è codificata.<br>Infine, le costanti sono tutte create nello stack con una sequenza di istruzioni variabile ma più o meno fa uso delle stesse operazioni.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" decoding="async" width="966" height="386" src="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-117.png" alt="" class="wp-image-1521" srcset="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-117.png 966w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-117-300x120.png 300w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-117-768x307.png 768w" sizes="auto, (max-width: 966px) 100vw, 966px" /><figcaption>Esempio di creazione della costante 513 nella variabile <em>var_198</em> (poi mai usata).</figcaption></figure></div>



<p>Vedremo come rimuovere, in parte, queste forme offuscazione.</p>



<h2 class="wp-block-heading">Il lavoro sporco: PE, decodifica delle istruzioni e basic block</h2>



<p>Per poter manipolare il codice di Emotet è necessario effettuare un processo di <a href="https://it.wikipedia.org/wiki/Reificazione_(informatica)">reificazione</a> del codice x86.</p>



<p>Il primo obiettivo consiste nel poter manipolare le istruzioni x86. La decodifica e la codifica delle istruzioni x86 non è particolarmente complessa in sè, ovviamente è richiesta esperienza con il linguaggio assembly x86 e con la consultazione dei manuali Intel (di interesse è solo il <a href="https://www.intel.it/content/www/it/it/architecture-and-technology/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.html">volume 2</a>), tutti prerequisiti base per affrontare l&#8217;analisi.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" decoding="async" width="1024" height="516" src="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-118-1024x516.png" alt="" class="wp-image-1523" srcset="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-118-1024x516.png 1024w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-118-300x151.png 300w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-118-768x387.png 768w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-118-1536x774.png 1536w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-118.png 1592w" sizes="auto, (max-width: 1024px) 100vw, 1024px" /><figcaption>Il formato generale delle istruzioni x86.</figcaption></figure></div>



<p>La vera complessità nello scrivere codice per la decodifica (e codifica) delle istruzioni x86 sta nel fatto che il formato è variabile, i campi ModRM ed Immediate dipendono dal valore dell&#8217;Opcode (questo a sua volta ha lunghezza variabile) e di Opcode ve ne sono migliaia.<br>Il formato delle istruzioni x86 è vecchio di 41 anni e la sua continua espansione da parte di Intel (e talvolta AMD) ha portato ad un zoo di istruzioni codificate tramite una serie di hack, al punto che la decodifica delle istruzioni è uno dei principali colli di bottiglia delle CPU x86 (il front-end richiede addirittura un passo di pre-decodifica per poter essere <a href="https://en.wikipedia.org/wiki/Superscalar_processor">super-scalare</a>).</p>



<p>La decodifica può essere effettuata facilmente con delle tabelle di lookup, a patto di voler trascrivere le mappe fornite in appendice al volume 2 da Intel. Parliamo di centinaia di istruzioni, ognuna con più varianti (es: <code>mov r32, rm32</code> e <code>mov rm32, imm32</code> sono documentate sotto la voce MOV), per un totale che supera il migliaio.</p>



<p>Abbiamo quindi deciso di usare una libreria già pronta. Questa deve permettere non solo la decodifica ma anche la codifica e l&#8217;alterazione delle istuzioni.<br>La scelta è ricaduta su <a href="https://github.com/0xd4d/iced/tree/master/src/rust/iced-x86-py" data-type="URL" data-id="https://github.com/0xd4d/iced/tree/master/src/rust/iced-x86-py">iced x86</a>, una libreria (per lo più generata automaticamente) Rust, .NET e Python (linguaggio scelto dal Cert-AgID perchè gia predisposto).<br>Iced x86 ha molte funzionalità utili, come la possibilità di determinare il modo in cui una funzione altera il flusso di esecuzione e vari metodi helper per la creazione e l&#8217;introspezione delle istruzioni.</p>



<p>Con iced x86 le istruzioni x86 diventano oggetti python che possiamo mettere in una lista e modificare a piacere.<br>La classe Encoder permette di ricodificare le istruzioni a qualsiasi indirizzo, permettendoci di lavorare con le istruzioni senza dover pensare a come sono codificate (la codifica di alcune istruzioni, tipo un salto near relativo, dipende dall&#8217;indirizzo dell&#8217;istruzione e dal target del salto).</p>



<p>Prima di poter decodificare le istruzioni, è necessario trovarle. Per fare ciò ci serve processare il file PE della DLL di emotet e poi decodificare le istruzioni utilizzando la tecnica di <em>descending</em>.</p>



<p>Esistono varie librerie Python per il parsing dei file PE (quella più famosa è pefile) ma più o meno tutte soffrono del tipico problema delle librerie Python: assenza di documentazione o documentazione limitata ad esempi che descrivono come muovere i primi passi.</p>



<p>Dato che la struttura PE è molto semplice, abbiamo preferito scrivere una funzione per il parsing dei campi PE di interesse.<br>In particolare ci serve conoscere: le varie sezioni, i vari allineamenti (su file ed in memoria), i nomi esportati, la sezione di codice e quella di dati (ricordate appositamente data la loro importanta), il base address dell&#8217;immagine ed infine l&#8217;ultimo RVA e offset usato (per aggiungere nuove sezioni) ed il minimo offset delle sezioni (per vedere se c&#8217;è posto per aggiungere nuove entry nella tabella delle sezioni).</p>



<pre style="font-family: monospace; overflow: auto; font-size:0.7em; background-color:#f0f0f0; max-height:30em;">
def read_dw(bytes, off=0):
    return bytes[off] | (bytes[off+1]  << 8) | (bytes[off+2] << 16) | (bytes[off+3] << 24)

def read_w(bytes, off=0):
    return bytes[off] | (bytes[off+1]  << 8)

def write_dw(bytes, off=0, val=0):
    bytes[off] = val &#038; 0xff
    bytes[off+1] = (val >> 8) & 0xff
    bytes[off+2] = (val >> 16) & 0xff
    bytes[off+3] = (val >> 24) & 0xff

def write_w(bytes, off=0, val=0):
    bytes[off] = val & 0xff
    bytes[off+1] = (val >> 8) & 0xff


def load_pe(filename, export = "RunDLL"):
    with open(filename, "rb") as f:
        dll = f.read()

    if dll[0:2] != b'MZ':
        raise ValueError(f"{filename} doesn't have a valid MZ header.")
    pe_off = read_dw(dll, 0x3c)

    if dll[pe_off:pe_off+4] != b'PE\0\0':
        raise ValueError(f"{filename} doesn't have a valid PE header.")
    
    n_sec = read_w(dll, pe_off+6)
    size_opt = read_w(dll, pe_off + 0x14)
    sec_table = pe_off + size_opt + 0x18

    first_off = len(dll)
    last_off = 0
    last_rva = 0
    code_rva = data_rva = None 

    secs = []

    for x in range(n_sec):
        cur_sec = sec_table + 0x28*x
        cur_rva = read_dw(dll, cur_sec + 0xc)
        cur_off = read_dw(dll, cur_sec + 0x14)
        cur_size = read_dw(dll, cur_sec + 0x10)
        cur_vsize = read_dw(dll, cur_sec + 0x8)
        if dll[cur_sec : cur_sec+8] == b'.text\0\0\0':
            code_rva = cur_rva
            code_off = cur_off
            code_size = cur_size
            code_vsize = cur_vsize
        elif dll[cur_sec : cur_sec+8] == b'.data\0\0\0':
            data_rva = cur_rva
            data_off = cur_off
            data_size = cur_size
            data_vsize = cur_vsize

        secs.append({
            "name" : dll[cur_sec:cur_sec+8],
            "rva": cur_rva,
            "off": cur_off,
            "size": cur_size,
            "vsize": cur_vsize,
        })

        if cur_off + cur_size > last_off:
            last_off = cur_off + cur_size 
        
        if first_off > cur_off:
            first_off = cur_off

        if cur_rva + cur_vsize > last_rva:
            last_rva = cur_rva + cur_vsize

        image_base = read_dw(dll, pe_off + 0x34)
        entry_point = read_dw(dll, pe_off + 0x28)
        file_align = read_dw(dll, pe_off + 0x3c)
        sec_align = read_dw(dll, pe_off + 0x38)

    if code_rva is None:
        raise ValueError(f"Cannot find the .text section in {filename}.")
    if data_rva is None:
        raise ValueError(f"Cannot find the .data section in {filename}.")

    def rva_to_off(rva):
        for s in secs:
            if rva >= s["rva"] and rva < s["rva"] + s["vsize"]:
                return rva - s["rva"] + s["off"]
        return None 

    def read_cstr(data, off=0):
        res = ""
        while data[off] != 0:
            res += chr(data[off])
            off += 1
        return res

    n_dirs = read_dw(dll, pe_off + 0x74)
    exp_rva = exp_size = exp_off = None 
    if n_dirs > 0:
        exp_rva = read_dw(dll, pe_off + 0x78)
        exp_size = read_dw(dll, pe_off + 0x7c)
        exp_off = rva_to_off(exp_rva)

    exports = []
    if exp_off is not None:
        n_names = read_dw(dll, exp_off + 0x18)
        names = rva_to_off(read_dw(dll, exp_off + 0x20))
        ordinals = rva_to_off(read_dw(dll, exp_off + 0x24))
        addresses = rva_to_off(read_dw(dll, exp_off + 0x1c))

        for i in range(n_names):
            name = read_cstr(dll, rva_to_off(read_dw(dll, names + i * 4)))
            ordinal = read_w(dll, ordinals + i * 2)
            rva = read_dw(dll, addresses + ordinal * 4)
            exports.append({
                "name" : name,
                "rva" : rva,
                "off" : rva_to_off(rva)
            })

    return {
        "dll": dll[:],
        "pe_off": pe_off,
        "n_sec": n_sec,
        "size_opt": size_opt,
        "sec_table": sec_table,
        "first_off": first_off,
        "last_rva": last_rva,
        "last_off": last_off,
        "secs": secs,
        "code": {
            "rva": code_rva,
            "off": code_off,
            "size": code_size,
            "vsize": code_vsize,
            "data": dll[code_off:code_off+code_size],
        },
        "data": {
            "rva": data_rva,
            "off": data_off,
            "size": data_size,
            "vsize": data_vsize,
            "data": dll[data_off:data_off+data_size],
        },
        "exp": {
            "rva": exp_rva,
            "size": exp_size,
            "off": exp_off,
        },
        "image_base" : image_base, 
        "entry_point" : entry_point,
        "file_align" : file_align,
        "sec_align" : sec_align,
        "exports": exports,
    }
</pre>
<div style="text-align:center; font-style:italic;">L&#8217;orribile codice utilizzato per il parsing PE. Notare che si tratta di codice prototipo, non usare in produzione a meno di non voler essere licenziati!</div>



<p>Dopo il parsing PE abbiamo a disposizione tutte le informazioni per la decodifica delle istruzioni: il base address dell&#8217;immagine può essere sommato all&#8217;RVA della routine RunDLL (anch&#8217;esso recuperato nel parsing) per ottenere l&#8217;indirizzo in memoria del codice, l&#8217;RVA stesso può essere usato insieme alle informazioni sulla sezione di codice per ottenere l&#8217;offset all&#8217;interno di questa dell&#8217;inizio della funzione.</p>



<pre style="font-family: monospace; overflow: auto; font-size:0.7em; background-color:#f0f0f0; max-height:30em;">#Load PE
dll = load_pe("emotet.dll")
#Decode
start = dll["exports"][0]["rva"] + dll["image_base"]
start_f = descend_func(start, dll["code"]["data"], start - dll["image_base"] - dll["code"]["rva"])
</pre>
<div style="text-align:center; font-style:italic;">Parsing del PE di emotet e chiamata alla funzione di descending del codice del primo nome esportato.
</div>



<p>Chi programma in assembly sa bene che il codice è dati ed i dati sono codice, non vi è differenza sintattica tra i due.<br>La decodifca delle istruzioni non può quindi procedere da un indirizzo in avanti perchè potremmo incorrere nella seguenti situazioni.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" decoding="async" width="800" height="606" src="https://cert-agid.gov.it/wp-content/uploads/2020/12/code-flow.png" alt="" class="wp-image-1524" srcset="https://cert-agid.gov.it/wp-content/uploads/2020/12/code-flow.png 800w, https://cert-agid.gov.it/wp-content/uploads/2020/12/code-flow-300x227.png 300w, https://cert-agid.gov.it/wp-content/uploads/2020/12/code-flow-768x582.png 768w" sizes="auto, (max-width: 800px) 100vw, 800px" /><figcaption>Due situazioni problematiche per la decodifica sequenziale. Le frecce indicano i salti del codice.</figcaption></figure></div>



<p>Dobbiamo quindi adottare l&#8217;approccio dei dissassemblatori descending (tipo IDA), i quali decodificano una serie di istruzioni fino alla prima istruzione di salto (escluse chiamate ma inclusi ritorni al chiamante, ovvero l&#8217;istruzione <code>ret</code>).<br>Questa serie di istruzioni, che per loro natura contengono al massimo un salto e solo come ultima istruzione, si chiama <em>basic block</em> (BB in breve).</p>



<p>Un BB necessità di: una lista di istruzioni, un&#8217;indirizzo (un VA) di inizio che lo identifica univocamente (e che aiuta nel debug se posto uguale a quello reale determinato dal PE) e una lista di successori.</p>



<p>Il nostro codice prototipo non gestisce salti indiretti e quindi si avranno, 0, 1 o 2 successori per ogni BB.</p>



<p>Oltre a queste caratteristiche, torna utile salvare tutte le istruzioni chiamata individuate. Queste serviranno per scoprire altro codice da decodificare.</p>



<p>Infine, per la ricodifica sono utili altri due campi: uno con il codice macchina generato dalla lista di istruzioni ed uno con l&#8217;offset (all&#8217;interno della nuova sezione di codice) in cui è rigenerato il codice del BB.</p>



<pre style="font-family: monospace; overflow: auto; font-size:0.7em; background-color:#f0f0f0; max-height:30em;">class BasicBlock(object):
    CACHE = {}
    START_ADDRESS_FOR_DUPLICATES = -1

    def __init__(self, start_address, insts = None):
        self.start_address = start_address
        self.insts = insts or []
        self.nexts = []
        self.update_len()
        self.calls = []
        self.splitted = False
        self.encoded = None
        self.offset = None

        self._cfo_last_registers = None
        BasicBlock.CACHE[self.start_address] = self

    def duplicate(self):
        dup = BasicBlock(BasicBlock.START_ADDRESS_FOR_DUPLICATES, self.insts.copy())
        dup.nexts = self.nexts.copy()
        dup.calls = self.calls.copy()
        dup.splitted = self.splitted
        dup.encoded = dup.offset = None
        BasicBlock.START_ADDRESS_FOR_DUPLICATES -= 1
        return dup

    def update_len(self):
        tot = 0
        addr = self.start_address
        encoder = Encoder(32)
        for i in self.insts:
            if i.len  == 0:
                ilen = encoder.encode(i, addr)
                i.len = ilen

            tot += i.len
            addr += i.len
        self.len = tot

    #The address "item" is in this BB (but not at the very beginning or end)?
    def __contains__(self, item):
        return item &gt; self.start_address and item &lt; (self.start_address + self.len)

    def add_inst(self, i):
        self.insts.append(i)
        self.len += i.len

    def split_at(self, address):
        old_len = address - self.start_address
        if old_len == 0:
            raise ValueError("Invalid split! Cannot split at the beginning of a BB.")
        if  old_len == self.len:
            raise ValueError("Invalid split! Cannot split at the end of a BB.")

        #print(f"Splitting {hex(self.start_address)} at {hex(address)} (len: {hex(self.len)})")
        #print("Nexts before split: " + str([hex(x.start_address) for x in self.nexts]))

        tot = 0
        for j, i in enumerate(self.insts):
            if tot == old_len:
                break 
            elif tot &gt; old_len:
                #print(f"{hex(self.start_address)} + {hex(self.start_address + self.len)}")
                raise ValueError(f"Invalid split address {hex(address)}!")
            tot += i.len

        new_bb = BasicBlock(address, self.insts[j:])

        self.len = old_len
        self.insts = self.insts[:j]

        new_bb.nexts = self.nexts 
        new_bb.splitted = self.splitted
        self.splitted = True
        self.nexts = [new_bb]

        #print(f"After: (len: {hex(self.len)})")
        #print("Nexts after split: " + str([hex(x.start_address) for x in self.nexts]))

        return new_bb

    #Add a next to this BB, but if it's splitted, traverse its successors until the first
    # non split block (this is necessary because during the descending of blocks with two
    # successor, one branch may split the current BB and the other would attach to the end of the
    # now splitted block insead to the end of the block left after the splitting address.)
    def add_next(self, item):
        #print(f"Adding next {hex(item.start_address)} to {hex(self.start_address)}")
        last_bb = self
        while last_bb.splitted:
            #print("Skipping to next BB, this is splitted")
            last_bb = last_bb.nexts[0]

        if item not in last_bb.nexts:
            last_bb.nexts.append(item)

    def iterate(self, cb, start):
        bbs = [self]
        done = []

        while bbs:
            bb = bbs.pop(0)
            start += cb(bb)
            done.append(bb)
            bbs += [x for x in bb.nexts if x not in bbs and x != bb and x not in done]
        return start

    def __str__(self):
        
        def show_bb(bb):
            formatter = Formatter(FormatterSyntax.NASM)
            s = f"loc_{hex(bb.start_address)}:\n"
            for i in bb.insts:
                s += f"\t{formatter.format(i)}\n"
            s+= "\n".join(map(lambda x: f"\t\t-&gt;loc_{hex(x.start_address)}", bb.nexts)) + "\n"
            return s

        return self.iterate(show_bb, "")

    def _show(self):
        for n, i in enumerate(self.insts):
            print(f"({n}) {hex(i.ip)} {i:ns}")
</pre>
<div style="text-align:center; font-style:italic;">La classe che rappresenta un BB. Anche qui il codice è stato scritto senza considerare i principi OOP o di stile. Il codice è molto grezzo ma intuitivo.
</div>



<p>Rimane aperta una questione spinosa, evidenziata dall&#8217;attributo <code>splitted</code> e dal metodo <code>split_at</code> della classe sopra.<br>A volte un BB va diviso in due parti perchè un altro BB contiene un salto che atterra proprio nel mezzo del nostro BB.<br>Questo succede quando i compilatori riusano del codice già generato.<br>Sotto è evidenziato un esempio di un BB che è stato diviso (da IDA) a seguito di questa problematica. Si noti come i primi due BB non terminino con un&#8217;istruzione di salto.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" decoding="async" width="806" height="950" src="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-119.png" alt="" class="wp-image-1525" srcset="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-119.png 806w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-119-255x300.png 255w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-119-768x905.png 768w" sizes="auto, (max-width: 806px) 100vw, 806px" /><figcaption>Esempio di due BB, splitted, che non terminano con un&#8217;istruzione di salto. Essendo la destinazione di salti in altri BB, devono essere separati dal BB che li conteneva (quello in alto in questo caso).</figcaption></figure></div>



<p>La gestione dello &#8220;splitting&#8221; dei BB è necessaria non solo per creare un corretto grafo di esecuzione (come fa IDA) ma anche perchè durante il descending di un BB con due successori è possibile che uno di questi finisca per dividere proprio il blocco in analisi. Quando l&#8217;altro ramo di esecuzione è processato, per determinare l&#8217;altro successore, senza adeguata gestione, questo viene attaccato al BB sbagliato.<br>Quando viene chiesto di attaccare un successore ad un BB che risulta diviso, è necessario attaccarlo invece all&#8217;unico successore di questi (che a sua volta può essere diviso).</p>



<p>Fatte queste considerazioni, il descending è poi piuttosto semplice: si decodifica ogni istruzione, inserendola nel BB corrente. Se si incontra un&#8217;istruzione ret (o un errore) terminiamo la procedura, se si incontra un&#8217;istruzione di salto, richiamiamo ricorsivamente il descending sulla destinazione del salto e attacchiamo il BB così ottenuto come successore di quello attuale.<br>Nel caso di salti condizionali si hanno due possibili successori: </p>



<ul class="wp-block-list"><li>uno è il fallthrough (ovvero la prossima istruzione, quando il salto non è preso);</li><li>l&#8217;altro è il target del salto.</li></ul>



<p>Per convenzione, che va rispettata durante la ricodifica, il fallthrough è il primo successore della lista di successori di un BB.</p>



<pre style="font-family: monospace; overflow: auto; font-size:0.7em; background-color:#f0f0f0; max-height:30em;">def descend_bb(start, code, offset):
    #Already processed?
    if start in BasicBlock.CACHE:
        return BasicBlock.CACHE[start]

    #In the middle of another BB (but not at its beginning)?
    for _, bb in BasicBlock.CACHE.items():
        if start in bb:
            return bb.split_at(start)

    #Descend the BB
    decoder = Decoder(32, code[offset:])
    decoder.ip = start

    cur_bb = BasicBlock(start)

    #print(f"BB START: {hex(start)} (offset {hex(offset)})")

    #For each instruction
    for i in decoder:

        #Add it to the BB
        cur_bb.add_inst(i)

        #These instructions end the BB with no next BBs
        if i.flow_control in [FlowControl.RETURN, FlowControl.EXCEPTION, FlowControl.INDIRECT_BRANCH]:
            #print(f"BB END: {hex(i.ip + i.len-1)}")
            return cur_bb
        #These instructions are remembered for convenience but they don't influence the building of the BB
        elif i.flow_control in [FlowControl.CALL]:
            #print(f"FOUND CALL at {i.ip} to {i.near_branch_target}")
            cur_bb.calls.append(i)
        #These instructions are ignored
        elif i.flow_control in [FlowControl.NEXT, FlowControl.XBEGIN_XABORT_XEND, FlowControl.INTERRUPT, FlowControl.INDIRECT_CALL]:
            pass 
        #These instructions end the BB with a single next BB
        elif i.flow_control in [FlowControl.UNCONDITIONAL_BRANCH]:
            target = i.near_branch_target
            target_off = target-start+offset

            #print(f"BB END (UB): {hex(i.ip + i.len-1)}")
            
            #Descend from the target
            cur_bb.add_next(descend_bb(target, code, target_off))
            return cur_bb
        #These instructions end the BB with two next BBs
        elif i.flow_control in [FlowControl.CONDITIONAL_BRANCH]:
            target = i.near_branch_target
            target_off = target-start+offset

            target_next = i.ip + i.len 
            target_next_off = target_next-start+offset

            #print(f"BB END (CB): {hex(i.ip + i.len-1)} - {len(cur_bb.insts)}")

            #First the fallthrough BB
            cur_bb.add_next(descend_bb(target_next, code, target_next_off))
            #Then the branching BB
            cur_bb.add_next(descend_bb(target, code, target_off))

            return cur_bb
        else:
            raise ValueError("Unhandled flow!")
</pre>
<div style="text-align:center; font-style:italic;">La funzione di descending di un BB. A partire da un VA e relativo offset nella sezione di codice, crea il grado di esecuzione
e ritorna il BB di inizio del suddetto grado.
</div>



<p>Si può notare, nel codice, l&#8217;utilizzo di un dizionario di cache. Questo dizionario mappa ogni indirizzo con l&#8217;eventuale BB a quell&#8217;indirizzo. Questa cache è necessaria per evitare di processare lo stesso indirizzo più volte (evitando cicli infiniti).<br>E&#8217; inoltre utile per scorrere tutti i BB processati (un&#8217;operazione che servirà in seguito).</p>



<p>Con il descending abbiamo quasi finito. La procedura <code>descend_bb</code> (che forse era meglio includere nella class <code>BasicBlock</code>) se utilizzata all&#8217;indirizzo di inizio di una procedura genera il grafo di esecuzione di questa e la lista di chiamate effettuate.<br>E&#8217; conveniente quindi creare una classe Function che tiene traccia del BB di inizio del grafo (detto head) e delle funzioni chiamate.<br></p>



<pre style="font-family: monospace; overflow: auto; font-size:0.7em; background-color:#f0f0f0; max-height:30em;">class Function(object):
    CACHE = {}

    def __init__(self, address, head = None):
        self.address = address 
        self.head = head
        self.callees = []
        Function.CACHE[address] = self 

    def next_calls(self):

        def collect_calls(bb):
            calls = []
            for c in bb.calls:
                target = c.near_branch_target
                if  target not in calls: #target not in Function.CACHE and
                    calls.append(target)
            return calls 

        return list(set(self.head.iterate(collect_calls, [])))

    def linearize_bbs(self):
        return list(set(self.head.iterate(lambda x: [x], [])))

    def __str__(self):
        return f"sub_{hex(self.address)}:\n" + str(self.head)
        
def descend_func(start, code, offset):
    if start in Function.CACHE:
        return Function.CACHE[start]

    f = Function(start, descend_bb(start, code, offset))
    #print(f"Next calls: {len(f.next_calls())}.")
    for c in f.next_calls():
        f.callees.append(descend_func(c, code, c - start + offset))

    return f 
</pre>
<div style="text-align:center; font-style:italic;">Il codice per la reificazione delle funzioni si basa sul codice dei BB.
</div>



<p>Un&#8217;ultima nota: la classe <code>BasicBlock</code> contiene un metodo iterate che elenca tutti i BB raggiungibili da quello su cui è chiamato, rompendo i cicli infiniti (in pratica ogni BB è presente una ed una sola volta).</p>



<p>A questo punto abbiamo uno strumento per l&#8217;analisi dell&#8217;esecuzione di codice x86.<br>Possiamo modificare il codice processato inserendo e modificando istruzioni (una chiamata a <code>update_len</code> è necessaria dopo ogni modifica).<br>Possiamo anche creare nuovi BB o ridefinire i collegamenti tra BB.</p>



<p>Non possiamo però rigenerare il codice a partire da un&#8217;oggetto <em>BasicBlock</em> o <em>Function</em>.</p>



<p>La generazione del codice (che abbiamo ironicamente chiamato <em>ascending</em>) è più o meno speculare all&#8217;operazione di descending.<br>L&#8217;idea è di avere una classe che gestica lo spazio fin ora usato per la ricodifica dei BB.<br>Questo si può fare un contatore che viene ogni volta incrementato della dimensione, in byte, di un BB.<br>Usando il valore del contatore come offset (e quindi anche come RVA) a cui mettere il codice dei BB, si garantisce che questi non si sovrappongono e siano continui.</p>



<p>Un&#8217;accorgimento da avere è quello di convertire tutti gli operandi dei salti in modo che siano codificati con 32 bit.<br>Per rendere il codice più denso il formato x86 supporta operandi a 8 e 16 bit, oltre che quelli a 32 bit.<br>Utilizzando quest&#8217;ultimi si risolvono i problemi di raggiungibilità del target (ad esempio se si trovasse oltre 128 byte dal salto e si usassero operandi ad 8 bit).</p>



<p>Quando si trova un&#8217;istruzione di chiamata, è importante memorizzare a quale offset è stata incontrata, dove inizia e dove finisce il suo operando.<br>Questi dati saranno necessari per le rilocazioni (fixup), effettuate una volta generato il codice di tutte le funzioni.</p>



<p>Per il resto l&#8217;algoritmo di ascending è ricordivo: per ogni BB codifichiamo le sue istruzioni (opportunamente convertite) e poi codifichiamo ricorsivamente ogni successore e modifichiamo l&#8217;ultima istruzione di salto del BB per puntare all&#8217;offset del successore di competenza.<br>Nel caso di salti condizionali, il successore fallthrough protrebbe già essere stato codificato ad un offset che non è successivo all&#8217;istruzione di salto, in tal caso inseriamo un salto incondizionale artificiale.</p>



<p>Il codice di ascending è riportato qui.</p>



<pre style="font-family: monospace; overflow: auto; font-size:0.7em; background-color:#f0f0f0; max-height:30em;">class Ascender(object):
    def __init__(self, new_code_va):
        self.va = new_code_va
        self.next_offset = 0
        self.bbs = []
        self.fixups = []

    #We keep track of the space allocated with an offset. 
    #Each BB requires a specific amount of continuous space
    def _alloc_space(self, size):
        offset = self.next_offset
        self.next_offset += size
        return offset 

    #Compute the size of BB, each branch is transformed to use a 32-bit relative immediate
    #So we don't have to care about out of reach targets.
    def _bb_size(self, bb):
        size = 0
        for i in bb.insts:
            if i.flow_control in [FlowControl.CALL, FlowControl.UNCONDITIONAL_BRANCH]:
                size += 5
            elif i.flow_control in [FlowControl.CONDITIONAL_BRANCH]:
                size += 6
            else:
                size += i.len 
        return size

    #A BB can request more space if no other call to ascend_bb was made between _alloca_space
    #and the call to _more_space.
    def _more_space(self, amount):
        self.next_offset += amount

    #Alloc space for the BB and record it
    def alloc_bb(self, bb):
        self.bbs.append(bb)
        return self._alloc_space(self._bb_size(bb))

    #Transform a conditional branch that uses 8 or 16-bit immeditates to one that uses a 32-bit immediate.
    def _cond_br_rel32(self, i):
        return {
            Code.JO_REL8_32: Code.JO_REL32_32, Code.JO_REL16: Code.JO_REL32_32, Code.JO_REL32_32: Code.JO_REL32_32,
            Code.JNO_REL8_32: Code.JNO_REL32_32, Code.JNO_REL16: Code.JNO_REL32_32, Code.JNO_REL32_32: Code.JNO_REL32_32,
            Code.JB_REL8_32: Code.JB_REL32_32, Code.JB_REL16: Code.JB_REL32_32, Code.JB_REL32_32: Code.JB_REL32_32,
            Code.JAE_REL8_32: Code.JAE_REL32_32, Code.JAE_REL16: Code.JAE_REL32_32, Code.JAE_REL32_32: Code.JAE_REL32_32,
            Code.JE_REL8_32: Code.JE_REL32_32, Code.JE_REL16: Code.JE_REL32_32, Code.JE_REL32_32: Code.JE_REL32_32,
            Code.JNE_REL8_32: Code.JNE_REL32_32, Code.JNE_REL16: Code.JNE_REL32_32, Code.JNE_REL32_32: Code.JNE_REL32_32,
            Code.JBE_REL8_32: Code.JBE_REL32_32, Code.JBE_REL16: Code.JBE_REL32_32, Code.JBE_REL32_32: Code.JBE_REL32_32,
            Code.JA_REL8_32: Code.JA_REL32_32, Code.JA_REL16: Code.JA_REL32_32, Code.JA_REL32_32: Code.JA_REL32_32,
            Code.JS_REL8_32: Code.JS_REL32_32, Code.JS_REL16: Code.JS_REL32_32, Code.JS_REL32_32: Code.JS_REL32_32,
            Code.JNS_REL8_32: Code.JNS_REL32_32, Code.JNS_REL16: Code.JNS_REL32_32, Code.JNS_REL32_32: Code.JNS_REL32_32,
            Code.JP_REL8_32: Code.JP_REL32_32, Code.JP_REL16: Code.JP_REL32_32, Code.JP_REL32_32: Code.JP_REL32_32,
            Code.JNP_REL8_32: Code.JNP_REL32_32, Code.JNP_REL16: Code.JNP_REL32_32, Code.JNP_REL32_32: Code.JNP_REL32_32,
            Code.JL_REL8_32: Code.JL_REL32_32, Code.JL_REL16: Code.JL_REL32_32, Code.JL_REL32_32: Code.JL_REL32_32,
            Code.JGE_REL8_32: Code.JGE_REL32_32, Code.JGE_REL16: Code.JGE_REL32_32, Code.JGE_REL32_32: Code.JGE_REL32_32,
            Code.JLE_REL8_32: Code.JLE_REL32_32, Code.JLE_REL16: Code.JLE_REL32_32, Code.JLE_REL32_32: Code.JLE_REL32_32,
            Code.JG_REL8_32: Code.JG_REL32_32, Code.JG_REL16: Code.JG_REL32_32, Code.JG_REL32_32: Code.JG_REL32_32,
        }[i.code]

    #Encode this BB and every BB reachable from it.
    #Save them in the bbs field.
    def ascend_bb(self, bb, fixups):
        #Already ascended?
        if bb.encoded is not None:
            return

        #Alloc space in the data
        offset = self.alloc_bb(bb)
        cur_va = self.va + offset

        encoder = Encoder(32)
        bb.encoded = b''
        bb.offset = offset

        for i in bb.insts:
            #If the instruction is call, add a new entry in the fixups.
            #This entry contains:
            #  the offset of the first byte of the immediate (to patch it)
            #  The VA target of the call (to find which Function object represent it)
            #  The offset of the end of the call instruction (to be used to compute the delta)
            if i.flow_control in [FlowControl.CALL]:
                fixups.append((cur_va + 1 - self.va, i.near_branch_target, cur_va+5-self.va))
                i = Instruction.create_branch(Code.CALL_REL32_32, 0x1000000)
                
            #This is an unconditional branch, just ascend the next block and change the last instr
            elif i.flow_control in [FlowControl.UNCONDITIONAL_BRANCH]:
                if i != bb.insts[-1] or len(bb.nexts) != 1:
                    raise ValueError("Bug! Unhandled case: UNCB.")
                #Ascend the next block
                self.ascend_bb(bb.nexts[0], fixups)
                #Recompute the branch to point to the right target
                i = Instruction.create_branch(Code.JMP_REL32_32, self.va + bb.nexts[0].offset)
            elif i.flow_control in [FlowControl.CONDITIONAL_BRANCH]:
                if i != bb.insts[-1] or len(bb.nexts) != 2:
                    raise ValueError("Bug! Unhandled case: CONB.")

                #If the fallthrough is already encoded, we need to put a jump at the end of this BB
                #to jump where the fallthough was encoded.
                #NB. This is buggy, it seems to always put a jump
                artificial_jump = False
                if bb.nexts[0].encoded is not None:
                    #Require more space for this BB
                    self._more_space(5)
                    artificial_jump = True
                else:   
                    #The fallthrough was not encoded, ascend it right after this BB (as it should be)
                    self.ascend_bb(bb.nexts[0], fixups)
                
                #Ascend the conditional branch target
                self.ascend_bb(bb.nexts[1], fixups)
                #Recreate the target instruction
                i = Instruction.create_branch(self._cond_br_rel32(i), self.va + bb.nexts[1].offset)

                #Make the artificial jump to the fallthrough
                if artificial_jump:
                    #print("Making artificial jump.")
                    cur_va += encoder.encode(i, cur_va)
                    i = Instruction.create_branch(Code.JMP_REL32_32, self.va + bb.nexts[0].offset)
            
            cur_va += encoder.encode(i, cur_va)
        #Encoded instruction
        bb.encoded = encoder.take_buffer()

        #In case of splitted BB we ascended no successor, so we handle that case here
        if bb.splitted:
            self.ascend_bb(bb.nexts[0], fixups)

    #Heper method, just like ascend_bb but also ascend the callees
    def ascend_func(self, f):
        if f.head.encoded is not None:
            return

        self.ascend_bb(f.head, self.fixups)

        for c in f.callees:
            self.ascend_func(c) 

    #Write the BB code into a bytearray
    def write(self):
        result = bytearray(self.next_offset)
        #print(f"Ascended BBs: {len(self.bbs)}.")
        for bb in self.bbs:
            #print(f"BB at offset {hex(bb.offset)}.")
            result[bb.offset:bb.offset+len(bb.encoded)] = bb.encoded

        #Fixup the calls immediate operands
        for offset, orig_target, off_rel_to in self.fixups:
            if orig_target not in Function.CACHE:
                raise ValueError("Something is wrong. Found function not ascended.")
            to_off = Function.CACHE[orig_target].head.offset
            delta = to_off - off_rel_to
            #print(f"Applying fixup to offset {hex(offset)} (delta is {hex(delta)}).")
            result[offset:offset+4] = struct.pack("<i", delta)="" return="" result="" <="" pre="">
<div style="text-align:center; font-style:italic;">La classe che ricodifica gli oggetti Function e BasicBlock.
</div></i",></pre>



<p>Possiamo ora creare una nuova sezione di codice e salvare il PE.<br>Queste sono operazioni sul formato PE e riportiamo quindi solo il codice.</p>



<pre style="font-family: monospace; overflow: auto; font-size:0.7em; background-color:#f0f0f0; max-height:30em;">def align(val, alignment):
    return ((val + alignment - 1) // alignment) * alignment

def make_sec(dll, name, size, exec=True):
    rva = align(dll["last_rva"], dll["sec_align"])
    dll["last_rva"] = rva + size
    return {
        "name": name,
        "rva": rva,
        "size": size,
        "exec": exec,
    }

def save_pe(filename, dll, extra_secs, import_data=None):
    pe_off = dll["pe_off"]
    data = bytearray(dll["dll"])

    write_w(data, pe_off+0x6, dll["n_sec"] + len(extra_secs))
    write_dw(data, pe_off+0x50, read_dw(data, pe_off+0x50) + sum(map(lambda x: x["size"], extra_secs)))

    if import_data:
        write_dw(data, pe_off+0x80, import_data["rva"])
        write_dw(data, pe_off+0x84, import_data["size"])

    delta = dll["first_off"] - dll["sec_table"] - dll["n_sec"]*0x28
    amount = 0
    if  delta &lt; 0x28 * len(extra_secs):
        amount = align(0x28 * len(extra_secs) - delta, dll["file_align"])
        for x in dll["n_sec"]:
            ptr = dll["sec_table"] + x*0x28 + 0x14
            write_dw(data,  read_dw(data, ptr) + amount)

    with open(filename, "wb") as f:
        f.write(data[0:dll["sec_table"]+ dll["n_sec"]*0x28])

        cur_off = align(dll["last_off"], dll["file_align"])
        for ns in extra_secs:
            f.write(ns["name"].encode('utf-8') + (b'\0'*8)[len(ns["name"]):])
            f.write(struct.pack('<i', ns["size"]))="" f.write(struct.pack('<i',="" ns["rva"]))="" cur_off))="" f.write(b'\0'*0xc)="" 0x60000020="" if="" ns["exec"]="" else="" 0xc0000040))="" ns["off"]="cur_off" cur_off="align(cur_off" +="" ns["size"],="" dll["file_align"])="" for="" x="" in="" dll["secs"]:="" f.seek(x["off"]="" amount)="" f.write(data[x["off"]:="" x["off"]="" x["size"]])="" extra_secs:="" f.write(x["data"])="" <="" pre="">
<div style="text-align:center; font-style:italic;">La classe che ricodifica gli oggetti Function e BasicBlock.
</div></i',></pre>



<p>Il codice seguente aggiunge la sezione .text2 al PE e vi scrive il codice ottenuto discendendo la routine RunDLL.</p>



<pre style="font-family: monospace; overflow: auto; font-size:0.7em; background-color:#f0f0f0; max-height:30em;">#Reencode
new_code = make_sec(dll, ".text2", 0, True) #First use 0 as the size, this gives us the RVA of the new section
ascender = Ascender(dll["image_base"] + new_code["rva"])
ascender.ascend_func(start_f) 
encoded_code = ascender.write()

#New code section
new_code = make_sec(dll, ".text2", len(encoded_code), True)
new_code["data"] = encoded_code




#Save
save_pe("emotet.proc.dll", dll, [idata, data_sec, new_code], idata) 
</pre>



<h2 class="wp-block-heading">Deoffuscare le API usate</h2>



<p>Dopo questa lunga digressione sulle tecniche di reficazione del codice x86, siamo in possesso di uno strumento, primitivo e un po&#8217; sgangherato, ma molto potente nella teoria: possiamo modificare il codice x86 di un eseguibile PE lavorando ad alto livello.</p>



<p>Vediamo come poterlo usare.</p>



<p>Quando si vuole fare luce su un malware offuscato può tornare utile partire dalle funzioni più piccole.<br>Con IDA è possibile ordinare le funzioni per dimensione crescente.</p>



<p>Se adottiamo questo approccio con il campione offuscato di emotet, notiamo che la quarta funzione (in ordine) è usata per ottenere l&#8217;indirizzo del PEB.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" decoding="async" width="1024" height="196" src="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-120-1024x196.png" alt="" class="wp-image-1527" srcset="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-120-1024x196.png 1024w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-120-300x57.png 300w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-120-768x147.png 768w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-120-1536x294.png 1536w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-120.png 1756w" sizes="auto, (max-width: 1024px) 100vw, 1024px" /><figcaption>La funzione di accesso al PEB.</figcaption></figure></div>



<p>Questa funzione è usata solo in un altro punto del codice, mostra qui sotto.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" decoding="async" width="848" height="1024" src="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-121-848x1024.png" alt="" class="wp-image-1528" srcset="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-121-848x1024.png 848w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-121-248x300.png 248w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-121-768x928.png 768w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-121.png 1030w" sizes="auto, (max-width: 848px) 100vw, 848px" /><figcaption>Cosa farà questa funzione? Gli offset usati parlano chiaro.</figcaption></figure></div>



<p>L&#8217;occhio esperto riconosce immediatamente gli offset usati nella struttura PEB, questa funzione scorre la lista dei moduli (DLL) caricati in memoria.<br>Possiamo quindi ipotizzare (dall&#8217;istruzione di xor successiva) che la chiamata evidenziata in giallo sia verso una funzione che fa l&#8217;hashing del nome della DLL.</p>



<p>Analizzando la chiamata in questione si scopre essere proprio questo il caso.<br>L&#8217;algoritmo di hashing è molto semplice e riportato qui sotto.</p>



<pre style="font-family: monospace; overflow: auto; font-size:0.7em; background-color:#f0f0f0; max-height:30em;">
def hash(string, ci=False):
    res = 0
    for x in string:
        res = (ord(x.lower() if ci else x) + (res << 0x10) + (res << 6) - res) &#038; 0xffffffff
    return hex(res)
</pre>
<div style="text-align:center; font-style:italic;">La funzione di hashing di Emotet.
</div>



<p>La funzione mostrata nella figura sopra non fa altro che recuperare il base address di una DLL, dato l'hashing del suo nome.<br>Anche questa funzione è utilizzata in un unico punto, insieme ad un'altra routine per recuperare un simbolo esportato da un PE.</p>



<p>Abbiamo quindi trovato la funzione che importa le API.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" decoding="async" width="828" height="958" src="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-122.png" alt="" class="wp-image-1529" srcset="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-122.png 828w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-122-259x300.png 259w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-122-768x889.png 768w" sizes="auto, (max-width: 828px) 100vw, 828px" /><figcaption>La funzione che importa le API.</figcaption></figure></div>



<p>Questa è usata sempre nel solito modo da Emotet: gli hash del modulo e della funzione da importare sono passati a getAPI, la quale ritorna un puntatore all'API ottenuta.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" decoding="async" width="646" height="390" src="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-123.png" alt="" class="wp-image-1530" srcset="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-123.png 646w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-123-300x181.png 300w" sizes="auto, (max-width: 646px) 100vw, 646px" /><figcaption>Come viene usata la funzione getAPI. Si notino i due hash passatogli.</figcaption></figure></div>



<p>Da questo come possiamo trovare le API importate?</p>



<p>Esattamente come abbiamo fatto con IDA. Il bello dello strumento che abbiamo macchinosamente creato è che ci indica per ogni funzione quali altre funzioni sono chiamate (tramite l'attributo <code>callees</code>) e che ci dà la possibilità di analizzare e modificare le istruzioni.</p>



<p>Possiamo identificare <code>getPEB</code> come l'unica funzione che contiene <code>mov eax, [fs:30h]</code> e quindi vedere chi la chiama per ottenere getModule.<br>Ripetiamo quest'ultimo passo per ottenere getAPI.</p>



<p>A questo punto possiamo scorrere il codice di <strong>tutti</strong> i BB per vedere se c'è una chiamata a <code>getAPI</code>, in caso positivo cerchiamo gli ultimi 4 push (qui occorre stare attenti al fatto che a volte sono presenti delle istruzioni pop, che se non gestite falserebbero il conteggio) e recupere gli hash.</p>



<p>Una volta ottenuti gli hash, dobbiamo trovare a quali moduli ed API corrispondono.<br>Abbiamo creato uno script che fa proprio questo e salva il risultato in un file JSON.</p>



<pre style="font-family: monospace; overflow: auto; font-size:0.7em; background-color:#f0f0f0; max-height:30em;">
import sys
import json
import pefile
import os
from collections import defaultdict

def hash(string, ci=False):
    res = 0
    for x in string:
        res = (ord(x.lower() if ci else x) + (res << 0x10) + (res << 6) - res) &#038; 0xffffffff
    return hex(res)

hashes = defaultdict(dict)
for filename in sys.argv[1:]:
    basename = os.path.basename(filename)
    module_hash = hash(basename, True)
    
    try:
        pe = pefile.PE(filename)
    except pefile.PEFormatError:
        continue
    hashes[module_hash]["name"] = basename
    hashes[module_hash]["exports"] = {}
    if not hasattr(pe, "DIRECTORY_ENTRY_EXPORT"):
        continue
    for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
        if exp.name is None:
            continue
        export_hash = hash(exp.name.decode('ascii'))
        hashes[module_hash]["exports"][export_hash] = exp.name.decode('ascii')
    print(basename)
with open("exports.json", "w") as f:
    json.dump(hashes, f)
</pre>
<div style="text-align:center; font-style:italic;">Lo script casareccio per l'associazione tra hash ed API. Processa i PE passati da riga di comando e
crea un file exports.json.
</div>



<p>Grazie al file <em>export.json</em> generato tramite lo script, possiamo finalmente ottenere, per ogni chiamata a <code>getAPI</code>, l'effettiva API importata.</p>



<p>Non ci rimane che modificare il codice affinchè chiami l'API direttamente.<br>Questo richiede la creazione di una directory di import nel file PE, questa operazione non verrà discussa in quanto piuttosto semplice.<br>Dato che Emotet è stato compilato usando la convenzione di chiamata C, possiamo semplicmente rimuovere la chiamata a <code>getAPI</code> e sostituire <code>call eax</code> con <code>call [import]</code>, dove <em>import</em> è il VA dell'entry opportuna nell'<em>Import Address Table</em>.</p>



<p>Il risultato è mostrato di seguito.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" decoding="async" width="699" height="1024" src="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-125-699x1024.png" alt="" class="wp-image-1532" srcset="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-125-699x1024.png 699w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-125-205x300.png 205w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-125-768x1126.png 768w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-125-1048x1536.png 1048w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-125-1397x2048.png 1397w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-125.png 1415w" sizes="auto, (max-width: 699px) 100vw, 699px" /><figcaption>Il sample di Emotet con le API importate.</figcaption></figure></div>



<p>Una miglioria possible è quella di rimuovere interamente la funzione wrapper intorno alla chiamata API (quella che nella figura sopra abbiamo chiamato <code>VirtualAllocAPI</code>).</p>



<p>Il codice per l'importazione delle API è riportato sotto.<br>La procedura ritorna una sezione da passare a <code>save_pe</code>, è la sezione che contiene i dati della directory di import.</p>



<pre style="font-family: monospace; overflow: auto; font-size:0.7em; background-color:#f0f0f0; max-height:30em;">
def import_apis(pe_dll):
    def _is_mov_eax_fs_30(inst):
        return (
            inst.code == Code.MOV_EAX_MOFFS32 and inst.op0_register == Register.EAX and inst.op_kind(1) == OpKind.MEMORY 
            and inst.memory_segment == Register.FS and inst.memory_displacement == 0x30)
    def _is_retn(inst):
        return inst.code == Code.RETND

    def _is_call_to(inst, target):
        return inst.flow_control == FlowControl.CALL and inst.near_branch_target == target

    def is_call_eax(inst):
        return inst.flow_control == FlowControl.INDIRECT_CALL and inst.op_kind(0) == OpKind.REGISTER and inst.op0_register == Register.EAX

    def _is_push_imm(inst):
        return inst.code in [Code.PUSHD_IMM8, Code.PUSHD_IMM32]

    #First we find the getPEB proc
    """
    mov     eax, large fs:30h
    retn
    """
    get_peb_fun = None
    for _, f in Function.CACHE.items():
        if len(f.head.nexts) != 0 or len(f.head.insts) != 2:
            continue

        if not _is_mov_eax_fs_30(f.head.insts[0]) or not _is_retn(f.head.insts[1]):
            continue 
        
        get_peb_fun = f
        break

    if get_peb_fun is not None:
        print(f"Found getPEB at {hex(get_peb_fun.head.start_address)}")
    else:
        return 

    #Now the only function that call getPEB
    get_module_fun = None
    for _, f in Function.CACHE.items():
        if get_peb_fun in f.callees:
            get_module_fun = f
            break
       
    if get_module_fun is not None:
        print(f"Found getModule at {hex(get_module_fun.head.start_address)}")
    else:
        return 

    #Now the only function that call getModule
    get_api_fun = None
    for _, f in Function.CACHE.items():
        if get_module_fun in f.callees:
            get_api_fun = f
            break
       
    if get_api_fun is not None:
        print(f"Found getAPI at {hex(get_api_fun.head.start_address)}")
    else:
        return 


    xrefs = []
    #Now get the XREF to get API
    for _, bb in BasicBlock.CACHE.items():
        for n, inst in enumerate(bb.insts):
            if _is_call_to(inst, get_api_fun.head.start_address):
                xrefs.append((bb, bb.insts[n-1::-1]))
                break
    
    if len(xrefs) > 0:
        print(f"Found {len(xrefs)} XREFS to getAPI")
    else:
        return


    #Now get the module and export hashes
    api_hashes = []
    for bb, insts in xrefs:
        module_hash = export_hash = None
        n_push = 0
        for inst in insts:
            if inst.flow_control == FlowControl.CALL:
                break
            if inst.mnemonic == Mnemonic.POP:
                n_push -= 1
            elif inst.mnemonic == Mnemonic.PUSH:
                if n_push == 0:
                    if not _is_push_imm(inst):
                        break
                    module_hash = inst.immediate(0)
                elif n_push == 3:
                    if _is_push_imm(inst):
                        export_hash = inst.immediate(0)
                    break
                n_push += 1
        if module_hash is not None and export_hash is not None:
            api_hashes.append((bb, module_hash ^ 0x39CEFC97, export_hash ^ 0x5E3043F1))
        else:
            print(f"API NOT PROCESSED: {hex(bb.start_address)}")
    print(f"Found {len(api_hashes)} API hashes")
    
    #Resolve the hashes
    import json
    with open("exports.json") as f:
        exports = json.load(f)

    apis = []
    for bb, mod, exp in api_hashes:
        if hex(mod) in exports:
            apis.append((bb, exports[hex(mod)]["name"], exports[hex(mod)]["exports"][hex(exp)]))

    #Make the import section
    idata, api_patch = make_import_sec(apis, pe_dll)
    
    #Now, nop the call to getAPI and replace the call eax after it
    for bb, dll, exp in apis:
        i = -1
        while i + 1 < len(bb.insts):
            i += 1
            inst = bb.insts[i]
            if _is_call_to(inst, get_api_fun.head.start_address):
                
                bb.insts.remove(inst)

                for j in range(i+1, len(bb.insts)):
                    inst_2 = bb.insts[j]
                    if is_call_eax(inst_2):
                        bb.insts.remove(inst_2)
                        #print(f"Patching API to {hex(pe_dll['image_base'] + api_patch[dll][exp])}")
                        bb.insts.insert(j, Instruction.create_mem(Code.CALL_RM32, 
                            MemoryOperand(displ = pe_dll["image_base"] + api_patch[dll][exp]) ))

                bb.update_len()
                break

    return idata
</pre>
<div style="text-align:center; font-style:italic;">Il codice per ripristinare l'import delle API.
</div>



<h2 class="wp-block-heading">Ripristino delle stringhe</h2>



<p>Seguendo Emotet con un debugger, si nota che le stringhe sono deoffuscate al volo.<br>Da analisi manuale è possibile riconoscere due metodi per la decodifca delle stringhe, entrambi identici se non nel formato di output (uno unicode, l'altro no).</p>



<p>Il reverse engineering dell'algoritmo è piuttosto semplice, riportiamo direttamente il formato delle stringhe.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" decoding="async" width="799" height="146" src="https://cert-agid.gov.it/wp-content/uploads/2020/12/emotet-strings.png" alt="" class="wp-image-1533" srcset="https://cert-agid.gov.it/wp-content/uploads/2020/12/emotet-strings.png 799w, https://cert-agid.gov.it/wp-content/uploads/2020/12/emotet-strings-300x55.png 300w, https://cert-agid.gov.it/wp-content/uploads/2020/12/emotet-strings-768x140.png 768w" sizes="auto, (max-width: 799px) 100vw, 799px" /><figcaption>La chiave XOR è, appunto, xorata con la lunghezza ed i byte della stringa.</figcaption></figure></div>



<p>Per identificare i metodi di decodifica possiamo:</p>



<ol class="wp-block-list"><li>Trovare tutte le istruzioni mov e push che hanno un operando che fa riferimento ad una stringa dentro la sezione <em>.data</em>.</li><li>Provare a decodificare ogni singola stringa  e scartare le istruzioni che non portano a stringhe valide (troppo lunghe o con caratteri &gt;= 0x80).</li><li>Delle restanti istruzioni, trovare la chiamata successiva più prossima. Otteniamo un insieme di funzioni candidate ad essere quelle di decodifica.</li><li>Ridurre la lista di candidati eliminando quelli che sono chiamati da altri candidati (questo succede quando la stringa è passata ad una funzione wrapper che chiama quella di decodifica).</li><li>Se si ottengono solo due candidati, quello con più chiamate è la funzione di decodifica unicode, l'altra quella ANSI.</li></ol>



<p>Di questi passi, solo il quinto è arbitrario, il resto fa uso solo delle informazioni presenti del codice parsato.</p>



<p>La chiamata alla funzione di decodifica può quindi essere sostituita con un'istruzione <code>mov eax, imm32</code> che ottiene il puntatore alla stringa già decodificata.</p>



<p>Per fare questo è necessario aggiungere un'altra sezione dati (<em>.data2</em>) al PE di Emotet.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" decoding="async" width="1024" height="812" src="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-126-1024x812.png" alt="" class="wp-image-1534" srcset="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-126-1024x812.png 1024w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-126-300x238.png 300w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-126-768x609.png 768w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-126-1536x1218.png 1536w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-126.png 1766w" sizes="auto, (max-width: 1024px) 100vw, 1024px" /><figcaption>Le stringhe di Emotet, da queste si intuisce il funzionamento del malware.</figcaption></figure></div>



<p>Il codice per la decodifica delle stringhe è riportato sotto, la procedura ritorna la sezioni dati da passare a <code>save_pe</code>.</p>



<pre style="font-family: monospace; overflow: auto; font-size:0.7em; background-color:#f0f0f0; max-height:30em;">
def decode_strings(dll):
    def _decode_string(data, offset, unicode):
        xor_key = struct.unpack("<I", data[offset:offset+4])[0]
        str_len = xor_key ^ struct.unpack("<I", data[offset+4:offset+8])[0]
        if str_len > 0x80:
            return None
        res = ""
        offset += 8
        while str_len > 0:
            cur_data = xor_key ^ struct.unpack("<I", data[offset:offset+4])[0]
            #print(f"cur_data: {hex(cur_data)}.")
            res += chr(cur_data &#038; 0xff)
            res += ("\0" if unicode else "")
            if str_len > 1:
                res += chr((cur_data >>8) & 0xff)
                res += ("\0" if unicode else "")
            if str_len > 2:
                res += chr((cur_data >>16) & 0xff)
                res += ("\0" if unicode else "")
            if str_len > 3:
                res += chr((cur_data >>24) & 0xff)
                res += ("\0" if unicode else "")
            str_len -= 4
            offset += 4

        res += "\0"
        res += ("\0" if unicode else "")
        return res



    def _is_null_sub(addr):
        return len(Function.CACHE[inst.near_branch_target].head.nexts) == 0 and len(Function.CACHE[inst.near_branch_target].head.insts) == 1
    #Look for push and mov of offsets in the data sections
    data_va_min = dll["image_base"] + dll["data"]["rva"]
    data_va_max = data_va_min + dll["data"]["size"]

    data = []
    decoders = {}
    for _, bb in BasicBlock.CACHE.items():
        armed = False
        for n, inst in enumerate(bb.insts):
            if inst.code == Code.PUSHD_IMM32 and inst.immediate(0) >= data_va_min and inst.immediate(0) < data_va_max:
                data.append((bb, n, inst.immediate(0)))
                armed = True
            elif inst.code == Code.MOV_R32_IMM32 and inst.immediate(1) >= data_va_min and inst.immediate(1) < data_va_max:
                data.append((bb, n, inst.immediate(1)))
                armed = True
            elif armed and inst.flow_control == FlowControl.CALL:
                if not _is_null_sub(inst.near_branch_target):
                    addr = inst.near_branch_target
                    decoders[addr] = decoders.get(addr, 0)
                    decoders[addr]+=1
                    bb, on, va = data[-1]
                    data[-1] = (bb, on, va, n, addr)
                armed = False

    #Remove functions that call other functions marked as decoders
    to_remove = []
    wrappers = {}
    decoders_addrs = [x for x in decoders.keys()]
    for i in range(0, len(decoders)):
        others = decoders_addrs[0:i] + decoders_addrs[i+1:]
        cur_decoder = Function.CACHE[decoders_addrs[i]]
        for callee in cur_decoder.callees:
            if callee.head.start_address in others:
                to_remove.append(cur_decoder.head.start_address)
                wrappers[decoders_addrs[i]] = callee.head.start_address

    for r in to_remove:
        del decoders[r]

    if len(decoders) != 2:
        raise ValueError("Cannot recognize the decoders!")

    decoders_addrs = [x for x in decoders.keys()]
    unicode_dec = decoders_addrs[0] if decoders[decoders_addrs[0]] > decoders[decoders_addrs[1]] else decoders_addrs[1]
    singlebyte_dec = decoders_addrs[0] if decoders[decoders_addrs[0]] <= decoders[decoders_addrs[1]] else decoders_addrs[1]

    #print(f"Found {len(data)} references to data.")
    #print(f"Unicode decoder: {hex(unicode_dec)}, single byte decoder: {hex(singlebyte_dec)}.")

    #Decode strings
    data_sec = make_sec(dll, ".data2", dll["data"]["size"] * 2, True)
    data_offset = 0
    data_data = bytearray(dll["data"]["size"] * 2)
    data_rva = dll["image_base"] + data_sec["rva"]

    for bb, n_data, vaddr, n_call, call_target in [d for d in data if len(d) == 5]:
        offset = vaddr - dll["image_base"] - dll["data"]["rva"]
        string = _decode_string(dll["data"]["data"], offset, call_target != singlebyte_dec)
        if string is None:
            continue
        new_va = data_rva + data_offset
        data_data[data_offset:data_offset + len(string)] = string.encode("ascii")
        data_offset += len(string)

        new_inst = Instruction.create_reg_u32(Code.MOV_R32_IMM32, Register.EAX, new_va)
        
        """
        if bb.insts[n_data].mnemonic == Mnemonic.PUSH:
            new_inst = Instruction.create_u32(Code.PUSHD_IMM32, new_va)
        else:
            new_inst = Instruction.create_reg_u32(Code.MOV_R32_IMM32, Register.EAX, new_va)
        """

        del bb.insts[n_call]
        bb.insts.insert(n_call, new_inst)
        bb.update_len()

    data_sec["data"] = data_data
    return data_sec
</pre>
<div style="text-align:center; font-style:italic;">Il codice per la decodifica delle stringhe.
</div>



<p>Anche in questo caso si tratta di codice prototipo.<br>Qui, come nel caso delle API importate, non sono aggiunte rilocazioni per gli indirizzi usati.<br>Il PE ottenuto non è quindi usabile per il debug a meno di non forzarne la caricatura al suo base address designato (ad esempio rimuovengo il flag "DLL can move" dall'header PE).</p>



<h2 class="wp-block-heading">Rimozione della CFO</h2>



<p>Questa è la parte più complessa (e buggata) dello script che stiamo costruendo.</p>



<p>Osserviamo il codice sottostante.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" decoding="async" width="1024" height="456" src="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-127-1024x456.png" alt="" class="wp-image-1536" srcset="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-127-1024x456.png 1024w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-127-300x134.png 300w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-127-768x342.png 768w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-127-1536x684.png 1536w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-127-2048x912.png 2048w" sizes="auto, (max-width: 1024px) 100vw, 1024px" /><figcaption>Il codice che dirama il controllo in base al token.</figcaption></figure></div>



<p>Avevamo già notato che questa forma di CFO si basa sul confronto di un valore, detto token, contenuto in un registro. In base al valore attuale del token, l'esecuzione finisce in un blocco piuttosto che in un altro.</p>



<p>La prima sfida consiste nell'identificare i BB di una funzione che effettuano questi confronti (chiamiamoli "BB di diramazione"). Possiamo dire che hanno tutti queste caratteristiche:</p>



<ul class="wp-block-list"><li>Sono composti da due, tre od una sola istruzione.</li><li>Nel caso vi siano due istruzioni, la prima è del tipo <code>cmp rm32, imm32</code> o <code>cmp r32, rm32</code>. Ovvero un confronto tra un registro ed un valore immediato o un altro registro. La seconda è un salto condizionale.</li><li>Nel caso vi sia solo un'istruzione, questa è un salto condizionale.</li><li>I salti condizionali hanno la forma <code>jg</code>, <code>jz</code>/<code>je</code> e <code>jnz</code>/<code>jne</code>.</li><li>Nel caso vi siano tre istruzioni, la prima è del tipo <code>mov rm32, imm32</code> e le altre due come nel punto 2. Ovvero, la prima istruzione imposta il registro, usato come secondo operando nel confronto, ad un valore noto.</li><li>Il registro usato per contenere il token è variabile.</li></ul>



<p>Questi punti non identificano i BB di diramazione in modo univoco, vi possono essere dei falsi positivi, in fin dei conti operazioni di confronto e salto compaiono spesso anche in funzioni non offuscate.<br>Dobbiamo quindi aggiungere delle euristiche per limitare i falsi positivi, ad esempio:</p>



<ul class="wp-block-list"><li>Dal primo blocco di una funzione raggiungiamo il primo blocco che ha due successori. Questo è un BB di diramazione se ha almeno due istruzioni, è nella forma indicata dalla lista sopra e almeno uno dei suoi successori è, a sua volta, un BB di diramazione.</li><li>Un successore del primo BB di diramazione è, a sua volta, un BB di diramazione se è nella forma indicata dalla lista sopra.</li></ul>



<p>Chiamiamo il primo blocco di diramazione (punto 1), il "blocco della CFO".</p>



<p>Quando siamo in grado di identificare in modo abbastanza affidabile i BB di diramazione, possiamo focalizzarci sul problema successivo: costrutire una mappa che per ogni valore del token ci dia il BB a cui arriva l'esecuzione.</p>



<p>Ad esempio, limitatamente ai blocco mostrati nella figura in alto, vogliamo costruire la mappa seguente:</p>



<pre style="font-family: monospace; overflow: auto; font-size:0.7em; background-color:#f0f0f0; max-height:30em;">{
	0x2C2F6692: &lt;BB a 0x1001c112&gt;,
	0x31BCED90: &lt;BB a 0x1001c108&gt;,
	0x00D59B4E: &lt;BB a 0x1001bf1e&gt;,
	0x36A336EE: &lt;BB a 0x1001c08b&gt;,
}
</pre>
<div style="text-align:center; font-style:italic;">Mappa che per ogni token indica il BB di destinazione.
</div>



<p>Per costruire questa mappa usiamo una funzione ricorsiva che è inizialmente richiamata sul primo BB di diramazione. Questa funzione necessità di sapere lo stato (parziale) dei registri e l'ultimo valore usato per il confronto.<br>Con queste informazioni, quando trova un salto nella forma jz o jnz, può associare l'ultimo valore usato per il confronto con una delle destinazioni del salto.<br>Ci serve quindi una funzione che processi ogni istruzione di un BB per costrutire una mappa dei valori contenuti nei registri, limitandosi a considerare solo le istruzioni <code>mov rm32, imm32</code> e <code>mov r32, rm32</code>, poichè sono queste quelle usate per impostare eventuali registri usati nei confronti.</p>



<pre style="font-family: monospace; overflow: auto; font-size:0.7em; background-color:#f0f0f0; max-height:30em;">    def _compute_registers(self, insts, cur_reg={}):
        registers = cur_reg.copy()
        for inst in insts:
            if self._is_mov_rm32_imm32(inst):
                registers[inst.op0_register] = inst.immediate(1)
            if self._is_mov_r32_rm32_any(inst) and inst.op1_register in registers:
                registers[inst.op0_register] = registers[inst.op1_register]
        return registers

    def _is_cfo_bb(self, bb):
        return len(bb.nexts) == 2 and (
            len(bb.insts) == 1 and self._is_jcc(bb.insts[0])
            or
            len(bb.insts) == 2 and self._is_cmp_r32_ri32(bb.insts[0]) and self._is_jcc(bb.insts[1])
            or
            len(bb.insts) == 3 and self._is_mov_rm32_imm32(bb.insts[0]) and self._is_cmp_r32_ri32(bb.insts[1]) and self._is_jcc(bb.insts[2])
                and bb.insts[0].op0_register == bb.insts[1].op1_register
            )

    #Make a map {token: bb} than tell for every token the BB of destination
    def _map_token(self, tokens, last_rhs, registers, bb, first=True):

        if first == False and not self._is_cfo_bb(bb):
            print("Stopped because not first and not a CFO BB : " + hex(bb.start_address))
            bb._show()
            return
        if first == True and (not self._is_cfo_bb(bb) or (not self._is_cfo_bb(bb.nexts[0]) and not self._is_cfo_bb(bb.nexts[1]))):
            print("Stopped because first and not a CFO BB followed by CFOs : "  + hex(bb.start_address))
            bb._show()
            return

        if not first and bb == self._cfo_start:
            return

        if len(bb.insts) == 2:
            cmp_reg, cmp_imm = self._get_cmp_operands(bb.insts[0], registers)
            if cmp_reg is None or cmp_imm is None:
                raise ValueError("Excepted a cmp instruction!")
            if cmp_reg != self._cfo_reg:
                raise ValueError("Expected the CFO cmp reg!")
            if not self._is_jcc(bb.insts[1]):
                raise ValueError("Excepted a jcc instruction!")
            cc = bb.insts[1].condition_code
        elif len(bb.insts) == 1:
            cmp_imm = last_rhs  
            if cmp_imm is None:
                raise ValueError("Expected a non null rhs!")  
            cc = bb.insts[0].condition_code
        elif len(bb.insts) == 3:
            registers = self._compute_registers(bb.insts, registers)
            cmp_imm = registers[bb.insts[0].op0_register]
            cc = bb.insts[2].condition_code

        if cc == ConditionCode.E:
            tokens[cmp_imm] = bb.nexts[1]
            self._map_token(tokens, cmp_imm, registers, bb.nexts[0], False)
        elif cc == ConditionCode.NE:
            tokens[cmp_imm] = bb.nexts[0]
            self._map_token(tokens, cmp_imm, registers, bb.nexts[1], False)
        else:
            self._map_token(tokens, cmp_imm, registers, bb.nexts[0], False)
            self._map_token(tokens, cmp_imm, registers, bb.nexts[1], False)

</pre>
<div style="text-align:center; font-style:italic;">Codice per la costruzione della mappa token-BB.
</div>



<p>Una volta ottenuta questa mappa, l'idea generale per rimuovere l'offuscazione CFO è quella di partire dal primo blocco di una funzione e seguire tutti i  successori, calcolando nel frattendo i valori dei vari registri.<br>Qualora un successore sia il blocco della CFO (vedi definizione sopra), lo sostituiamo con il blocco indicatoci dalla mappa appena costruita.</p>



<p>Dobbiamo però considerare altri tre aspetti importanti, i primi due si risolvono con lo stesso accorgimento e li trattiamo insieme. Ci riferiamo ai cicli (che risulterebbero in una ricorsione infinita) e ai blocchi condivisi.</p>



<p>Riconsideriamo la figura in alto, ma focalizzandosi su un blocco in particolare.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" decoding="async" width="1024" height="728" src="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-128-1024x728.png" alt="" class="wp-image-1537" srcset="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-128-1024x728.png 1024w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-128-300x213.png 300w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-128-768x546.png 768w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-128.png 1134w" sizes="auto, (max-width: 1024px) 100vw, 1024px" /><figcaption>Il blocco evidenziato è un blocco condiviso, due esecuzioni vi passano sopra con valori del token che sono diversi.</figcaption></figure></div>



<p>Il blocco evidenziato è un blocco condiviso da due rami di esecuzioni (il primo proveniente dal blocco sopra, l'altro da un altro blocco non mostrato) che hanno due valori diversi del token.<br>Il nostro algoritmo si limiterebbe a cambiare il successo di questo blocco prima verso una destinazione e poi verso l'altra, risultato così in un grafo non corretto.</p>



<p>Per ovviare a questo problema, salviamo per ogni blocco lo stato dei registri alla fine della sua esecuzione, nel caso questa differisse con lo stato creato da una precedente esecuzione, il blocco è <strong>clonato</strong>.<br>L'indirizzo a cui mettere il blocco clonato può essere arbitrario, purchè unico, questo è il vantaggio di aver reificato l'esecuzione tramite i BB.</p>



<p>Inoltre, se il valore dei registri risulta identico a quello già calcolato da un'altra esecuzione, il blocco è già stato processato e possiamo interrompere il ramo di esecuzione corrente, di fatto rompedo la ricorsione infinita.</p>



<p>L'ultimo problema sta nel modo in cui alcuni BB calcolano il token successivo.<br>Nella maggioranza dei casi viene usata un'istruzione mov ma è presente anche un'altra variante, usata come ottimizzazione al posto di un salto.</p>



<p>Questa variante è usata quanto vi è una chiamata ad una funzione che ritorna un valore 0 o non-0 e, in base a questo, due possibili token sono scelti.<br>Anzichè usare un "if" per scegliere uno dei due valori, <code>t0</code> o <code>t1</code>, viene usata la formula <code>token = t0 + (t1-t0) &amp; (0xffffffff if eax != 0 else 0)</code>.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" decoding="async" width="540" height="226" src="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-129.png" alt="" class="wp-image-1538" srcset="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-129.png 540w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-129-300x126.png 300w" sizes="auto, (max-width: 540px) 100vw, 540px" /><figcaption>Il registro ESI contiene il token, la chiamata in alto ritorna un valore nullo o non nullo ed in base a questa dicotomia, un token viene scelto.</figcaption></figure></div>



<p>L'espressione <code>0xffffffff if eax != 0 else 0</code> è calcolata con due istruzioni: <code>neg</code>, che setta il CF solo se eax non è zero, e <code>sbb</code> (<em>sub with borrow</em>) che ritorna 0, se CF è 0, o 0xffffffff, se CF è 1.</p>



<p>Questo è un caso particolare che va considerato a parte, qualora rilevassimo la presenza di queste istruzioni, dobbiamo considerare come se il blocco avesse due successori, ognuno con il proprio stato dei registri (che differisce solo per il registro in cui è messo il token).<br>Un'altra complicazione è dovuta al fatto che a volte l'ultima istruzione si trova in un BB a parte, dobbiamo quindi gestire anche questo caso particolare.</p>



<p>Il codice finale è quello del metodo <code>_cfo_trace</code> della classe <code>Function</code>.</p>



<pre style="font-family: monospace; overflow: auto; font-size:0.7em; background-color:#f0f0f0; max-height:30em;">
def _cfo_trace(self, registers, bb, parent_bb, parent_next_index):

        print(f"Tracing block {hex(bb.start_address)}.")
        print(f"Last registers: {bb._cfo_last_registers is not None}.")
        print(f"Last token: {bb._cfo_last_registers[self._cfo_reg] if bb._cfo_last_registers is not None else None}.")
        #If this is the last block, done
        if len(bb.nexts) == 0:
            return

        #Compute the registers at the end of the block
        new_registers = self._compute_registers(bb.insts, registers)
        print(f"Registers computed, token is {hex(new_registers[self._cfo_reg])}.")

        #Dynamic branch case
        branch_z, branch_nz = self._get_bb_dynamic_branches(bb)
        if branch_z is not None and branch_nz is not None:
            print(f"Dynamic branches.")
            if (len(bb.nexts) != 1 or bb.nexts[0] != self._cfo_start): 
                raise ValueError("WEIRD CASE!")
            
            #Make the new regs
            regs_branch_z = new_registers.copy()
            regs_branch_z[self._cfo_reg] = branch_z
            regs_branch_nz = new_registers.copy()
            regs_branch_nz[self._cfo_reg] = branch_nz

            #Update this block regs with a 64-bit value holding both values
            new_registers[self._cfo_reg] = branch_z | (branch_nz << 32)

            print(f"Registers computed, token is {hex(new_registers[self._cfo_reg])}.")

        #If this is has already been done, stop
        cfo_token = new_registers[self._cfo_reg]
        if bb._cfo_last_registers and bb._cfo_last_registers[self._cfo_reg] == cfo_token:
            print("ALREADY PROCESSED")
            return

        print(f"{hex(bb.start_address)} never processed with {hex(cfo_token)}.")
        #Make the dinamic branches explicit
        if branch_z is not None and branch_nz is not None:
            print("Dynamic branch processing.")
            bb.insts = bb.insts[:-6]
            bb.insts.append(Instruction.create_reg_reg(Code.TEST_RM32_R32, Register.EAX, Register.EAX))
            bb.insts.append(Instruction.create_branch(Code.JE_REL32_32, self._cfo_start.start_address))
            bb.update_len()
            bb.nexts = [self._cfo_tokens[branch_nz], self._cfo_tokens[branch_z]]

            self._cfo_trace(regs_branch_nz, bb.nexts[0], bb, 0)
            self._cfo_trace(regs_branch_z, bb.nexts[1], bb, 1)

        else:
            #If this has been done but with different register, copy the block
            if bb._cfo_last_registers and bb._cfo_last_registers[self._cfo_reg] != cfo_token:
                print("Copying block.")
                bb = bb.duplicate()
                parent_bb.nexts[parent_next_index] = bb

            #Move to each next bb, but skip CFO
            bb._cfo_last_registers = new_registers
            for n, nbb in enumerate(bb.nexts):
                if nbb == self._cfo_start:
                    bb.nexts[n] = self._cfo_tokens[cfo_token]
                    print(f"Successor {n} goes to CFO, replacing with {hex(bb.nexts[n].start_address)}")
                self._cfo_trace(bb._cfo_last_registers, bb.nexts[n], bb, n)

</pre>
<div style="text-align:center; font-style:italic;">Il metodo per la rimozione della CFO di una funzione.
</div>



<p>Le tecniche usate necessitano ancora di vari affinamenti, ma siamo riusciti a deoffuscare la routine principale di Emotet.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" decoding="async" width="1024" height="724" src="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-130-1024x724.png" alt="" class="wp-image-1539" srcset="https://cert-agid.gov.it/wp-content/uploads/2020/12/image-130-1024x724.png 1024w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-130-300x212.png 300w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-130-768x543.png 768w, https://cert-agid.gov.it/wp-content/uploads/2020/12/image-130.png 1449w" sizes="auto, (max-width: 1024px) 100vw, 1024px" /><figcaption>La routine principale di Emotet, prima (a sinistra) di essere processata, e dopo (a destra).</figcaption></figure></div>



<p>Per riferimento (e solo per questo), è possibile scaricare lo script usato <a href="https://cert-agid.gov.it/wp-content/uploads/2020/12/emotent_processing.zip">qui</a>.<br>Facciamo presente, e rimarcato dall'estensione .txt usata, che lo script non è da intendersi come un deoffuscatore ma piuttosto come esempio di alcune tecniche di deoffuscazione.</p>



<p>Lo script contenuto nell'archivio allegato nel paragrafo precedente, contiene alcune migliorie rispetto al codice mostrato in questo articolo.</p>



<p>Il DB IDA della DLL processa è scaricabile <a href="https://cert-agid.gov.it/wp-content/uploads/2020/12/emotet.proc_.i64.zip">qui</a> (si ricorda che si tratta essenzialmente di un PoC).</p>



<h2 class="wp-block-heading">Breve panoramica di Emotet</h2>



<p>Di Emotet si parla già a sufficienza in letteratura, vogliamo qui solo dare una <strong>panoramica superficiale</strong> di quello che è più facilmente intuibile dall'analisi statica della DLL deoffuscata.</p>



<p>Quest'ultima carica le seguenti librerie: advapi32.dll, crypt32.dll, shell32.dll, shlwapi.dll, urlmon.dll, userenv.dll, wininet.dll.<br>In questo modo il meccanismo di importazione della API visto precedentemente, che fa uso del PEB e della relativa lista di moduli caricati, può trovare le funzioni necessarie.</p>



<p>Effettua una serie di controlli e, se tutti i requisiti sono soddisfatti, crea una copia di se stesso all'interno di una nuova cartella, generata con caratteri casuali, dentro <em>%LocalAppData%</em>. In caso contrario invoca <code>ExitProcess</code> e termina l'esecuzione.</p>



<p>Successivamente genera un servizio con <code>rundll32.exe</code>, quindi il loader chiama la funzione <code>ChangeServiceConfig2W</code> per modificarne la descrizione. </p>



<p>La chiamata API a <code>OpenSCManagerW</code> viene utilizzata per pianificare operazioni che ne garantiscono la persistenza al riavvio della macchina. Altro metodo utilizzato per la persistenza è l'uso della chiave di registro "<em>HKCU\Software\Microsoft\Windows\CurrentVersion\Run</em>" come abbiamo visto nella sezione decodificata.</p>



<p>Tramite la chiamata a <code>PathFindFileNameW</code> verifica la presenza di determinati file sul disco, enumera i servizi (<code>EnumServicesStatusExW, Process32FirstW, Process32NextW)</code>, acquisisce informazioni sulla macchina (<code>GetComputerNameExW</code>), infine i dati raccolti vengono cifrati tramite l'uso della libreria crypt32 e inviati al C2 tramite richiesta POST.</p>



<p>La presenza delle API InternetXXX mostra chiaramente come Emotet comunichi con il C2.<br>La stringa "<em>%u.%u.%u.%u</em>" evidenzia l'utilizzo di un indirizzo IP, anzichè di un hostname, per identificare il C2.</p>



<p></p>
	    </div>

          </article>
	 <section>
		<div class="u-padding-top-xs" style="border-bottom: 2px solid #aaaaaa; margin-bottom: 4rem; "></div> 
		<div class="u-padding-left-s">
			Taggato&nbsp; 
						<a class="tag-item u-textClean u-textWeight-700 u-text-r-xxs u-color-80-commented u-color-print " href="https://cert-agid.gov.it/tag/emotet/">
				emotet			</a>
		</div>
	 </section>
	  
		<div class="u-padding-bottom-xl u-margin-top-l" style="border-top: 1px solid #aaaaaa"></div>		
	 	
	<nav class="navigation post-navigation" aria-label="Articoli">
		<h2 class="screen-reader-text">Navigazione articoli</h2>
		<div class="nav-links"><div class="nav-previous"><a href="https://cert-agid.gov.it/news/riepilogo-delle-campagne-malevole-che-hanno-interessato-litalia-nellultimo-quadrimestre-2020/" rel="prev"><span class="u-hiddenVisually u-hiddenPrint">Notizia precedente</span> <span class="Icon-chevron-left u-text-r-s u-hiddenPrint" role="presentation u-hiddenPrint"></span><span class="u-text-s u-padding-r-left u-hiddenPrint u-hidden u-sm-inline u-md-inline u-lg-inline">Riepilogo delle campagne malevole che hanno interessato l&#8217;Italia  nell&#8217;ultimo quadrimestre 2020</span></a></div><div class="nav-next"><a href="https://cert-agid.gov.it/news/phishing/phishing-sfrutta-il-nome-dellagenzia-delle-dogane/" rel="next"><span class="u-hiddenVisually u-hiddenPrint">Prossima notizia:</span> <span class="u-text-s u-padding-r-right u-hiddenPrint u-hidden u-sm-inline u-md-inline u-lg-inline">Campagna di phishing sfrutta il nome dell&#8217;Agenzia delle Dogane</span><span class="Icon-chevron-right u-text-r-s u-hiddenPrint" role="presentation"></span></a></div></div>
	</nav>
  	          </div>

        <div class="Grid-cell u-sizeFull u-md-size2of12 u-lg-size2of12"></div>

      </div>

    </div>
  </div>
      </div>

    </div>
  </div>

  <!-- FOOTER -->
  
  <footer class="Footer u-background-95 u-margin-top-xxl u-hiddenPrint">
    <div class="u-layout-wide u-layout-r-withGutter u-layoutCenter">

      <div class="Grid Grid--withGutter Grid--alignMiddle">
        <div class="Grid-cell u-sizeFull u-sm-size1of2 u-md-size1of2 u-lg-size1of2" aria-hidden="true">
            
            <div class="Grid Grid--alignMiddle">
              <img class="Grid-cell Footer-logo u-sizeFit" src="/wp-content/themes/cert-agid/assets/images/cert-agid-logo-white.svg" alt="Logo del CERT-PA">
              <span class="Grid-cell Footer-siteName u-sizeFit" >CERT-AGID</span>
            </div>
<!--
            <img class="Footer-logo" src="/wp-content/themes/cert-agid/assets/images/cert-agid-logo-white.svg" alt="Logo del CERT-PA">
            <span class="Footer-siteName" >CERT-AGID</span>
-->
        </div>

        <div class="Grid-cell u-sizeFull u-sm-size1of2 u-md-size1of2 u-lg-size1of2 u-hidden u-sm-block u-md-block u-lg-block u-hiddenPrint">
          <form class="Form" action="/">
            <div class="Form-field Form-field--withPlaceholder Grid u-background-white u-color-gray-30 u-border-radius-s" role="search">
              <input type="text" name="s" class="Form-input Grid-cell u-sizeFill u-border-radius-s Form-input--ultraLean u-color-black u-text-r-xs" required id="cerca-in-footer" value="">
              <label for="cerca-in-footer" class="Form-label u-text-r-xxs u-color-grey-50">cerca nel sito</label>
              <button type="submit" class="clickable Grid-cell Icon Icon-search u-sizeFit u-padding-all-s u-color-gray-50 u-text-weight-700" title="Avvia la ricerca" aria-label="Avvia la ricerca">
            </div>          
          </form>
        </div>        
      </div>

      <div class="Footer-separator u-hiddenPrint" aria-hidden="true"></div>

      <div class="Grid Grid--withGutter Grid--alignMiddle Grid-sm--reverse u-hiddenPrint">
        <div class="Grid-cell u-sizeFull u-sm-size1of2 u-md-size1of2 u-lg-size1of2 u-margin-top-s u-sm-margin-top-none">
          <ul class="Footer-links u-cf">
<li id="menu-item-25" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-25"><a href="https://cert-agid.gov.it/contatti/">Contatti</a></li>
<li id="menu-item-24" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-privacy-policy menu-item-24"><a rel="privacy-policy" href="https://cert-agid.gov.it/privacy/">Privacy</a></li>
<li id="menu-item-26" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-26"><a href="https://cert-agid.gov.it/note-legali/">Note legali</a></li>
          </ul>
        </div> 
        <div class="Footer-linksRow Grid-cell u-sizeFull u-margin-top-xs u-margin-bottom-xs u-sm-margin-top-none u-sm-margin-bottom-none u-sm-size1of2 u-md-size1of2 u-lg-size1of2">
	  <h4 class="Footer-blockTitle">Seguici su</h4>
          <ul class="Footer-socialIcons">
              <li>
                <a href="https://cert-agid.gov.it/feed/" title="RSS">
                  <span class="Icon Icon-rss"></span>
                  <span class="u-hiddenVisually">RSS</span>
                </a>
              </li>
              <li>
                <a href="https://t.me/certagid" title="Telegram">
                  <span class="fab fa-telegram-plane"></span>
                  <span class="u-hiddenVisually">Telegram</span>
                </a>
              </li>
              <li>
                <a href="https://twitter.com/agidcert" title="X / Twitter">
                  <span class="fa-brands fa-x-twitter"></span>
                  <span class="u-hiddenVisually">X / Twitter</span>
                </a>
              </li>
	  </ul>
        </div> 
      </div>
   
    </div>
  </footer>
  
  <!-- Print footer -->
  <footer class="Footer u-margin-top-xxl u-blockPrint u-hidden" style="page-break-inside: avoid;">
    <div class="u-layout-wide u-layout-r-withGutter u-layoutCenter">

      <div class="Grid Grid--withGutter Grid--alignMiddle">
        <div class="Grid-cell u-sizeFull" aria-hidden="true">
            
            <div class="Grid Grid--alignMiddle">
              <img class="Grid-cell Footer-logo u-sizeFit" src="/wp-content/themes/cert-agid/assets/images/cert-agid-logo-black.svg" alt="Logo del CERT-PA">
              
              <span class="Grid-cell Footer-siteName u-sizeFit" >CERT-AGID</span>

              <div class="Grid-cell u-sizeFill u-color-print u-text-xl">
                <a href="https://cert-agid.gov.it/" class="Print-link">https://cert-agid.gov.it/</a>
              </div>
            </div>

        </div>
      </div>
    </div>
  </footer>

  <!--[if IE 8]>
  <script src="/wp-content/themes/cert-agid/build/vendor/respond.min.js"></script>
  <script src="/wp-content/themes/cert-agid/build/vendor/rem.min.js"></script>
  <script src="/wp-content/themes/cert-agid/build/vendor/selectivizr.js"></script>
  <script src="/wp-content/themes/cert-agid/build/vendor/slice.js"></script>
  <![endif]-->

  <!--[if lte IE 9]>
  <script src="/wp-content/themes/cert-agid/build/vendor/polyfill.min.js"></script>
  <![endif]-->

  <script>__PUBLIC_PATH__ = '/wp-content/themes/cert-agid/build/'</script>
  <script src="/wp-content/themes/cert-agid/build/IWT.min.js"></script>
<script type="text/javascript" src="https://cert-agid.gov.it/wp-content/themes/cert-agid/assets/js/imagelink.js?ver=1" id="image-link-js"></script>
</body>
</html>

<!--
Performance optimized by W3 Total Cache. Learn more: https://www.boldgrid.com/w3-total-cache/

Object Caching 150/310 objects using Memcached
Page Caching using Disk: Enhanced 

Served from: cert-agid.gov.it @ 2024-12-18 05:03:09 by W3 Total Cache
-->