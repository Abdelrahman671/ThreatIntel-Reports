<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Detecting Hotkey-Based Keyloggers Using an Undocumented Kernel Data Structure — Elastic Security Labs</title><meta name="description" content="In this article, we explore what hotkey-based keyloggers are and how to detect them. Specifically, we explain how these keyloggers intercept keystrokes, then present a detection technique that leverages an undocumented hotkey table in kernel space."/><meta property="og:title" content="Detecting Hotkey-Based Keyloggers Using an Undocumented Kernel Data Structure — Elastic Security Labs"/><meta property="og:description" content="In this article, we explore what hotkey-based keyloggers are and how to detect them. Specifically, we explain how these keyloggers intercept keystrokes, then present a detection technique that leverages an undocumented hotkey table in kernel space."/><meta property="og:image" content="https://www.elastic.co/security-labs/assets/images/detecting-hotkey-based-keyloggers/Security Labs Images 12.jpg?07356be5df2ef3656644e0c9480c1944"/><meta property="og:image:alt" content="In this article, we explore what hotkey-based keyloggers are and how to detect them. Specifically, we explain how these keyloggers intercept keystrokes, then present a detection technique that leverages an undocumented hotkey table in kernel space."/><meta property="og:site_name"/><meta property="og:url" content="https://www.elastic.co/security-labs/detecting-hotkey-based-keyloggers"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Detecting Hotkey-Based Keyloggers Using an Undocumented Kernel Data Structure — Elastic Security Labs"/><meta name="twitter:description" content="In this article, we explore what hotkey-based keyloggers are and how to detect them. Specifically, we explain how these keyloggers intercept keystrokes, then present a detection technique that leverages an undocumented hotkey table in kernel space."/><meta name="twitter:image" content="https://www.elastic.co/security-labs/assets/images/detecting-hotkey-based-keyloggers/Security Labs Images 12.jpg?07356be5df2ef3656644e0c9480c1944"/><meta name="twitter:image:alt" content="In this article, we explore what hotkey-based keyloggers are and how to detect them. Specifically, we explain how these keyloggers intercept keystrokes, then present a detection technique that leverages an undocumented hotkey table in kernel space."/><link rel="canonical" href="https://www.elastic.co/security-labs/detecting-hotkey-based-keyloggers"/><link rel="preload" href="/security-labs/logo.svg" as="image" fetchpriority="high"/><link rel="preload" as="image" imageSrcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fdetecting-hotkey-based-keyloggers%2FSecurity%20Labs%20Images%2012.jpg&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fdetecting-hotkey-based-keyloggers%2FSecurity%20Labs%20Images%2012.jpg&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fdetecting-hotkey-based-keyloggers%2FSecurity%20Labs%20Images%2012.jpg&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fdetecting-hotkey-based-keyloggers%2FSecurity%20Labs%20Images%2012.jpg&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fdetecting-hotkey-based-keyloggers%2FSecurity%20Labs%20Images%2012.jpg&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fdetecting-hotkey-based-keyloggers%2FSecurity%20Labs%20Images%2012.jpg&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fdetecting-hotkey-based-keyloggers%2FSecurity%20Labs%20Images%2012.jpg&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fdetecting-hotkey-based-keyloggers%2FSecurity%20Labs%20Images%2012.jpg&amp;w=3840&amp;q=75 3840w" imageSizes="100vw" fetchpriority="high"/><meta name="next-head-count" content="19"/><script src="https://play.vidyard.com/embed/v4.js" type="text/javascript" async=""></script><link rel="icon" href="/security-labs/favicon.svg"/><link rel="mask-icon" href="/security-labs/favicon.svg" color="#1C1E23"/><link rel="apple-touch-icon" href="/security-labs/favicon.svg"/><meta name="theme-color" content="#1C1E23"/><link rel="preload" href="/security-labs/_next/static/media/6d93bde91c0c2823-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/a34f9d1faa5f3315-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/369c6e283c5acc6e-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/92f44bb82993d879-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/ee71530a747ff30b-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/9fac010bc1f02be0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/cbf5fbad4d73afac-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><script id="google-tag-manager" data-nscript="beforeInteractive">
          (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
          new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
          j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
          'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
          })(window,document,'script','dataLayer','GTM-KNJMG2M');
          </script><link rel="preload" href="/security-labs/_next/static/css/265ed7605fd03477.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/265ed7605fd03477.css" data-n-g=""/><link rel="preload" href="/security-labs/_next/static/css/1007ff9e696f6f88.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/1007ff9e696f6f88.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/security-labs/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/security-labs/_next/static/chunks/webpack-7987c6fda769d510.js" defer=""></script><script src="/security-labs/_next/static/chunks/framework-7a7e500878b44665.js" defer=""></script><script src="/security-labs/_next/static/chunks/main-ebd33a9f1cae5951.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/_app-cb8664d1d3df2511.js" defer=""></script><script src="/security-labs/_next/static/chunks/fec483df-43ee602fabdfe3a4.js" defer=""></script><script src="/security-labs/_next/static/chunks/877-34f408271ef44c22.js" defer=""></script><script src="/security-labs/_next/static/chunks/511-d08fe0fdd6f8a984.js" defer=""></script><script src="/security-labs/_next/static/chunks/683-a5053c37fe5bd0c9.js" defer=""></script><script src="/security-labs/_next/static/chunks/402-3e1f0db8cdad45fc.js" defer=""></script><script src="/security-labs/_next/static/chunks/616-0b017b9cfa597392.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/%5Bslug%5D-b0c191de1a3710e4.js" defer=""></script><script src="/security-labs/_next/static/0PDZemg2oGX1bus_dquF1/_buildManifest.js" defer=""></script><script src="/security-labs/_next/static/0PDZemg2oGX1bus_dquF1/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KNJMG2M" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><main class="__variable_0351a5 __variable_1f211e __variable_a5b5f5 flex flex-col min-h-screen"><div class="scroll-percentage-container"><div class="scroll-percentage-bar" style="width:0%"></div></div><nav class="fixed w-full z-40" data-headlessui-state=""><div class="bg-gradient-to-b from-zinc-900 from-20% h-[200%] to-transparent absolute inset-0 z-0 pointer-events-none"></div><div class="container relative z-10"><div class="flex h-16 items-center justify-between"><div class="flex items-center justify-start w-full"><div><a class="hover:opacity-50 transition" href="/security-labs"><img alt="elastic security labs logo" fetchpriority="high" width="200" height="30" decoding="async" data-nimg="1" style="color:transparent" src="/security-labs/logo.svg"/></a></div><div class="hidden lg:ml-6 lg:block"><div class="flex space-x-4"><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/about"><span>About</span></a><div class="relative" data-headlessui-state=""><div><button class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" id="headlessui-menu-button-:R2kpm:" type="button" aria-haspopup="menu" aria-expanded="false" data-headlessui-state="">Topics<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="ml-1 -mr-1 h-4 w-4 text-zinc-400 relative top-[1px]"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z" clip-rule="evenodd"></path></svg></button></div></div><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/vulnerability-updates"><span>Vulnerability updates</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/reports"><span>Reports</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/tools"><span>Tools</span></a></div></div><div class="hidden lg:ml-auto lg:block"><div class="flex items-center space-x-4"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/detecting-hotkey-based-keyloggers"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="https://www.elastic.co/security-labs/rss/feed.xml"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="h-4 w-4 mr-1"><path d="M3.75 3a.75.75 0 00-.75.75v.5c0 .414.336.75.75.75H4c6.075 0 11 4.925 11 11v.25c0 .414.336.75.75.75h.5a.75.75 0 00.75-.75V16C17 8.82 11.18 3 4 3h-.25z"></path><path d="M3 8.75A.75.75 0 013.75 8H4a8 8 0 018 8v.25a.75.75 0 01-.75.75h-.5a.75.75 0 01-.75-.75V16a6 6 0 00-6-6h-.25A.75.75 0 013 9.25v-.5zM7 15a2 2 0 11-4 0 2 2 0 014 0z"></path></svg><span class="hidden xl:block">Subscribe</span></a><a class="font-display inline-flex items-center justify-center rounded font-semibold disabled:!select-none disabled:!bg-gray-400 bg-blue-600 text-white hover:bg-blue-500 enabled:hover:text-white/80 transition-colors px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://cloud.elastic.co/registration?cta=cloud-registration&amp;tech=trial&amp;plcmt=navigation&amp;pg=security-labs">Start free trial</a><a class="font-display inline-flex items-center justify-center rounded font-semibold text-white disabled:!select-none disabled:!bg-gray-400 button px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://www.elastic.co/contact">Contact sales</a></div></div></div><div class="-mr-2 flex lg:hidden"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/detecting-hotkey-based-keyloggers"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><button class="inline-flex items-center justify-center rounded-md p-2 text-gray-400 hover:bg-gray-700 hover:text-white focus:outline-none focus:ring-2 focus:ring-inset focus:ring-white" id="headlessui-disclosure-button-:R59m:" type="button" aria-expanded="false" data-headlessui-state=""><span class="sr-only">Open navigation menu</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="block h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div></div></div></nav><main class="mb-20 flex-1 flex flex-col"><div class="h-48 md:h-64"><div class="after:absolute after:block after:bg-blue-400 after:blur-3xl after:content-[&#x27; &#x27;] after:h-96 after:opacity-5 after:right-0 after:rounded-full after:top-20 after:w-1/2 after:z-0 before:absolute before:block before:blur-3xl before:bg-orange-400 before:content-[&#x27; &#x27;] before:h-96 before:left-0 before:opacity-5 before:rounded-full before:w-1/2 before:z-0 w-full h-full relative"><div class="relative z-10 w-full h-[125%] -top-[25%] bg-no-repeat bg-cover bg-bottom flex items-center justify-center" style="background-image:url(/security-labs/grid.svg)"></div></div></div><article class="px-4"><div class="max-w-7xl mx-auto relative z-10 flex flex-col space-y-4"><div class="eyebrow break-words"><time class="block mb-2 md:mb-0 md:inline-block article-published-date" dateTime="2025-03-04T00:00:00.000Z">4 March 2025</time><span class="hidden md:inline-block md:mx-2">•</span><a class="hover:text-blue-400 text-xs md:text-sm whitespace-nowrap author-name" href="/security-labs/author/asuka-nakajima">Asuka Nakajima</a></div><h1 class="font-bold leading-tighter text-3xl md:text-5xl"><span>Detecting Hotkey-&nbsp;Based Keyloggers Using an Undocumented Kernel Data&nbsp;Structure</span></h1><p class="text-zinc-200 text-base md:text-xl">In this article, we explore what hotkey-based keyloggers are and how to detect them. Specifically, we explain how these keyloggers intercept keystrokes, then present a detection technique that leverages an undocumented hotkey table in kernel space.</p><div class="flex items-center mt-4 text-zinc-200 text-sm space-x-4 border-t border-white/25 pt-4"><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span>15 min read</span></span><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M9.568 3H5.25A2.25 2.25 0 003 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 005.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 009.568 3z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M6 6h.008v.008H6V6z"></path></svg><span><a class="hover:text-blue-400 whitespace-nowrap" href="/security-labs/category/security-research">Security research</a>, </span><span><a class="hover:text-blue-400 whitespace-nowrap" href="/security-labs/category/detection-science">Detection science</a></span></span></div></div><div class="max-w-7xl mx-auto"><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 sm:p-8 md:p-10 rounded-3xl mt-5 md:mt-10"><div class="relative w-full rounded-lg overflow-hidden aspect-video"><img alt="Detecting Hotkey-Based Keyloggers Using an Undocumented Kernel Data Structure" fetchpriority="high" decoding="async" data-nimg="fill" class="object-cover absolute h-full w-full" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" sizes="100vw" srcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fdetecting-hotkey-based-keyloggers%2FSecurity%20Labs%20Images%2012.jpg&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fdetecting-hotkey-based-keyloggers%2FSecurity%20Labs%20Images%2012.jpg&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fdetecting-hotkey-based-keyloggers%2FSecurity%20Labs%20Images%2012.jpg&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fdetecting-hotkey-based-keyloggers%2FSecurity%20Labs%20Images%2012.jpg&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fdetecting-hotkey-based-keyloggers%2FSecurity%20Labs%20Images%2012.jpg&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fdetecting-hotkey-based-keyloggers%2FSecurity%20Labs%20Images%2012.jpg&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fdetecting-hotkey-based-keyloggers%2FSecurity%20Labs%20Images%2012.jpg&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fdetecting-hotkey-based-keyloggers%2FSecurity%20Labs%20Images%2012.jpg&amp;w=3840&amp;q=75 3840w" src="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fdetecting-hotkey-based-keyloggers%2FSecurity%20Labs%20Images%2012.jpg&amp;w=3840&amp;q=75"/><div class="absolute border border-white/50 inset-0 mix-blend-overlay rounded-lg z-10"></div></div></div></div><div class="lg:max-w-7xl mx-auto relative mt-12 lg:grid lg:grid-cols-4 lg:gap-8 items-start"><div class="flex justify-center lg:col-span-3"><div class="prose lg:prose-lg prose-invert w-full article-content"><div><h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="detecting-hotkey-based-keyloggers-using-an-undocumented-kernel-data-structure" class="absolute -top-32"></span>Detecting Hotkey-Based Keyloggers Using an Undocumented Kernel Data Structure</h1>
<p>In this article, we explore what hotkey-based keyloggers are and how to detect them. Specifically, we explain how these keyloggers intercept keystrokes, then present a detection technique that leverages an undocumented hotkey table in kernel space.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="introduction" class="absolute -top-32"></span>Introduction</h2>
<p>In May 2024, Elastic Security Labs published <a href="https://www.elastic.co/security-labs/protecting-your-devices-from-information-theft-keylogger-protection">an article</a> highlighting new features added in <a href="https://www.elastic.co/guide/en/integrations/current/endpoint.html">Elastic Defend</a> (starting with 8.12) to enhance the detection of keyloggers running on Windows. In that post, we covered four types of keyloggers commonly employed in cyberattacks — polling-based keyloggers, hooking-based keyloggers, keyloggers using the Raw Input Model, and keyloggers using DirectInput — and explained our detection methodology. In particular, we introduced a behavior-based detection method using the Microsoft-Windows-Win32k provider within <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/event-tracing-for-windows--etw-">Event Tracing for Windows</a> (ETW).</p>
<p>Shortly after publication, we were honored to have our article noticed by <a href="https://jonathanbaror.com/">Jonathan Bar Or</a>, Principal Security Researcher at Microsoft. He provided invaluable feedback by pointing out the existence of hotkey-based keyloggers and even shared proof-of-concept (PoC) code with us. Leveraging his PoC code <a href="https://github.com/yo-yo-yo-jbo/hotkeyz">Hotkeyz</a> as a starting point, this article presents one potential method for detecting hotkey-based keyloggers.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="overview-of-hotkey-based-keyloggers" class="absolute -top-32"></span>Overview of Hotkey-based Keyloggers</h2>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="what-is-a-hotkey" class="absolute -top-32"></span>What Is a Hotkey?</h3>
<p>Before delving into hotkey-based keyloggers, let’s first clarify what a hotkey is. A hotkey is a type of keyboard shortcut that directly invokes a specific function on a computer by pressing a single key or a combination of keys. For example, many Windows users press <strong>Alt + Tab</strong> to switch between tasks (or, in other words, windows). In this instance, <strong>Alt + Tab</strong> serves as a hotkey that directly triggers the task-switching function.</p>
<p><em>(Note: Although other types of keyboard shortcuts exist, this article focuses solely on hotkeys. Also, <strong>all information herein is based on Windows 10 version 22H2 OS Build 19045.5371 without virtualization based security</strong>. Please note that the internal data structures and behavior may differ in other versions of Windows.)</em></p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="abusing-custom-hotkey-registration-functionality" class="absolute -top-32"></span>Abusing Custom Hotkey Registration Functionality</h3>
<p>In addition to using the pre-configured hotkeys in Windows as shown in the previous example, you can also register your own custom hotkeys. There are various methods to do this, but one straightforward approach is to use the Windows API function <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerhotkey"><strong>RegisterHotKey</strong></a>, which allows a user to register a specific key as a hotkey. For instance, the following code snippet demonstrates how to use the <strong>RegisterHotKey</strong> API to register the <strong>A</strong> key (with a <a href="https://learn.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes">virtual-key code</a> of 0x41) as a global hotkey:</p>
<pre><code>/*
BOOL RegisterHotKey(
  [in, optional] HWND hWnd, 
  [in]           int  id,
  [in]           UINT fsModifiers,
  [in]           UINT vk
);
*/
RegisterHotKey(NULL, 1, 0, 0x41);</code></pre>
<p>After registering a hotkey, when the registered key is pressed, a <a href="https://learn.microsoft.com/en-us/windows/win32/inputdev/wm-hotkey"><strong>WM_HOTKEY</strong></a> message is sent to the message queue of the window specified as the first argument to the <strong>RegisterHotKey</strong> API (or to the thread that registered the hotkey if <strong>NULL</strong> is used). The code below demonstrates a message loop that uses the <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessage"><strong>GetMessage</strong></a> API to check for a <strong>WM_HOTKEY</strong> message in the <a href="https://learn.microsoft.com/en-us/windows/win32/winmsg/about-messages-and-message-queues">message queue</a>, and if one is received, it extracts the virtual-key code (in this case, 0x41) from the message.</p>
<pre><code>MSG msg = { 0 };
while (GetMessage(&amp;msg, NULL, 0, 0)) {
    if (msg.message == WM_HOTKEY) {
        int vkCode = HIWORD(msg.lParam);
        std::cout &lt;&lt; &quot;WM_HOTKEY received! Virtual-Key Code: 0x&quot;
            &lt;&lt; std::hex &lt;&lt; vkCode &lt;&lt; std::dec &lt;&lt; std::endl;
    }
}</code></pre>
<p>In other words, imagine you&#x27;re writing something in a notepad application. If the A key is pressed, the character won&#x27;t be treated as normal text input — it will be recognized as a global hotkey instead.</p>
<p>In this example, only the A key is registered as a hotkey. However, you can register multiple keys (like B, C, or D) as separate hotkeys at the same time. This means that any key (i.e., any virtual-key code) that can be registered with the <strong>RegisterHotKey</strong> API can potentially be hijacked as a global hotkey. A hotkey-based keylogger abuses this capability to capture the keystrokes entered by the user.</p>
<p>Based on our testing, we found that not only alphanumeric and basic symbol keys, but also those keys when combined with the SHIFT modifier, can all be registered as hotkeys using the <strong>RegisterHotKey</strong> API. This means that a keylogger can effectively monitor every keystroke necessary to steal sensitive information.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="capturing-keystrokes-stealthily" class="absolute -top-32"></span>Capturing Keystrokes Stealthily</h3>
<p>Let&#x27;s walk through the actual process of how a hotkey-based keylogger captures keystrokes, using the Hotkeyz hotkey-based keylogger as an example.</p>
<p>In Hotkeyz, it first registers each alphanumeric virtual-key code — and some additional keys,  such as <strong>VK_SPACE</strong> and <strong>VK_RETURN</strong> — as individual hotkeys by using the <strong>RegisterHotKey</strong> API.</p>
<p>Then, inside the keylogger&#x27;s message loop, the <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-peekmessagew"><strong>PeekMessageW</strong></a> API is used to check whether any <strong>WM_HOTKEY</strong> messages from these registered hotkeys have appeared in the message queue. When a <strong>WM_HOTKEY</strong> message is detected, the virtual-key code it contains is extracted and eventually saved to a text file. Below is an excerpt from the message loop code, highlighting the most important parts.</p>
<pre><code>while (...)
{
    // Get the message in a non-blocking manner and poll if necessary
    if (!PeekMessageW(&amp;tMsg, NULL, WM_HOTKEY, WM_HOTKEY, PM_REMOVE))
    {
        Sleep(POLL_TIME_MILLIS);
        continue;
    }
....
   // Get the key from the message
   cCurrVk = (BYTE)((((DWORD)tMsg.lParam) &amp; 0xFFFF0000) &gt;&gt; 16);

   // Send the key to the OS and re-register
   (VOID)UnregisterHotKey(NULL, adwVkToIdMapping[cCurrVk]);
   keybd_event(cCurrVk, 0, 0, (ULONG_PTR)NULL);
   if (!RegisterHotKey(NULL, adwVkToIdMapping[cCurrVk], 0, cCurrVk))
   {
       adwVkToIdMapping[cCurrVk] = 0;
       DEBUG_MSG(L&quot;RegisterHotKey() failed for re-registration (cCurrVk=%lu,    LastError=%lu).&quot;, cCurrVk, GetLastError());
       goto lblCleanup;
   }
   // Write to the file
  if (!WriteFile(hFile, &amp;cCurrVk, sizeof(cCurrVk), &amp;cbBytesWritten, NULL))
  {
....</code></pre>
<p>One important detail is this: to avoid alerting the user to the keylogger&#x27;s presence, once the virtual-key code is extracted from the message, the key&#x27;s hotkey registration is temporarily removed using the <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-unregisterhotkey"><strong>UnregisterHotKey</strong></a> API. After that, the key press is simulated with <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-keybd_event"><strong>keybd_event</strong></a> so that it appears to the user as if the key was pressed normally. Once the key press is simulated, the key is re-registered using the <strong>RegisterHotKey</strong> API to wait for further input. This is the core mechanism behind how a hotkey-based keylogger operates.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="detecting-hotkey-based-keyloggers" class="absolute -top-32"></span>Detecting Hotkey-Based Keyloggers</h2>
<p>Now that we understand what hotkey-based keyloggers are and how they operate, let&#x27;s explain how to detect them.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="etw-does-not-monitor-the-registerhotkey-api" class="absolute -top-32"></span>ETW Does Not Monitor the RegisterHotKey API</h3>
<p>Following the approach described in an earlier article, we first investigated whether <a href="https://learn.microsoft.com/en-us/windows/win32/etw/about-event-tracing">Event Tracing for Windows</a> (ETW) could be used to detect hotkey-based keyloggers. Our research quickly revealed that ETW currently does not monitor the <strong>RegisterHotKey</strong> or <strong>UnregisterHotKey</strong> APIs. In addition to reviewing the manifest file for the Microsoft-Windows-Win32k provider, we reverse-engineered the internals of the <strong>RegisterHotKey</strong> API — specifically, the <strong>NtUserRegisterHotKey</strong> function in win32kfull.sys. Unfortunately, we found no evidence that these APIs trigger any ETW events when executed.</p>
<p>The image below shows a comparison between the decompiled code for <strong>NtUserGetAsyncKeyState</strong> (which is monitored by ETW) and <strong>NtUserRegisterHotKey</strong>. Notice that at the beginning of <strong>NtUserGetAsyncKeyState</strong>, there is a call to <strong>EtwTraceGetAsyncKeyState</strong> — a function associated with  logging ETW events — while <strong>NtUserRegisterHotKey</strong> does not contain such a call.</p>
<p>
　<br/>
<!-- -->Although we also considered using ETW providers other than Microsoft-Windows-Win32k to indirectly monitor calls to the <strong><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RegisterHotKey</code></strong> API, we found that the detection method using the &quot;hotkey table&quot; — which will be introduced next and does not rely on ETW — achieves results that are comparable to or even better than monitoring the <strong><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RegisterHotKey</code></strong> API. In the end, we chose to implement this method.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="detection-using-the-hotkey-table-gphkhashtable" class="absolute -top-32"></span>Detection Using the Hotkey Table (<strong>gphkHashTable</strong>)</h3>
<p>After discovering that ETW cannot directly monitor calls to the <strong>RegisterHotKey</strong> API, we started exploring detection methods that don&#x27;t rely on ETW. During our investigation, we wondered, &quot;Isn&#x27;t the information for registered hotkeys stored somewhere? And if so, could that data be used for detection?&quot; Based on that hypothesis, we quickly found a hash table labeled <strong>gphkHashTable</strong> within <strong>NtUserRegisterHotKey</strong>. Searching Microsoft&#x27;s online documentation revealed no details on <strong>gphkHashTable</strong>, suggesting that it&#x27;s an undocumented kernel data structure.</p>
<p></p>
<p>Through reverse engineering, we discovered that this hash table stores objects containing information about registered hotkeys. Each object holds details such as the virtual-key code and modifiers specified in the arguments to the <strong>RegisterHotKey</strong> API. The right side of Figure 3 shows part of the structure definition for a hotkey object (named <strong>HOT_KEY</strong>), while the left side displays how the registered hotkey objects appear when accessed via WinDbg.</p>
<p></p>
<p>We also determined that <strong>ghpkHashTable</strong> is structured as shown in Figure 4.  Specifically, it uses the result of the modulo operation (with 0x80) on the virtual-key code (specified by the RegisterHotKey API) as the index into the hash table. Hotkey objects sharing the same index are linked together in a list, which allows the table to store and manage hotkey information even when the virtual-key codes are identical but the modifiers differ.</p>
<p></p>
<p>In other words, by scanning all HOT_KEY objects stored in <strong>ghpkHashTable</strong>, we can retrieve details about every registered hotkey. If we find that every main key — for example, each individual alphanumeric key — is registered as a separate hotkey, that strongly indicates the presence of an active hotkey-based keylogger.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="implementing-the-detection-tool" class="absolute -top-32"></span>Implementing the Detection Tool</h2>
<p>Now, let&#x27;s move on to implementing the detection tool. Since <strong>gphkHashTable</strong> resides in the kernel space, it cannot be accessed by a user-mode application. For this reason, it was necessary to develop a device driver for detection. More specifically, we decided to develop a device driver that obtains the address of <strong>gphkHashTable</strong> and scans through all the hotkey objects stored in the hash table. If the number of alphanumeric keys registered as hotkeys exceeds a predefined threshold, it will alert us to the potential presence of a hotkey-based keylogger.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="how-to-obtain-the-address-of-gphkhashtable" class="absolute -top-32"></span>How to Obtain the Address of <strong>gphkHashTable</strong></h3>
<p>While developing the detection tool, one of the first challenges we faced was how to obtain the address of <strong>gphkHashTable</strong>. After some consideration, we decided to extract the address directly from an instruction in the <strong>win32kfull.sys</strong> driver that accesses <strong>gphkHashTable</strong>.</p>
<p>Through reverse engineering, we discovered that within the IsHotKey function — right at the beginning — there is a lea instruction (lea rbx, <strong>gphkHashTable</strong>) that accesses <strong>gphkHashTable</strong>. We used the opcode byte sequence (0x48, 0x8d, 0x1d) from that instruction as a signature to locate the corresponding line, and then computed the address of <strong>gphkHashTable</strong> using the obtained 32-bit (4-byte) offset.</p>
<p></p>
<p>Additionally, since <strong>IsHotKey</strong> is not an exported function, we also need to know its address before looking for <strong>gphkHashTable</strong>. Through further reverse engineering, we discovered that the exported function <strong>EditionIsHotKey</strong> calls the <strong>IsHotKey</strong> function. Therefore, we decided to compute the address of IsHotKey within the <strong>EditionIsHotKey</strong> function using the same method described earlier. (For reference, the base address of <strong>win32kfull.sys</strong> can be found using the <strong>PsLoadedModuleList</strong> API.)</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="accessing-the-memory-space-of-win32kfullsys" class="absolute -top-32"></span>Accessing the Memory Space of <strong>win32kfull.sys</strong></h3>
<p>Once we finalized our approach to obtaining the address of <strong>gphkHashTable</strong>, we began writing code to access the memory space of <strong>win32kfull.sys</strong> to retrieve that address. One challenge we encountered at this stage was that win32kfull.sys is a <em>session driver</em>. Before proceeding further, here’s a brief, simplified explanation of what a <em>session</em> is.</p>
<p>In Windows, when a user logs in, a separate session (with session numbers starting from 1) is assigned to each user. Simply put, the first user to log in is assigned <strong>Session 1</strong>. If another user logs in while that session is active, that user is assigned <strong>Session 2</strong>, and so on. Each user then has their own desktop environment within their assigned session.</p>
<p>Kernel data that must be managed separately for each session (i.e., per logged-in user) is stored in an isolated area of kernel memory called <em>session space</em>. This includes GUI objects managed by win32k drivers, such as windows and mouse/keyboard input data, ensuring that the screen and input remain properly separated between users.</p>
<p><em>(This is a simplified explanation. For a more detailed discussion on sessions, please refer to <a href="https://googleprojectzero.blogspot.com/2016/01/raising-dead.html">James Forshaw’s blog post</a>.)</em></p>
<p></p>
<p>Based on the above, <strong>win32kfull.sys</strong> is known as a <em>session driver</em>. This means that, for example, hotkey information registered in the session of the first logged-in user (Session 1) can only be accessed from within that same session. So, how can we work around this limitation? In such cases, <a href="https://eversinc33.com/posts/kernel-mode-keylogging.html">it is known</a> that <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-kestackattachprocess"><strong>KeStackAttachProcess</strong></a> can be used.</p>
<p><strong>KeStackAttachProcess</strong> allows the current thread to temporarily attach to the address space of a specified process. If we can attach to a GUI process in the target session — more precisely, a process that has loaded <strong>win32kfull.sys</strong> — then we can access <strong>win32kfull.sys</strong> and its associated data within that session. For our implementation, assuming that only one user is logged in, we decided to locate and attach to <strong>winlogon.exe</strong>, the process responsible for handling user logon operations.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="enumerating-registered-hotkeys" class="absolute -top-32"></span>Enumerating Registered Hotkeys</h3>
<p>Once we have successfully attached to the winlogon.exe process and determined the address of <strong>gphkHashTable</strong>, the next step is simply scanning <strong>gphkHashTable</strong> to check the registered hotkeys. Below is an excerpt of that code:</p>
<pre><code>BOOL CheckRegisteredHotKeys(_In_ const PVOID&amp; gphkHashTableAddr)
{
-[skip]-
    // Cast the gphkHashTable address to an array of pointers.
    PVOID* tableArray = static_cast&lt;PVOID*&gt;(gphkHashTableAddr);
    // Iterate through the hash table entries.
    for (USHORT j = 0; j &lt; 0x80; j++)
    {
        PVOID item = tableArray[j];
        PHOT_KEY hk = reinterpret_cast&lt;PHOT_KEY&gt;(item);
        if (hk)
        {
            CheckHotkeyNode(hk);
        }
    }
-[skip]-
}

VOID CheckHotkeyNode(_In_ const PHOT_KEY&amp; hk)
{
    if (MmIsAddressValid(hk-&gt;pNext)) {
        CheckHotkeyNode(hk-&gt;pNext);
    }

    // Check whether this is a single numeric hotkey.
    if ((hk-&gt;vk &gt;= 0x30) &amp;&amp; (hk-&gt;vk &lt;= 0x39) &amp;&amp; (hk-&gt;modifiers1 == 0))
    {
        KdPrint((&quot;[+] hk-&gt;id: %u hk-&gt;vk: %x\n&quot;, hk-&gt;id, hk-&gt;vk));
        hotkeyCounter++;
    }
    // Check whether this is a single alphabet hotkey.
    else if ((hk-&gt;vk &gt;= 0x41) &amp;&amp; (hk-&gt;vk &lt;= 0x5A) &amp;&amp; (hk-&gt;modifiers1 == 0))
    {
        KdPrint((&quot;[+] hk-&gt;id: %u hk-&gt;vk: %x\n&quot;, hk-&gt;id, hk-&gt;vk));
        hotkeyCounter++;
    }
-[skip]-
}
....
if (CheckRegisteredHotKeys(gphkHashTableAddr) &amp;&amp; hotkeyCounter &gt;= 36)
{
   detected = TRUE;
   goto Cleanup;
}</code></pre>
<p>The code itself is straightforward: it iterates through each index of the hash table, following the linked list to access every <strong>HOT_KEY</strong> object, and checks whether the registered hotkeys correspond to alphanumeric keys without any modifiers. In our detection tool, if every alphanumeric key is registered as a hotkey, an alert is raised, indicating the possible presence of a hotkey-based keylogger. For simplicity, this implementation only targets alphanumeric key hotkeys, although it would be easy to extend the tool to check for hotkeys with modifiers such as <strong>SHIFT</strong>.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="detecting-hotkeyz" class="absolute -top-32"></span>Detecting Hotkeyz</h3>
<p>The detection tool (Hotkey-based Keylogger Detector) has been released below. Detailed usage instructions are provided as well. Additionally, this research was presented at <a href="https://nullcon.net/goa-2025/speaker-windows-keylogger-detection">NULLCON Goa 2025</a>, and the <a href="https://docs.google.com/presentation/d/1B0Gdfpo-ER2hPjDbP_NNoGZ8vXP6X1_BN7VZCqUgH8c/edit?usp=sharing">presentation slides</a> are available.</p>
<p><a href="https://github.com/AsuNa-jp/HotkeybasedKeyloggerDetector">https://github.com/AsuNa-jp/HotkeybasedKeyloggerDetector</a></p>
<p>The following is a demo video showcasing how the Hotkey-based Keylogger Detector detects Hotkeyz.</p>
<p><a href="https://drive.google.com/file/d/1koGLqA5cPlhL8C07MLg9VDD9-SW2FM9e/view?usp=drive_link">DEMO_VIDEO.mp4</a></p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="acknowledgments" class="absolute -top-32"></span>Acknowledgments</h2>
<p>We would like to express our heartfelt gratitude to Jonathan Bar Or for reading our previous article, sharing his insights on hotkey-based keyloggers, and generously publishing the PoC tool <strong>Hotkeyz</strong>.</p></div></div></div><div class="hidden lg:flex lg:col-span-1 text-sm lg:flex-col lg:space-y-6"><div class="toc"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Jump to section</h4><ul class="flex flex-col space-y-2"><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/detecting-hotkey-based-keyloggers#introduction"><span>Introduction</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/detecting-hotkey-based-keyloggers#overview-of-hotkey-based-keyloggers"><span>Overview of Hotkey-&nbsp;based&nbsp;Keyloggers</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/detecting-hotkey-based-keyloggers#what-is-a-hotkey"><span>What Is a&nbsp;Hotkey?</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/detecting-hotkey-based-keyloggers#abusing-custom-hotkey-registration-functionality"><span>Abusing Custom Hotkey Registration&nbsp;Functionality</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/detecting-hotkey-based-keyloggers#capturing-keystrokes-stealthily"><span>Capturing Keystrokes&nbsp;Stealthily</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/detecting-hotkey-based-keyloggers#detecting-hotkey-based-keyloggers"><span>Detecting Hotkey-&nbsp;Based&nbsp;Keyloggers</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/detecting-hotkey-based-keyloggers#etw-does-not-monitor-the-registerhotkey-api"><span>ETW Does Not Monitor the RegisterHotKey&nbsp;API</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/detecting-hotkey-based-keyloggers#detection-using-the-hotkey-table-gphkhashtable"><span>Detection Using the Hotkey Table&nbsp;(**gphkHashTable**)</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/detecting-hotkey-based-keyloggers#implementing-the-detection-tool"><span>Implementing the Detection&nbsp;Tool</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/detecting-hotkey-based-keyloggers#how-to-obtain-the-address-of-gphkhashtable"><span>How to Obtain the Address of&nbsp;**gphkHashTable**</span></a></li></ul><button class="border-t border-white/20 w-full mt-3 py-2 flex items-center space-x-1 text-xs font-medium uppercase tracking-wide hover:text-white"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="w-3 h-3"><path d="M10.75 4.75a.75.75 0 00-1.5 0v4.5h-4.5a.75.75 0 000 1.5h4.5v4.5a.75.75 0 001.5 0v-4.5h4.5a.75.75 0 000-1.5h-4.5v-4.5z"></path></svg><span>Show more</span></button></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Elastic Security Labs Newsletter</h4><div><a target="_blank" class="button inline-flex" href="https://www.elastic.co/elastic-security-labs/newsletter?utm_source=security-labs">Sign Up</a></div></div></div></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl my-5 md:my-10 max-w-3xl mx-auto flex flex-col items-center shadow-2xl"><h4 class="font-bold leading-tight text-lg md:text-2xl">Share this article</h4><div class="flex flex-wrap items-center justify-center mt-4 space-x-4"><a class="flex items-center space-x-2 button" href="https://twitter.com/intent/tweet?text=Detecting Hotkey-Based Keyloggers Using an Undocumented Kernel Data Structure&amp;url=https://www.elastic.co/security-labs/detecting-hotkey-based-keyloggers" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Twitter" title="Share this article on Twitter"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>Twitter</span></a><a class="flex items-center space-x-2 button" href="https://www.facebook.com/sharer/sharer.php?u=https://www.elastic.co/security-labs/detecting-hotkey-based-keyloggers" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Facebook" title="Share this article on Facebook"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M22.5 12c0-5.799-4.701-10.5-10.5-10.5S1.5 6.201 1.5 12c0 5.301 3.901 9.699 9 10.401V14.4h-2.7v-2.7h2.7v-2.1c0-2.7 1.8-4.2 4.2-4.2 1.2 0 2.1.1 2.4.2v2.4h-1.5c-1.2 0-1.5.6-1.5 1.5v1.8h3l-.3 2.7h-2.7V22C18.599 21.3 22.5 17.301 22.5 12z"></path></svg><span>Facebook</span></a><a class="flex items-center space-x-2 button" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://www.elastic.co/security-labs/detecting-hotkey-based-keyloggers&amp;title=Detecting Hotkey-Based Keyloggers Using an Undocumented Kernel Data Structure" target="_blank" rel="noopener noreferrer" aria-label="Share this article on LinkedIn" title="Share this article on LinkedIn"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"></path></svg><span>LinkedIn</span></a><a class="flex items-center space-x-2 button" href="https://reddit.com/submit?url=https://www.elastic.co/security-labs/detecting-hotkey-based-keyloggers&amp;title=Detecting Hotkey-Based Keyloggers Using an Undocumented Kernel Data Structure" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Reddit" title="Share this article on Reddit"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M24 12C24 18.6274 18.6274 24 12 24C5.37258 24 0 18.6274 0 12C0 5.37258 5.37258 0 12 0C18.6274 0 24 5.37258 24 12ZM19.6879 11.0584C19.8819 11.3352 19.9916 11.6622 20.004 12C20.0091 12.3306 19.9205 12.656 19.7485 12.9384C19.5765 13.2208 19.3281 13.4488 19.032 13.596C19.0455 13.7717 19.0455 13.9483 19.032 14.124C19.032 16.812 15.9 18.996 12.036 18.996C8.172 18.996 5.04 16.812 5.04 14.124C5.02649 13.9483 5.02649 13.7717 5.04 13.596C4.80919 13.49 4.6042 13.335 4.43923 13.1419C4.27427 12.9487 4.15327 12.722 4.08462 12.4775C4.01598 12.2329 4.00133 11.9764 4.04169 11.7256C4.08205 11.4748 4.17646 11.2358 4.31837 11.0251C4.46028 10.8145 4.6463 10.6372 4.86354 10.5056C5.08078 10.3739 5.32404 10.2911 5.57646 10.2629C5.82889 10.2346 6.08444 10.2616 6.32541 10.3419C6.56638 10.4222 6.78701 10.5539 6.972 10.728C8.35473 9.79023 9.98146 9.27718 11.652 9.252L12.54 5.088C12.55 5.03979 12.5694 4.99405 12.5972 4.95341C12.625 4.91277 12.6605 4.87805 12.7018 4.85127C12.7431 4.82448 12.7894 4.80615 12.8378 4.79735C12.8862 4.78855 12.9359 4.78945 12.984 4.8L15.924 5.388C16.0676 5.14132 16.2944 4.9539 16.5637 4.85937C16.833 4.76484 17.1272 4.7694 17.3934 4.87222C17.6597 4.97505 17.8806 5.1694 18.0164 5.42041C18.1523 5.67141 18.1942 5.96262 18.1348 6.24177C18.0753 6.52092 17.9182 6.76972 17.6918 6.94352C17.4654 7.11732 17.1845 7.20473 16.8995 7.19006C16.6144 7.1754 16.3439 7.05962 16.1366 6.8635C15.9292 6.66738 15.7985 6.40378 15.768 6.12L13.2 5.58L12.42 9.324C14.0702 9.3594 15.6749 9.87206 17.04 10.8C17.2839 10.566 17.5902 10.4074 17.9221 10.3436C18.254 10.2797 18.5973 10.3132 18.9106 10.4401C19.2239 10.5669 19.4939 10.7817 19.6879 11.0584ZM8.20624 12.5333C8.07438 12.7307 8.004 12.9627 8.004 13.2C8.004 13.5183 8.13043 13.8235 8.35547 14.0485C8.58051 14.2736 8.88574 14.4 9.204 14.4C9.44134 14.4 9.67335 14.3296 9.87068 14.1978C10.068 14.0659 10.2218 13.8785 10.3127 13.6592C10.4035 13.4399 10.4272 13.1987 10.3809 12.9659C10.3346 12.7331 10.2204 12.5193 10.0525 12.3515C9.8847 12.1836 9.67089 12.0694 9.43811 12.0231C9.20533 11.9768 8.96405 12.0005 8.74478 12.0913C8.52551 12.1822 8.33809 12.336 8.20624 12.5333ZM12.012 17.424C13.0771 17.4681 14.1246 17.1416 14.976 16.5V16.548C15.0075 16.5173 15.0327 16.4806 15.05 16.4402C15.0674 16.3997 15.0766 16.3563 15.0772 16.3122C15.0777 16.2682 15.0696 16.2245 15.0533 16.1837C15.0369 16.1428 15.0127 16.1055 14.982 16.074C14.9513 16.0425 14.9146 16.0173 14.8742 16C14.8337 15.9826 14.7903 15.9734 14.7462 15.9728C14.7022 15.9723 14.6585 15.9804 14.6177 15.9967C14.5768 16.0131 14.5395 16.0373 14.508 16.068C13.7797 16.5904 12.895 16.8487 12 16.8C11.1061 16.8399 10.2255 16.5732 9.504 16.044C9.44182 15.993 9.36289 15.9669 9.28256 15.9708C9.20222 15.9748 9.12622 16.0085 9.06935 16.0653C9.01247 16.1222 8.97879 16.1982 8.97484 16.2786C8.97089 16.3589 8.99697 16.4378 9.048 16.5C9.89937 17.1416 10.9469 17.4681 12.012 17.424ZM14.0933 14.2458C14.2907 14.3776 14.5227 14.448 14.76 14.448L14.748 14.496C14.9107 14.4978 15.0721 14.4664 15.2223 14.4038C15.3725 14.3413 15.5084 14.2488 15.6218 14.1321C15.7352 14.0154 15.8236 13.8768 15.8818 13.7248C15.9399 13.5728 15.9665 13.4106 15.96 13.248C15.96 13.0107 15.8896 12.7787 15.7578 12.5813C15.6259 12.384 15.4385 12.2302 15.2192 12.1393C14.9999 12.0485 14.7587 12.0248 14.5259 12.0711C14.2931 12.1174 14.0793 12.2316 13.9115 12.3995C13.7436 12.5673 13.6294 12.7811 13.5831 13.0139C13.5368 13.2467 13.5605 13.4879 13.6513 13.7072C13.7422 13.9265 13.896 14.1139 14.0933 14.2458Z" fill="currentColor"></path></svg><span>Reddit</span></a></div></div></article></main><footer class="mt-auto text-xs md:text-sm"><div class="container py-6 flex flex-col md:flex-row gap-2 md:gap-0 justify-between items-center"><div class="text-zinc-300"><nav><ul class="flex space-x-4"><li><a class="hover:text-white font-medium" href="/security-labs/sitemap.xml">Sitemap</a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://elastic.co?utm_source=elastic-search-labs&amp;utm_medium=referral&amp;utm_campaign=search-labs&amp;utm_content=footer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="inline-block w-3 h-3"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 003 8.25v10.5A2.25 2.25 0 005.25 21h10.5A2.25 2.25 0 0018 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg><span>Elastic.co</span></a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://twitter.com/elasticseclabs"><svg class="w-4 h-4 inline-block w-3 h-3" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>@elasticseclabs</span></a></li></ul></nav></div><div class="flex flex-col space-y-1 text-zinc-300"><p>© <!-- -->2025<!-- -->. Elasticsearch B.V. All Rights Reserved.</p></div></div></footer></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"title":"Detecting Hotkey-Based Keyloggers Using an Undocumented Kernel Data Structure","slug":"detecting-hotkey-based-keyloggers","date":"2025-03-04","description":"In this article, we explore what hotkey-based keyloggers are and how to detect them. Specifically, we explain how these keyloggers intercept keystrokes, then present a detection technique that leverages an undocumented hotkey table in kernel space.","image":"Security Labs Images 12.jpg","tags":["detection engineering","threat detection"],"body":{"raw":"\n# Detecting Hotkey-Based Keyloggers Using an Undocumented Kernel Data Structure\n\nIn this article, we explore what hotkey-based keyloggers are and how to detect them. Specifically, we explain how these keyloggers intercept keystrokes, then present a detection technique that leverages an undocumented hotkey table in kernel space.\n\n## Introduction\n\nIn May 2024, Elastic Security Labs published [an article](https://www.elastic.co/security-labs/protecting-your-devices-from-information-theft-keylogger-protection) highlighting new features added in [Elastic Defend](https://www.elastic.co/guide/en/integrations/current/endpoint.html) (starting with 8.12) to enhance the detection of keyloggers running on Windows. In that post, we covered four types of keyloggers commonly employed in cyberattacks — polling-based keyloggers, hooking-based keyloggers, keyloggers using the Raw Input Model, and keyloggers using DirectInput — and explained our detection methodology. In particular, we introduced a behavior-based detection method using the Microsoft-Windows-Win32k provider within [Event Tracing for Windows](https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/event-tracing-for-windows--etw-) (ETW).\n\nShortly after publication, we were honored to have our article noticed by [Jonathan Bar Or](https://jonathanbaror.com/), Principal Security Researcher at Microsoft. He provided invaluable feedback by pointing out the existence of hotkey-based keyloggers and even shared proof-of-concept (PoC) code with us. Leveraging his PoC code [Hotkeyz](https://github.com/yo-yo-yo-jbo/hotkeyz) as a starting point, this article presents one potential method for detecting hotkey-based keyloggers.\n\n## Overview of Hotkey-based Keyloggers\n\n### What Is a Hotkey?\n\nBefore delving into hotkey-based keyloggers, let’s first clarify what a hotkey is. A hotkey is a type of keyboard shortcut that directly invokes a specific function on a computer by pressing a single key or a combination of keys. For example, many Windows users press **Alt \\+ Tab** to switch between tasks (or, in other words, windows). In this instance, **Alt \\+ Tab** serves as a hotkey that directly triggers the task-switching function. \n\n*(Note: Although other types of keyboard shortcuts exist, this article focuses solely on hotkeys. Also, **all information herein is based on Windows 10 version 22H2 OS Build 19045.5371 without virtualization based security**. Please note that the internal data structures and behavior may differ in other versions of Windows.)*\n\n### Abusing Custom Hotkey Registration Functionality\n\nIn addition to using the pre-configured hotkeys in Windows as shown in the previous example, you can also register your own custom hotkeys. There are various methods to do this, but one straightforward approach is to use the Windows API function [**RegisterHotKey**](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerhotkey), which allows a user to register a specific key as a hotkey. For instance, the following code snippet demonstrates how to use the **RegisterHotKey** API to register the **A** key (with a [virtual-key code](https://learn.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes) of 0x41) as a global hotkey:\n\n```c\n/*\nBOOL RegisterHotKey(\n  [in, optional] HWND hWnd, \n  [in]           int  id,\n  [in]           UINT fsModifiers,\n  [in]           UINT vk\n);\n*/\nRegisterHotKey(NULL, 1, 0, 0x41);\n```\n\nAfter registering a hotkey, when the registered key is pressed, a [**WM\\_HOTKEY**](https://learn.microsoft.com/en-us/windows/win32/inputdev/wm-hotkey) message is sent to the message queue of the window specified as the first argument to the **RegisterHotKey** API (or to the thread that registered the hotkey if **NULL** is used). The code below demonstrates a message loop that uses the [**GetMessage**](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessage) API to check for a **WM\\_HOTKEY** message in the [message queue](https://learn.microsoft.com/en-us/windows/win32/winmsg/about-messages-and-message-queues), and if one is received, it extracts the virtual-key code (in this case, 0x41) from the message.\n\n```c\nMSG msg = { 0 };\nwhile (GetMessage(\u0026msg, NULL, 0, 0)) {\n    if (msg.message == WM_HOTKEY) {\n        int vkCode = HIWORD(msg.lParam);\n        std::cout \u003c\u003c \"WM_HOTKEY received! Virtual-Key Code: 0x\"\n            \u003c\u003c std::hex \u003c\u003c vkCode \u003c\u003c std::dec \u003c\u003c std::endl;\n    }\n}\n```\n\nIn other words, imagine you're writing something in a notepad application. If the A key is pressed, the character won't be treated as normal text input — it will be recognized as a global hotkey instead.\n\nIn this example, only the A key is registered as a hotkey. However, you can register multiple keys (like B, C, or D) as separate hotkeys at the same time. This means that any key (i.e., any virtual-key code) that can be registered with the **RegisterHotKey** API can potentially be hijacked as a global hotkey. A hotkey-based keylogger abuses this capability to capture the keystrokes entered by the user.\n\nBased on our testing, we found that not only alphanumeric and basic symbol keys, but also those keys when combined with the SHIFT modifier, can all be registered as hotkeys using the **RegisterHotKey** API. This means that a keylogger can effectively monitor every keystroke necessary to steal sensitive information.\n\n### Capturing Keystrokes Stealthily\n\nLet's walk through the actual process of how a hotkey-based keylogger captures keystrokes, using the Hotkeyz hotkey-based keylogger as an example.\n\nIn Hotkeyz, it first registers each alphanumeric virtual-key code — and some additional keys,  such as **VK\\_SPACE** and **VK\\_RETURN** — as individual hotkeys by using the **RegisterHotKey** API. \n\nThen, inside the keylogger's message loop, the [**PeekMessageW**](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-peekmessagew) API is used to check whether any **WM\\_HOTKEY** messages from these registered hotkeys have appeared in the message queue. When a **WM\\_HOTKEY** message is detected, the virtual-key code it contains is extracted and eventually saved to a text file. Below is an excerpt from the message loop code, highlighting the most important parts.\n\n```c\nwhile (...)\n{\n    // Get the message in a non-blocking manner and poll if necessary\n    if (!PeekMessageW(\u0026tMsg, NULL, WM_HOTKEY, WM_HOTKEY, PM_REMOVE))\n    {\n        Sleep(POLL_TIME_MILLIS);\n        continue;\n    }\n....\n   // Get the key from the message\n   cCurrVk = (BYTE)((((DWORD)tMsg.lParam) \u0026 0xFFFF0000) \u003e\u003e 16);\n\n   // Send the key to the OS and re-register\n   (VOID)UnregisterHotKey(NULL, adwVkToIdMapping[cCurrVk]);\n   keybd_event(cCurrVk, 0, 0, (ULONG_PTR)NULL);\n   if (!RegisterHotKey(NULL, adwVkToIdMapping[cCurrVk], 0, cCurrVk))\n   {\n       adwVkToIdMapping[cCurrVk] = 0;\n       DEBUG_MSG(L\"RegisterHotKey() failed for re-registration (cCurrVk=%lu,    LastError=%lu).\", cCurrVk, GetLastError());\n       goto lblCleanup;\n   }\n   // Write to the file\n  if (!WriteFile(hFile, \u0026cCurrVk, sizeof(cCurrVk), \u0026cbBytesWritten, NULL))\n  {\n....\n```\n\nOne important detail is this: to avoid alerting the user to the keylogger's presence, once the virtual-key code is extracted from the message, the key's hotkey registration is temporarily removed using the [**UnregisterHotKey**](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-unregisterhotkey) API. After that, the key press is simulated with [**keybd\\_event**](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-keybd_event) so that it appears to the user as if the key was pressed normally. Once the key press is simulated, the key is re-registered using the **RegisterHotKey** API to wait for further input. This is the core mechanism behind how a hotkey-based keylogger operates.\n\n## Detecting Hotkey-Based Keyloggers\n\nNow that we understand what hotkey-based keyloggers are and how they operate, let's explain how to detect them.\n\n### ETW Does Not Monitor the RegisterHotKey API\n\nFollowing the approach described in an earlier article, we first investigated whether [Event Tracing for Windows](https://learn.microsoft.com/en-us/windows/win32/etw/about-event-tracing) (ETW) could be used to detect hotkey-based keyloggers. Our research quickly revealed that ETW currently does not monitor the **RegisterHotKey** or **UnregisterHotKey** APIs. In addition to reviewing the manifest file for the Microsoft-Windows-Win32k provider, we reverse-engineered the internals of the **RegisterHotKey** API — specifically, the **NtUserRegisterHotKey** function in win32kfull.sys. Unfortunately, we found no evidence that these APIs trigger any ETW events when executed.\n\nThe image below shows a comparison between the decompiled code for **NtUserGetAsyncKeyState** (which is monitored by ETW) and **NtUserRegisterHotKey**. Notice that at the beginning of **NtUserGetAsyncKeyState**, there is a call to **EtwTraceGetAsyncKeyState** — a function associated with  logging ETW events — while **NtUserRegisterHotKey** does not contain such a call.\n\n![Figure 1: Comparison of the Decompiled Code for **NtUserGetAsyncKeyState** and **NtUserRegisterHotKey**](/assets/images/detecting-hotkey-based-keyloggers/image3.png)\n　  \n Although we also considered using ETW providers other than Microsoft-Windows-Win32k to indirectly monitor calls to the **`RegisterHotKey`** API, we found that the detection method using the \"hotkey table\" — which will be introduced next and does not rely on ETW — achieves results that are comparable to or even better than monitoring the **`RegisterHotKey`** API. In the end, we chose to implement this method.\n\n### Detection Using the Hotkey Table (**gphkHashTable**)\n\nAfter discovering that ETW cannot directly monitor calls to the **RegisterHotKey** API, we started exploring detection methods that don't rely on ETW. During our investigation, we wondered, \"Isn't the information for registered hotkeys stored somewhere? And if so, could that data be used for detection?\" Based on that hypothesis, we quickly found a hash table labeled **gphkHashTable** within **NtUserRegisterHotKey**. Searching Microsoft's online documentation revealed no details on **gphkHashTable**, suggesting that it's an undocumented kernel data structure.\n\n![Figure 2: The hotkey table (**gphkHashTable**), discovered within the **RegisterHotKey** function called inside **NtUserRegisterHotKey**](/assets/images/detecting-hotkey-based-keyloggers/image1.png)\n\nThrough reverse engineering, we discovered that this hash table stores objects containing information about registered hotkeys. Each object holds details such as the virtual-key code and modifiers specified in the arguments to the **RegisterHotKey** API. The right side of Figure 3 shows part of the structure definition for a hotkey object (named **HOT\\_KEY**), while the left side displays how the registered hotkey objects appear when accessed via WinDbg.\n\n![Figure 3: Hotkey Object Details. WinDbg view (left) and HOT\\_KEY structure details (right)](/assets/images/detecting-hotkey-based-keyloggers/image4.png)\n\nWe also determined that **ghpkHashTable** is structured as shown in Figure 4\\.  Specifically, it uses the result of the modulo operation (with 0x80) on the virtual-key code (specified by the RegisterHotKey API) as the index into the hash table. Hotkey objects sharing the same index are linked together in a list, which allows the table to store and manage hotkey information even when the virtual-key codes are identical but the modifiers differ. \n\n![Figure 4: Structure of **gphkHashTable**](/assets/images/detecting-hotkey-based-keyloggers/image6.png)  \n\nIn other words, by scanning all HOT\\_KEY objects stored in **ghpkHashTable**, we can retrieve details about every registered hotkey. If we find that every main key — for example, each individual alphanumeric key — is registered as a separate hotkey, that strongly indicates the presence of an active hotkey-based keylogger.\n\n## Implementing the Detection Tool\n\nNow, let's move on to implementing the detection tool. Since **gphkHashTable** resides in the kernel space, it cannot be accessed by a user-mode application. For this reason, it was necessary to develop a device driver for detection. More specifically, we decided to develop a device driver that obtains the address of **gphkHashTable** and scans through all the hotkey objects stored in the hash table. If the number of alphanumeric keys registered as hotkeys exceeds a predefined threshold, it will alert us to the potential presence of a hotkey-based keylogger.\n\n### How to Obtain the Address of **gphkHashTable**\n\nWhile developing the detection tool, one of the first challenges we faced was how to obtain the address of **gphkHashTable**. After some consideration, we decided to extract the address directly from an instruction in the **win32kfull.sys** driver that accesses **gphkHashTable**.\n\nThrough reverse engineering, we discovered that within the IsHotKey function — right at the beginning — there is a lea instruction (lea rbx, **gphkHashTable**) that accesses **gphkHashTable**. We used the opcode byte sequence (0x48, 0x8d, 0x1d) from that instruction as a signature to locate the corresponding line, and then computed the address of **gphkHashTable** using the obtained 32-bit (4-byte) offset.\n\n![Figure 5: Inside the **IsHotKey** function](/assets/images/detecting-hotkey-based-keyloggers/image5.png)\n\nAdditionally, since **IsHotKey** is not an exported function, we also need to know its address before looking for **gphkHashTable**. Through further reverse engineering, we discovered that the exported function **EditionIsHotKey** calls the **IsHotKey** function. Therefore, we decided to compute the address of IsHotKey within the **EditionIsHotKey** function using the same method described earlier. (For reference, the base address of **win32kfull.sys** can be found using the **PsLoadedModuleList** API.) \n\n### Accessing the Memory Space of **win32kfull.sys**\n\nOnce we finalized our approach to obtaining the address of **gphkHashTable**, we began writing code to access the memory space of **win32kfull.sys** to retrieve that address. One challenge we encountered at this stage was that win32kfull.sys is a *session driver*. Before proceeding further, here’s a brief, simplified explanation of what a *session* is.\n\nIn Windows, when a user logs in, a separate session (with session numbers starting from 1) is assigned to each user. Simply put, the first user to log in is assigned **Session 1**. If another user logs in while that session is active, that user is assigned **Session 2**, and so on. Each user then has their own desktop environment within their assigned session.\n\nKernel data that must be managed separately for each session (i.e., per logged-in user) is stored in an isolated area of kernel memory called *session space*. This includes GUI objects managed by win32k drivers, such as windows and mouse/keyboard input data, ensuring that the screen and input remain properly separated between users.\n\n*(This is a simplified explanation. For a more detailed discussion on sessions, please refer to [James Forshaw’s blog post](https://googleprojectzero.blogspot.com/2016/01/raising-dead.html).)*\n\n![Figure 6: Overview of Sessions. Session 0 is dedicated exclusively to service processes](/assets/images/detecting-hotkey-based-keyloggers/image2.png)  \n  \nBased on the above, **win32kfull.sys** is known as a *session driver*. This means that, for example, hotkey information registered in the session of the first logged-in user (Session 1) can only be accessed from within that same session. So, how can we work around this limitation? In such cases, [it is known](https://eversinc33.com/posts/kernel-mode-keylogging.html) that [**KeStackAttachProcess**](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-kestackattachprocess) can be used.\n\n**KeStackAttachProcess** allows the current thread to temporarily attach to the address space of a specified process. If we can attach to a GUI process in the target session — more precisely, a process that has loaded **win32kfull.sys** — then we can access **win32kfull.sys** and its associated data within that session. For our implementation, assuming that only one user is logged in, we decided to locate and attach to **winlogon.exe**, the process responsible for handling user logon operations.\n\n### Enumerating Registered Hotkeys\n\nOnce we have successfully attached to the winlogon.exe process and determined the address of **gphkHashTable**, the next step is simply scanning **gphkHashTable** to check the registered hotkeys. Below is an excerpt of that code:\n\n```c\nBOOL CheckRegisteredHotKeys(_In_ const PVOID\u0026 gphkHashTableAddr)\n{\n-[skip]-\n    // Cast the gphkHashTable address to an array of pointers.\n    PVOID* tableArray = static_cast\u003cPVOID*\u003e(gphkHashTableAddr);\n    // Iterate through the hash table entries.\n    for (USHORT j = 0; j \u003c 0x80; j++)\n    {\n        PVOID item = tableArray[j];\n        PHOT_KEY hk = reinterpret_cast\u003cPHOT_KEY\u003e(item);\n        if (hk)\n        {\n            CheckHotkeyNode(hk);\n        }\n    }\n-[skip]-\n}\n\nVOID CheckHotkeyNode(_In_ const PHOT_KEY\u0026 hk)\n{\n    if (MmIsAddressValid(hk-\u003epNext)) {\n        CheckHotkeyNode(hk-\u003epNext);\n    }\n\n    // Check whether this is a single numeric hotkey.\n    if ((hk-\u003evk \u003e= 0x30) \u0026\u0026 (hk-\u003evk \u003c= 0x39) \u0026\u0026 (hk-\u003emodifiers1 == 0))\n    {\n        KdPrint((\"[+] hk-\u003eid: %u hk-\u003evk: %x\\n\", hk-\u003eid, hk-\u003evk));\n        hotkeyCounter++;\n    }\n    // Check whether this is a single alphabet hotkey.\n    else if ((hk-\u003evk \u003e= 0x41) \u0026\u0026 (hk-\u003evk \u003c= 0x5A) \u0026\u0026 (hk-\u003emodifiers1 == 0))\n    {\n        KdPrint((\"[+] hk-\u003eid: %u hk-\u003evk: %x\\n\", hk-\u003eid, hk-\u003evk));\n        hotkeyCounter++;\n    }\n-[skip]-\n}\n....\nif (CheckRegisteredHotKeys(gphkHashTableAddr) \u0026\u0026 hotkeyCounter \u003e= 36)\n{\n   detected = TRUE;\n   goto Cleanup;\n}\n```\n\nThe code itself is straightforward: it iterates through each index of the hash table, following the linked list to access every **HOT\\_KEY** object, and checks whether the registered hotkeys correspond to alphanumeric keys without any modifiers. In our detection tool, if every alphanumeric key is registered as a hotkey, an alert is raised, indicating the possible presence of a hotkey-based keylogger. For simplicity, this implementation only targets alphanumeric key hotkeys, although it would be easy to extend the tool to check for hotkeys with modifiers such as **SHIFT**.\n\n### Detecting Hotkeyz\n\nThe detection tool (Hotkey-based Keylogger Detector) has been released below. Detailed usage instructions are provided as well. Additionally, this research was presented at [NULLCON Goa 2025](https://nullcon.net/goa-2025/speaker-windows-keylogger-detection), and the [presentation slides](https://docs.google.com/presentation/d/1B0Gdfpo-ER2hPjDbP_NNoGZ8vXP6X1_BN7VZCqUgH8c/edit?usp=sharing) are available. \n\n[https://github.com/AsuNa-jp/HotkeybasedKeyloggerDetector](https://github.com/AsuNa-jp/HotkeybasedKeyloggerDetector)\n\nThe following is a demo video showcasing how the Hotkey-based Keylogger Detector detects Hotkeyz.\n\n[DEMO\\_VIDEO.mp4](https://drive.google.com/file/d/1koGLqA5cPlhL8C07MLg9VDD9-SW2FM9e/view?usp=drive_link)\n\n## Acknowledgments\n\nWe would like to express our heartfelt gratitude to Jonathan Bar Or for reading our previous article, sharing his insights on hotkey-based keyloggers, and generously publishing the PoC tool **Hotkeyz**.","code":"var Component=(()=\u003e{var c=Object.create;var o=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var k=(n,e)=\u003e()=\u003e(e||n((e={exports:{}}).exports,e),e.exports),f=(n,e)=\u003e{for(var s in e)o(n,s,{get:e[s],enumerable:!0})},a=(n,e,s,r)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let i of y(e))!p.call(n,i)\u0026\u0026i!==s\u0026\u0026o(n,i,{get:()=\u003ee[i],enumerable:!(r=g(e,i))||r.enumerable});return n};var w=(n,e,s)=\u003e(s=n!=null?c(u(n)):{},a(e||!n||!n.__esModule?o(s,\"default\",{value:n,enumerable:!0}):s,n)),m=n=\u003ea(o({},\"__esModule\",{value:!0}),n);var d=k((K,h)=\u003e{h.exports=_jsx_runtime});var T={};f(T,{default:()=\u003eH,frontmatter:()=\u003eb});var t=w(d()),b={title:\"Detecting Hotkey-Based Keyloggers Using an Undocumented Kernel Data Structure\",slug:\"detecting-hotkey-based-keyloggers\",date:\"2025-03-04\",description:\"In this article, we explore what hotkey-based keyloggers are and how to detect them. Specifically, we explain how these keyloggers intercept keystrokes, then present a detection technique that leverages an undocumented hotkey table in kernel space.\",author:[{slug:\"asuka-nakajima\"}],image:\"Security Labs Images 12.jpg\",category:[{slug:\"security-research\"},{slug:\"detection-science\"}],tags:[\"detection engineering\",\"threat detection\"]};function l(n){let e=Object.assign({h1:\"h1\",p:\"p\",h2:\"h2\",a:\"a\",h3:\"h3\",strong:\"strong\",em:\"em\",pre:\"pre\",code:\"code\",img:\"img\",br:\"br\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h1,{id:\"detecting-hotkey-based-keyloggers-using-an-undocumented-kernel-data-structure\",children:\"Detecting Hotkey-Based Keyloggers Using an Undocumented Kernel Data Structure\"}),`\n`,(0,t.jsx)(e.p,{children:\"In this article, we explore what hotkey-based keyloggers are and how to detect them. Specifically, we explain how these keyloggers intercept keystrokes, then present a detection technique that leverages an undocumented hotkey table in kernel space.\"}),`\n`,(0,t.jsx)(e.h2,{id:\"introduction\",children:\"Introduction\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"In May 2024, Elastic Security Labs published \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/protecting-your-devices-from-information-theft-keylogger-protection\",rel:\"nofollow\",children:\"an article\"}),\" highlighting new features added in \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/guide/en/integrations/current/endpoint.html\",rel:\"nofollow\",children:\"Elastic Defend\"}),\" (starting with 8.12) to enhance the detection of keyloggers running on Windows. In that post, we covered four types of keyloggers commonly employed in cyberattacks \\u2014 polling-based keyloggers, hooking-based keyloggers, keyloggers using the Raw Input Model, and keyloggers using DirectInput \\u2014 and explained our detection methodology. In particular, we introduced a behavior-based detection method using the Microsoft-Windows-Win32k provider within \",(0,t.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/event-tracing-for-windows--etw-\",rel:\"nofollow\",children:\"Event Tracing for Windows\"}),\" (ETW).\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Shortly after publication, we were honored to have our article noticed by \",(0,t.jsx)(e.a,{href:\"https://jonathanbaror.com/\",rel:\"nofollow\",children:\"Jonathan Bar Or\"}),\", Principal Security Researcher at Microsoft. He provided invaluable feedback by pointing out the existence of hotkey-based keyloggers and even shared proof-of-concept (PoC) code with us. Leveraging his PoC code \",(0,t.jsx)(e.a,{href:\"https://github.com/yo-yo-yo-jbo/hotkeyz\",rel:\"nofollow\",children:\"Hotkeyz\"}),\" as a starting point, this article presents one potential method for detecting hotkey-based keyloggers.\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"overview-of-hotkey-based-keyloggers\",children:\"Overview of Hotkey-based Keyloggers\"}),`\n`,(0,t.jsx)(e.h3,{id:\"what-is-a-hotkey\",children:\"What Is a Hotkey?\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Before delving into hotkey-based keyloggers, let\\u2019s first clarify what a hotkey is. A hotkey is a type of keyboard shortcut that directly invokes a specific function on a computer by pressing a single key or a combination of keys. For example, many Windows users press \",(0,t.jsx)(e.strong,{children:\"Alt + Tab\"}),\" to switch between tasks (or, in other words, windows). In this instance, \",(0,t.jsx)(e.strong,{children:\"Alt + Tab\"}),\" serves as a hotkey that directly triggers the task-switching function.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsxs)(e.em,{children:[\"(Note: Although other types of keyboard shortcuts exist, this article focuses solely on hotkeys. Also, \",(0,t.jsx)(e.strong,{children:\"all information herein is based on Windows 10 version 22H2 OS Build 19045.5371 without virtualization based security\"}),\". Please note that the internal data structures and behavior may differ in other versions of Windows.)\"]})}),`\n`,(0,t.jsx)(e.h3,{id:\"abusing-custom-hotkey-registration-functionality\",children:\"Abusing Custom Hotkey Registration Functionality\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"In addition to using the pre-configured hotkeys in Windows as shown in the previous example, you can also register your own custom hotkeys. There are various methods to do this, but one straightforward approach is to use the Windows API function \",(0,t.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerhotkey\",rel:\"nofollow\",children:(0,t.jsx)(e.strong,{children:\"RegisterHotKey\"})}),\", which allows a user to register a specific key as a hotkey. For instance, the following code snippet demonstrates how to use the \",(0,t.jsx)(e.strong,{children:\"RegisterHotKey\"}),\" API to register the \",(0,t.jsx)(e.strong,{children:\"A\"}),\" key (with a \",(0,t.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes\",rel:\"nofollow\",children:\"virtual-key code\"}),\" of 0x41) as a global hotkey:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-c\",children:`/*\nBOOL RegisterHotKey(\n  [in, optional] HWND hWnd, \n  [in]           int  id,\n  [in]           UINT fsModifiers,\n  [in]           UINT vk\n);\n*/\nRegisterHotKey(NULL, 1, 0, 0x41);\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"After registering a hotkey, when the registered key is pressed, a \",(0,t.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/inputdev/wm-hotkey\",rel:\"nofollow\",children:(0,t.jsx)(e.strong,{children:\"WM_HOTKEY\"})}),\" message is sent to the message queue of the window specified as the first argument to the \",(0,t.jsx)(e.strong,{children:\"RegisterHotKey\"}),\" API (or to the thread that registered the hotkey if \",(0,t.jsx)(e.strong,{children:\"NULL\"}),\" is used). The code below demonstrates a message loop that uses the \",(0,t.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessage\",rel:\"nofollow\",children:(0,t.jsx)(e.strong,{children:\"GetMessage\"})}),\" API to check for a \",(0,t.jsx)(e.strong,{children:\"WM_HOTKEY\"}),\" message in the \",(0,t.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/winmsg/about-messages-and-message-queues\",rel:\"nofollow\",children:\"message queue\"}),\", and if one is received, it extracts the virtual-key code (in this case, 0x41) from the message.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-c\",children:`MSG msg = { 0 };\nwhile (GetMessage(\u0026msg, NULL, 0, 0)) {\n    if (msg.message == WM_HOTKEY) {\n        int vkCode = HIWORD(msg.lParam);\n        std::cout \u003c\u003c \"WM_HOTKEY received! Virtual-Key Code: 0x\"\n            \u003c\u003c std::hex \u003c\u003c vkCode \u003c\u003c std::dec \u003c\u003c std::endl;\n    }\n}\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"In other words, imagine you're writing something in a notepad application. If the A key is pressed, the character won't be treated as normal text input \\u2014 it will be recognized as a global hotkey instead.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"In this example, only the A key is registered as a hotkey. However, you can register multiple keys (like B, C, or D) as separate hotkeys at the same time. This means that any key (i.e., any virtual-key code) that can be registered with the \",(0,t.jsx)(e.strong,{children:\"RegisterHotKey\"}),\" API can potentially be hijacked as a global hotkey. A hotkey-based keylogger abuses this capability to capture the keystrokes entered by the user.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Based on our testing, we found that not only alphanumeric and basic symbol keys, but also those keys when combined with the SHIFT modifier, can all be registered as hotkeys using the \",(0,t.jsx)(e.strong,{children:\"RegisterHotKey\"}),\" API. This means that a keylogger can effectively monitor every keystroke necessary to steal sensitive information.\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"capturing-keystrokes-stealthily\",children:\"Capturing Keystrokes Stealthily\"}),`\n`,(0,t.jsx)(e.p,{children:\"Let's walk through the actual process of how a hotkey-based keylogger captures keystrokes, using the Hotkeyz hotkey-based keylogger as an example.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"In Hotkeyz, it first registers each alphanumeric virtual-key code \\u2014 and some additional keys,  such as \",(0,t.jsx)(e.strong,{children:\"VK_SPACE\"}),\" and \",(0,t.jsx)(e.strong,{children:\"VK_RETURN\"}),\" \\u2014 as individual hotkeys by using the \",(0,t.jsx)(e.strong,{children:\"RegisterHotKey\"}),\" API.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Then, inside the keylogger's message loop, the \",(0,t.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-peekmessagew\",rel:\"nofollow\",children:(0,t.jsx)(e.strong,{children:\"PeekMessageW\"})}),\" API is used to check whether any \",(0,t.jsx)(e.strong,{children:\"WM_HOTKEY\"}),\" messages from these registered hotkeys have appeared in the message queue. When a \",(0,t.jsx)(e.strong,{children:\"WM_HOTKEY\"}),\" message is detected, the virtual-key code it contains is extracted and eventually saved to a text file. Below is an excerpt from the message loop code, highlighting the most important parts.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-c\",children:`while (...)\n{\n    // Get the message in a non-blocking manner and poll if necessary\n    if (!PeekMessageW(\u0026tMsg, NULL, WM_HOTKEY, WM_HOTKEY, PM_REMOVE))\n    {\n        Sleep(POLL_TIME_MILLIS);\n        continue;\n    }\n....\n   // Get the key from the message\n   cCurrVk = (BYTE)((((DWORD)tMsg.lParam) \u0026 0xFFFF0000) \u003e\u003e 16);\n\n   // Send the key to the OS and re-register\n   (VOID)UnregisterHotKey(NULL, adwVkToIdMapping[cCurrVk]);\n   keybd_event(cCurrVk, 0, 0, (ULONG_PTR)NULL);\n   if (!RegisterHotKey(NULL, adwVkToIdMapping[cCurrVk], 0, cCurrVk))\n   {\n       adwVkToIdMapping[cCurrVk] = 0;\n       DEBUG_MSG(L\"RegisterHotKey() failed for re-registration (cCurrVk=%lu,    LastError=%lu).\", cCurrVk, GetLastError());\n       goto lblCleanup;\n   }\n   // Write to the file\n  if (!WriteFile(hFile, \u0026cCurrVk, sizeof(cCurrVk), \u0026cbBytesWritten, NULL))\n  {\n....\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"One important detail is this: to avoid alerting the user to the keylogger's presence, once the virtual-key code is extracted from the message, the key's hotkey registration is temporarily removed using the \",(0,t.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-unregisterhotkey\",rel:\"nofollow\",children:(0,t.jsx)(e.strong,{children:\"UnregisterHotKey\"})}),\" API. After that, the key press is simulated with \",(0,t.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-keybd_event\",rel:\"nofollow\",children:(0,t.jsx)(e.strong,{children:\"keybd_event\"})}),\" so that it appears to the user as if the key was pressed normally. Once the key press is simulated, the key is re-registered using the \",(0,t.jsx)(e.strong,{children:\"RegisterHotKey\"}),\" API to wait for further input. This is the core mechanism behind how a hotkey-based keylogger operates.\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"detecting-hotkey-based-keyloggers\",children:\"Detecting Hotkey-Based Keyloggers\"}),`\n`,(0,t.jsx)(e.p,{children:\"Now that we understand what hotkey-based keyloggers are and how they operate, let's explain how to detect them.\"}),`\n`,(0,t.jsx)(e.h3,{id:\"etw-does-not-monitor-the-registerhotkey-api\",children:\"ETW Does Not Monitor the RegisterHotKey API\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Following the approach described in an earlier article, we first investigated whether \",(0,t.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/etw/about-event-tracing\",rel:\"nofollow\",children:\"Event Tracing for Windows\"}),\" (ETW) could be used to detect hotkey-based keyloggers. Our research quickly revealed that ETW currently does not monitor the \",(0,t.jsx)(e.strong,{children:\"RegisterHotKey\"}),\" or \",(0,t.jsx)(e.strong,{children:\"UnregisterHotKey\"}),\" APIs. In addition to reviewing the manifest file for the Microsoft-Windows-Win32k provider, we reverse-engineered the internals of the \",(0,t.jsx)(e.strong,{children:\"RegisterHotKey\"}),\" API \\u2014 specifically, the \",(0,t.jsx)(e.strong,{children:\"NtUserRegisterHotKey\"}),\" function in win32kfull.sys. Unfortunately, we found no evidence that these APIs trigger any ETW events when executed.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The image below shows a comparison between the decompiled code for \",(0,t.jsx)(e.strong,{children:\"NtUserGetAsyncKeyState\"}),\" (which is monitored by ETW) and \",(0,t.jsx)(e.strong,{children:\"NtUserRegisterHotKey\"}),\". Notice that at the beginning of \",(0,t.jsx)(e.strong,{children:\"NtUserGetAsyncKeyState\"}),\", there is a call to \",(0,t.jsx)(e.strong,{children:\"EtwTraceGetAsyncKeyState\"}),\" \\u2014 a function associated with  logging ETW events \\u2014 while \",(0,t.jsx)(e.strong,{children:\"NtUserRegisterHotKey\"}),\" does not contain such a call.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.img,{src:\"/assets/images/detecting-hotkey-based-keyloggers/image3.png\",alt:\"Figure 1: Comparison of the Decompiled Code for NtUserGetAsyncKeyState and NtUserRegisterHotKey\",width:\"1122\",height:\"556\"}),`\n\\u3000`,(0,t.jsx)(e.br,{}),`\n`,\"Although we also considered using ETW providers other than Microsoft-Windows-Win32k to indirectly monitor calls to the \",(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.code,{children:\"RegisterHotKey\"})}),' API, we found that the detection method using the \"hotkey table\" \\u2014 which will be introduced next and does not rely on ETW \\u2014 achieves results that are comparable to or even better than monitoring the ',(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.code,{children:\"RegisterHotKey\"})}),\" API. In the end, we chose to implement this method.\"]}),`\n`,(0,t.jsxs)(e.h3,{id:\"detection-using-the-hotkey-table-gphkhashtable\",children:[\"Detection Using the Hotkey Table (\",(0,t.jsx)(e.strong,{children:\"gphkHashTable\"}),\")\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"After discovering that ETW cannot directly monitor calls to the \",(0,t.jsx)(e.strong,{children:\"RegisterHotKey\"}),` API, we started exploring detection methods that don't rely on ETW. During our investigation, we wondered, \"Isn't the information for registered hotkeys stored somewhere? And if so, could that data be used for detection?\" Based on that hypothesis, we quickly found a hash table labeled `,(0,t.jsx)(e.strong,{children:\"gphkHashTable\"}),\" within \",(0,t.jsx)(e.strong,{children:\"NtUserRegisterHotKey\"}),\". Searching Microsoft's online documentation revealed no details on \",(0,t.jsx)(e.strong,{children:\"gphkHashTable\"}),\", suggesting that it's an undocumented kernel data structure.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/detecting-hotkey-based-keyloggers/image1.png\",alt:\"Figure 2: The hotkey table (gphkHashTable), discovered within the RegisterHotKey function called inside NtUserRegisterHotKey\",width:\"722\",height:\"340\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Through reverse engineering, we discovered that this hash table stores objects containing information about registered hotkeys. Each object holds details such as the virtual-key code and modifiers specified in the arguments to the \",(0,t.jsx)(e.strong,{children:\"RegisterHotKey\"}),\" API. The right side of Figure 3 shows part of the structure definition for a hotkey object (named \",(0,t.jsx)(e.strong,{children:\"HOT_KEY\"}),\"), while the left side displays how the registered hotkey objects appear when accessed via WinDbg.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/detecting-hotkey-based-keyloggers/image4.png\",alt:\"Figure 3: Hotkey Object Details. WinDbg view (left) and HOT_KEY structure details (right)\",width:\"1220\",height:\"410\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"We also determined that \",(0,t.jsx)(e.strong,{children:\"ghpkHashTable\"}),\" is structured as shown in Figure 4.  Specifically, it uses the result of the modulo operation (with 0x80) on the virtual-key code (specified by the RegisterHotKey API) as the index into the hash table. Hotkey objects sharing the same index are linked together in a list, which allows the table to store and manage hotkey information even when the virtual-key codes are identical but the modifiers differ.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/detecting-hotkey-based-keyloggers/image6.png\",alt:\"Figure 4: Structure of gphkHashTable\",width:\"1113\",height:\"542\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"In other words, by scanning all HOT_KEY objects stored in \",(0,t.jsx)(e.strong,{children:\"ghpkHashTable\"}),\", we can retrieve details about every registered hotkey. If we find that every main key \\u2014 for example, each individual alphanumeric key \\u2014 is registered as a separate hotkey, that strongly indicates the presence of an active hotkey-based keylogger.\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"implementing-the-detection-tool\",children:\"Implementing the Detection Tool\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Now, let's move on to implementing the detection tool. Since \",(0,t.jsx)(e.strong,{children:\"gphkHashTable\"}),\" resides in the kernel space, it cannot be accessed by a user-mode application. For this reason, it was necessary to develop a device driver for detection. More specifically, we decided to develop a device driver that obtains the address of \",(0,t.jsx)(e.strong,{children:\"gphkHashTable\"}),\" and scans through all the hotkey objects stored in the hash table. If the number of alphanumeric keys registered as hotkeys exceeds a predefined threshold, it will alert us to the potential presence of a hotkey-based keylogger.\"]}),`\n`,(0,t.jsxs)(e.h3,{id:\"how-to-obtain-the-address-of-gphkhashtable\",children:[\"How to Obtain the Address of \",(0,t.jsx)(e.strong,{children:\"gphkHashTable\"})]}),`\n`,(0,t.jsxs)(e.p,{children:[\"While developing the detection tool, one of the first challenges we faced was how to obtain the address of \",(0,t.jsx)(e.strong,{children:\"gphkHashTable\"}),\". After some consideration, we decided to extract the address directly from an instruction in the \",(0,t.jsx)(e.strong,{children:\"win32kfull.sys\"}),\" driver that accesses \",(0,t.jsx)(e.strong,{children:\"gphkHashTable\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Through reverse engineering, we discovered that within the IsHotKey function \\u2014 right at the beginning \\u2014 there is a lea instruction (lea rbx, \",(0,t.jsx)(e.strong,{children:\"gphkHashTable\"}),\") that accesses \",(0,t.jsx)(e.strong,{children:\"gphkHashTable\"}),\". We used the opcode byte sequence (0x48, 0x8d, 0x1d) from that instruction as a signature to locate the corresponding line, and then computed the address of \",(0,t.jsx)(e.strong,{children:\"gphkHashTable\"}),\" using the obtained 32-bit (4-byte) offset.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/detecting-hotkey-based-keyloggers/image5.png\",alt:\"Figure 5: Inside the IsHotKey function\",width:\"1128\",height:\"350\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Additionally, since \",(0,t.jsx)(e.strong,{children:\"IsHotKey\"}),\" is not an exported function, we also need to know its address before looking for \",(0,t.jsx)(e.strong,{children:\"gphkHashTable\"}),\". Through further reverse engineering, we discovered that the exported function \",(0,t.jsx)(e.strong,{children:\"EditionIsHotKey\"}),\" calls the \",(0,t.jsx)(e.strong,{children:\"IsHotKey\"}),\" function. Therefore, we decided to compute the address of IsHotKey within the \",(0,t.jsx)(e.strong,{children:\"EditionIsHotKey\"}),\" function using the same method described earlier. (For reference, the base address of \",(0,t.jsx)(e.strong,{children:\"win32kfull.sys\"}),\" can be found using the \",(0,t.jsx)(e.strong,{children:\"PsLoadedModuleList\"}),\" API.)\"]}),`\n`,(0,t.jsxs)(e.h3,{id:\"accessing-the-memory-space-of-win32kfullsys\",children:[\"Accessing the Memory Space of \",(0,t.jsx)(e.strong,{children:\"win32kfull.sys\"})]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Once we finalized our approach to obtaining the address of \",(0,t.jsx)(e.strong,{children:\"gphkHashTable\"}),\", we began writing code to access the memory space of \",(0,t.jsx)(e.strong,{children:\"win32kfull.sys\"}),\" to retrieve that address. One challenge we encountered at this stage was that win32kfull.sys is a \",(0,t.jsx)(e.em,{children:\"session driver\"}),\". Before proceeding further, here\\u2019s a brief, simplified explanation of what a \",(0,t.jsx)(e.em,{children:\"session\"}),\" is.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In Windows, when a user logs in, a separate session (with session numbers starting from 1) is assigned to each user. Simply put, the first user to log in is assigned \",(0,t.jsx)(e.strong,{children:\"Session 1\"}),\". If another user logs in while that session is active, that user is assigned \",(0,t.jsx)(e.strong,{children:\"Session 2\"}),\", and so on. Each user then has their own desktop environment within their assigned session.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Kernel data that must be managed separately for each session (i.e., per logged-in user) is stored in an isolated area of kernel memory called \",(0,t.jsx)(e.em,{children:\"session space\"}),\". This includes GUI objects managed by win32k drivers, such as windows and mouse/keyboard input data, ensuring that the screen and input remain properly separated between users.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsxs)(e.em,{children:[\"(This is a simplified explanation. For a more detailed discussion on sessions, please refer to \",(0,t.jsx)(e.a,{href:\"https://googleprojectzero.blogspot.com/2016/01/raising-dead.html\",rel:\"nofollow\",children:\"James Forshaw\\u2019s blog post\"}),\".)\"]})}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/detecting-hotkey-based-keyloggers/image2.png\",alt:\"Figure 6: Overview of Sessions. Session 0 is dedicated exclusively to service processes\",width:\"735\",height:\"543\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Based on the above, \",(0,t.jsx)(e.strong,{children:\"win32kfull.sys\"}),\" is known as a \",(0,t.jsx)(e.em,{children:\"session driver\"}),\". This means that, for example, hotkey information registered in the session of the first logged-in user (Session 1) can only be accessed from within that same session. So, how can we work around this limitation? In such cases, \",(0,t.jsx)(e.a,{href:\"https://eversinc33.com/posts/kernel-mode-keylogging.html\",rel:\"nofollow\",children:\"it is known\"}),\" that \",(0,t.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-kestackattachprocess\",rel:\"nofollow\",children:(0,t.jsx)(e.strong,{children:\"KeStackAttachProcess\"})}),\" can be used.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"KeStackAttachProcess\"}),\" allows the current thread to temporarily attach to the address space of a specified process. If we can attach to a GUI process in the target session \\u2014 more precisely, a process that has loaded \",(0,t.jsx)(e.strong,{children:\"win32kfull.sys\"}),\" \\u2014 then we can access \",(0,t.jsx)(e.strong,{children:\"win32kfull.sys\"}),\" and its associated data within that session. For our implementation, assuming that only one user is logged in, we decided to locate and attach to \",(0,t.jsx)(e.strong,{children:\"winlogon.exe\"}),\", the process responsible for handling user logon operations.\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"enumerating-registered-hotkeys\",children:\"Enumerating Registered Hotkeys\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Once we have successfully attached to the winlogon.exe process and determined the address of \",(0,t.jsx)(e.strong,{children:\"gphkHashTable\"}),\", the next step is simply scanning \",(0,t.jsx)(e.strong,{children:\"gphkHashTable\"}),\" to check the registered hotkeys. Below is an excerpt of that code:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-c\",children:`BOOL CheckRegisteredHotKeys(_In_ const PVOID\u0026 gphkHashTableAddr)\n{\n-[skip]-\n    // Cast the gphkHashTable address to an array of pointers.\n    PVOID* tableArray = static_cast\u003cPVOID*\u003e(gphkHashTableAddr);\n    // Iterate through the hash table entries.\n    for (USHORT j = 0; j \u003c 0x80; j++)\n    {\n        PVOID item = tableArray[j];\n        PHOT_KEY hk = reinterpret_cast\u003cPHOT_KEY\u003e(item);\n        if (hk)\n        {\n            CheckHotkeyNode(hk);\n        }\n    }\n-[skip]-\n}\n\nVOID CheckHotkeyNode(_In_ const PHOT_KEY\u0026 hk)\n{\n    if (MmIsAddressValid(hk-\u003epNext)) {\n        CheckHotkeyNode(hk-\u003epNext);\n    }\n\n    // Check whether this is a single numeric hotkey.\n    if ((hk-\u003evk \u003e= 0x30) \u0026\u0026 (hk-\u003evk \u003c= 0x39) \u0026\u0026 (hk-\u003emodifiers1 == 0))\n    {\n        KdPrint((\"[+] hk-\u003eid: %u hk-\u003evk: %x\\\\n\", hk-\u003eid, hk-\u003evk));\n        hotkeyCounter++;\n    }\n    // Check whether this is a single alphabet hotkey.\n    else if ((hk-\u003evk \u003e= 0x41) \u0026\u0026 (hk-\u003evk \u003c= 0x5A) \u0026\u0026 (hk-\u003emodifiers1 == 0))\n    {\n        KdPrint((\"[+] hk-\u003eid: %u hk-\u003evk: %x\\\\n\", hk-\u003eid, hk-\u003evk));\n        hotkeyCounter++;\n    }\n-[skip]-\n}\n....\nif (CheckRegisteredHotKeys(gphkHashTableAddr) \u0026\u0026 hotkeyCounter \u003e= 36)\n{\n   detected = TRUE;\n   goto Cleanup;\n}\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"The code itself is straightforward: it iterates through each index of the hash table, following the linked list to access every \",(0,t.jsx)(e.strong,{children:\"HOT_KEY\"}),\" object, and checks whether the registered hotkeys correspond to alphanumeric keys without any modifiers. In our detection tool, if every alphanumeric key is registered as a hotkey, an alert is raised, indicating the possible presence of a hotkey-based keylogger. For simplicity, this implementation only targets alphanumeric key hotkeys, although it would be easy to extend the tool to check for hotkeys with modifiers such as \",(0,t.jsx)(e.strong,{children:\"SHIFT\"}),\".\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"detecting-hotkeyz\",children:\"Detecting Hotkeyz\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The detection tool (Hotkey-based Keylogger Detector) has been released below. Detailed usage instructions are provided as well. Additionally, this research was presented at \",(0,t.jsx)(e.a,{href:\"https://nullcon.net/goa-2025/speaker-windows-keylogger-detection\",rel:\"nofollow\",children:\"NULLCON Goa 2025\"}),\", and the \",(0,t.jsx)(e.a,{href:\"https://docs.google.com/presentation/d/1B0Gdfpo-ER2hPjDbP_NNoGZ8vXP6X1_BN7VZCqUgH8c/edit?usp=sharing\",rel:\"nofollow\",children:\"presentation slides\"}),\" are available.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:\"https://github.com/AsuNa-jp/HotkeybasedKeyloggerDetector\",rel:\"nofollow\",children:\"https://github.com/AsuNa-jp/HotkeybasedKeyloggerDetector\"})}),`\n`,(0,t.jsx)(e.p,{children:\"The following is a demo video showcasing how the Hotkey-based Keylogger Detector detects Hotkeyz.\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:\"https://drive.google.com/file/d/1koGLqA5cPlhL8C07MLg9VDD9-SW2FM9e/view?usp=drive_link\",rel:\"nofollow\",children:\"DEMO_VIDEO.mp4\"})}),`\n`,(0,t.jsx)(e.h2,{id:\"acknowledgments\",children:\"Acknowledgments\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"We would like to express our heartfelt gratitude to Jonathan Bar Or for reading our previous article, sharing his insights on hotkey-based keyloggers, and generously publishing the PoC tool \",(0,t.jsx)(e.strong,{children:\"Hotkeyz\"}),\".\"]})]})}function v(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(l,n)})):l(n)}var H=v;return m(T);})();\n;return Component;"},"_id":"articles/detecting-hotkey-based-keyloggers.mdx","_raw":{"sourceFilePath":"articles/detecting-hotkey-based-keyloggers.mdx","sourceFileName":"detecting-hotkey-based-keyloggers.mdx","sourceFileDir":"articles","contentType":"mdx","flattenedPath":"articles/detecting-hotkey-based-keyloggers"},"type":"Article","imageUrl":"/assets/images/detecting-hotkey-based-keyloggers/Security Labs Images 12.jpg","readingTime":"15 min read","series":"","url":"/detecting-hotkey-based-keyloggers","headings":[{"level":2,"title":"Introduction","href":"#introduction"},{"level":2,"title":"Overview of Hotkey-based Keyloggers","href":"#overview-of-hotkey-based-keyloggers"},{"level":3,"title":"What Is a Hotkey?","href":"#what-is-a-hotkey"},{"level":3,"title":"Abusing Custom Hotkey Registration Functionality","href":"#abusing-custom-hotkey-registration-functionality"},{"level":3,"title":"Capturing Keystrokes Stealthily","href":"#capturing-keystrokes-stealthily"},{"level":2,"title":"Detecting Hotkey-Based Keyloggers","href":"#detecting-hotkey-based-keyloggers"},{"level":3,"title":"ETW Does Not Monitor the RegisterHotKey API","href":"#etw-does-not-monitor-the-registerhotkey-api"},{"level":3,"title":"Detection Using the Hotkey Table (**gphkHashTable**)","href":"#detection-using-the-hotkey-table-gphkhashtable"},{"level":2,"title":"Implementing the Detection Tool","href":"#implementing-the-detection-tool"},{"level":3,"title":"How to Obtain the Address of **gphkHashTable**","href":"#how-to-obtain-the-address-of-gphkhashtable"},{"level":3,"title":"Accessing the Memory Space of **win32kfull.sys**","href":"#accessing-the-memory-space-of-win32kfullsys"},{"level":3,"title":"Enumerating Registered Hotkeys","href":"#enumerating-registered-hotkeys"},{"level":3,"title":"Detecting Hotkeyz","href":"#detecting-hotkeyz"},{"level":2,"title":"Acknowledgments","href":"#acknowledgments"}],"author":[{"title":"Asuka Nakajima","slug":"asuka-nakajima","description":"Senior Security Research Engineer, Elastic","body":{"raw":"","code":"var Component=(()=\u003e{var x=Object.create;var i=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,l=Object.prototype.hasOwnProperty;var _=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),d=(t,e)=\u003e{for(var n in e)i(t,n,{get:e[n],enumerable:!0})},s=(t,e,n,o)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let r of f(e))!l.call(t,r)\u0026\u0026r!==n\u0026\u0026i(t,r,{get:()=\u003ee[r],enumerable:!(o=j(e,r))||o.enumerable});return t};var k=(t,e,n)=\u003e(n=t!=null?x(g(t)):{},s(e||!t||!t.__esModule?i(n,\"default\",{value:t,enumerable:!0}):n,t)),p=t=\u003es(i({},\"__esModule\",{value:!0}),t);var u=_((E,c)=\u003e{c.exports=_jsx_runtime});var C={};d(C,{default:()=\u003ey,frontmatter:()=\u003eM});var a=k(u()),M={title:\"Asuka Nakajima\",description:\"Senior Security Research Engineer, Elastic\",slug:\"asuka-nakajima\"};function m(t){return(0,a.jsx)(a.Fragment,{})}function h(t={}){let{wrapper:e}=t.components||{};return e?(0,a.jsx)(e,Object.assign({},t,{children:(0,a.jsx)(m,t)})):m(t)}var y=h;return p(C);})();\n;return Component;"},"_id":"authors/asuka-nakajima.mdx","_raw":{"sourceFilePath":"authors/asuka-nakajima.mdx","sourceFileName":"asuka-nakajima.mdx","sourceFileDir":"authors","contentType":"mdx","flattenedPath":"authors/asuka-nakajima"},"type":"Author","imageUrl":"","url":"/authors/asuka-nakajima"}],"category":[{"title":"Security research","slug":"security-research","body":{"raw":"","code":"var Component=(()=\u003e{var x=Object.create;var s=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var l=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),d=(t,e)=\u003e{for(var r in e)s(t,r,{get:e[r],enumerable:!0})},c=(t,e,r,a)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let o of _(e))!j.call(t,o)\u0026\u0026o!==r\u0026\u0026s(t,o,{get:()=\u003ee[o],enumerable:!(a=f(e,o))||a.enumerable});return t};var h=(t,e,r)=\u003e(r=t!=null?x(g(t)):{},c(e||!t||!t.__esModule?s(r,\"default\",{value:t,enumerable:!0}):r,t)),p=t=\u003ec(s({},\"__esModule\",{value:!0}),t);var i=l((X,u)=\u003e{u.exports=_jsx_runtime});var D={};d(D,{default:()=\u003eC,frontmatter:()=\u003ey});var n=h(i()),y={title:\"Security research\",slug:\"security-research\"};function m(t){return(0,n.jsx)(n.Fragment,{})}function M(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var C=M;return p(D);})();\n;return Component;"},"_id":"categories/security-research.mdx","_raw":{"sourceFilePath":"categories/security-research.mdx","sourceFileName":"security-research.mdx","sourceFileDir":"categories","contentType":"mdx","flattenedPath":"categories/security-research"},"type":"Category","url":"/categories/security-research"},{"title":"Detection science","slug":"detection-science","body":{"raw":"","code":"var Component=(()=\u003e{var x=Object.create;var c=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var d=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var j=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),l=(t,e)=\u003e{for(var n in e)c(t,n,{get:e[n],enumerable:!0})},i=(t,e,n,s)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let o of _(e))!g.call(t,o)\u0026\u0026o!==n\u0026\u0026c(t,o,{get:()=\u003ee[o],enumerable:!(s=f(e,o))||s.enumerable});return t};var p=(t,e,n)=\u003e(n=t!=null?x(d(t)):{},i(e||!t||!t.__esModule?c(n,\"default\",{value:t,enumerable:!0}):n,t)),D=t=\u003ei(c({},\"__esModule\",{value:!0}),t);var u=j((h,a)=\u003e{a.exports=_jsx_runtime});var X={};l(X,{default:()=\u003eF,frontmatter:()=\u003eM});var r=p(u()),M={title:\"Detection science\",slug:\"detection-science\"};function m(t){return(0,r.jsx)(r.Fragment,{})}function C(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(m,t)})):m(t)}var F=C;return D(X);})();\n;return Component;"},"_id":"categories/detection-science.mdx","_raw":{"sourceFilePath":"categories/detection-science.mdx","sourceFileName":"detection-science.mdx","sourceFileDir":"categories","contentType":"mdx","flattenedPath":"categories/detection-science"},"type":"Category","url":"/categories/detection-science"}]},"seriesArticles":null},"__N_SSG":true},"page":"/[slug]","query":{"slug":"detecting-hotkey-based-keyloggers"},"buildId":"0PDZemg2oGX1bus_dquF1","assetPrefix":"/security-labs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>