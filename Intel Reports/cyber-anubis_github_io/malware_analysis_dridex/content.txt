<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.19.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Dridex Trojan - Cyber-Anubis</title>
<meta name="description" content="Defeating Dridex anti-analysis. Dridex -is also known as Bugat and Cridex- specializes in stealing bank credentials via a syste … ">


  <meta name="author" content="Nidal Fikri">


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Cyber-Anubis">
<meta property="og:title" content="Dridex Trojan">
<meta property="og:url" content="https://cyber-anubis.github.io/malware%20analysis/dridex/">


  <meta property="og:description" content="Defeating Dridex anti-analysis. Dridex -is also known as Bugat and Cridex- specializes in stealing bank credentials via a syste … ">



  <meta property="og:image" content="https://cyber-anubis.github.io/assets/images/malware-analysis/Dridex/dridex.png">





  <meta property="article:published_time" content="2021-11-21T00:00:00+00:00">





  

  


<link rel="canonical" href="https://cyber-anubis.github.io/malware%20analysis/dridex/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Nidal Fikri",
      "url": "https://cyber-anubis.github.io/"
    
  }
</script>


  <meta name="google-site-verification" content="J3MnMF94zaZhTUoNtUiRt9cKsr7hiMyTxEdAvQ3GfmY" />





<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Cyber-Anubis Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

<!-- favicon -->
<link rel="icon" type="image/png" sizes="32x32" href="/assets/images/site_data/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/images/site_data/favicon-16x16.png">
<meta name="theme-color" content="#ffffff">

  </head>

  <body class="layout--single wide">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/site_data/logo.png" alt=""></a>
        
        <a class="site-title" href="/">
          Cyber-Anubis
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/categories/#malware-analysis">Malware Analysis</a>
            </li><li class="masthead__menu-item">
              <a href="">Tutorials</a>
            </li><li class="masthead__menu-item">
              <a href="/categories">All Categories</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="/assets/images/site_data/avatar.jpg" alt="Nidal Fikri" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Nidal Fikri</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Hatching Triage Malware Research Analyst. Ex-Trend Micro Intern.</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Egypt</span>
        </li>
      

      
        
          
            <li><a href="https://cyber-anubis.github.io/aboutme/" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-link" aria-hidden="true"></i><span class="label">About Me</span></a></li>
          
        
          
            <li><a href="mailto:nidalfikrikamil@gmail.com" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Email</span></a></li>
          
        
          
            <li><a href="https://twitter.com/cyber_anubis" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i><span class="label">Twitter</span></a></li>
          
        
          
        
          
            <li><a href="https://www.linkedin.com/in/nidal-fikri-kamil/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span class="label">LinkedIn</span></a></li>
          
        
          
            <li><a href="https://github.com/cyber-anubis" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Dridex Trojan">
    <meta itemprop="description" content="Dridex in a Nutshell">
    <meta itemprop="datePublished" content="2021-11-21T00:00:00+00:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Dridex Trojan
</h1>
          
            <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  15 minute read

</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu">
  <li><a href="#dridex-in-a-nutshell">Dridex in a Nutshell</a></li>
  <li><a href="#technical-summary">Technical Summary</a></li>
  <li><a href="#technical-analysis">Technical Analysis</a>
    <ul>
      <li><a href="#defeating-anti-analysis">Defeating Anti-Analysis</a></li>
      <li><a href="#strings-decryption">Strings Decryption</a></li>
      <li><a href="#extracting-cc-configuration">Extracting C&amp;C Configuration</a></li>
    </ul>
  </li>
  <li><a href="#conclusion">Conclusion</a></li>
  <li><a href="#iocs">IoCs</a></li>
  <li><a href="#refrences">Refrences</a></li>
</ul>

            </nav>
          </aside>
        
        <h1 id="dridex-in-a-nutshell">Dridex in a Nutshell</h1>

<p>Dridex is a famous banking Trojan which appeared around 2011 and is still very active today. This is because of its evolution and its complex architecture, which is based on proxy layers to hide the main command and control servers (C&amp;C). The APT known as <a href="https://malpedia.caad.fkie.fraunhofer.de/actor/ta505">TA505</a> is associated to Dridex, as well as with other malwares such as TrickBot and Locky ransomware. Dridex is known for its unique anti-analysis techniques which combines API hashing with VEH (Vectored Exception Handling) manipulation. As a consequence, Dridex is able to effectively hide its intentions and requires skillful reverse engineers to accurately dissect it. Once installed, Dridex can download additional files to provide more functionality to the Trojan.</p>

<h1 id="technical-summary">Technical Summary</h1>

<ol>
  <li>Dridex uses API hashing to conceal its imports. It’s using CRC32 hashing, as well as another layer of XORing with hard-coded key. It’s prasing the loaded DLLs in memory and its export tables. As a consequence, Dridex can resolve any imported win APIs then jumps to their addresses.</li>
  <li>Another layer of complication is done with Vectored Exception Handling manipulation. Dridex inserts a lot of <code class="language-plaintext highlighter-rouge">int 3</code> and <code class="language-plaintext highlighter-rouge">ret</code> instructions everywhere to make the reverse engineering harder. Furthermore, the use of <code class="language-plaintext highlighter-rouge">int 3</code> triggers a custom exception handler planted by the malware. This malicious handler alters the execution flow to effectively jump between APIs.</li>
  <li>Dridex comes with encrypted strings on its <code class="language-plaintext highlighter-rouge">.rdata</code> section. These strings are used as API parameters/settings for the malicious impact. Therefore, they are must be decrypted to know its intentions. Dridex uses RC4 to do the decryption. The first 40 bytes of every data chunk is the key (stored in a reverse order) then followed by the encrypted data.</li>
  <li>Dridex stores its network configuration in plain text on its <code class="language-plaintext highlighter-rouge">.data</code> section. Obviously, it establishes connection with its C&amp;C for further commands, and also to download additional malware modules. These modules extend its functionality. Dridex comes with 4 embedded C&amp;C IP addresses.</li>
</ol>

<p><br /></p>
<h1 id="technical-analysis">Technical Analysis</h1>

<h2 id="defeating-anti-analysis">Defeating Anti-Analysis</h2>

<h3 id="api-hashing">API Hashing</h3>

<p>Dridex is famous for its anti-analysis techniques which include API hashing. API hashing -in a nutshell- is when a malware hashes the names (strings) of its imports, making it harder to know what APIs it will resolve at run-time. API hashing is famous among shellcodes. That’s because a tightly crafted shellcode can’t make use of the OS loader, it’s not a PE file and it must depend on itself to find where DLLs are residing in memory. Once it finds the targeted module, it parses its export table to know where it’s providing its exported APIs (the address in memory). One way to spot API hashing techniques, is to look for a function which takes constant (random-like data) inputs, and finding that they are using its return value as a function pointer.</p>

<p><a href="/assets/images/malware-analysis/Dridex/1.png"><img src="/assets/images/malware-analysis/Dridex/1.png" alt="" /></a></p>
<center><font size="3"> <u>Figure</u>(1): <u>sub_6015C0 will be renamed to be mw_API_Resolver </u> </font></center>

<p><br />
We can see that <code class="language-plaintext highlighter-rouge">sub_6015C0</code> matches the description we have just stated. It’s called twice to resolve two Windows APIs. Also, we can notice that the 1st parameter is the same during the two calls here. This may indicate that the 1st parameter is likely to be the hashed DLL name and the 2nd parameter is likely to be the hashed API name.</p>

<p>We can label <code class="language-plaintext highlighter-rouge">sub_6015C0</code> as a potential API resolving routine. Now let’s dive into it for more detailed analysis.
We can see that it’s depending on two more functions: <code class="language-plaintext highlighter-rouge">sub_607564</code> and <code class="language-plaintext highlighter-rouge">sub_6067C8</code>.</p>

<p><a href="/assets/images/malware-analysis/Dridex/2.png"><img src="/assets/images/malware-analysis/Dridex/2.png" alt="" /></a></p>
<center><font size="3"> <u>Figure</u>(2): <u>Using IDA Pro structs.</u> </font></center>

<p><br />
In <code class="language-plaintext highlighter-rouge">sub_607564</code>, we find that Dridex is parsing the process <code class="language-plaintext highlighter-rouge">PEB</code> structure in order to get the loaded modules- in the process address space-. By using the appropriate structs in IDA Pro, the code looks more readable right now.</p>

<table>
  <thead>
    <tr>
      <th>Variable Name</th>
      <th>Struct</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Ldr</td>
      <td>Pointer to _PEB_LDR_DATA</td>
    </tr>
    <tr>
      <td>Current_DLL</td>
      <td>Pointer to <a href="http://undocumented.ntinternals.net/">_LDR_MODULE</a>  (Click the link and search the documentation)</td>
    </tr>
    <tr>
      <td>Prev_DLL</td>
      <td>Pointer to <a href="http://undocumented.ntinternals.net/">_LDR_MODULE</a></td>
    </tr>
  </tbody>
</table>

<p>As we can see, Dridex is using the <code class="language-plaintext highlighter-rouge">Flink</code> pointer to parse the loaded modules (DLLs) as <code class="language-plaintext highlighter-rouge">_LDR_MODULE</code> structs. The <code class="language-plaintext highlighter-rouge">BaseDllName</code> of every loaded module is obtained, and properly converted to the right form for further comparison. The <code class="language-plaintext highlighter-rouge">BaseDllName</code> is hashed by <code class="language-plaintext highlighter-rouge">sub_61D620</code> and XORed against the <code class="language-plaintext highlighter-rouge">38BA5C7B</code> hard-coded key.</p>

<p><a href="/assets/images/malware-analysis/Dridex/3.png"><img src="/assets/images/malware-analysis/Dridex/3.png" alt="" /></a></p>
<center><font size="3"> <u>Figure</u>(3): <u>Hash comparison; between the function input hash and the obtained name (after hashing and XORing).</u> </font></center>

<p><br />
We can determine the type of hashing algorithm using <u>PEiD</u> tool. Using the <u>Krypto ANALyzer</u> plugin, it was able to identify the hashing algorithm as <code class="language-plaintext highlighter-rouge">CRC32</code> based on the used algorithm constants. After hashing and XORing the <code class="language-plaintext highlighter-rouge">BaseDllName</code> of the loaded module, it’s compared against the target hash. Once there is a match, at <code class="language-plaintext highlighter-rouge">0X60769A</code>, the <code class="language-plaintext highlighter-rouge">BaseAddress</code> of the wanted module (DLL) is returned. This address is used later for locating the wanted API within the module’s export table. This address also points to the <code class="language-plaintext highlighter-rouge">IMAGE_DOS_HEADER</code> aka MZ header of the module. All that is purely done in the memory without the need of exposing the malware’s imports.</p>

<p>We proceed to reverse <code class="language-plaintext highlighter-rouge">sub_6067C8</code>. The routine accepts the previously returned DLL <code class="language-plaintext highlighter-rouge">BaseAddress</code> as a parameter along with the second hash. We can make a strong prediction that this function is using those parameters to return the API address in order to be used by Dridex. As we can see, The malware is parsing the module header in order to locate its export table. The export table of a certain DLL contains the addresses which its exported APIs are residing in memory.</p>

<p><a href="/assets/images/malware-analysis/Dridex/4.png"><img src="/assets/images/malware-analysis/Dridex/4.png" alt="" /></a></p>
<center><font size="3"> <u>Figure</u>(4): <u>The offsets are calculated based on the function argurment (DLL ImageAddress)</u> </font></center>

<p><br />
The malwares first references the <code class="language-plaintext highlighter-rouge">e_lfanew</code> field at offset <code class="language-plaintext highlighter-rouge">0X3C</code> from the beginning of the module. This field denotes the offset which the <code class="language-plaintext highlighter-rouge">NT Headers</code> begin. From there and by offset <code class="language-plaintext highlighter-rouge">0X78</code> -i.e. at offset <code class="language-plaintext highlighter-rouge">0X3C + 0X78 = 0X160</code> from the beginning of the DLL-, the malware can access the <code class="language-plaintext highlighter-rouge">Data Directory</code>. The first two fields of this array is the address of the <code class="language-plaintext highlighter-rouge">Export Directory</code> address and its <code class="language-plaintext highlighter-rouge">size</code>.  We can use PEBear tool to visualize all these offsets within the PE header. We use the <code class="language-plaintext highlighter-rouge">_IMAGE_EXPORT_DIRECTORY</code> struct with the variable <code class="language-plaintext highlighter-rouge">EXPORT_TABLE_Start_Address</code> to make the code more readable.</p>

<p>Hence, we can see the malware parsing <code class="language-plaintext highlighter-rouge">AddressOfNames</code>, <code class="language-plaintext highlighter-rouge">AddressOfNameOrdinals</code>, and <code class="language-plaintext highlighter-rouge">AddressOfFunctions</code> to make a mapping between every exported API’s name and its memory address. If the hashed -and XORed- API name matches the 2nd argument of the function, its memory address is returned. By using this way, Dridex is able to effectively hide its needed APIs from security solutions. For more details about how to find an API address in memory check this <a href="https://www.ired.team/offensive-security/code-injection-process-injection/finding-kernel32-base-and-function-addresses-in-shellcode#offsets-in-tables">out</a>.</p>

<p>Combining all together from the previous analysis, we now know that Dridex is doing API hashing using CRC32 + another layer of XORing. We can try to write a script to create a hash table of the famous Windows DLLs and their exports. Generating this table, we can then search into it using the hashes that Dridex uses. As a consequence, we can know which API and DLL Dridex is trying to resolve without the need of dynamic code analysis.</p>

<p>Fortunately, we don’t have to create this script. We can use the amazing <a href="https://github.com/OALabs/hashdb">hashdb</a> IDA plugin from OALabs. It will automate everything for us. We just need to identify the hashing algorithm and the XOR key to make hashdb ready.</p>

<p><a href="/assets/images/malware-analysis/Dridex/5.png"><img src="/assets/images/malware-analysis/Dridex/5.png" alt="" /></a></p>
<center><font size="3"> <u>Figure</u>(5): <u>Use enums with the 'm' button</u> </font></center>

<p><br />
This announces our victory over API hashing anti-analysis, and we can easily use the newly added enums to make the malware code more readable right now. For instance, at <code class="language-plaintext highlighter-rouge">0X5F9E47</code> we find that <code class="language-plaintext highlighter-rouge">CreatThread</code> is being resolved at that particular address.</p>

<h3 id="vectored-exception-handling">Vectored Exception Handling</h3>

<p>To fully understand the intention of this anti-analysis technique, we need to know how Dridex is utilizing API hashing:</p>

<p><a href="/assets/images/malware-analysis/Dridex/6.png"><img src="/assets/images/malware-analysis/Dridex/6.png" alt="" /></a></p>
<center><font size="3"> <u>Figure</u>(6): <u>This pattern is found hunderds of times in this sample and also in any downloaded module.</u> </font></center>

<p><br />
The returned API address from <code class="language-plaintext highlighter-rouge">sub_6015C0</code> (labeled as <code class="language-plaintext highlighter-rouge">mw_API_Resolver</code>) is not used as <code class="language-plaintext highlighter-rouge">call</code> instruction operand. Rather, at <code class="language-plaintext highlighter-rouge">sub_607980</code>, Dridex is registering (adding) a new customized <em>Exception Handler</em> using <code class="language-plaintext highlighter-rouge">RtlAddVectoredExceptionHandler</code> API, which accepts an <code class="language-plaintext highlighter-rouge">_EXCEPTION_POINTERS</code> arguemnt. This customized exception handler will adjust the thread stack and <code class="language-plaintext highlighter-rouge">EIP</code> register, in order to alter the process flow to the previously resolved API address (via the <code class="language-plaintext highlighter-rouge">ret</code> instruction).</p>

<p>After calling the <code class="language-plaintext highlighter-rouge">mw_API_Resolver</code> function, <code class="language-plaintext highlighter-rouge">EAX</code> now contains the address of the resolved API. Dridex then traps the debugger or -more accurately- generates an <code class="language-plaintext highlighter-rouge">EXCEPTION_BREAKPOINT</code> using <code class="language-plaintext highlighter-rouge">int 3</code> instruction. This exception is passed to the process exception handlers vector in order to be properly handled. The previously planted customized exception handler will be the first to process the exception.</p>

<p><a href="/assets/images/malware-analysis/Dridex/7.png"><img src="/assets/images/malware-analysis/Dridex/7.png" alt="" /></a></p>
<center><font size="3"> <u>Figure</u>(7): <u>A process context is like a snapshot of its registers and stack.</u> </font></center>

<p><br />
This malicious handler will execute and alter the process’ context if and only if the exception is caused by <code class="language-plaintext highlighter-rouge">int 3</code> instruction -which Dridex exactly wants-. The final process’ context will be altered by these steps:</p>

<ol>
  <li>
    <p>Incrementing <code class="language-plaintext highlighter-rouge">EIP</code> by 1 in order to make it point to the <code class="language-plaintext highlighter-rouge">ret</code> instruction.</p>
  </li>
  <li>
    <p>Mimicking a <code class="language-plaintext highlighter-rouge">push EIP+1</code> instruction, in order to save <u>the address</u> of the instruction after <code class="language-plaintext highlighter-rouge">ret</code> on the stack ( manually building a stack frame).</p>
  </li>
  <li>
    <p>Also mimicking a <code class="language-plaintext highlighter-rouge">push EAX</code> instruction, in order to make <code class="language-plaintext highlighter-rouge">ESP = Resolved API Address</code>.</p>
  </li>
</ol>

<p>Successfully achieving these steps, the flow will exactly resume at the <code class="language-plaintext highlighter-rouge">ret</code> instruction, pointed by the corrupted <code class="language-plaintext highlighter-rouge">EIP</code>, which will pop the address on top of the stack and jumps to it. This will make the wanted jump to the resolved API with no <code class="language-plaintext highlighter-rouge">call</code> instruction. Furthermore, after executing the resolved API code, the flow resumes at the previously saved address of the manually built stack frame (step no. 2). This will make the flow resume at the instruction after the <code class="language-plaintext highlighter-rouge">ret</code>, successfully returning back to the previous normal flow before the <code class="language-plaintext highlighter-rouge">int 3</code> instruction. Not to forget, this technique makes the dynamic code analysis harder, because you will deal with hundreds of debugger traps everywhere in the code.</p>

<p>Moreover, inserting <code class="language-plaintext highlighter-rouge">ret</code> instructions everywhere in the code tricks the disassemblers when trying to identify functions. Some disassemblers use <code class="language-plaintext highlighter-rouge">ret</code> instructions to identify the end of the functions. This makes another layer of complication using this anti-disassembly technique.</p>

<p>To overcome all this, we need to create a script which parses the code section of the sample, in order to fix those complication.
We can create a small IDA Python script to search for the opcodes <code class="language-plaintext highlighter-rouge">int 3</code> and  <code class="language-plaintext highlighter-rouge">ret</code>,  and then patch them to be  <code class="language-plaintext highlighter-rouge">call EAX</code> . This means that we are looking for the bytes <code class="language-plaintext highlighter-rouge">0xCCC3</code>, then we patch them to be <code class="language-plaintext highlighter-rouge">0xFFD0</code>. The script is below:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">idautils</span>
<span class="kn">import</span> <span class="nn">idaapi</span>
<span class="kn">import</span> <span class="nn">ida_search</span>

<span class="k">def</span> <span class="nf">get_text_section</span> <span class="p">():</span>
    <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">idautils</span><span class="p">.</span><span class="n">Segments</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">idc</span><span class="p">.</span><span class="n">get_segm_name</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span> <span class="o">==</span> <span class="s">".text"</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">idc</span><span class="p">.</span><span class="n">get_segm_start</span><span class="p">(</span><span class="n">seg</span><span class="p">),</span> <span class="n">idc</span><span class="p">.</span><span class="n">get_segm_end</span><span class="p">(</span><span class="n">seg</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">search_N_patch</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">patch</span><span class="p">):</span>
    <span class="n">search_range</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">search_range</span> <span class="o">=</span> <span class="n">get_text_section</span><span class="p">()</span>

    <span class="n">flag</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">while</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>															<span class="c1"># The value 16 is the default.
</span>        <span class="n">addr</span> <span class="o">=</span> <span class="n">ida_search</span><span class="p">.</span><span class="n">find_binary</span><span class="p">(</span><span class="n">search_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">search_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pattern</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">ida_search</span><span class="p">.</span><span class="n">SEARCH_DOWN</span><span class="p">)</span>
		
        <span class="n">idc</span><span class="p">.</span><span class="n">patch_word</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="n">patch</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="n">ida_idaapi</span><span class="p">.</span><span class="n">BADADDR</span> <span class="ow">or</span> <span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">search_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="bp">False</span>

<span class="n">pattern</span> <span class="o">=</span> <span class="s">'cc c3'</span>   <span class="c1"># int 3  ret
</span><span class="n">patch</span> <span class="o">=</span> <span class="mh">0xd0ff</span>     <span class="c1"># call eax (Little Endian)
</span>
<span class="n">search_N_patch</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span><span class="n">patch</span><span class="p">)</span>
</code></pre></div></div>

<p>PS: This script only alters the IDA database and not the actual binary. To patch the sample in order to open it in a debugger, use the <code class="language-plaintext highlighter-rouge">pefile</code> python library instead.</p>

<p>Now, using hashdb as well as our IDA Python script, we have a better chance to understand Dridex functionality. First, we edit the data types of the <code class="language-plaintext highlighter-rouge">mw_API_Resolver</code> arguments to be <code class="language-plaintext highlighter-rouge">hashdb_strings_crc32</code> enum instead of integers. This in order to make IDA Pro automatically resolve the hashes, Secondly, we use IDA Pro Xrefs to know which API is being resolved at any particular location.</p>

<h2 id="strings-decryption">Strings Decryption</h2>

<p>Dridex contains a lot of malicious functionality. From simple host profiling up to DLL hijacking, there are a lot to cover when reversing Dridex. I will not dive deeply into all of its functionality, I will rather focus on the interesting parts only. To get the most of its intentions, you need to decrypt all the embedded strings. They are stored on the <code class="language-plaintext highlighter-rouge">.rdata</code> section in chunks. These strings are used as parameters with the resolved APIs to perform certain malicious impact.</p>

<p><a href="/assets/images/malware-analysis/Dridex/8.png"><img src="/assets/images/malware-analysis/Dridex/8.png" alt="" /></a></p>
<center><font size="3"> <u>Figure</u>(8): <u>The key is initialized in the KSA part of the RC4. Check the wiki page.</u> </font></center>

<p><br />
We can use the amazing <a href="https://github.com/mandiant/capa">capa</a> tool from Mandiant to find out if it can detect any encryption algorithms. Fortunately, capa was able to identify <a href="https://en.wikipedia.org/wiki/RC4">RC4</a> is being used at <code class="language-plaintext highlighter-rouge">sub_61E5D0</code>. Also, from capa’s output, we can detect the operation: “key modulo its length” at the address <code class="language-plaintext highlighter-rouge">0x61E657</code>.</p>

<p><a href="/assets/images/malware-analysis/Dridex/9.png"><img src="/assets/images/malware-analysis/Dridex/9.png" alt="" /></a></p>
<center><font size="3"> <u>Figure</u>(9): <u>The first renamed function just copies memory from certain source to defined destination.</u> </font></center>

<p><br />
From here, we can trace the Xrefs to <code class="language-plaintext highlighter-rouge">sub_61E5D0</code> to find out where the key is located and what is the key length. Taking the last Xref, at <code class="language-plaintext highlighter-rouge">sub_607B30</code>, we can trace back the function arguments to find that the key is loaded from a certain offset at the <code class="language-plaintext highlighter-rouge">.rdata</code> section. The key length is 40 bytes and the data to decrypted starts after the key. As a consequence, we can deduce that for every chunk of data, their decryption key is the first 40 bytes then followed by the encrypted data. Also from other threat intel resources, we can know that Dridex stores the decryption key bytes in a reverse order.</p>

<p><a href="/assets/images/malware-analysis/Dridex/10.png"><img src="/assets/images/malware-analysis/Dridex/10.png" alt="" /></a></p>
<center><font size="3"> <u>Figure</u>(10): <u>It's always a good habit to quickly test decryption using CyberChef before developing scripts.</u> </font></center>

<p><br />
Let’s try to use CyberChef to manually decrypt the data at the address <code class="language-plaintext highlighter-rouge">0X629BC0</code>. The key starts at <code class="language-plaintext highlighter-rouge">0X629BC0</code> with a length of 40 bytes in a reverse order. The encrypted data starts at <code class="language-plaintext highlighter-rouge">0X629BE8</code>. We can see the fully decrypted strings clearly now. The first two words are “Program Manager”. That’s why I didn’t prefer to reverse all of Dridex functionality. The more important is to find out how the decryption is happening and then you can decipher any code snippets. From this point, you can try yourself to decrypt every chunk of data and find out how they are being used for every malicious impact.</p>

<h2 id="extracting-cc-configuration">Extracting C&amp;C Configuration</h2>

<p>Dridex of course tries to connect with its threat actor. It’s a must to find these remote ends in order to block them and cut out the lines between the malware operators and the infected machines. One way to find out the C&amp;C servers, is to look for where networking functions are being called. From Xrefs to <code class="language-plaintext highlighter-rouge">mw_API_Resolver</code>, we can find that there are two important functions which are responsible for networking functionality; <code class="language-plaintext highlighter-rouge">sub_623370</code> and <code class="language-plaintext highlighter-rouge">sub_623820</code>. At <code class="language-plaintext highlighter-rouge">sub_623820</code>, it seems that it is used for further download activity, because it’s resolving the <code class="language-plaintext highlighter-rouge">InternetReadFile</code> API. Inside <code class="language-plaintext highlighter-rouge">sub_623370</code>, we can see Dridex is resolving <code class="language-plaintext highlighter-rouge">InternetConnectW</code> API which accepts the <code class="language-plaintext highlighter-rouge">lpszServerName</code> parameter. This parameter identifies the remote end to where the connection is happening.</p>

<p><a href="/assets/images/malware-analysis/Dridex/11.png"><img src="/assets/images/malware-analysis/Dridex/11.png" alt="" /></a></p>
<center><font size="3"> <u>Figure</u>(11): <u>This chuck of code is a little before the Xref.</u> </font></center>

<p><br />
Tracing the only Xref to <code class="language-plaintext highlighter-rouge">sub_623370</code>, we can spot Dridex parsing a data offset to extract the embedded IPs. This is at the address <code class="language-plaintext highlighter-rouge">0X5F7232</code> just a little before the call to <code class="language-plaintext highlighter-rouge">sub_623370</code>.</p>

<p><a href="/assets/images/malware-analysis/Dridex/12.png"><img src="/assets/images/malware-analysis/Dridex/12.png" alt="" /></a></p>
<center><font size="3"> <u>Figure</u>(12): <u>This pattern is repeated starting from (c2_array)  to store the whole 4 IPs and their associated ports.</u> </font></center>

<p><br />
The network configuration is not encrypted. Starting at offset <code class="language-plaintext highlighter-rouge">0X62B024</code>. The ports can be converted via simple hex to decimal conversion. Yet, for the IPs we can use this small Python script to convert them into a human-readable format:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">struct</span>

<span class="k">def</span> <span class="nf">int2ip</span><span class="p">(</span><span class="n">addr</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">socket</span><span class="p">.</span><span class="n">inet_ntoa</span><span class="p">(</span><span class="n">struct</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="s">"!I"</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="n">int2ip</span><span class="p">(</span><span class="mh">0xC02ED2DC</span><span class="p">))</span> <span class="c1"># First IP
</span></code></pre></div></div>

<p>The extracted C&amp;C IPs are below:</p>

<table>
  <thead>
    <tr>
      <th>No</th>
      <th>IP Address : Port Number</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>192.46.210.220:443</td>
    </tr>
    <tr>
      <td>2</td>
      <td>143.244.140.214:808</td>
    </tr>
    <tr>
      <td>3</td>
      <td>45.77.0.96:6891</td>
    </tr>
    <tr>
      <td>4</td>
      <td>185.56.219.47:8116</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h1 id="conclusion">Conclusion</h1>

<p>The techniques of Dridex are somehow unique when combined together. We can easily defeat API hashing once we know the hashing algorithm and the XOR key. The use of VEH makes the reverse engineering process very painful and needs urgent patching. Dridex has a lot of capabilities and techniques, I’ve decided to rather focus on defeating anti-analysis and strings decryption. From there, you are able to identify any of its intentions.</p>

<p><br /></p>

<h1 id="iocs">IoCs</h1>

<table>
  <thead>
    <tr>
      <th>No</th>
      <th>Description</th>
      <th>Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Unpacked Sample Hash</td>
      <td>F9495E968F9A1610C0CF9383053E5B5696ECC85CA3CA2A338C24C7204CC93881</td>
    </tr>
    <tr>
      <td>2</td>
      <td>1st C2</td>
      <td>192.46.210.220:443</td>
    </tr>
    <tr>
      <td>3</td>
      <td>2nd C2</td>
      <td>143.244.140.214:808</td>
    </tr>
    <tr>
      <td>4</td>
      <td>3rd C2</td>
      <td>45.77.0.96:6891</td>
    </tr>
    <tr>
      <td>5</td>
      <td>4th C2</td>
      <td>185.56.219.47:8116</td>
    </tr>
    <tr>
      <td>6</td>
      <td>Botnet ID</td>
      <td>10444</td>
    </tr>
  </tbody>
</table>

<p><br /></p>
<h1 id="refrences">Refrences</h1>

<ul>
  <li><a href="https://www.0ffset.net/reverse-engineering/malware-analysis/dridex-veh-api-obfuscation/">https://www.0ffset.net/reverse-engineering/malware-analysis/dridex-veh-api-obfuscation/</a></li>
  <li><a href="https://www.appgate.com/blog/reverse-engineering-dridex-and-automating-ioc-extraction">https://www.appgate.com/blog/reverse-engineering-dridex-and-automating-ioc-extraction</a></li>
  <li><a href="https://blog.lexfo.fr/dridex-malware.html">https://blog.lexfo.fr/dridex-malware.html</a></li>
</ul>

        
      </section>

      <footer class="page__meta">
        
        


  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/#malware-analysis" class="page__taxonomy-item" rel="tag">Malware Analysis</a>
    
    </span>
  </p>


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2021-11-21T00:00:00+00:00">November 21, 2021</time></p>
        
      </footer>

      

      
  <nav class="pagination">
    
      <a href="/malware%20analysis/redline/" class="pagination--pager" title="RedLine Infostealer
">Previous</a>
    
    
      <a href="#" class="pagination--pager disabled">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2021 Nidal Fikri. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://kit.fontawesome.com/4eee35f757.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <script>
  window.ga=function(){ga.q.push(arguments)};ga.q=[];ga.l=+new Date;
  ga('create','UA-207369386-2','auto');
  ga('set', 'anonymizeIp', false);
  ga('send','pageview')
</script>
<script src="https://www.google-analytics.com/analytics.js" async></script>









  </body>
</html>
