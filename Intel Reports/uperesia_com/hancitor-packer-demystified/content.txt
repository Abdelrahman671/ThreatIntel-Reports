Error: INSERT INTO `STATS_uperesia` ( `ID` , `ip` , `useragent` , `hostname` , `country`, `referer`, `time`, `pagename`, `visitorID`) VALUES ('', '***.***.***.***', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36', '200-149-184-120.user3p.veloxzone.com.br' , 'BR', 'none', '1734493006', 'hancitor', 'K4V7WcpU1qfm0uYfHgydAjDhq1QOCaXjFJQwFgYxhNulATjFSlsKgmXhCyRqc7lBWghRaFFESNjtaxz7hKAAwy7roiClxKNfzZsPlPZJBfDMqG6B3AfbLAcjuB4piO6ZG')<br><strong>Error:</strong>INSERT command denied to user 'uperesiadsdb'@'10.23.20.89' for table 'STATS_uperesia'<html>
    <head>
        <title>Hancitor's packer demystified</title>
        <meta charset="utf-8">
        <meta name="description" property="og:description" content="Post about reverse-engineering a packer which has been used in the past year by the Hancitor malware family to evade security detection. The packer can also be linked to many other financially motivated attacks in the past.">
        <meta name="keywords" content="hancitor, chanitor, packer, unpacking, spaghetti code, shellcode, control flow obfuscation, import table reconstruction, reflective PE loading, YARA"/>
        <meta name="author" content="Felix Weyne" />
        <meta name="title" property="og:title" content="Hancitor's packer demystified" />
        <meta property="og:image" content="https://www.uperesia.com/img/previews/hancitor_prvw.png" />
        <link rel="shortcut icon" href="favicon.ico" />
        <link rel="stylesheet" href="lightbox/css/lightbox.css" type="text/css" media="screen">
        <link rel="stylesheet" href="css/style.css" type="text/css" media="screen">
        <style type="text/css">
            p.uitlijnen {
                text-align: justify;
            }
			
			a.modLnk {
					font-family: Consolas,monaco,monospace; 
			}
			
			.modName {
				    border-bottom: 1px dashed #000;
					font-family: Consolas,monaco,monospace; 
			}
			
			.asm {
				    border: 1px solid #000000;
					font-family: Consolas,monaco,monospace; 
					background-color: #e7e7e7;
			
					padding:1px; 

			}
			
			ul.mylist {
				margin-left:20px;
			}
			
			.verticaltext {

		    -ms-writing-mode: tb-rl;
    -webkit-writing-mode: vertical-rl;
    -moz-writing-mode: vertical-rl;
    -ms-writing-mode: vertical-rl;
    writing-mode: vertical-rl;

    /* only currently works in Blink/WebKit */
    -webkit-text-orientation: upright;
    -moz-text-orientation: upright;
    -ms-text-orientation: upright;
    text-orientation: upright;

    /* only currently works in IE11 */
   -webkit-text-combine-horizontal: digits;
   -moz-text-combine-horizontal: digits;
   -ms-text-combine-horizontal: digits;
   text-combine-horizontal: digits;

				color: #ed217c;
				float:left;
				width:30px;
				height:370px;
				text-align: center;
				background-color: lightblue;
				padding-right:10px;
				
			}

        </style>
    </head>
    <body>
        <!-- WRAPPER -->
        <div id="wrapper">
            <!-- SIDEBAR -->
            <div id="sidebar">
                <!-- logo -->
                <a href="index.php"><img src="img/template/logo.png" alt="" id="logo"></a>
                <!-- Navigation -->
                <ul id="nav" class="sf-menu sf-vertical">
                     <li><a href="/">HOME</a></li><li><a href="https://sourceforge.net/projects/khoorio/" target="_blank">KHOORIO</a></li><li><a href="https://github.com/felixweyne/imaginaryC2/" target="_blank">IMAGINARY C2</a></li><li><a href="https://github.com/felixweyne/ProcessSpawnControl" target="_blank">PROCESS SPAWN CONTROL</a></li><li><a href="contact">CONTACT</a></li></ul><div style='padding-left: 22px;'><h6>Blogs:</h6></div><ul id='nav' class='sf-menu sf-vertical'><li class="current-menu-item"><a href="hancitor-packer-demystified">HANCITOR'S PACKER</a></li><li><a href="how-trickbot-tricks-its-victims">TRICKBOT'S WEBINJECTS</a></li><li><a href="malicious-dropper-as-an-attack-vector">ATTACK VECTORS</a></li><li><a href="booby-trapped-shortcut">BOOBY TRAPPED SHORTCUT <img width="12" src="img/mini-icon/hot.png"></a></li><li><a href="inside-the-necurs-botnet">INSIDE THE NECURS BOTNET</a></li><li><a href="buffer-overflow-explained">BUFFER OVERFLOW 101</a></li><li><a href="analyzing-rig-exploit-kit">RIG EK ANALYSIS</a></li><li><a href="threat-hunting">THREAT HUNTING</a> </li><li><a href="analyzing-malicious-office-documents">MALDOC ANALYSIS <img width="12" src="img/mini-icon/hot.png"></a></a></li><li><a href="analysis-of-a-packed-pony-downloader">PACKED PONY ANALYSIS</a></li><li><a href="deobfuscating-a-locky-dropper">LOCKY DROPPER ANALYSIS</a></li><li><a href="angler-wordpress-backdoor">ANGLER EK ANALYSIS (2)</a></li><li><a href="a-closer-look-to-fileless-click-fraud-malware-poweliks">POWELIKS ANALYSIS</a></li><li><a href="reverse-engineering-tinder">REV. ENGINEERING TINDER <img width="12" src="img/mini-icon/hot.png"></a></a></li><li><a href="jrat-inside-a-honeypot">JRAT ANALYSIS</a></li><li><a href="dridex-a-modern-bank-robber">DRIDEX ANALYSIS</a></li><li><a href="angler-top-three-facts">ANGLER EK ANALYSIS (1)</a></li><li><a href="pgp-explained">PGP EXPLAINED</a></li>                </ul>
                <!-- Navigation -->
            </div>
            <!-- ENDS SIDEBAR -->
            <!-- MAIN -->
            <div id="main">
                
                <!-- CONTENT -->
                <div id="content">
                    <!-- PAGE CONTENT -->
                    <div id="page-content">
						<br>
						<p>
						<img width="600" src="img/articles/hancitor/hancitor_packer_header.png"><br> 
						<img width="14" src="img/mini-icon/time.png"> 
						Posted by Felix Weyne, May 2019.						<br><img width="14" src="img/mini-icon/world.png"> Author contact: <a target='_blank' href='referer.php?id=twitter'>Twitter</a> | <a target='_blank' href='referer.php?id=linkedin'>LinkedIn 						<br><img width="14" src="img/mini-icon/tag.png"> Tags: <a href ="#">Hancitor</a>, <a href ="#">Chanitor</a>, <a href ="#">packer</a>, <a href ="#">unpacking</a>, <a href ="#">spaghetti code</a>, <a href ="#">shellcode</a>,  <a href ="#">control flow obfuscation</a>, <a href ="#">import table reconstruction</a>, <a href ="#">reflective PE loading</a>, <a href ="#">YARA</a>
						</p>


						<p class="uitlijnen">
						It has been a while since I have written a blog - I have been working on <a href='https://github.com/felixweyne/' target="_blank">some tools</a> and other projects instead - so I decided to have another go at it <img width="16" src="img/smiley/smiley-fun.png">. A while ago, the Twitter users <a href='https://0ffset.net/reverse-engineering/malware-analysis/reversing-hancitor-again/'  target="_blank">0verfl0w_</a> and <a href='https://www.vkremez.com/2018/11/lets-learn-in-depth-reversing-of.html'  target="_blank">Vitali</a> published some nice blogs on the Hancitor malware.
						This made me curious to also have a look at the malware family. <br><br>

						The Hancitor malware family has been around for a while and its core job is to download and execute additional malware. In order to succeed at its job, the malware must succeed in being run undetected on the machine and thus effectively stay under the radar of security software such as an antivirus. 
						One of Hancitor's endeavors to bypass antivirus is by making use of a booby trapped Office document and to instruct Office to inject the Hancitor binary in a legitimate Windows process. This method has been documented well by the <a href='https://airbus-cyber-security.com/analysing-hancitor-maldoc/'  target="_blank">Airbus security team</a> and has been used untill approximately the summer of 2018. 
						Around that time, the Hancitor crew has shifted its infection mechanism by making their spammed Office documents download a packed executable to disk. An executable written to disk usually gets inspected/scanned by antivirus, yet the Hancitor malware has been reasonably successful in evading being detected (initially) as malicious. <br><br>

						Hancitor's evasive success can be partly attributed to the packer/crypter being used. <strong>In this blog I will do a (technical) deep dive into Hancitor's packer, which has not changed much since the summer of 2018. I will discuss how the packer protects its payload and how it tries to thwart analysis. At the end of this blog, I'll demonstrate how this packer has also been used by many other malware families in the past.</strong>
						</p>
						
 
						<h6>The packer</h6>
						<br>

						<p class="uitlijnen">
						The below image gives an overview of the <a target='_blank' href='https://www.virustotal.com/#/file/e4ad65ade2f04e05a886b398ef08261f5858b15cc822ef29b604cecaac3036b5/detection'>sample</a> which I'll discuss in this blog. Although I will be discussing a specific packed Hancitor sample, the information in this blog is applicable to many other packed Hancitor samples, as the packer has not changed much between the many SPAM campaigns (particularly the first layer of the packer has been very consistent). In <a href='resources/hancitor_packer_samples.zip'>this archive</a> (password=infected) a collection of many packed Hancitor samples can be found (many thanks to <a target='_blank' href='https://twitter.com/malware_traffic'>Brad</a> and <a target='_blank' href='https://twitter.com/James_inthe_box'>James</a> for sharing the samples on Twitter!).
						</p>

						<p>
						<a href="img/articles/hancitor/hancitor_packer_overview.png" data-lightbox="hancitorPacker" data-title="Image one: Overview of the packed Hancitor sample">
						<img src="img/articles/hancitor/hancitor_packer_overview.png"  width="500" style="border:3px solid black"></a><br> Image one: Overview of the packed Hancitor sample
						</p>
						
						<p class="uitlijnen">
						<strong>In order to keep the analysis organized, I have a divided the packed sample into "modules" (pieces) based on functionality. For each module I have added the address of the first and last relevant assembly instruction, such that interested readers can use this blog as a reference when unpacking the sample themselves in a debugger.</strong> For those who are interested in the disassembled code, but don't want to plow through the entire sample in a debugger, I have added a commented assembly output per module. Lastly, for the malware hunters among us, I have added a YARA rule for the packer in the blog's addendum. 
						</p>
						
						<p><ul class='myList'>
						<li>Module 0: <a target='_blank' href='resources/packer_module0.html'>link to commented disassembled code</a> (start address: 0x0040266D)</li>
						<li>Module 1: <a target='_blank' href='resources/packer_module1.html'>link to commented disassembled code</a> (start address: 0X00405177)</li>
						<li>Module 2: <a target='_blank' href='resources/packer_module2.html'>link to commented disassembled code</a> (start address: 0X004087A1)</li>
						<li>Module 3: <a target='_blank' href='resources/packer_module3.html'>link to commented disassembled code</a> (start address: start_mem_region+0x3E4)</li>
						<li>Module 4: <a target='_blank' href='resources/packer_module4.html'>link to commented disassembled code</a> (start address: 0X004015F0)</li>
						<li>Module 5: <a target='_blank' href='resources/packer_module5.html'>link to commented disassembled code</a> (start address: 0X00401520)</li>
						<li>Module 6: <a target='_blank' href='resources/packer_module6.html'>link to commented disassembled code</a> (start address: start_mem_region+0x2BF0)</li>
						</ul></p>
						
						<h6>Spaghetti code</h6>
						<br>

						
						<p class="uitlijnen">
						The packed Hancitor executables always start by executing random, non-dodgy functions. We will define this code region as <span class='modName'>module zero</span> (<a class='modLnk' target='_blank' href='resources/packer_module0.html'>disassembled code</a>). Putting random code near the executables' entrypoint makes them look unique, that is to say, for security products which (understandably) only parse/emulate executables partially because of performance reasons. 
						The random code ends by jumping to the next module, <span class='modName'>module one</span> (<a class='modLnk' target='_blank' href='resources/packer_module1.html'>disassembled code</a>). 
						</p>
						
						<p class="uitlijnen">
						The disassembled output of the <span class='modName'>module one</span> section is hard to interpret. <strong>The packer's author has broken the linear sequence of assembly instructions by reordering the instructions and connecting them to each other via JUMP instructions, as can be seen in image two. Additionally, between each instruction random instructions -&nbsp;which will never be executed&nbsp;- are placed.</strong>
						</p>
						
						<p>
						<a href="img/articles/hancitor/hancitor_packer_spaghetti_code.gif" data-lightbox="hancitorPacker" data-title="Image two: Spaghetti code which decrypts the next module">
						<img src="img/articles/hancitor/hancitor_packer_spaghetti_code.gif"  width="600" style="border:3px solid black"></a><br> Image two: Spaghetti code which decrypts the next module
						</p>
						
						<p class="uitlijnen">
						This technique, known as spaghetti code, bypasses static detection techniques which rely on the malicious instructions being placed consecutively on each other.
						The goal of the spaghetti code is to change the memory protection of a part of the executable (to which we will referrer as <span class='modName'>module two</span>) and then to decrypt said part via a simple XOR loop. Once the relevant part is decrypted, the code execution is transferred  to that part via a simple <span class="asm">JMP EAX</span> instruction.
						</span>

						
						<h6>Resolving APIs</h6>
						<br>						
						<p class="uitlijnen">
						<span class='modName'>Module two</span> (<a class='modLnk' target='_blank' href='resources/packer_module2.html'>disassembled code</a>) has three tasks: resolve the addresses of APIs which will be used in the next module, map itself and the next module in a newly allocated memory region and hunt for the start of the next module in the new memory region (delimited by the <span class="asm">70C5BA88</span> byte marker). 
						</p>
						
						<p class="uitlijnen">
						I will not discuss how the API addresses are resolved, as the packer will use a similar technique in a later module, at which point I'll discuss the technique in depth (see paragraph: reconstruct import table). 
						The most important part of the API resolving code is the list of APIs which are resolved:</p>
						
						<p><ul class='myList'>
						<li>kernel32_GetProcAddress</li>
						<li>kernel32_GetModuleHandleA</li>
						<li>kernel32_LoadLibraryA</li>
						<li>kernel32_VirtualAlloc</li>
						<li>kernel32_VirtualFree</li>
						<li>kernel32_OutputDebugStringA</li>
						<li>ntdll_memset</li>
						<li>ntdll_memcpy</li>
						</ul></p>
						
						<p class="uitlijnen">
						The APIs in the list will be used to map DLLs into the packer's process memory, to resolve additional API addresses and to allocate and free memory regions. <strong>The thing in <span class='modName'>module two</span> that stands out the most is the way (API) strings are embedded inline with the assembly code, as can be seen on image three.</strong> 
						</p>


						<p>
						<a href="img/articles/hancitor/hancitor_packer_data_inline_with_assembly.png" data-lightbox="hancitorPacker" data-title="Image three: Data (API names) inline with the assembly code">
						<img src="img/articles/hancitor/hancitor_packer_data_inline_with_assembly.png"  width="500" style="border:3px solid black"></a><br> Image three: Data (API names) inline with the assembly code
						</p>
						
						
						<p class="uitlijnen">
						Most compilers will place strings in a region which is different from the region where the assembly code resides. <strong>To get the memory address of the inline string, the assembly code makes use of a simple trick: it will execute a <span class="asm">CALL $+5</span> instruction (a procedure call where the destination is the subsequent instruction).</strong> 
						</p>
						<p class="uitlijnen">
						Executing a <span class="asm">CALL</span> instruction will result in the return address (i.e. the address of the instruction that follows the call instruction) being pushed on the stack. 
						The return address is immediately retrieved by executing a <span class="asm">POP EAX</span> instruction (pop the top of the stack into the EAX register). The return address is thus pointing to the location of the <span class="asm">POP</span> instruction. Because the assembly is interested in the start address of the inline placed string, three bytes needs to be added to return address (skip the <span class="asm">POP</span> and <span class="asm">JMP short</span> instructions).  We can see the assembly code performing this action as follows: <span class="asm">ADD EAX, 3</span>.
						It is useful to remember this little trick in your short-term memory, because it will also be used in the next module.
						</p>



						<h6>Decrypt next layer</h6>
						<br>
					
						<p class="uitlijnen">
						<span class='modName'>Module three</span> (<a class='modLnk' target='_blank' href='resources/packer_module3.html'>disassembled code</a>) starts by overwriting code at three locations, as can be seen on image four. These locations correspond with the packed executable's entrypoint (<span class='modName'>module zero</span>), the start of the spaghetti code (<span class='modName'>module one</span>) and the start of <span class='modName'>module two</span> (the addresses are described on image one). 
						</span>

						<p>
						<a href="img/articles/hancitor/hancitor_packer_overwrite_previous_layer.png" data-lightbox="hancitorPacker" data-title="Image four: Overwriting three previous modules">
						<img src="img/articles/hancitor/hancitor_packer_overwrite_previous_layer.png"  width="600" style="border:3px solid black"></a><br> Image four: Overwriting three previous modules
						</p>
						
						<p class="uitlijnen">
						The code then continues by decrypting the next layer (the next modules), by making use of the APIs listed in the previous paragraph. Once the next layer has been decrypted, the module resolves the addresses of the APIs which will be used in the next layer (image five), to which we will refer as <span class='modName'>layer two</span>.
						</p>
						

						<p>
						<a href="img/articles/hancitor/hancitor_packer_resolved_API.png" data-lightbox="hancitorPacker" data-title="Image five: addresses of resolved APIs in memory">
						<img src="img/articles/hancitor/hancitor_packer_resolved_API.png"  width="500" style="border:3px solid black"></a><br> Image five: addresses of resolved APIs in memory
						</p>
						
						<p class="uitlijnen">
						After having resolved the API addresses, the code does something somewhat odd: it patches values in the PE header and it overwrites the section header. This action doesn't make much sense to me, because I believe these values are of no use once the executable has been mapped into memory <img width='16' src='img/smiley/smiley-thinking.png'>? Nevertheless, this action helps us in our efforts to dump the second layer executable from memory, as it seems like we have the correct PE header as well as the decrypted code.
						</span>
						
						<p>
						<a href="img/articles/hancitor/hancitor_packer_section_header.png" data-lightbox="hancitorPacker" data-title="Image six: overwriting section headers bug">
						<img src="img/articles/hancitor/hancitor_packer_section_header.png"  width="600" style="border:3px solid black"></a><br> Image six: overwriting section headers bug
						</p>
						
						<p class="uitlijnen">
						Upon inspecting the dumped <span class='modName'>second layer</span> executable, I noticed that the section headers were shifted. 
						<strong>When we look at the code responsible for overwriting the section headers, we can notice an interesting bug in the packer.</strong> Remember the inline data trick I discussed in the previous paragraph? It looks like the packer's author made a small mistake while using it to overwrite the section header  <img width='16' src='img/smiley/smiley-humor-amazed.png'>. 
						</p>
						
						<p class="uitlijnen">
						Because the <span class="asm">JMP</span> instruction following the <span class="asm">POP EAX</span> instruction in <span class='modName'>module three</span> consists of five bytes (it consisted of only three bytes in <span class='modName'>module two</span>), the start address of the section header data is off by three bytes (image six). 
						Instead of adding three bytes to the EAX register, the code should've added six bytes. If we correct this mistake while debugging, we get a correct dump of <span class='modName'>layer two</span> (which I have added <a href='resources/hancitor_packer_samples.zip'>here</a>).
						</p>
						
						
						<p class="uitlijnen">
						<span class='modName'>Module three</span> ends by destroying its own code. The destruction is performed via a simple loop which overwrites every address in the module with zero valued bytes (image seven). 
						</p>
						
						<p>
						<a href="img/articles/hancitor/hancitor_packer_self_destruction.gif" data-lightbox="hancitorPacker" data-title="Image seven: self destruction code in action (as seen via IDA debugger)">
						<img src="img/articles/hancitor/hancitor_packer_self_destruction.gif"  width="450" style="border:3px solid black"></a><br> Image seven: self destruction code in action (as seen via IDA debugger)
						</p>
						
						<p class="uitlijnen">
						Given the fact that the module is mapped in a newly allocated memory region (image one), one can only guess why the packer's author didn't just free the region. 
						Maybe (s)he wanted to avoid analysis techniques which dump code by hooking VirtualFree calls? Maybe (s)he wanted to keep the modules nicely separated (VirtualFree can not be called before execution is transferred  to another region/module, as a VirtualFree call would destroy the code responsible for said execution transferring)? 
						After destroying everything, a jump is made to the entrypoint of the <span class='modName'>second layer</span> executable, to which I will refer as <span class='modName'>module four</span>.
						</p>
						
						<h6>Decrypt Hancitor binary</h6>
						<br>
						
						<p class="uitlijnen">
						<span class='modName'>Module four</span> (<a class='modLnk' target='_blank' href='resources/packer_module4.html'>disassembled code</a>) contains a debug-thwarting trick which can be confusing if you are not aware of what is happening. The module makes use of a technique called control flow obfuscation. 
						<strong>The goal of the trick is to make use of a Windows API call in such a way that the main code flow does not continue on the code following the API call. Instead the main code flow is transferred  to a callback function which is executed during the API call. 
						If you are not aware of this trick, you would probably jump over each instruction in <span class='modName'>module four</span> which would result in loosing control over the execution, since no debugger points are set in the registered callback function.</strong> 
						Image eight shows how the Hancitor packer makes use of this technique.
						</span>

						<p>
						<a href="img/articles/hancitor/hancitor_packer_control_flow_obfuscation.png" data-lightbox="hancitorPacker" data-title="Image eight: Control flow obfuscation by making use of Window Procedures (RegisterClassExA + CreateWindowExA)">
						<img src="img/articles/hancitor/hancitor_packer_control_flow_obfuscation.png"  width="600" style="border:3px solid black"></a><br> Image eight: Control flow obfuscation by making use of Window Procedures (RegisterClassExA &amp; CreateWindowExA)
						</p>
						
						<p class="uitlijnen">
						The callback function is registered as part of a <a target='_blank' href='https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-tagwndclassexa'>Windows Class Ex structure</a>, which is passed as an argument to the <span class="asm">RegisterClassExA</span> API call. When a call is made to the <span class="asm">DispatchMessageA</span> API, the callback function gets executed. The callback function contains a jump to the fifth module.
						</p>
						
						<p class="uitlijnen">
						<span class='modName'>Module five</span> (<a class='modLnk' target='_blank' href='resources/packer_module5.html'>disassembled code</a>) does not contain many interesting functions. The most important function is a function which decrypts and decompresses the Hancitor executable 
						(if you are still reading at this point, you probably wondered when we would ever get to this stage <img width="16" src="img/smiley/smiley-fun.png">). The encrypted executable is stored as data inside <span class='modName'>layer two</span>, the decryption is performed by three simple XOR loops, as can be seen on the decompiled function code on image nine. 
						</span>
						
						<p>
						<a href="img/articles/hancitor/hancitor_packer_decryption.png" data-lightbox="hancitorPacker" data-title="Image nine: decompiled decryption code">
						<img src="img/articles/hancitor/hancitor_packer_decryption.png"  width="450" style="border:3px solid black"></a><br> Image nine: decompiled decryption code
						</p>
						
						<p class="uitlijnen">
						The decompression is performed via a function call to <span class="asm">RtlDecompressBuffer</span> (note that the address of this API was resolved in <span class='modName'>module three</span>, the puzzle pieces are starting to come together!). The decrypted executable is mapped into a newly allocated memory region, to which we will refer to as <span class='modName'>module six</span>.
						</p>
						
						
						<h6>Reconstruct import table</h6>
						<br>
						<p class="uitlijnen">
						<span class='modName'>Module six</span> (<a class='modLnk' target='_blank' href='resources/packer_module6.html'>disassembled code</a>) contains the last functionality of the packer. <strong>The goal of the module is to emulate behavior which normally is performed by the Windows Loader: map libraries (DLLs) into the process' address space, resolve the addresses of APIs and store those addresses in the executable's <span class="asm">Import Address Table (IAT)</span>. </strong>
						This behavior needs to be emulated by the packer because it has loaded the Hancitor executable directly into memory. If the Hancitor executable were to have been loaded from disk, the Windows Loader would have done its job. Obviously, loading the malware from disk is not feasible, as it would be detected quickly by security products. 
						Code similar to the code in this module is frequently present in malware and greyhat tools which load an executable reflectively. As the reader will notice, the reverse engineered code discussed below for example looks very similar to a <a href='https://github.com/gbrindisi/malware/blob/667b44f64edcd1c5e8c42489b8e767813a589158/windows/gozi-isfb/AcDll/stubs.c#L30-L132' target='_blank'>leaked Gozi/IFSB code part</a> (<a href='img/articles/hancitor/gozi_github.png' target='_blank'>mirror</a>) which is described by the author as: 'a routine used to create, initialize and execute [a] PE-image without a file'.
						</span>
						
						<!--<div>
						<div class='verticaltext'>Import Tables</div>
						<div style='overflow: hidden;'>
						<p class="uitlijnen"> dsqfsf</p>
						</div> -->
						<p class="uitlijnen" style="margin-left:20px; padding-left:5px;  border-left: 5px solid grey;">
						I am <i>not</i> a suitable person to write referral material about PE structures <img width="16" src="img/smiley/smiley-silent.png">. However, for the sake of giving some background information on the actions which are performed in <span class='modName'>module six</span>, I'll try to briefly write down some pointers about the PE's import tables.<br><br>
						
						The IAT is a table of pointers to function (API) addresses which is used as a lookup table when an application is calling a function. The addresses of functions inside a library (DLL) are not static but change when updated versions of the DLL are released, so applications cannot be built using hardcoded function addresses. In order for the Windows Loader to know which libraries and functions it needs to import, they obviously need to be defined inside the executable. 
						This is where the <span class="asm">Import Directory Table (IDT)</span> comes into play. <br><br>
						
						
						The IDT contains structures which contain information about a DLL which a PE file imports functions from. Two important fields in those structures are <span class="asm">FirstThunk</span>: a relative virtual address (RVA) inside the IAT, and <span class="asm">OriginalFirstThunk</span>: a RVA of the <span class="asm">Import Lookup Table (ILT)</span>. The Import Lookup Table contains an array of RVAs, each RVA points to a <span class="asm">hint/name table</span>
						(source: <a href='https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format' target='_blank'>PE format, Microsoft</a>). As the name suggests, the hint/name table contains the name of a function which needs to be imported.
						</p>
						
						
						
						<p class="uitlijnen">
						<span class='modName'>Module six</span> starts by calculating the in-memory start address of the <span class="asm">Import Directory Table</span>. It calculates said address by parsing the PE header of the in-memory mapped Hancitor executable, as can be seen on image ten. 
						First, the executable searches for the start offset of the PE header, a value which is stored at the <span class="asm">e_lfanew field</span> (ref: <a href='https://www.aldeid.com/wiki/PE-Portable-executable' target='_blank'>PE offsets</a>). The module then jumps to a certain offset from the start of the PE header to locate a field whose value contains the RVA of the Import Directory. 
						Because this value is a <i>relative</i> offset, the value needs to be added to the in-memory start of the mapped executable. This resulting calculation contains the in-memory start of the <span class="asm">Import Directory Table</span>. 
                       
					

						<p>
						<a href="img/articles/hancitor/hancitor_packer_parse_pe_header.png" data-lightbox="hancitorPacker" data-title="Image ten: Resolve address of kernelbase + find address of import directory table ">
						<img src="img/articles/hancitor/hancitor_packer_parse_pe_header.png"  width="600" style="border:3px solid black"></a><br> Image ten: Resolve address of kernelbase &amp; find address of import directory table 
						</p>
						
						
						<p class="uitlijnen">
						For <span class='modName'>module six</span> to be able to map libraries (used by Hancitor) into the process' address space, it needs the memory location of kernel32's <span class="asm">LoadLibrary</span> and <span class="asm">GetProcAddress</span> functions. To retrieve the function addresses, the packer needs to figure out at which address (inside its own process address space) the kernel32 library is mapped. 
						For this hunt the packer relies on a small piece of shellcode which reads the <span class="asm">Process Environment Block</span> (PEB). The below slide from a <a href='https://www.blackhat.com/presentations/bh-asia-03/bh-asia-03-chong.pdf' target='_blank'>fifteen-years-old presentation</a> about shellcode explains how the PEB is used to resolve kernel32's base address. 
						</span>

						
						<p>
						<a href="img/articles/hancitor/hancitor_packer_shellcode_kernel32_base_hunting.png" data-lightbox="hancitorPacker" data-title="Image eleven: Fifteen-year-old presentation discussing shellcode which retrieves the kernel32 base memory address">
						<img src="img/articles/hancitor/hancitor_packer_shellcode_kernel32_base_hunting.png"  width="475" style="border:3px solid black"></a><br> Image eleven: Fifteen-year-old presentation discussing shellcode which retrieves the kernel32 base memory address  
						</p>
						
						<p class="uitlijnen">
						After having resolved the in-memory location of the <span class="asm">LoadLibrary</span> and <span class="asm">GetProcAddress</span> functions, <span class='modName'>module six</span> reads the <span class="asm">FirstThunk</span> and the <span class="asm">OriginalFirstThunk</span> field values inside the <span class="asm">Import Directory Table</span> (image twelve, image thirteen). 
						</span>

						<p>
						<a href="img/articles/hancitor/hancitor_packer_import_lookup_table.png" data-lightbox="hancitorPacker" data-title="Image twelve: Parsing Import Directory Table for OriginalFirstThunk + FirstThunk fields">
						<img src="img/articles/hancitor/hancitor_packer_import_lookup_table.png"  width="475" style="border:3px solid black"></a><br> Image twelve: Parsing Import Directory Table for OriginalFirstThunk &amp; FirstThunk fields
						</p>
						
						<p class="uitlijnen">
						<strong>By enumerating these fields, the module knows via the corresponding <span class="asm">hint/name tables</span> which functions need to be imported. The libraries are imported via calls to the <span class="asm">LoadLibrary</span> function, the function addresses are resolved via calls to the <span class="asm">GetProcAddress</span> function. </strong>
						The module writes the function addressess into Hancitor's <span class="asm">Import Address Table</span>. The result of this action can be seen on image fourteen (note that the Import Directory field values can be nicely visualised via <a href='https://hshrzd.wordpress.com/pe-bear/' target='_blank'>Hasherezade's PE bear</a>). A graphical overview of the relation between the fields and import tables discussed in this paragraph can be seen on image thirteen.
						
						<br><br>This action is the last action by the packer, the execution can now *finally* be transferred to Hancitor's code <img width="16" src="img/smiley/smiley-sun.png">.
						</span>

						<p>
						<a href="img/articles/hancitor/hancitor_packer_pe_import_table.png" data-lightbox="hancitorPacker" data-title="Image thirteen: Graphical overview of the relations between the import tables. Source: dematte.org.">
						<img src="img/articles/hancitor/hancitor_packer_pe_import_table.png"  width="450" style="border:3px solid black"></a><br> Image thirteen: Graphical overview of the relations between the import tables. <br>Source: <a href='http://www.dematte.org/2006/03/04/InterceptingWindowsAPIs.aspx'>dematte.org</a>.
						</p>
						
						<p>
						<a href="img/articles/hancitor/hancitor_packer_import_directory_table.png" data-lightbox="hancitorPacker" data-title="Image fourteen: Parsing the Import Directory Table (IDT) with the ultimate goal of filling the Import Address Table (IAT)">
						<img src="img/articles/hancitor/hancitor_packer_import_directory_table.png"  width="600" style="border:3px solid black"></a><br> Image fourteen: Parsing the Import Directory Table (IDT) with the ultimate goal of filling the Import Address Table (IAT)
						</p>
						
						<h6>Old packer, still does the job</h6>
						<br>
						<p class="uitlijnen">
						During the hunt for additional packed Hancitor samples (using the below YARA rule), I noticed that some of the packed samples were protecting a malware family which didn't look like Hancitor at all <img width="16" src="img/smiley/smiley-investigating.png">. <a href='https://www.virustotal.com/#/file/cd3cff88a9be3624de40018397b4844d7da3be67f959de2d271bde98b5674ce8/detection' target='_blank'>One sample</a> protected some kind of Delphi malware which embedded the names of Turkish banks. The malware looked very similar to the ATMZombie malware, which 
						Kaspersky <a href='https://securelist.com/atmzombie-banking-trojan-in-israeli-waters/73866/' target='_blank'>blogged about</a> (<a href='img/articles/hancitor/kaspersky_atmzombie.png' target='_blank'>mirror</a>). When we look at an ATMZombie sample which is <a href='https://www.virustotal.com/#/file/8662e3c0c564b85ee4af656dcf76fdafdacb41a2f13a3de509bca16b2e8928c7/detection' target='_blank'>explicitly mentioned</a> in the Kaspersky blog, we can see that the packer of the mentioned sample is the same packer as the one which is discussed in this blog.
						<a href='https://www.virustotal.com/#/file/39ac90410bd78f541eb42b1108d2264c7bd7a5feafe102cd7ac8f517c1bd3754/details'>Another packed sample</a> which I noticed during my hunt protected a shellcode loader. The sample <a href='https://www.proofpoint.com/us/threat-insight/post/microsoft-word-intruder-integrates-cve-2017-0199-utilized-cobalt-group-target' target='_blank'>is mentioned</a> in a Proofpoint blog (<a href='img/articles/hancitor/proofpoint_wmi_intruder.png' target='_blank'>mirror</a>) as a Metasploit Stager which in turn downloaded Cobalt Strike. 
						</p>
						
						<p class="uitlijnen">
						<strong>At this point it became clear to me that this packer has been around for a time, and that it isn't exclusively used by Hancitor. In fact, when I kept digging, I found many samples of (old) malware families which were packed by this packer. Some examples are: <a href='https://www.virustotal.com/#/file/b8ce490bc146c058abad4b6593d9e08adcf0b9d374616bca25df78e92ae7d753/detection' target='_blank'>Zeus/Panda banker</a>, <a href='https://www.virustotal.com/#/file/bf352825a70685039401abde5daf1712fd968d6eee233ea72393cbc6faffe5a2/detection' target='_blank'>Cryptowall</a>, <a href='https://www.virustotal.com/#/file/e64ffc50c920105c03a1f0cf40dc015bdba23db13021bf12321b5145fc21485c/detection' target='_blank'>Ramnit</a>, <a href='https://www.virustotal.com/gui/file/50524041df82a17a0e28d1e6ed7cb205e4c427e552c25cb36cc4dfab13c121df/detection' target='_blank'>PoSeidon</a> and <a href='https://www.virustotal.com/gui/file/c839f4cca442547096bad395e58eee579f6d73e31d6549ee0859ff2a64a1304e/detection' target='_blank'>Gootkit</a>.</strong> All packed and unpacked malware samples can be found <a href='resources/hancitor_packer_samples.zip'>here</a> (password=infected).
                        When I launched a <a href='resources/hancitor_packer_like_YARA.txt' target='_blank'>YARA search</a> on parts of the encrypted <span class='modName'>module two</span> bytes (there are 255 variations, as a single byte XOR key is used in the spaghetti code of <span class='modName'>module one</span>), I found older versions of the packer. 
						One example is a packed <a href='https://www.virustotal.com/#/file/04f0feb7ab6b68dabbebc3da2082afabacbe488bca3464f3da985a9b4d9c7c2c/detection' target='_blank'>Qadars sample</a>. The sample is mentioned as an IOC in an <a href='https://www.welivesecurity.com/2013/12/18/qadars-a-banking-trojan-with-the-netherlands-in-its-sights/' target='_blank'>ESET article</a> (<a href='img/articles/hancitor/eset_qadars.png' target='_blank'>mirror</a>) from 2013. This suggests that the packer has been around for at least five years already. 
						</p>
												
						<h6>Addendum: YARA Rule</h6>
						<br>
						<div style="background: #eeeedd; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;font-family: Consolas,monaco,monospace;"><pre style="margin: 0; line-height: 125%">import <span style="color: #CD5555">&quot;pe&quot;</span>
rule hancitor_packer
{
  meta:
    <span style="color: #00688B">author</span> = <span style="color: #CD5555">&quot;Felix Weyne, 2019&quot;</span>
    <span style="color: #00688B">description</span> = <span style="color: #CD5555">&quot;Hancitor packer spaghetti code (loose match)&quot;</span>
    <span style="color: #00688B">hash1</span>= <span style="color: #CD5555">&quot;37f6f1f59bf7952fd7182deeb07d4cd0d367dd59&quot;</span>
    <span style="color: #00688B">hash2</span>= <span style="color: #CD5555">&quot;2508b3211b066022c2ab41725fbc400e8f3dec1e&quot;</span>
    <span style="color: #00688B">hash3</span>= <span style="color: #CD5555">&quot;3855f6d9049936ddb29561d2ab4b2bf26df7a7ff&quot;</span>
    <span style="color: #00688B">hash4</span>= <span style="color: #CD5555">&quot;e9ec4a4fb6f5d143b304df866bba4277cd473843&quot;</span>
  strings:
    //E9=JMP, EB=JMP SHORT, 71/0F=JNO
    <span style="color: #00688B">$change_sp</span>={89 EC (E9|EB|71|0F)}		//mov    esp,ebp
    <span style="color: #00688B">$2</span>={5D (E9|EB|71|0F)}			//pop    ebp
    <span style="color: #00688B">$3</span>={BF ?? ?? ?? 00 (E9|EB|71|0F)}		//mov    edi, 274C67h
    <span style="color: #00688B">$4</span>={81 ?? ?? ?? ?? 00 (E9|EB|71|0F)}	//add    edi, 17E792h
    <span style="color: #00688B">$5</span>={57 (E9|EB|71|0F)}			//push   edi
    <span style="color: #00688B">$6</span>={BE ?? ?? 00 00 (E9|EB|71|0F)}		//mov    esi, 88Bh
    <span style="color: #00688B">$7</span>={6A 00 (E9|EB|71|0F)}			//push   0
    <span style="color: #00688B">$8</span>={54 (E9|EB|71|0F)}			//push   esp
    <span style="color: #00688B">$9</span>={6A 40 (E9|EB|71|0F)}			//push   40h
    <span style="color: #00688B">$mov_eax</span>={B8 ?? ?? ?? 00 (E9|EB|71|0F)}	//mov    eax, 5ADBh
    <span style="color: #00688B">$add_eax</span>={05 ?? ?? ?? 00 (E9|EB|71|0F)}	//add    eax, 0E525h
    <span style="color: #00688B">$12</span>={8B 00 (E9|EB|71|0F)}			//mov    eax, [eax]
    <span style="color: #00688B">$13</span>={FF D0 (E9|EB|71|0F)}			//call   eax
    <span style="color: #00688B">$ecx_zero</span>={B9 00 00 00 00 (E9|EB|71|0F)}	//mov    ecx, 0
    <span style="color: #00688B">$xor</span>={30 07 (E9|EB|71|0F)}			//xor    [edi], al
    <span style="color: #00688B">$18</span>={41 (E9|EB|71|0F)}			//inc    ecx
    <span style="color: #00688B">$19</span>={47 (E9|EB|71|0F)}			//inc    edi     
    <span style="color: #00688B">$20</span>={39 F1 (E9|EB|71|0F)}			//cmp    ecx, esi  
    <span style="color: #00688B">$21</span>={58 (E9|EB|71|0F)}			//pop    eax
  condition:
    filesize &lt; 110KB
    and pe.is_32bit()
    and <span style="color: #228B22">#add_eax &gt;= 3</span>
    and <span style="color: #228B22">#mov_eax &gt;= 3</span>
    and all of them
    and <span style="color: #8B008B; font-weight: bold">for </span>any i in (1..#xor):(<span style="color: #00688B">$change_sp</span> in (@xor[i]-400..@xor[i]+400))
    and <span style="color: #8B008B; font-weight: bold">for </span>any i in (1..#xor):(<span style="color: #00688B">$ecx_zero</span> in (@xor[i]-300..@xor[i]+300))
}
</pre></div>

						
						
						
					</div>
                    <!-- ENDS PAGE-CONTENT -->
                </div>
                <!-- ENDS CONTENT -->
            </div>
            <!-- ENDS MAIN -->
        </div>
        <!-- ENDS WRAPPER -->
        <!-- FOOTER -->
        <div id="footer">
            <!-- FOOTER-WRAPPER -->
            <div id="footer-wrapper">
                 Website created by Felix Weyne, 2024 | Website Template By Luiszuno 
            </div>
            <!-- ENDS FOOTER-WRAPPER -->
        </div>
        <!-- ENDS FOOTER -->
	<script src="lightbox/js/lightbox.js"></script>
	</body>
</html>