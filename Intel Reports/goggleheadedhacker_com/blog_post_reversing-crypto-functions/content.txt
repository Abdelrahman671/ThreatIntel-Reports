<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="shortcut icon" type="image/png" href="/favicon.png">
    
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Reverse Engineering Crypto Functions: RC4 and Salsa20 | GoggleHeadedHacker</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Reverse Engineering Crypto Functions: RC4 and Salsa20" />
<meta name="author" content="Jacob Pimental" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This tutorial will show how RC4 and Salsa20 algorithms work and how they can be identified in assembly when reverse engineering an application." />
<meta property="og:description" content="This tutorial will show how RC4 and Salsa20 algorithms work and how they can be identified in assembly when reverse engineering an application." />
<link rel="canonical" href="https://goggleheadedhacker.com/blog/post/reversing-crypto-functions" />
<meta property="og:url" content="https://goggleheadedhacker.com/blog/post/reversing-crypto-functions" />
<meta property="og:site_name" content="GoggleHeadedHacker" />
<meta property="og:image" content="https://goggleheadedhacker.com/assets/images/thumbnails/reversing_crypto_functions.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-08-25T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://goggleheadedhacker.com/assets/images/thumbnails/reversing_crypto_functions.jpg" />
<meta property="twitter:title" content="Reverse Engineering Crypto Functions: RC4 and Salsa20" />
<meta name="twitter:site" content="@Jacob_Pimental" />
<meta name="twitter:creator" content="@Jacob Pimental" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Jacob Pimental"},"dateModified":"2021-08-25T00:00:00+00:00","datePublished":"2021-08-25T00:00:00+00:00","description":"This tutorial will show how RC4 and Salsa20 algorithms work and how they can be identified in assembly when reverse engineering an application.","headline":"Reverse Engineering Crypto Functions: RC4 and Salsa20","image":"https://goggleheadedhacker.com/assets/images/thumbnails/reversing_crypto_functions.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://goggleheadedhacker.com/blog/post/reversing-crypto-functions"},"url":"https://goggleheadedhacker.com/blog/post/reversing-crypto-functions"}</script>
<!-- End Jekyll SEO tag -->

</head>

  <body>
    <div id="navbar" class="navbar">
    <a href="/" class="nav-title">
        <img class="nav-img" src="/assets/images/homepage/logo_plain_svg.svg">
        <h1>GoggleHeadedHacker</h1>
    </a>
    <label for="click" id="link-list-mobile-button" class="link-list-mobile-button">
        <input id="click" class="chkbx" type="checkbox">
        <span></span>
        <span></span>
        <span></span>
    </label>
    <div id="link-list" class="link-list">
        <div id="search-container">
            <input id="search" type="text" placeholder="Search...">
            <div id="results-container">
                <ul id="results-list"></ul>
            </div>
        </div>
        <a href="/about">About</a>
        <a href="/projects">Projects</a>
        <a href="/contact">Contact</a>
        <a class="r" href="/feed.xml"><i class="fa-solid fa-rss"></i></a>
    </div>
</div>

<script src="\assets\js\simple-jekyll-search.min.js" type="text/javascript"></script>

<script>
    SimpleJekyllSearch({
        searchInput: document.getElementById('search'),
        resultsContainer: document.getElementById('results-list'),
        json: '/assets/config/posts.json',
        limit: 30
    })

    const searchBar = document.getElementById("search");
    const clickInput = document.getElementById("click");
    const linkListMobileButton = document.getElementById("link-list-mobile-button");

    clickInput.addEventListener("change", function() {
        if (this.checked) {
            linkListMobileButton.classList.add("checked");
        } else {
            linkListMobileButton.classList.remove("checked");
            searchBar.value = '';
        }
    });


    var prevScrollpos = window.pageYOffset;
    window.onscroll = function() {
        var currentScrollPos = window.pageYOffset;
        var element = document.getElementById("click");
        if ((prevScrollpos > currentScrollPos && screen.width <= 800) || element.checked) {
            document.getElementById("navbar").style.top = "0";
        } else if (prevScrollpos < currentScrollPos && screen.width <= 800) {
            document.getElementById("navbar").style.top = "-5rem";
        }
        prevScrollpos = currentScrollPos;
    }
</script>
    <div class="container">
      <div class="main_content post">
        <img style="width:35rem" src="/assets/images/thumbnails/reversing_crypto_functions.jpg" alt="Reverse Engineering Crypto Functions">
        <h1>Reverse Engineering Crypto Functions: RC4 and Salsa20</h1>
        <h3>25 August 2021</h3>
        <p>By Jacob Pimental</p>
        <div class="share-box">

    <a class="f" href="https://www.facebook.com/sharer/sharer.php?u=https://goggleheadedhacker.com/blog/post/reversing-crypto-functions" onclick="window.open(this.href, 'mywin',
    'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" ><i class="fa-brands fa-facebook"></i></a>

    <a class="t" href="https://twitter.com/intent/tweet?text=&url=https://goggleheadedhacker.com/blog/post/reversing-crypto-functions" onclick="window.open(this.href, 'mywin',
    'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;"><i class="fa-brands fa-twitter"></i></a>

    <a class="r" href="http://www.reddit.com/submit?url=https://goggleheadedhacker.com/blog/post/reversing-crypto-functions" onclick="window.open(this.href, 'mywin',
    'left=20,top=20,width=900,height=500,toolbar=1,resizable=0'); return false;" ><i class="fa-brands fa-reddit"></i></a>

    <a class="l" href="https://www.linkedin.com/shareArticle?mini=true&url=https://goggleheadedhacker.com/blog/post/reversing-crypto-functions&title=Reverse Engineering Crypto Functions: RC4 and Salsa20" onclick="window.open(this.href, 'mywin',
    'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" ><i class="fa-brands fa-linkedin"></i></a>

    <a class="e" href="mailto:?subject=&amp;body=Check out this site https://goggleheadedhacker.com/blog/post/reversing-crypto-functions"><i class="fa-solid fa-envelope"></i></a>                          
</div>

        <br>
        
<p>Many malware samples use encryption for Command and Control (C2) communications, encrypting files, string obfuscation, and many other tasks. It can be challenging to know which encryption algorithm you are looking at when analyzing a sample. This post aims to teach newer analysts about common encryption algorithms, how they work, and how you can identify them when reverse engineering.</p>

<ol id="markdown-toc">
  <li><a href="#rc4-algorithm" id="markdown-toc-rc4-algorithm">RC4 Algorithm</a>    <ol>
      <li><a href="#how-it-works" id="markdown-toc-how-it-works">How it Works</a>        <ol>
          <li><a href="#key-scheduling-algorithm-ksa" id="markdown-toc-key-scheduling-algorithm-ksa">Key Scheduling Algorithm (KSA)</a></li>
          <li><a href="#pseudo-random-generation-algorithm-prga" id="markdown-toc-pseudo-random-generation-algorithm-prga">Pseudo-Random Generation Algorithm (PRGA)</a></li>
          <li><a href="#putting-it-all-together" id="markdown-toc-putting-it-all-together">Putting it All Together</a></li>
        </ol>
      </li>
      <li><a href="#identifying-rc4-in-assembly" id="markdown-toc-identifying-rc4-in-assembly">Identifying RC4 in Assembly</a></li>
    </ol>
  </li>
  <li><a href="#salsa20-algorithm" id="markdown-toc-salsa20-algorithm">Salsa20 Algorithm</a>    <ol>
      <li><a href="#how-it-works-1" id="markdown-toc-how-it-works-1">How it Works</a>        <ol>
          <li><a href="#state-generation" id="markdown-toc-state-generation">State Generation</a></li>
          <li><a href="#generating-keystream" id="markdown-toc-generating-keystream">Generating Keystream</a></li>
          <li><a href="#putting-it-all-together-1" id="markdown-toc-putting-it-all-together-1">Putting it All Together</a></li>
        </ol>
      </li>
      <li><a href="#identifying-salsa20-in-assembly" id="markdown-toc-identifying-salsa20-in-assembly">Identifying Salsa20 in Assembly</a></li>
    </ol>
  </li>
  <li><a href="#conclusion" id="markdown-toc-conclusion">Conclusion</a></li>
</ol>

<h2 id="rc4-algorithm">RC4 Algorithm</h2>

<h3 id="how-it-works">How it Works</h3>

<p>RC4’s internal state is an array of 256 bytes, denoted as <code class="language-plaintext highlighter-rouge">S[]</code>, ranging from 0-255. RC4 will use its Key Scheduling Algorithm (KSA) to randomly swap the bytes in <code class="language-plaintext highlighter-rouge">S[]</code> using the user inputted key as the seed. <code class="language-plaintext highlighter-rouge">S[]</code> is then used to generate a keystream via the Pseudo-Random Generation Algorithm (PRGA). This keystream, denoted as <code class="language-plaintext highlighter-rouge">KS[]</code>, is the same size as the plaintext input. Finally, RC4 will XOR the keystream by the plaintext to create the encrypted ciphertext.</p>

<h4 id="key-scheduling-algorithm-ksa">Key Scheduling Algorithm (KSA)</h4>

<p>The Key Scheduling Algorithm for RC4 will take the internal state referenced earlier, denoted as <code class="language-plaintext highlighter-rouge">S[]</code>, and permutate it based on a key the user inputs. For each index in <code class="language-plaintext highlighter-rouge">S[]</code>, the algorithm will swap the value with another index of <code class="language-plaintext highlighter-rouge">S[]</code> based on the value: <code class="language-plaintext highlighter-rouge">(j + S[index] + key[index % keylength]) % 256</code>, where <code class="language-plaintext highlighter-rouge">j</code> has a starting value of zero. This can be shown in the following Python code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">KSA</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
    <span class="s">"""Rearranges the values in an array of 256 bytes based on key.

    Params:
        key (str): Key used to permutate the bytes

    Returns:
        list: A permutation of 256 bytes used to generate keystream
    """</span>
    <span class="n">S</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">256</span><span class="p">)]</span> <span class="c1"># Initialize array of 256 bytes
</span>    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">256</span><span class="p">):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nf">ord</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="nf">len</span><span class="p">(</span><span class="n">key</span><span class="p">)])</span>
        <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span> <span class="o">%</span> <span class="mi">256</span> <span class="c1"># Calculate index to swap
</span>        <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1"># Swap values in the array based
</span>    <span class="k">return</span> <span class="n">S</span>
</code></pre></div></div>

<h4 id="pseudo-random-generation-algorithm-prga">Pseudo-Random Generation Algorithm (PRGA)</h4>

<p>The output from the <a href="#key-scheduling-algorithm-ksa">Key Scheduling Algorithm</a> is used to generate a keystream using RC4’s PRGA. This keystream will be the same size as the plaintext input and is generated by taking the value at <code class="language-plaintext highlighter-rouge">S[i + 1]</code>, and swapping that with the value of <code class="language-plaintext highlighter-rouge">(j + S[i + 1]) % 256</code>. For this example, <code class="language-plaintext highlighter-rouge">i</code> is all numbers from zero to the length of the plaintext and <code class="language-plaintext highlighter-rouge">j</code> is zero. After this swap, the value <code class="language-plaintext highlighter-rouge">S[ (S[i] + S[j]) % 256 ]</code> is appended to the keystream, thus creating a pseudo-random list of bytes. This can be shown in the following Python code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">PRGA</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
    <span class="s">"""Pseudo-Random algorithm that creates the final keystream used to encrypt.

    Params:
        S (list): The 256 byte array generated by KSA
        amount (int): Length the keystream needs to be (size of plaintext)

    Returns:
        list: The final keystream used for encryption
    """</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">K</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">amount</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">256</span>
        <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="mi">256</span>
        <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">K</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">S</span><span class="p">[(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">%</span> <span class="mi">256</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">K</span>
</code></pre></div></div>

<h4 id="putting-it-all-together">Putting it All Together</h4>

<p>Once the keystream is generated, the RC4 algorithm will use it to encrypt the plaintext input by XORing the bytes together. Decryption works by deriving the same keystream using the original key and XORing that by the ciphertext. This entire process is shown in the following Python code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">XOR</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="s">"""XORs two arrays together.

    Params:
      pt (list): The plaintext array
      k (list): The key to XOR by

    Returns:
      list: The ciphertext
    """</span>
    <span class="n">ct</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">pt</span><span class="p">)):</span>
        <span class="n">ct</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">ord</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">^</span> <span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">ct</span>

<span class="k">def</span> <span class="nf">RC4</span><span class="p">(</span><span class="n">plaintext</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="s">"""Main RC4 function.

    Params:
      plaintext (str): The plaintext to encrypt
      key (str): The key used for encryption

    Returns:
      list: List of encrypted bytes
    """</span>
    <span class="n">S</span> <span class="o">=</span> <span class="nc">KSA</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="n">K</span> <span class="o">=</span> <span class="nc">PRGA</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">plaintext</span><span class="p">))</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
    <span class="n">ct</span> <span class="o">=</span> <span class="nc">XOR</span><span class="p">(</span><span class="n">plaintext</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ct</span>
</code></pre></div></div>

<h3 id="identifying-rc4-in-assembly">Identifying RC4 in Assembly</h3>

<p>An easy way of identifying that an application is using the RC4 algorithm is by looking for the value <code class="language-plaintext highlighter-rouge">256</code> when the algorithm is creating the initial state (<code class="language-plaintext highlighter-rouge">S[]</code>). This normally occurs in two loops that run 256 times each and will be either creating or modifying an array.</p>

<p><img src="/assets/images/posts/reversing-crypto-functions/rc4-s-array-creation.png" alt="RC4 S array creation" />
<em>Loop that creates initial S array of bytes from 0 to 255</em></p>

<p>It is important to notice that in the second loop in RC4’s key scheduling algorithm the bytes in <code class="language-plaintext highlighter-rouge">S[]</code> will be swapped around. You can see this in the following screenshot:</p>

<p><img src="/assets/images/posts/reversing-crypto-functions/rc4-s-array-substitution.png" alt="RC4 S Array Substitution" />
<em>Second loop in S array creation that swaps bytes</em></p>

<p>You can also identify RC4 by its pseudo-random generation algorithm. Two important things to notice here are the use of the previously created <code class="language-plaintext highlighter-rouge">S[]</code> variable and the XOR operand being used. Keep in mind that this section will be looped by the length of the plaintext, not 256 times like the KSA.</p>

<p><img src="/assets/images/posts/reversing-crypto-functions/rc4-prga-algorithm.png" alt="RC4 PRGA Algorithm" />
<em>Main loop used for RC4 PRGA</em></p>

<p>By identifying both functionalities in the code, it is safe to say that this is the RC4 algorithm. This particular example was from my analysis of the <a href="/blog/post/sodinokibi-ransomware-analysis#string-encryption">Sodinokbi Ransomware in a previous post</a>.</p>

<h2 id="salsa20-algorithm">Salsa20 Algorithm</h2>

<h3 id="how-it-works-1">How it Works</h3>

<p>Salsa20 works by encrypting data in 64 bytes “blocks”. The algorithm is counter-based, meaning that a counter variable is used when generating the key depending on which “block” of data is being encrypted. The internal state of Salsa20 consists of an array of 16 32-bit words that can be shown as a 4x4 matrix:</p>

<p><img src="/assets/images/posts/reversing-crypto-functions/salsa20-initial-state.png" alt="Salsa20 Initial State" />
<em>Salsa20’s initial state</em></p>

<p>This state then undergoes a “quarter-round” function which randomizes the values in the matrix. Once the state is run through this function multiple times, normally 20, the final result is then added back to the initial state’s values. This becomes the keystream that will be XOR’d against 64 bytes of the plaintext data. Finally, the counter variable will be incremented and the process starts again with the next 64 bytes.</p>

<h4 id="state-generation">State Generation</h4>

<p>The initial state for Salsa20 consists of 16 32-bit words consisting of the following:</p>

<div class="table">

  <table>
    <thead>
      <tr>
        <th>State variable</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Key</td>
        <td>16 or 32 byte key defined by the user</td>
      </tr>
      <tr>
        <td>Nonce</td>
        <td>Eight byte nonce value that can be randomly generated or given</td>
      </tr>
      <tr>
        <td>Counter</td>
        <td>The counter variable that denotes which “block” is being encrypted</td>
      </tr>
      <tr>
        <td>Constant</td>
        <td>Constant value of either “expand 32-byte k” or “expand 16-byte k” depending on the length of the key</td>
      </tr>
    </tbody>
  </table>

</div>

<p>If the length of the key is 32 bytes, then it is split between the two sets of four 32-bit words in the state with the first 16 bytes in the first set and the last 16 bytes in the second. Otherwise, if the length of the key is 16 bytes it is repeated between the two sets of four 32-bit words. The state generation can be defined in the following Python code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">setup_keystate</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">nonce</span><span class="p">,</span> <span class="n">counter</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
      <span class="s">"""Sets up initial keystate for Salsa20.

      Params:
          key (bytes): Key used to encrypt data (16 or 32 bytes)
          nonce (bytes): One-time pad used to generate keystate
          counter (int): Determines which blok is being encrypted
      """</span>
      <span class="n">nonce</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="s">'&lt;2I'</span><span class="p">,</span> <span class="n">nonce</span><span class="p">))</span>  <span class="c1"># Splits nonce into 2 words
</span>      <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="n">counter</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">counter</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">]</span>  <span class="c1"># Generates high and low order words for counter
</span>      <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">32</span><span class="p">:</span>
          <span class="n">const</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="s">'&lt;4I'</span><span class="p">,</span> <span class="sa">b</span><span class="s">'expand 32-byte k'</span><span class="p">))</span>  <span class="c1"># Splits const into 4 words
</span>          <span class="n">k</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="s">'&lt;8I'</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>  <span class="c1"># Splits key into 8 words
</span>          <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>     <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>     <span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                        <span class="n">k</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>     <span class="n">const</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nonce</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nonce</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">count</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">const</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
                        <span class="n">k</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>     <span class="n">k</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>     <span class="n">k</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span>     <span class="n">const</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
      <span class="k">elif</span> <span class="nf">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">16</span><span class="p">:</span>
          <span class="n">const</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="s">'&lt;4I'</span><span class="p">,</span> <span class="sa">b</span><span class="s">'expand 16-byte k'</span><span class="p">))</span>
          <span class="n">k</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="s">'&lt;4I'</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>  <span class="c1"># Splits key into 4 words
</span>          <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>     <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>     <span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                        <span class="n">k</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>     <span class="n">const</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nonce</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nonce</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">count</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">const</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>     <span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>     <span class="n">k</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>     <span class="n">const</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
</code></pre></div></div>

<p>An example of how the state would look with a 16 byte and 32 byte key can be seen below:</p>

<p><img src="/assets/images/posts/reversing-crypto-functions/salsa20-16-vs-32-byte-key.png" alt="Salsa20 16 vs 32 byte key" />
<em>Difference between 16 and 32 Byte key in Salsa20</em></p>

<h4 id="generating-keystream">Generating Keystream</h4>

<p>To generate the keystream, Salsa20 uses a “quarter-round” function to randomize the data in its initial state. This function is called “quarter-round” as it is working on one column or row at a time out of four, or one “quarter” at a time. The default number of “rounds” is 20, unless otherwise specified. On even rounds, the algorithm will transform its column values using the quarter-round function and on odd rounds it will transform its rows. The quarter-round funtion can be shown in the following Python code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">QR</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
      <span class="s">"""quarter-round function used in Salsa20.

      Params:
          x (array): Starting array to permutate
          a (int): index value for array
          b (int): index value for array
          c (int): index value for array
          d (int): index value for array
      """</span>
      <span class="n">x</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">^=</span> <span class="nf">rol</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
      <span class="n">x</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">^=</span> <span class="nf">rol</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
      <span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">^=</span> <span class="nf">rol</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
      <span class="n">x</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">^=</span> <span class="nf">rol</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mi">18</span><span class="p">)</span>
</code></pre></div></div>

<p>Once the initial state is run through this permutation function for the number of rounds specified, it will then add the newly randomized state to its original values. This will ensure that the process cannot be reversed and the key cannot be recovered. The entire keystream generation process looks like:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">generate_ks</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="s">"""Generates Keystream for Salsa20

    Returns:
        bytes: 64-byte keystream
    """</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">state</span><span class="p">[:]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nc">QR</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="nc">QR</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="nc">QR</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="nc">QR</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>

        <span class="n">self</span><span class="p">.</span><span class="nc">QR</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="nc">QR</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="nc">QR</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="nc">QR</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">state</span><span class="p">)):</span>
        <span class="n">out</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">self</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="nf">pack</span><span class="p">(</span><span class="s">'&lt;16I'</span><span class="p">,</span>
                      <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>  <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>  <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>  <span class="n">out</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                      <span class="n">out</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>  <span class="n">out</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>  <span class="n">out</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>  <span class="n">out</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span>
                      <span class="n">out</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span>  <span class="n">out</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span>  <span class="n">out</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span>
                      <span class="n">out</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">13</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">14</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">15</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">out</span>
</code></pre></div></div>

<h4 id="putting-it-all-together-1">Putting it All Together</h4>

<p>After the keystream is generated, the Salsa20 algorithm will XOR it by the first 64 bytes, or less, of the plaintext. If there is more than 64 bytes in the plaintext data, then the counter variable is incremented and a new keystream is generated for the next 64 byte block. This process continues until the entirety of the plaintext is encrypted. The Python code for this would look like the following:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
      <span class="n">ct</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="nf">print</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">))</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">),</span> <span class="mi">64</span><span class="p">):</span>
          <span class="n">block</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">64</span><span class="p">]</span>
          <span class="n">self</span><span class="p">.</span><span class="nf">setup_keystate</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">key</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">nonce</span><span class="p">,</span> <span class="n">i</span><span class="o">//</span><span class="mi">64</span><span class="p">)</span>
          <span class="n">ks</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">generate_ks</span><span class="p">()</span>
          <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">block</span><span class="p">)):</span>
              <span class="n">ct</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">^</span> <span class="n">ks</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
      <span class="k">return</span> <span class="n">ct</span>
</code></pre></div></div>

<h3 id="identifying-salsa20-in-assembly">Identifying Salsa20 in Assembly</h3>

<p>The easiest way to identify Salsa20 when analyzing a binary is to look for the constants <code class="language-plaintext highlighter-rouge">expand 32-byte k</code> or <code class="language-plaintext highlighter-rouge">expand 16-byte k</code>. These will almost always be present for Salsa20 and are a guaranteed indicator.</p>

<p><img src="/assets/images/posts/reversing-crypto-functions/salsa20-constant-value.png" alt="Salsa20 Constant Value" />
<em>Salsa20 constant value being moved into the state</em></p>

<p>However, in order to evade analysis, the author might change these constant values. If these values are changed, next thing to look for would be the quarter-round function that Salsa20 uses to generate the keystream. To locate this, the analyst should be looking for the <code class="language-plaintext highlighter-rouge">rol</code> operands followed by the normal quarter-round values: 7, 9, 13, and 18.</p>

<p><img src="/assets/images/posts/reversing-crypto-functions/salsa20-quarter-round-function-in-assembly.png" alt="Salsa20 quarter-round function in assembly" />
<em>Salsa20 quarter-round function showing the <code class="language-plaintext highlighter-rouge">rol</code> operands</em></p>

<p>The examples for this section were from an <a href="https://github.com/alexwebr/salsa20">open source version of the Salsa20 algorithm written in C</a> by <a href="https://github.com/alexwebr">alexwebr</a>.</p>

<h2 id="conclusion">Conclusion</h2>
<p>Hopefully this post will help newer analysts in identifying basic crypto functions that can be used by malware. By learning how the algorithms operate at a low level, it will make it easier to spot them in the wild and possibly be able to identify different variations of the same algorithm that an author may use to evade detection. If you have any questions or comments about this post, feel free to message me on my <a href="https://twitter.com/jacob_pimental">Twitter</a> or <a href="https://www.linkedin.com/in/jacobpimental/">LinkedIn</a>.</p>

<p>Thanks for reading and happy reversing!</p>


        <h4>Tutorial, Encryption, RC4, Salsa20</h4>
        <h2>More Content Like This:</h2>
<div class="card-container">
    
    
    

    
        
        

        
            
            <div class="card">
                <a href="/post/onenote-analysis"><img class="card-image" src="/assets/images/thumbnails/onenote_analysis_thumb.jpg"/></a>
                <div class="card-body">
                    <a href="/post/onenote-analysis"><h4>OneNote Analysis</h4></a>
                </div>
            </div>
            
            
        
    
        
        

        
            
            <div class="card">
                <a href="/post/intro-to-cutter"><img class="card-image" src="/assets/images/thumbnails/Intro-To-Cutter_thumb.jpg"/></a>
                <div class="card-body">
                    <a href="/post/intro-to-cutter"><h4>Intro to Cutter</h4></a>
                </div>
            </div>
            
            
        
    
        
        

        
    
        
        

        
    
        
        

        
            
            <div class="card">
                <a href="/blog/post/reversing-crypto-functions-aes"><img class="card-image" src="/assets/images/thumbnails/reversing_crypto_functions_aes_thumb.jpg"/></a>
                <div class="card-body">
                    <a href="/blog/post/reversing-crypto-functions-aes"><h4>Reverse Engineering Crypto Functions: AES</h4></a>
                </div>
            </div>
            
            
        
    
        
        

        
    
        
        

        
    
        
        

        
    
        
        

        
    
        
        

        
    
        
        

        
    
        
        

        
    
        
        

        
    
        
        

        
    
        
        

        
    
        
        

        
    
        
        

        
    
        
        

        
    
        
        

        
            
            <div class="card">
                <a href="/blog/post/12"><img class="card-image" src="/assets/images/thumbnails/robbinhood-analysis_thumb.jpg"/></a>
                <div class="card-body">
                    <a href="/blog/post/12"><h4>Robbinhood Malware Analysis with Radare2</h4></a>
                </div>
            </div>
            
            
        
    
        
        

        
    
        
        

        
    
        
        

        
    
        
        

        
            
            <div class="card">
                <a href="/blog/post/8"><img class="card-image" src="/assets/images/thumbnails/r2pipe-automation_thumb.jpg"/></a>
                <div class="card-body">
                    <a href="/blog/post/8"><h4>Automating RE Using r2pipe</h4></a>
                </div>
            </div>
            
            
        
    
        
        

        
    
        
        

        
            
            <div class="card">
                <a href="/blog/post/6"><img class="card-image" src="/assets/images/thumbnails/unpacking-executables_thumb.jpg"/></a>
                <div class="card-body">
                    <a href="/blog/post/6"><h4>Unpacking Executables - The ESP Trick</h4></a>
                </div>
            </div>
            
            
                
</div>
      </div>
    </div>
    <script src="/assets/js/donationButton.js"></script>
    <script>
      addDonationButton("Buy Me a Tea");
    </script>
    <script src="/assets/js/vanilla-back-to-top.min.js"></script>
    <script>addBackToTop({
                diameter: 40,
                backgroundColor: '#b5e853',
                textColor: '#151515'
            })</script>

		
    
      <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-153169514-1', 'auto');
  ga('send', 'pageview');
</script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WT9456CQQZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-WT9456CQQZ');
</script>
    
  </body>
</html>
