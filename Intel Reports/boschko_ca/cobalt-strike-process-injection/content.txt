<!DOCTYPE html>
<html lang="en">
<head>

    <title>Cobalt Strike Process Injection</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <link rel="preload" as="style" href="https://boschko.ca/assets/built/screen.css?v=4b789ea714" />
    <link rel="preload" as="script" href="https://boschko.ca/assets/built/casper.js?v=4b789ea714" />

    <link rel="stylesheet" type="text/css" href="https://boschko.ca/assets/built/screen.css?v=4b789ea714" />

    <meta name="description" content="Discussing the various methods that Cobalt Strike uses to perform process injection.">
    <link rel="canonical" href="https://boschko.ca/cobalt-strike-process-injection/">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <link rel="amphtml" href="https://boschko.ca/cobalt-strike-process-injection/amp/">
    
    <meta property="og:site_name" content="Boschko Security Blog">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Cobalt Strike Process Injection">
    <meta property="og:description" content="Discussing the various methods that Cobalt Strike uses to perform process injection.">
    <meta property="og:url" content="https://boschko.ca/cobalt-strike-process-injection/">
    <meta property="article:published_time" content="2021-11-02T23:51:30.000Z">
    <meta property="article:modified_time" content="2024-11-25T22:16:56.000Z">
    <meta property="article:tag" content="Windows Internal">
    <meta property="article:tag" content="C2">
    <meta property="article:tag" content="Cobalt Strike">
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Cobalt Strike Process Injection">
    <meta name="twitter:description" content="Discussing the various methods that Cobalt Strike uses to perform process injection.">
    <meta name="twitter:url" content="https://boschko.ca/cobalt-strike-process-injection/">
    <meta name="twitter:image" content="https://boschko.ca/content/images/2021/11/spawn.PNG">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="Olivier Laflamme">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="Windows Internal, C2, Cobalt Strike">
    <meta name="twitter:site" content="@olivier_boschko">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Boschko Security Blog",
        "url": "https://boschko.ca/",
        "logo": {
            "@type": "ImageObject",
            "url": "https://boschko.ca/content/images/2021/09/Capture.PNG"
        }
    },
    "author": {
        "@type": "Person",
        "name": "Olivier Laflamme",
        "image": {
            "@type": "ImageObject",
            "url": "https://boschko.ca/content/images/2021/09/119486535_632169284368147_173960549788702982_n-1.jpg",
            "width": 1080,
            "height": 1075
        },
        "url": "https://boschko.ca/author/olivier/",
        "sameAs": []
    },
    "headline": "Cobalt Strike Process Injection",
    "url": "https://boschko.ca/cobalt-strike-process-injection/",
    "datePublished": "2021-11-02T23:51:30.000Z",
    "dateModified": "2024-11-25T22:16:56.000Z",
    "keywords": "Windows Internal, C2, Cobalt Strike",
    "description": "Discussing the various methods that Cobalt Strike uses to perform process injection.",
    "mainEntityOfPage": "https://boschko.ca/cobalt-strike-process-injection/"
}
    </script>

    <meta name="generator" content="Ghost 5.105">
    <link rel="alternate" type="application/rss+xml" title="Boschko Security Blog" href="https://boschko.ca/rss/">
    <script defer src="https://cdn.jsdelivr.net/ghost/portal@~2.46/umd/portal.min.js" data-i18n="true" data-ghost="https://boschko.ca/" data-key="0ab6c89b32274048f7d9cc1298" data-api="https://boschko-security-blog.ghost.io/ghost/api/content/" data-locale="en" crossorigin="anonymous"></script><style id="gh-members-styles">.gh-post-upgrade-cta-content,
.gh-post-upgrade-cta {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    text-align: center;
    width: 100%;
    color: #ffffff;
    font-size: 16px;
}

.gh-post-upgrade-cta-content {
    border-radius: 8px;
    padding: 40px 4vw;
}

.gh-post-upgrade-cta h2 {
    color: #ffffff;
    font-size: 28px;
    letter-spacing: -0.2px;
    margin: 0;
    padding: 0;
}

.gh-post-upgrade-cta p {
    margin: 20px 0 0;
    padding: 0;
}

.gh-post-upgrade-cta small {
    font-size: 16px;
    letter-spacing: -0.2px;
}

.gh-post-upgrade-cta a {
    color: #ffffff;
    cursor: pointer;
    font-weight: 500;
    box-shadow: none;
    text-decoration: underline;
}

.gh-post-upgrade-cta a:hover {
    color: #ffffff;
    opacity: 0.8;
    box-shadow: none;
    text-decoration: underline;
}

.gh-post-upgrade-cta a.gh-btn {
    display: block;
    background: #ffffff;
    text-decoration: none;
    margin: 28px 0 0;
    padding: 8px 18px;
    border-radius: 4px;
    font-size: 16px;
    font-weight: 600;
}

.gh-post-upgrade-cta a.gh-btn:hover {
    opacity: 0.92;
}</style>
    <script defer src="https://cdn.jsdelivr.net/ghost/sodo-search@~1.5/umd/sodo-search.min.js" data-key="0ab6c89b32274048f7d9cc1298" data-styles="https://cdn.jsdelivr.net/ghost/sodo-search@~1.5/umd/main.css" data-sodo-search="https://boschko-security-blog.ghost.io/" data-locale="en" crossorigin="anonymous"></script>
    
    <link href="https://boschko.ca/webmentions/receive/" rel="webmention">
    <script defer src="/public/cards.min.js?v=4b789ea714"></script>
    <link rel="stylesheet" type="text/css" href="/public/cards.min.css?v=4b789ea714">
    <script defer src="/public/member-attribution.min.js?v=4b789ea714"></script><style>:root {--ghost-accent-color: #000000;}</style>
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-209482797-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-209482797-1');
  gtag('set', {'user_id': 'USER_ID'}); // Set the user ID using signed-in user_id
</script>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3GEFND46EZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-3GEFND46EZ');
</script>

</head>
<body class="post-template tag-windows-internal tag-c2 tag-cobalt-strike is-head-left-logo has-cover">
<div class="viewport">

    <header id="gh-head" class="gh-head outer">
        <div class="gh-head-inner inner">
            <div class="gh-head-brand">
                <a class="gh-head-logo" href="https://boschko.ca">
                        <img src="https://boschko.ca/content/images/2021/09/Capture.PNG" alt="Boschko Security Blog">
                </a>
                <button class="gh-search gh-icon-btn" aria-label="Search this site" data-ghost-search><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg></button>
                <button class="gh-burger" aria-label="Main Menu"></button>
            </div>

            <nav class="gh-head-menu">
                <ul class="nav">
    <li class="nav-home"><a href="https://boschko.ca/">Home</a></li>
    <li class="nav-tags"><a href="https://boschko.ca/tags/">Tags</a></li>
    <li class="nav-about-boschko"><a href="https://boschko.ca/about/">About Boschko</a></li>
    <li class="nav-red-rain-security"><a href="https://boschko.ca/redrainsecurity/">Red Rain Security</a></li>
</ul>

            </nav>

            <div class="gh-head-actions">
                    <button class="gh-search gh-icon-btn" aria-label="Search this site" data-ghost-search><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg></button>
                    <div class="gh-head-members">
                                <a class="gh-head-link" href="#/portal/signin" data-portal="signin">Sign in</a>
                                <a class="gh-head-button" href="#/portal/signup" data-portal="signup">Subscribe</a>
                    </div>
            </div>
        </div>
    </header>

    <div class="site-content">
        



<main id="site-main" class="site-main">
<article class="article post tag-windows-internal tag-c2 tag-cobalt-strike no-image ">

    <header class="article-header gh-canvas">

        <div class="article-tag post-card-tags">
                <span class="post-card-primary-tag">
                    <a href="/tag/windows-internal/">Windows Internal</a>
                </span>
        </div>

        <h1 class="article-title">Cobalt Strike Process Injection</h1>

            <p class="article-excerpt">Discussing the various methods that Cobalt Strike uses to perform process injection.</p>

        <div class="article-byline">
        <section class="article-byline-content">

            <ul class="author-list instapaper_ignore">
                <li class="author-list-item">
                    <a href="/author/olivier/" class="author-avatar" aria-label="Read more of Olivier Laflamme">
                        <img class="author-profile-image" src="/content/images/size/w100/2021/09/119486535_632169284368147_173960549788702982_n-1.jpg" alt="Olivier Laflamme" />
                    </a>
                </li>
            </ul>

            <div class="article-byline-meta">
                <h4 class="author-name"><a href="/author/olivier/">Olivier Laflamme</a></h4>
                <div class="byline-meta-content">
                    <time class="byline-meta-date" datetime="2021-11-02">02 Nov 2021</time>
                        <span class="byline-reading-time"><span class="bull">&bull;</span> 14 min read</span>
                </div>
            </div>

        </section>
        </div>


    </header>

    <section class="gh-content gh-canvas">
        <p>I've documented some of my thoughts and ideas around process injection. In this blog will mostly cover some technical details about Cobalt Strike's process injection, as well as some of the red team attack techniques you may want to know?</p><h2 id="injection-function">Injection Function</h2><p>Cobalt Strike currently provides process injection functions in some scenarios. The most common is to directly inject payload into a new process. This function can be executed through various sessions that you have obtained, such as <a href="https://www.cobaltstrike.com/help-artifact-kit?ref=boschko.ca" rel="noopener">Artifact Kit</a> , <a href="https://www.youtube.com/watch?v=QvQerXsPSvc&ref=boschko.ca" rel="noopener">Applet Kit</a> and <a href="https://www.cobaltstrike.com/help-resource-kit?ref=boschko.ca" rel="noopener">Resource Kit</a>. This article will focus on Cobalt Strike's process injection in Beacon sessions.</p><p>The <code>shinject</code> command injects code into any remote process, some built-in post-exploitation modules can also be injected to a particular remote process through this method. Cobalt Strike did this because injecting shellocde into a new session would be safer than migrating the session directly to another C2.</p><p>(Probably the reason is that if the new session is not pulled up, it will be embarrassing if the original session has dropped.)</p><p>Therefore, Cobalt Strike "post-exploitation" will start a temporary process when it is executed, and inject the DLL file corresponding to the payload into the process, and confirm the result of the injection by retrieving the named pipe. Of course, this is just a special case of process injection. In this way, we can safely operate the main thread of these temporary processes without worrying about operation errors that cause the program to crash and result in loss of permissions. This is a very important detail to understand when learning to use Cobalt Strike injection process.</p><p>The first parameter of the inject command mentioned in the original text is the PID of the target program to be injected, and the second parameter is the architecture of the target program. If not filled, the default is x86.</p><pre><code>inject 7696 x64
</code></pre>
<figure class="kg-card kg-image-card"><img src="https://boschko.ca/content/images/2021/11/image-2.png" class="kg-image" alt="" loading="lazy" width="1259" height="595" srcset="https://boschko.ca/content/images/size/w600/2021/11/image-2.png 600w, https://boschko.ca/content/images/size/w1000/2021/11/image-2.png 1000w, https://boschko.ca/content/images/2021/11/image-2.png 1259w" sizes="(min-width: 720px) 720px"></figure><figure class="kg-card kg-image-card"><img src="https://boschko.ca/content/images/2021/11/image-1.png" class="kg-image" alt="" loading="lazy" width="704" height="108" srcset="https://boschko.ca/content/images/size/w600/2021/11/image-1.png 600w, https://boschko.ca/content/images/2021/11/image-1.png 704w"></figure><p>The parameter writing method of <code>shinject</code> is the same as that of inject. If the third parameter is not written, you will be prompted to select a shellcode file. Pay attention to the bin format payload that needs to be generated.</p><pre><code>shinject 7696 x64 C:\Users\VM_Windows\Documents\payload.bin</code></pre><figure class="kg-card kg-image-card"><img src="https://boschko.ca/content/images/2021/11/image-3.png" class="kg-image" alt="" loading="lazy" width="712" height="78" srcset="https://boschko.ca/content/images/size/w600/2021/11/image-3.png 600w, https://boschko.ca/content/images/2021/11/image-3.png 712w"></figure><figure class="kg-card kg-image-card"><img src="https://boschko.ca/content/images/2021/11/image-4.png" class="kg-image" alt="" loading="lazy" width="646" height="88" srcset="https://boschko.ca/content/images/size/w600/2021/11/image-4.png 600w, https://boschko.ca/content/images/2021/11/image-4.png 646w"></figure><p>In addition to the two beacon commands mentioned above, in fact, there is also a <code>shspawn</code>. Its role is to start a process and inject shellcode into it. The parameters only need to select the program architecture.</p><pre><code>shspawn x64 C:\Users\VM_Windows\Documents\payload.bin
</code></pre>
<figure class="kg-card kg-image-card"><img src="https://boschko.ca/content/images/2021/11/image-5.png" class="kg-image" alt="" loading="lazy" width="720" height="68" srcset="https://boschko.ca/content/images/size/w600/2021/11/image-5.png 600w, https://boschko.ca/content/images/2021/11/image-5.png 720w" sizes="(min-width: 720px) 720px"></figure><figure class="kg-card kg-image-card"><img src="https://boschko.ca/content/images/2021/11/image-6.png" class="kg-image" alt="" loading="lazy" width="653" height="111" srcset="https://boschko.ca/content/images/size/w600/2021/11/image-6.png 600w, https://boschko.ca/content/images/2021/11/image-6.png 653w"></figure><figure class="kg-card kg-image-card"><img src="https://boschko.ca/content/images/2021/11/image-8.png" class="kg-image" alt="" loading="lazy" width="1224" height="463" srcset="https://boschko.ca/content/images/size/w600/2021/11/image-8.png 600w, https://boschko.ca/content/images/size/w1000/2021/11/image-8.png 1000w, https://boschko.ca/content/images/2021/11/image-8.png 1224w" sizes="(min-width: 720px) 720px"></figure><p>As shown in the figure, the payload is injected into the dllhost.exe program. This method is much more stable than the first two, and you are not afraid of crashing the program. shspawn and shinject are quite flexible because they allow us to provide any arbitrary shellcode – including 64-bit and stageless. </p><p><strong>So whats actually going on? </strong></p><h2 id="prior-knowledge">Prior Knowledge </h2><p>To better understand all that follows lets take a step back and have a look at sacrificial processes by looking at execute-assembly. </p><figure class="kg-card kg-image-card"><img src="https://boschko.ca/content/images/2021/11/image-9.png" class="kg-image" alt="" loading="lazy" width="1245" height="391" srcset="https://boschko.ca/content/images/size/w600/2021/11/image-9.png 600w, https://boschko.ca/content/images/size/w1000/2021/11/image-9.png 1000w, https://boschko.ca/content/images/2021/11/image-9.png 1245w" sizes="(min-width: 720px) 720px"></figure><p>In a nutshell, whats happening when you're invoking execute-assembly is that you're going to create a new job (as the function highly suggests) but the beauty of it is that there is a <code>.spawn</code> and as you can see the only difference between the two lines is just the architecture. </p><p>So if the beacon that is running on the target is x64 its actually going to spawn a new x64 job, if not its going to spin a 32bit version.</p><p>The main takeaway is<em> </em>every time you see  <code>.spawn</code>, especially with the BIDs which is the reference to the current beacon running on the target, this is where things can get slightly dangerous if you dont understand whats happening. </p><figure class="kg-card kg-image-card"><img src="https://boschko.ca/content/images/2021/11/image-10.png" class="kg-image" alt="" loading="lazy" width="1325" height="887" srcset="https://boschko.ca/content/images/size/w600/2021/11/image-10.png 600w, https://boschko.ca/content/images/size/w1000/2021/11/image-10.png 1000w, https://boschko.ca/content/images/2021/11/image-10.png 1325w" sizes="(min-width: 720px) 720px"></figure><p>In a nutshell, there is a concept in Cobalt Strike that is called sacrificial process. What is does is pretty simply. Its just going to spawn a process, and inject itself into it and do whatever you asked for it to invoke. The main reason / the idea behind this is that your main beacon is not going to die regardless of whatever you're running. Because technically, you could kill your beacon if you're doing something extremely bad, and its just corrupting the whole process, and you'd lose your foothold. So the idea here is that you're going to inject inside of a process that is not related to the current process. </p><p>Therefore, even if you execute something in assembly and its not working the way its supposed to then its just going to kill the sacrificial process as opposed to killing your whole beacon.</p><p>The thing is, you might think that "oh that's super cool ill just run my .net payload with execute-assembly and nothing bad will happen" but in reality if you look at the code there is no indicator that you're actually creating a remote process. Which is something that you should keep in mind.</p><p>So the main takeaway is that you might want to have a list of all the functionality that uses the <code>.spawn</code><em> </em>function because you may want to avoid doing remote process injection in some specific cases. Every time you see <code>.spawn</code><em> </em>in the CS code its pretty sure that it'll create a new process. This is something to keep in mind.</p><figure class="kg-card kg-image-card"><img src="https://boschko.ca/content/images/2021/11/image-12.png" class="kg-image" alt="" loading="lazy" width="1942" height="131" srcset="https://boschko.ca/content/images/size/w600/2021/11/image-12.png 600w, https://boschko.ca/content/images/size/w1000/2021/11/image-12.png 1000w, https://boschko.ca/content/images/size/w1600/2021/11/image-12.png 1600w, https://boschko.ca/content/images/2021/11/image-12.png 1942w" sizes="(min-width: 720px) 720px"></figure><p>You'll also see something called SetupSmartInject and all that kind of stuff. </p><figure class="kg-card kg-image-card"><img src="https://boschko.ca/content/images/2021/11/image-13.png" class="kg-image" alt="" loading="lazy" width="1040" height="1013" srcset="https://boschko.ca/content/images/size/w600/2021/11/image-13.png 600w, https://boschko.ca/content/images/size/w1000/2021/11/image-13.png 1000w, https://boschko.ca/content/images/2021/11/image-13.png 1040w" sizes="(min-width: 720px) 720px"></figure><p>Really, all that is is setting up everything needed to inject inside of the remote process. And here its just using some internal magic to try an obfuscate what you're trying to do. But once again, when it comes to EDR's and stuff like that, if you don't try and actually hide yourself you're probably still going to raise alerts about the fact that you remotely created a process. And this is something that can be configured in your malleable  profile.</p><p><a href="https://github.com/threatexpress/malleable-c2/blob/master/jquery-c2.4.3.profile?ref=boschko.ca">This</a> is a typical malleable config file. The idea behind these are that because most of the time its going to be using http so you'll want to customize your http traffic to blend into legitimate traffic.</p><figure class="kg-card kg-image-card"><img src="https://boschko.ca/content/images/2021/11/image-11.png" class="kg-image" alt="" loading="lazy" width="1176" height="707" srcset="https://boschko.ca/content/images/size/w600/2021/11/image-11.png 600w, https://boschko.ca/content/images/size/w1000/2021/11/image-11.png 1000w, https://boschko.ca/content/images/2021/11/image-11.png 1176w" sizes="(min-width: 720px) 720px"></figure><p>So this is usually where you have your SpawnTo Process information. As you can see the sacrificial process can actually be defined for both architectures. But whats important is that you can specify which function you want to use when you do remote process injection. So you can specify how you want to do it and in which order.</p><p>Before diving deeper into this, its always a good thing to disable the one's you think is insecure. We'll discuss all about this further down the blog. </p><p>In this case the <code>NtQueueApcThread</code> was commented out so you wont be using that one. By default the top 6 listed are what you "can" use. <code>CreateThread</code> as you know is only going to be used to create a thread inside of the remote process. <code>CreateRemoteThread</code> is fairly safe IF you had EDR unhooking in place. <code>NtQueueApcThread</code> is probably the least secure one of them. The reason is that <code>QueueApcThread</code> is actually hijacking an existing thread most of the time. So sometimes if you're hijacking something that you shouldn't then you may run into some unintended issues, so if possible avoid this at all costs. The other ones are more or less the same as <code>CreateRemoteThread</code> just using a different approach. This is in my opinion super important when it comes to process injection, because as we've just seen above some CS functionality will force you to have process injection by default. And the ones that rely on sacrificial processes will always call <code>.spawn</code> and will always end up injecting inside of a remote process. The process is actually going to be the one that you specify in your profile, so technically you could have a different one for x64 and x86.</p><p>Now there is quite a lot of people who have lists of processes that get spawned all the time that don't live for to long so you could try to mimic that. </p><h2 id="injection-process">Injection Process</h2><p>The <a href="https://www.cobaltstrike.com/help-malleable-postex?ref=boschko.ca#processinject">process-inject</a> block in Cobalt Strike's Malleable C2 configuration file is where the configurations for process injection is defined. So this is usually where you have your SpawnTo Process information.</p><pre><code class="language-c">process-inject {
    # set remote memory allocation technique
    set allocator "NtMapViewOfSection";

    # shape the content and properties of what we will inject
    set min_alloc "16384";
    set userwx    "false";

    transform-x86 {
        prepend "\x90";
    }

    transform-x64 {
        prepend "\x90";
    }

    # specify how we execute code in the remote process
    execute {
        CreateThread "ntdll!RtlUserThreadStart";
        CreateThread;
        NtQueueApcThread-s;
        CreateRemoteThread;
        RtlCreateUserThread;
    }
}

</code></pre>
<p>So, the execution flow for process-inject block of code in Cobalt Strike's Malleable profile is roughly as follows:</p><ol><li>Open the handle of the remote process.</li><li>Allocate memory in remote processes.</li><li>Copy the shellcode to the remote process.</li><li>Execute shellcode in the remote process.</li></ol><h4 id="step-1">Step 1:</h4><p>The first step is to distribute and copy data to the remote host. If we start a temporary process; that is, we already have a handle to the remote process, at this time if we want to inject the code into the existing remote process Cobalt Strike will use <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess?ref=boschko.ca" rel="noopener">OpenProcess</a> to solve this problem.</p><h4 id="step-2">Step 2:</h4><p>Cobalt Strike provides two options for allocating memory and copying data into remote processes.</p><p>The first solution is the classic: <code>VirtualAllocEx -&gt; WriteProcessMemorypattern</code>, which is very common in attack tools. It is worth mentioning that this solution is also applicable to different process architectures, and the application of process injection is not limited to the injection of x64 target processes. This means that a good solution needs to take into account the different extreme situations that can occur (for example, x86-&gt; x64, or x64-&gt; x86, etc.). This makes it <code>VirtualAllocEx</code> a relatively reliable choice, and Cobalt Strike's default solution is also this. If you want to directly specify this mode, you can set <code>process-inject</code> <code>allocator </code>option <code>VirtualAllocEx</code>.</p><p>The second solution provided by Cobalt Strike is <code>CreateFileMapping</code> -&gt; <code>MapViewOfFile</code> -&gt; <code>NtMapViewOfSection</code> mode. This solution will first create a mapping file that supports the Windows system, and then map the view of the mapping file to the current process. Then Cobalt Strike will copy the injected data to the memory associated with the view and <code>NtMapViewOfSection</code> call our remote process. To use this scheme you can set the <code>allocator</code> to <code>NtMapViewOfSection</code>. The disadvantage of this scheme is only for <code>x86 -&gt; x86</code> and <code>x64 -&gt; x64</code>, regarding the cross-architecture injection when Cobalt Strike will automatically switch back to <code>VirtualAllocEx</code> mode.</p><p>When <code>VirtualAllocEx</code> -&gt; <code>WriteProcessMemory</code> mode injection is subject to soft defense it is also a good choice to try this scheme instead. (It is very useful when killing software without detecting other methods of copying data to a remote process.)</p><h4 id="step-3">Step 3: </h4><p>The third step is data conversion. Step 2 and this step as mentioned above assume that everything is normal and the original data is copied to the injected data, which is almost impossible in a real environment. To this end, Cobalt Strike's <code>process-inject</code> adds the function of transforming and injecting data. The <code>min_alloc</code> option is the minimum size of the block that Beacon will allocate in the remote process, <code>startrwx</code> and the <code>userwx</code> option is the initial Boolean value of the allocated memory and the final permission of the allocated memory. If you want to prohibit data from being readable, writable, and executable (<code>RWX</code>), please set these values ​​to <code>false</code>. <code>transform-x86</code> and those that <code>transform-x64</code> support converting data to another architecture. If you need to add data in advance, make sure it is executable code for the corresponding architecture.</p><p>Note, many content signatures look for specific bytes at a fixed offset at the beginning of the observable boundary. These checks occur in O (1) time, which is conducive to O (n) search. Excessive Inspection and security technology may consume a lot of memory, and performance will be reduced accordingly.</p><p><a href="https://attack.mitre.org/techniques/T1009/?ref=boschko.ca" rel="noopener">Binary padding</a> also affects post-exploitation of the thread start address offset in Cobalt Strike. When a Beacon injects a DLL into memory; its <code>ReflectiveLoader</code> starts the thread at the position where the function exported by the DLL should be. This offset is shown in the thread start address feature, and is looking for a specific "post-exploitation" DLL of <a href="https://medium.com/@olafhartong/cobalt-strike-remote-threads-detection-206372d11d0f?ref=boschko.ca" rel="noopener">potential indicators</a>. The data before injection into the DLL will affect this offset. (It ’s okay not to know about thread related things, I will talk about it next ...)</p><h4 id="step-4">Step 4: </h4><p>The fourth step is code execution. To better understand all of this let's take a look at the subtle differences between different execution methods in a beacon:</p><h4 id="createthread">CreateThread</h4><p><code>CreateThread</code> from the beginning. I think that <code>CreateThread</code> if it exists,  should first appear in an execution block, this function only runs when it is limited to self-injection. Using <code>CreateThread</code> will start a thread pointing to the code you want your Beacon to run. But be careful, when you self-inject in this way, the thread you pull will have a starting address, which is not related to the module (by module I mean DLL / current program itself) loaded into the current process space. For this you can specify <code>CreateThread“module！somefunction + 0x ##”</code>. This variant will generate a suspended thread that points to the specified function, if the specified function cannot be <code>GetProcAddressobtained</code> this is because Beacon will use to <code>SetThreadContextupdate</code> and will use this new thread to run the injected code, which is also a self-injection method that can provide you with a more favorable foothold.</p><h4 id="setthreadcontext">SetThreadContext</h4><p>Next is <code>SetThreadContext</code>, which is used in post-exploitation. One of the main thread method interim process tasks generated. The Beacon is <code>SetThreadContext</code> suitable for <code>x86 -&gt; x86, x64 -&gt; x64and x64-&gt; x86</code>. If you choose to use it <code>SetThreadContext</code>, place it in <code>CreateThread</code> after the option in the execution block. <code>SetThreadContext</code> when used; your thread will have a starting address that reflects the original execution entry point of the temporary process which is very nice.</p><h4 id="ntqueueapcthread-s">NtQueueApcThread-s</h4><p>Another way to suspend a process is to use it <code>NtQueueApcThread-s</code>. This method uses <code>NtQueueApcThread</code> which is a one-time function to queue up when the target thread wakes up next time. In this case, the target thread is the main thread of the temporary process. The next step is to call <code>ResumeThread</code>, this function wakes up the main thread of our suspended process, because the process has been suspended at this time, we do not have to worry about returning this main thread to the process. This method only applies to <code>x86 -&gt; x86 and x64 -&gt; x64</code>.</p><p>Determining whether to use  <code>SetThreadContext</code> or <code>NtQueueApcThread-s</code> depends on you. In most cases I think the latter is obviously more convenient.</p><h4 id="ntqueueapcthread">NtQueueApcThread</h4><p>Another approach is through <code>NtQueueApcThread</code> it is like <code>NtQueueApcThread-sun</code> but it targets existing remote processes. This method needs to push the RWX stub to the remote process. This stub contains the code related to the injection. To execute the stub, you need to add the stub to the APC queue of each thread in the remote process. The stub code will be executed.</p><p>So what is the role of stubs?</p><p>First, the stub checks whether it is already running, and if it is, it executes nothing, preventing the injected code from running multiple times.</p><p>Then the stub will be called with the code and its parameters we injected <code>CreateThread</code>. This is done to let APC return quickly and let the original thread continue to work.</p><p>No thread will wake up and execute our stub. Beacon will wait about 200ms to start and check the stub to determine whether the code is still running. If not, update the stub and mark the injection as already running, and continue to the next item. This It is <code>NtQueueApcThread</code> the implementation details of the technology.</p><p>At present, I have used this method a few times, because some security products have very little attention to this incident. In other words, OPSEC has paid attention to it, and it is indeed a memory indicator that promotes RWX stubs. It will also call the code of the remote process that we push <code>CreateThread</code>. The starting address of the thread does not support the module on the disk. Use <code>Get-InjectedThread</code> scan not effectively. If you think this injection method is valuable, please continue to use it. Pay attention to weighing its pros and cons. It is worth mentioning that this method is limited to x86 -&gt; x86 and x64 -&gt; x64.</p><h4 id="createremotethread">CreateRemoteThread</h4><p>Another way is via <code>CreateRemoteThread</code> which can be used literally as a remote injection technology. Starting with Windows Vista, injecting code across session boundaries will fail. In Cobalt Strike, <code>vanilla CreateRemoteThreadcovers</code> <code>x86 -&gt; x86, x64 -&gt; x64 and x64 -&gt; x86</code>. The movement of this technology is also obvious. When this method is used to create a thread in another process, it will trigger event 8 of the system monitoring tool Sysmon. Such, Beacon has indeed implemented a <code>CreateRemoteThread</code> variant that <code>“module！function + 0x ##”</code> accepts a pseudo start address in the form CreateThreadSimilarly, Beacon will create its thread in the suspended state and use <code>SetThreadContext / ResumeThread</code> enable to execute our code. This variant is limited to <code>x86 -&gt; x86 and x64 -&gt; x64</code>. If the <code>GetProcAddress</code> specified function cannot be used, this variant will also fail.</p><h4 id="rtlcreateuserthread">RtlCreateUserThread</h4><p>The last way Cobalt Strike executes blocks is <code>RtlCreateUserThread</code>. This way <code>CreateRemoteThread</code> functions is very enjoyable but has some limitations, it is not perfect and has flaws.</p><p><code>RtlCreateUserThread</code> code will be injected across the session boundary. It is said that there will be many problems during the injection on Windows XP. This method will also trigger event 8 of the system monitoring tool Sysmon. One benefit is that it covers <code>x86-&gt; x86, x64-&gt; x64, x64-&gt; x86, and x86-&gt; x64</code>, the last case is very important.</p><p><code>x86 -&gt; x64</code> injection are in x86 Beacon carried out sessions. And for your <em>post-exploitation</em> generation process x64 tasks,<code> hashdump</code>, <code>mimikatz</code>, <code>execute-assembly</code> and <code>powerpick</code> modules are silent as x64. In order to achieve <code>x86 -&gt; x64</code> injection, this method converts the x86 process to x64 mode and injects RWX stubs to facilitate calling from x64 <code>RtlCreateUserThread</code>. This technique comes from Meterpreter. RWX stubs are a pretty good memory indicator. I have long suggested: "Let the process stay in x64 mode as much as possible", the above situation is why I would say this, and it is also recommended to put one in all. So <code>process-inject</code> is the lowest way to have it, you can use it when there is no other <code>work execute blockRtlCreateUserThread</code></p><h3 id="how-to-live-without-process-injection">How to Live Without Process Injection</h3><p>When thinking about how to use these attack techniques flexibly, I was also thinking what to do if none of these methods work?</p><p>Process injection is a technique used to, at its core transfer payload / capability to migrate to different processes (such as from desktop session <code>0</code> to desktop session <code>1</code>), you can use the <code>runu</code> command to transfer to different processes without process injection, (in other words, you can run <code>runu</code> if you want to run a command under a parent in another desktop session.) and you can specify the program that you want to run as child processes of any process. This is a way to introduce a session to another desktop session without process injection.</p><figure class="kg-card kg-image-card"><img src="https://boschko.ca/content/images/2021/11/image-14.png" class="kg-image" alt="" loading="lazy" width="1037" height="577" srcset="https://boschko.ca/content/images/size/w600/2021/11/image-14.png 600w, https://boschko.ca/content/images/size/w1000/2021/11/image-14.png 1000w, https://boschko.ca/content/images/2021/11/image-14.png 1037w" sizes="(min-width: 720px) 720px"></figure><p>Process injection is also one of the methods to execute code without landing files on the target. Many post-exploitation functions in Cobalt Strike can choose to attack specific processes. For example, specifying the current Beacon process can be leveraged without having to perform a remote injection. This is more-or-less self-injection.</p><p>Of course, life is not perfect and it is not perfect to execute code without a "file on the ground". Sometimes it is best to put something on the disk. </p><p></p><h5 id="references">References:</h5><ul><li><a href="https://blog.cobaltstrike.com/2019/08/21/cobalt-strikes-process-injection-the-details/?ref=boschko.ca">https://blog.cobaltstrike.com/2019/08/21/cobalt-strikes-process-injection-the-details/</a></li><li><a href="https://blog.cobaltstrike.com/2016/11/03/agentless-post-exploitation/?ref=boschko.ca">https://blog.cobaltstrike.com/2016/11/03/agentless-post-exploitation/</a></li><li><a href="https://blog.cobaltstrike.com/2018/04/23/fighting-the-toolset/?ref=boschko.ca">https://blog.cobaltstrike.com/2018/04/23/fighting-the-toolset/</a></li><li><a href="https://www.cobaltstrike.com/help-resource-kit?ref=boschko.ca">https://www.cobaltstrike.com/help-resource-kit</a></li><li><a href="https://www.cobaltstrike.com/help-artifact-kit?ref=boschko.ca">https://www.cobaltstrike.com/help-artifact-kit</a></li><li><a href="https://www.youtube.com/watch?v=QvQerXsPSvc&ref=boschko.ca">https://www.youtube.com/watch?v=QvQerXsPSvc</a></li><li><a href="https://rastamouse.me/exploring-process-injection-opsec-part-1/?ref=boschko.ca">https://rastamouse.me/exploring-process-injection-opsec-part-1/</a></li><li><a href="https://rastamouse.me/exploring-process-injection-opsec-part-2/?ref=boschko.ca">https://rastamouse.me/exploring-process-injection-opsec-part-2/</a></li></ul>
    </section>


</article>
</main>

    <section class="footer-cta outer">
        <div class="inner">
            <h2 class="footer-cta-title">Sign up for more like this.</h2>
            <a class="footer-cta-button" href="#/portal" data-portal>
                <div class="footer-cta-input">Enter your email</div>
                <span>Subscribe</span>
            </a>
        </div>
    </section>



            <aside class="read-more-wrap outer">
                <div class="read-more inner">
                        
<article class="post-card post no-image keep-ratio">


    <div class="post-card-content">

        <a class="post-card-content-link" href="/adversarial-ml/">
            <header class="post-card-header">
                <div class="post-card-tags">
                </div>
                <h2 class="post-card-title">
                    Breaking Down Adversarial Machine Learning Attacks Through Red Team Challenges
                </h2>
            </header>
                <div class="post-card-excerpt">Learn how to craft and understand adversarial attacks on AI/ML models through hands-on challenges on Dreadnode’s Crucible CTF platform.</div>
        </a>

        <footer class="post-card-meta">
            <time class="post-card-meta-date" datetime="2024-11-27">27 Nov 2024</time>
                <span class="post-card-meta-length">25 min read</span>
        </footer>

    </div>

</article>
                        
<article class="post-card post no-image keep-ratio">


    <div class="post-card-content">

        <a class="post-card-content-link" href="/incinerator/">
            <header class="post-card-header">
                <div class="post-card-tags">
                </div>
                <h2 class="post-card-title">
                    Incinerator: The Ultimate Android Malware Reversing Tool
                </h2>
            </header>
                <div class="post-card-excerpt">Master Android malware reversal with ease using Incinerator, your trusted ally in the fight against threat actors for experts and novices alike.</div>
        </a>

        <footer class="post-card-meta">
            <time class="post-card-meta-date" datetime="2024-04-03">03 Apr 2024</time>
                <span class="post-card-meta-length">15 min read</span>
        </footer>

    </div>

</article>
                        
<article class="post-card post no-image keep-ratio">


    <div class="post-card-content">

        <a class="post-card-content-link" href="/tp-link-tddp-bof/">
            <header class="post-card-header">
                <div class="post-card-tags">
                </div>
                <h2 class="post-card-title">
                    TP-Link TDDP Buffer Overflow Vulnerability
                </h2>
            </header>
                <div class="post-card-excerpt">TP-Link&#39;s TDDP programs listening on UDP port 1040, fails to properly verify data length during parsing, leading to memory overflow destroying the memory structure and causing a denial of service.</div>
        </a>

        <footer class="post-card-meta">
            <time class="post-card-meta-date" datetime="2024-03-19">19 Mar 2024</time>
                <span class="post-card-meta-length">8 min read</span>
        </footer>

    </div>

</article>
                </div>
            </aside>



    </div>

    <footer class="site-footer outer">
        <div class="inner">
            <section class="copyright"><a href="https://boschko.ca">Boschko Security Blog</a> &copy; 2024</section>
            <nav class="site-footer-nav">
                
            </nav>
            <div class="gh-powered-by"><a href="https://ghost.org/" target="_blank" rel="noopener">Powered by Ghost</a></div>
        </div>
    </footer>

</div>

    <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <div class="pswp__bg"></div>

    <div class="pswp__scroll-wrap">
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
<script
    src="https://code.jquery.com/jquery-3.5.1.min.js"
    integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
    crossorigin="anonymous">
</script>
<script src="https://boschko.ca/assets/built/casper.js?v=4b789ea714"></script>
<script>
$(document).ready(function () {
    // Mobile Menu Trigger
    $('.gh-burger').click(function () {
        $('body').toggleClass('gh-head-open');
    });
    // FitVids - Makes video embeds responsive
    $(".gh-content").fitVids();
});
</script>



</body>
</html>
